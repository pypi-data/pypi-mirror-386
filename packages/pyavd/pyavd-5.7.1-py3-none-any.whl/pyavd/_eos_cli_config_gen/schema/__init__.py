# Copyright (c) 2025 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.

from __future__ import annotations

from typing import TYPE_CHECKING, ClassVar, Literal

from pyavd._schema.models.avd_indexed_list import AvdIndexedList
from pyavd._schema.models.avd_list import AvdList
from pyavd._schema.models.avd_model import AvdModel
from pyavd._schema.models.eos_cli_config_gen_root_model import EosCliConfigGenRootModel

if TYPE_CHECKING:
    from pyavd._utils import Undefined, UndefinedType


class EosCliConfigGen(EosCliConfigGenRootModel):
    """Subclass of EosCliConfigGenRootModel."""

    class AaaAccounting(AvdModel):
        """Subclass of AvdModel."""

        class Exec(AvdModel):
            """Subclass of AvdModel."""

            class Console(AvdModel):
                """Subclass of AvdModel."""

                class MethodsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"method": {"type": str}, "group": {"type": str}}
                    method: Literal["logging", "group"]
                    group: str | None
                    """
                    Specify the server group to be used.
                    This option is applicable only when the `method` key is
                    explicitly set to `group`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, method: Literal["logging", "group"] | UndefinedType = Undefined, group: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            MethodsItem.


                            Subclass of AvdModel.

                            Args:
                                method: method
                                group:
                                   Specify the server group to be used.
                                   This option is applicable only when the `method` key is
                                   explicitly set to `group`.

                            """

                class Methods(AvdList[MethodsItem]):
                    """Subclass of AvdList with `MethodsItem` items."""

                Methods._item_type = MethodsItem

                _fields: ClassVar[dict] = {"type": {"type": str}, "group": {"type": str}, "logging": {"type": bool}, "methods": {"type": Methods}}
                type: Literal["none", "start-stop", "stop-only"]
                group: str | None
                """Group Name."""
                logging: bool | None
                methods: Methods
                """Subclass of AvdList with `MethodsItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        type: Literal["none", "start-stop", "stop-only"] | UndefinedType = Undefined,
                        group: str | None | UndefinedType = Undefined,
                        logging: bool | None | UndefinedType = Undefined,
                        methods: Methods | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Console.


                        Subclass of AvdModel.

                        Args:
                            type: type
                            group: Group Name.
                            logging: logging
                            methods: Subclass of AvdList with `MethodsItem` items.

                        """

            class Default(AvdModel):
                """Subclass of AvdModel."""

                class MethodsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"method": {"type": str}, "group": {"type": str}}
                    method: Literal["logging", "group"]
                    group: str | None
                    """
                    Specify the server group to be used.
                    This option is applicable only when the `method` key is
                    explicitly set to `group`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, method: Literal["logging", "group"] | UndefinedType = Undefined, group: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            MethodsItem.


                            Subclass of AvdModel.

                            Args:
                                method: method
                                group:
                                   Specify the server group to be used.
                                   This option is applicable only when the `method` key is
                                   explicitly set to `group`.

                            """

                class Methods(AvdList[MethodsItem]):
                    """Subclass of AvdList with `MethodsItem` items."""

                Methods._item_type = MethodsItem

                _fields: ClassVar[dict] = {"type": {"type": str}, "group": {"type": str}, "logging": {"type": bool}, "methods": {"type": Methods}}
                type: Literal["none", "start-stop", "stop-only"] | None
                group: str | None
                """Group Name."""
                logging: bool | None
                methods: Methods
                """Subclass of AvdList with `MethodsItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        type: Literal["none", "start-stop", "stop-only"] | None | UndefinedType = Undefined,
                        group: str | None | UndefinedType = Undefined,
                        logging: bool | None | UndefinedType = Undefined,
                        methods: Methods | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Default.


                        Subclass of AvdModel.

                        Args:
                            type: type
                            group: Group Name.
                            logging: logging
                            methods: Subclass of AvdList with `MethodsItem` items.

                        """

            _fields: ClassVar[dict] = {"console": {"type": Console}, "default": {"type": Default}}
            console: Console
            """Subclass of AvdModel."""
            default: Default
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, console: Console | UndefinedType = Undefined, default: Default | UndefinedType = Undefined) -> None:
                    """
                    Exec.


                    Subclass of AvdModel.

                    Args:
                        console: Subclass of AvdModel.
                        default: Subclass of AvdModel.

                    """

        class System(AvdModel):
            """Subclass of AvdModel."""

            class Default(AvdModel):
                """Subclass of AvdModel."""

                class MethodsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"method": {"type": str}, "group": {"type": str}}
                    method: Literal["logging", "group"]
                    group: str | None
                    """
                    Specify the server group to be used.
                    This option is applicable only when the `method` key is
                    explicitly set to `group`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, method: Literal["logging", "group"] | UndefinedType = Undefined, group: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            MethodsItem.


                            Subclass of AvdModel.

                            Args:
                                method: method
                                group:
                                   Specify the server group to be used.
                                   This option is applicable only when the `method` key is
                                   explicitly set to `group`.

                            """

                class Methods(AvdList[MethodsItem]):
                    """Subclass of AvdList with `MethodsItem` items."""

                Methods._item_type = MethodsItem

                _fields: ClassVar[dict] = {"type": {"type": str}, "group": {"type": str}, "methods": {"type": Methods}}
                type: Literal["none", "start-stop", "stop-only"] | None
                group: str | None
                """Group Name."""
                methods: Methods
                """Subclass of AvdList with `MethodsItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        type: Literal["none", "start-stop", "stop-only"] | None | UndefinedType = Undefined,
                        group: str | None | UndefinedType = Undefined,
                        methods: Methods | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Default.


                        Subclass of AvdModel.

                        Args:
                            type: type
                            group: Group Name.
                            methods: Subclass of AvdList with `MethodsItem` items.

                        """

            _fields: ClassVar[dict] = {"default": {"type": Default}}
            default: Default
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, default: Default | UndefinedType = Undefined) -> None:
                    """
                    System.


                    Subclass of AvdModel.

                    Args:
                        default: Subclass of AvdModel.

                    """

        class Dot1x(AvdModel):
            """Subclass of AvdModel."""

            class Default(AvdModel):
                """Subclass of AvdModel."""

                class MethodsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"multicast": {"type": bool}, "method": {"type": str}, "group": {"type": str}}
                    multicast: bool | None
                    """
                    Forward accounting packets to all servers within the specified group.
                    This option is applicable only
                    when the `method` key is explicitly set to `group`.
                    """
                    method: Literal["logging", "group"]
                    group: str | None
                    """
                    Specify the server group to be used.
                    This option is applicable only when the `method` key is
                    explicitly set to `group`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            multicast: bool | None | UndefinedType = Undefined,
                            method: Literal["logging", "group"] | UndefinedType = Undefined,
                            group: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MethodsItem.


                            Subclass of AvdModel.

                            Args:
                                multicast:
                                   Forward accounting packets to all servers within the specified group.
                                   This option is applicable only
                                   when the `method` key is explicitly set to `group`.
                                method: method
                                group:
                                   Specify the server group to be used.
                                   This option is applicable only when the `method` key is
                                   explicitly set to `group`.

                            """

                class Methods(AvdList[MethodsItem]):
                    """Subclass of AvdList with `MethodsItem` items."""

                Methods._item_type = MethodsItem

                _fields: ClassVar[dict] = {"type": {"type": str}, "group": {"type": str}, "methods": {"type": Methods}}
                type: Literal["start-stop", "stop-only"] | None
                group: str | None
                """Group Name."""
                methods: Methods
                """Subclass of AvdList with `MethodsItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        type: Literal["start-stop", "stop-only"] | None | UndefinedType = Undefined,
                        group: str | None | UndefinedType = Undefined,
                        methods: Methods | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Default.


                        Subclass of AvdModel.

                        Args:
                            type: type
                            group: Group Name.
                            methods: Subclass of AvdList with `MethodsItem` items.

                        """

            _fields: ClassVar[dict] = {"default": {"type": Default}}
            default: Default
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, default: Default | UndefinedType = Undefined) -> None:
                    """
                    Dot1x.


                    Subclass of AvdModel.

                    Args:
                        default: Subclass of AvdModel.

                    """

        class Commands(AvdModel):
            """Subclass of AvdModel."""

            class ConsoleItem(AvdModel):
                """Subclass of AvdModel."""

                class MethodsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"method": {"type": str}, "group": {"type": str}}
                    method: Literal["logging", "group"]
                    group: str | None
                    """
                    Specify the server group to be used.
                    This option is applicable only when the `method` key is
                    explicitly set to `group`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, method: Literal["logging", "group"] | UndefinedType = Undefined, group: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            MethodsItem.


                            Subclass of AvdModel.

                            Args:
                                method: method
                                group:
                                   Specify the server group to be used.
                                   This option is applicable only when the `method` key is
                                   explicitly set to `group`.

                            """

                class Methods(AvdList[MethodsItem]):
                    """Subclass of AvdList with `MethodsItem` items."""

                Methods._item_type = MethodsItem

                _fields: ClassVar[dict] = {
                    "commands": {"type": str},
                    "type": {"type": str},
                    "group": {"type": str},
                    "logging": {"type": bool},
                    "methods": {"type": Methods},
                }
                commands: str | None
                """Privilege level 'all' or 0-15. Ensure that if ranges are used, they do not overlap with one another."""
                type: Literal["none", "start-stop", "stop-only"] | None
                group: str | None
                """Group Name."""
                logging: bool | None
                methods: Methods
                """Subclass of AvdList with `MethodsItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        commands: str | None | UndefinedType = Undefined,
                        type: Literal["none", "start-stop", "stop-only"] | None | UndefinedType = Undefined,
                        group: str | None | UndefinedType = Undefined,
                        logging: bool | None | UndefinedType = Undefined,
                        methods: Methods | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ConsoleItem.


                        Subclass of AvdModel.

                        Args:
                            commands: Privilege level 'all' or 0-15. Ensure that if ranges are used, they do not overlap with one another.
                            type: type
                            group: Group Name.
                            logging: logging
                            methods: Subclass of AvdList with `MethodsItem` items.

                        """

            class Console(AvdList[ConsoleItem]):
                """Subclass of AvdList with `ConsoleItem` items."""

            Console._item_type = ConsoleItem

            class DefaultItem(AvdModel):
                """Subclass of AvdModel."""

                class MethodsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"method": {"type": str}, "group": {"type": str}}
                    method: Literal["logging", "group"]
                    group: str | None
                    """
                    Specify the server group to be used.
                    This option is applicable only when the `method` key is
                    explicitly set to `group`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, method: Literal["logging", "group"] | UndefinedType = Undefined, group: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            MethodsItem.


                            Subclass of AvdModel.

                            Args:
                                method: method
                                group:
                                   Specify the server group to be used.
                                   This option is applicable only when the `method` key is
                                   explicitly set to `group`.

                            """

                class Methods(AvdList[MethodsItem]):
                    """Subclass of AvdList with `MethodsItem` items."""

                Methods._item_type = MethodsItem

                _fields: ClassVar[dict] = {
                    "commands": {"type": str},
                    "type": {"type": str},
                    "group": {"type": str},
                    "logging": {"type": bool},
                    "methods": {"type": Methods},
                }
                commands: str | None
                """Privilege level 'all' or 0-15. Ensure that if ranges are used, they do not overlap with one another."""
                type: Literal["none", "start-stop", "stop-only"] | None
                group: str | None
                """Group Name."""
                logging: bool | None
                methods: Methods
                """Subclass of AvdList with `MethodsItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        commands: str | None | UndefinedType = Undefined,
                        type: Literal["none", "start-stop", "stop-only"] | None | UndefinedType = Undefined,
                        group: str | None | UndefinedType = Undefined,
                        logging: bool | None | UndefinedType = Undefined,
                        methods: Methods | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultItem.


                        Subclass of AvdModel.

                        Args:
                            commands: Privilege level 'all' or 0-15. Ensure that if ranges are used, they do not overlap with one another.
                            type: type
                            group: Group Name.
                            logging: logging
                            methods: Subclass of AvdList with `MethodsItem` items.

                        """

            class Default(AvdList[DefaultItem]):
                """Subclass of AvdList with `DefaultItem` items."""

            Default._item_type = DefaultItem

            _fields: ClassVar[dict] = {"console": {"type": Console}, "default": {"type": Default}}
            console: Console
            """Subclass of AvdList with `ConsoleItem` items."""
            default: Default
            """Subclass of AvdList with `DefaultItem` items."""

            if TYPE_CHECKING:

                def __init__(self, *, console: Console | UndefinedType = Undefined, default: Default | UndefinedType = Undefined) -> None:
                    """
                    Commands.


                    Subclass of AvdModel.

                    Args:
                        console: Subclass of AvdList with `ConsoleItem` items.
                        default: Subclass of AvdList with `DefaultItem` items.

                    """

        _fields: ClassVar[dict] = {"exec": {"type": Exec}, "system": {"type": System}, "dot1x": {"type": Dot1x}, "commands": {"type": Commands}}
        exec: Exec
        """Subclass of AvdModel."""
        system: System
        """Subclass of AvdModel."""
        dot1x: Dot1x
        """Subclass of AvdModel."""
        commands: Commands
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                exec: Exec | UndefinedType = Undefined,
                system: System | UndefinedType = Undefined,
                dot1x: Dot1x | UndefinedType = Undefined,
                commands: Commands | UndefinedType = Undefined,
            ) -> None:
                """
                AaaAccounting.


                Subclass of AvdModel.

                Args:
                    exec: Subclass of AvdModel.
                    system: Subclass of AvdModel.
                    dot1x: Subclass of AvdModel.
                    commands: Subclass of AvdModel.

                """

    class AaaAuthentication(AvdModel):
        """Subclass of AvdModel."""

        class Login(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"default": {"type": str}, "command_api": {"type": str}, "console": {"type": str}}
            default: str | None
            """
            Login authentication method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP none"
            - "group radius group MYGROUP local"
            """
            command_api: str | None
            """
            Command-API authentication method(s) as a string.
            This feature is not yet visible in EOS.
            This
            feature only supports local authentication at the moment.
            Examples:
            - "local"
            """
            console: str | None
            """
            Console authentication method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP
            none"
            - "group radius group MYGROUP local"
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    default: str | None | UndefinedType = Undefined,
                    command_api: str | None | UndefinedType = Undefined,
                    console: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Login.


                    Subclass of AvdModel.

                    Args:
                        default:
                           Login authentication method(s) as a string.
                           Examples:  # fmt: skip
                           - "group tacacs+ local"
                           - "group MYGROUP none"
                           - "group radius group MYGROUP local"
                        command_api:
                           Command-API authentication method(s) as a string.
                           This feature is not yet visible in EOS.
                           This
                           feature only supports local authentication at the moment.
                           Examples:  # fmt: skip
                           - "local"
                        console:
                           Console authentication method(s) as a string.
                           Examples:  # fmt: skip
                           - "group tacacs+ local"
                           - "group MYGROUP
                           none"
                           - "group radius group MYGROUP local"

                    """

        class Enable(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"default": {"type": str}}
            default: str | None
            """
            Enable authentication method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP
            none"
            - "group radius group MYGROUP local"
            """

            if TYPE_CHECKING:

                def __init__(self, *, default: str | None | UndefinedType = Undefined) -> None:
                    """
                    Enable.


                    Subclass of AvdModel.

                    Args:
                        default:
                           Enable authentication method(s) as a string.
                           Examples:  # fmt: skip
                           - "group tacacs+ local"
                           - "group MYGROUP
                           none"
                           - "group radius group MYGROUP local"

                    """

        class Dot1x(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"default": {"type": str}}
            default: str | None
            """
            802.1x authentication method(s) as a string.
            Examples:
            - "group radius"
            - "group MYGROUP group
            radius"
            """

            if TYPE_CHECKING:

                def __init__(self, *, default: str | None | UndefinedType = Undefined) -> None:
                    """
                    Dot1x.


                    Subclass of AvdModel.

                    Args:
                        default:
                           802.1x authentication method(s) as a string.
                           Examples:  # fmt: skip
                           - "group radius"
                           - "group MYGROUP group
                           radius"

                    """

        class Policies(AvdModel):
            """Subclass of AvdModel."""

            class Local(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"allow_nopassword": {"type": bool}}
                allow_nopassword: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, allow_nopassword: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Local.


                        Subclass of AvdModel.

                        Args:
                            allow_nopassword: allow_nopassword

                        """

            class Lockout(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"failure": {"type": int}, "duration": {"type": int}, "window": {"type": int}}
                failure: int | None
                duration: int | None
                window: int | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        failure: int | None | UndefinedType = Undefined,
                        duration: int | None | UndefinedType = Undefined,
                        window: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Lockout.


                        Subclass of AvdModel.

                        Args:
                            failure: failure
                            duration: duration
                            window: window

                        """

            _fields: ClassVar[dict] = {
                "on_failure_log": {"type": bool},
                "on_success_log": {"type": bool},
                "local": {"type": Local},
                "lockout": {"type": Lockout},
            }
            on_failure_log: bool | None
            on_success_log: bool | None
            local: Local
            """Subclass of AvdModel."""
            lockout: Lockout
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    on_failure_log: bool | None | UndefinedType = Undefined,
                    on_success_log: bool | None | UndefinedType = Undefined,
                    local: Local | UndefinedType = Undefined,
                    lockout: Lockout | UndefinedType = Undefined,
                ) -> None:
                    """
                    Policies.


                    Subclass of AvdModel.

                    Args:
                        on_failure_log: on_failure_log
                        on_success_log: on_success_log
                        local: Subclass of AvdModel.
                        lockout: Subclass of AvdModel.

                    """

        _fields: ClassVar[dict] = {"login": {"type": Login}, "enable": {"type": Enable}, "dot1x": {"type": Dot1x}, "policies": {"type": Policies}}
        login: Login
        """Subclass of AvdModel."""
        enable: Enable
        """Subclass of AvdModel."""
        dot1x: Dot1x
        """Subclass of AvdModel."""
        policies: Policies
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                login: Login | UndefinedType = Undefined,
                enable: Enable | UndefinedType = Undefined,
                dot1x: Dot1x | UndefinedType = Undefined,
                policies: Policies | UndefinedType = Undefined,
            ) -> None:
                """
                AaaAuthentication.


                Subclass of AvdModel.

                Args:
                    login: Subclass of AvdModel.
                    enable: Subclass of AvdModel.
                    dot1x: Subclass of AvdModel.
                    policies: Subclass of AvdModel.

                """

    class AaaAuthorization(AvdModel):
        """Subclass of AvdModel."""

        class Policy(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"local_default_role": {"type": str}}
            local_default_role: str | None

            if TYPE_CHECKING:

                def __init__(self, *, local_default_role: str | None | UndefinedType = Undefined) -> None:
                    """
                    Policy.


                    Subclass of AvdModel.

                    Args:
                        local_default_role: local_default_role

                    """

        class Exec(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"default": {"type": str}}
            default: str | None
            """
            Exec authorization method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP none"
            -
            "group radius group MYGROUP local"
            """

            if TYPE_CHECKING:

                def __init__(self, *, default: str | None | UndefinedType = Undefined) -> None:
                    """
                    Exec.


                    Subclass of AvdModel.

                    Args:
                        default:
                           Exec authorization method(s) as a string.
                           Examples:  # fmt: skip
                           - "group tacacs+ local"
                           - "group MYGROUP none"
                           -
                           "group radius group MYGROUP local"

                    """

        class Dynamic(AvdModel):
            """Subclass of AvdModel."""

            class Dot1xAdditionalGroups(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Dot1xAdditionalGroups._item_type = str

            _fields: ClassVar[dict] = {"dot1x_additional_groups": {"type": Dot1xAdditionalGroups}}
            dot1x_additional_groups: Dot1xAdditionalGroups
            """Subclass of AvdList with `str` items."""

            if TYPE_CHECKING:

                def __init__(self, *, dot1x_additional_groups: Dot1xAdditionalGroups | UndefinedType = Undefined) -> None:
                    """
                    Dynamic.


                    Subclass of AvdModel.

                    Args:
                        dot1x_additional_groups: Subclass of AvdList with `str` items.

                    """

        class Commands(AvdModel):
            """Subclass of AvdModel."""

            class PrivilegeItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "default": {"type": str}}
                level: str | None
                """Privilege level(s) 0-15."""
                default: str | None
                """
                Command authorization method(s) as a string.
                Examples:
                - "group tacacs+ local"
                - "group MYGROUP
                none"
                - "group tacacs+ group MYGROUP local"
                """

                if TYPE_CHECKING:

                    def __init__(self, *, level: str | None | UndefinedType = Undefined, default: str | None | UndefinedType = Undefined) -> None:
                        """
                        PrivilegeItem.


                        Subclass of AvdModel.

                        Args:
                            level: Privilege level(s) 0-15.
                            default:
                               Command authorization method(s) as a string.
                               Examples:  # fmt: skip
                               - "group tacacs+ local"
                               - "group MYGROUP
                               none"
                               - "group tacacs+ group MYGROUP local"

                        """

            class Privilege(AvdList[PrivilegeItem]):
                """Subclass of AvdList with `PrivilegeItem` items."""

            Privilege._item_type = PrivilegeItem

            _fields: ClassVar[dict] = {"all_default": {"type": str}, "privilege": {"type": Privilege}}
            all_default: str | None
            """
            Command authorization method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP
            none"
            - "group tacacs+ group MYGROUP local
            """
            privilege: Privilege
            """Subclass of AvdList with `PrivilegeItem` items."""

            if TYPE_CHECKING:

                def __init__(self, *, all_default: str | None | UndefinedType = Undefined, privilege: Privilege | UndefinedType = Undefined) -> None:
                    """
                    Commands.


                    Subclass of AvdModel.

                    Args:
                        all_default:
                           Command authorization method(s) as a string.
                           Examples:  # fmt: skip
                           - "group tacacs+ local"
                           - "group MYGROUP
                           none"
                           - "group tacacs+ group MYGROUP local
                        privilege: Subclass of AvdList with `PrivilegeItem` items.

                    """

        _fields: ClassVar[dict] = {
            "policy": {"type": Policy},
            "exec": {"type": Exec},
            "config_commands": {"type": bool},
            "serial_console": {"type": bool},
            "dynamic": {"type": Dynamic},
            "commands": {"type": Commands},
        }
        policy: Policy
        """Subclass of AvdModel."""
        exec: Exec
        """Subclass of AvdModel."""
        config_commands: bool | None
        serial_console: bool | None
        dynamic: Dynamic
        """Subclass of AvdModel."""
        commands: Commands
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                policy: Policy | UndefinedType = Undefined,
                exec: Exec | UndefinedType = Undefined,
                config_commands: bool | None | UndefinedType = Undefined,
                serial_console: bool | None | UndefinedType = Undefined,
                dynamic: Dynamic | UndefinedType = Undefined,
                commands: Commands | UndefinedType = Undefined,
            ) -> None:
                """
                AaaAuthorization.


                Subclass of AvdModel.

                Args:
                    policy: Subclass of AvdModel.
                    exec: Subclass of AvdModel.
                    config_commands: config_commands
                    serial_console: serial_console
                    dynamic: Subclass of AvdModel.
                    commands: Subclass of AvdModel.

                """

    class AaaRoot(AvdModel):
        """Subclass of AvdModel."""

        class Secret(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sha512_password": {"type": str}}
            sha512_password: str | None

            if TYPE_CHECKING:

                def __init__(self, *, sha512_password: str | None | UndefinedType = Undefined) -> None:
                    """
                    Secret.


                    Subclass of AvdModel.

                    Args:
                        sha512_password: sha512_password

                    """

        _fields: ClassVar[dict] = {"disabled": {"type": bool}, "secret": {"type": Secret}}
        disabled: bool | None
        """Set to `true` to configure `no aaa root` which is the EOS default."""
        secret: Secret
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, disabled: bool | None | UndefinedType = Undefined, secret: Secret | UndefinedType = Undefined) -> None:
                """
                AaaRoot.


                Subclass of AvdModel.

                Args:
                    disabled: Set to `true` to configure `no aaa root` which is the EOS default.
                    secret: Subclass of AvdModel.

                """

    class AaaServerGroupsItem(AvdModel):
        """Subclass of AvdModel."""

        class ServersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"server": {"type": str}, "vrf": {"type": str}}
            server: str | None
            """Hostname or IP address."""
            vrf: str | None
            """VRF name."""

            if TYPE_CHECKING:

                def __init__(self, *, server: str | None | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                    """
                    ServersItem.


                    Subclass of AvdModel.

                    Args:
                        server: Hostname or IP address.
                        vrf: VRF name.

                    """

        class Servers(AvdList[ServersItem]):
            """Subclass of AvdList with `ServersItem` items."""

        Servers._item_type = ServersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "type": {"type": str}, "servers": {"type": Servers}}
        name: str
        """Group name."""
        type: Literal["tacacs+", "radius", "ldap"] | None
        servers: Servers
        """Subclass of AvdList with `ServersItem` items."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                type: Literal["tacacs+", "radius", "ldap"] | None | UndefinedType = Undefined,
                servers: Servers | UndefinedType = Undefined,
            ) -> None:
                """
                AaaServerGroupsItem.


                Subclass of AvdModel.

                Args:
                    name: Group name.
                    type: type
                    servers: Subclass of AvdList with `ServersItem` items.

                """

    class AaaServerGroups(AvdIndexedList[str, AaaServerGroupsItem]):
        """Subclass of AvdIndexedList with `AaaServerGroupsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    AaaServerGroups._item_type = AaaServerGroupsItem

    class AccessListsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}}
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "deny ip any any"
            """

            if TYPE_CHECKING:

                def __init__(self, *, sequence: int | UndefinedType = Undefined, action: str | UndefinedType = Undefined) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        action:
                           Action as string.
                           Example: "deny ip any any"

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "permit_response_traffic": {"type": str},
            "sequence_numbers": {"type": SequenceNumbers},
        }
        name: str
        """Access-list Name."""
        counters_per_entry: bool | None
        permit_response_traffic: Literal["nat"] | None
        """
        Permit response traffic automatically based on NAT translations.
        Minimum EOS version requirement
        4.32.2F.
        """
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                counters_per_entry: bool | None | UndefinedType = Undefined,
                permit_response_traffic: Literal["nat"] | None | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
            ) -> None:
                """
                AccessListsItem.


                Subclass of AvdModel.

                Args:
                    name: Access-list Name.
                    counters_per_entry: counters_per_entry
                    permit_response_traffic:
                       Permit response traffic automatically based on NAT translations.
                       Minimum EOS version requirement
                       4.32.2F.
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).

                """

    class AccessLists(AvdIndexedList[str, AccessListsItem]):
        """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    AccessLists._item_type = AccessListsItem

    class AddressLocking(AvdModel):
        """Subclass of AvdModel."""

        class DhcpServersIpv4(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        DhcpServersIpv4._item_type = str

        class LeasesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ip": {"type": str}, "mac": {"type": str}}
            ip: str
            """IP address."""
            mac: str
            """MAC address (hhhh.hhhh.hhhh or hh:hh:hh:hh:hh:hh)."""

            if TYPE_CHECKING:

                def __init__(self, *, ip: str | UndefinedType = Undefined, mac: str | UndefinedType = Undefined) -> None:
                    """
                    LeasesItem.


                    Subclass of AvdModel.

                    Args:
                        ip: IP address.
                        mac: MAC address (hhhh.hhhh.hhhh or hh:hh:hh:hh:hh:hh).

                    """

        class Leases(AvdList[LeasesItem]):
            """Subclass of AvdList with `LeasesItem` items."""

        Leases._item_type = LeasesItem

        class LockedAddress(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "expiration_mac_disabled": {"type": bool},
                "ipv4_enforcement_disabled": {"type": bool},
                "ipv6_enforcement_disabled": {"type": bool},
            }
            expiration_mac_disabled: bool | None
            """Configure deauthorizing locked addresses upon MAC aging out."""
            ipv4_enforcement_disabled: bool | None
            """Configure enforcement for locked IPv4 addresses."""
            ipv6_enforcement_disabled: bool | None
            """Configure enforcement for locked IPv6 addresses."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    expiration_mac_disabled: bool | None | UndefinedType = Undefined,
                    ipv4_enforcement_disabled: bool | None | UndefinedType = Undefined,
                    ipv6_enforcement_disabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LockedAddress.


                    Subclass of AvdModel.

                    Args:
                        expiration_mac_disabled: Configure deauthorizing locked addresses upon MAC aging out.
                        ipv4_enforcement_disabled: Configure enforcement for locked IPv4 addresses.
                        ipv6_enforcement_disabled: Configure enforcement for locked IPv6 addresses.

                    """

        _fields: ClassVar[dict] = {
            "dhcp_servers_ipv4": {"type": DhcpServersIpv4},
            "disabled": {"type": bool},
            "leases": {"type": Leases},
            "local_interface": {"type": str},
            "locked_address": {"type": LockedAddress},
        }
        dhcp_servers_ipv4: DhcpServersIpv4
        """Subclass of AvdList with `str` items."""
        disabled: bool | None
        """Disable IP locking on configured ports."""
        leases: Leases
        """Subclass of AvdList with `LeasesItem` items."""
        local_interface: str | None
        locked_address: LockedAddress
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                dhcp_servers_ipv4: DhcpServersIpv4 | UndefinedType = Undefined,
                disabled: bool | None | UndefinedType = Undefined,
                leases: Leases | UndefinedType = Undefined,
                local_interface: str | None | UndefinedType = Undefined,
                locked_address: LockedAddress | UndefinedType = Undefined,
            ) -> None:
                """
                AddressLocking.


                Subclass of AvdModel.

                Args:
                    dhcp_servers_ipv4: Subclass of AvdList with `str` items.
                    disabled: Disable IP locking on configured ports.
                    leases: Subclass of AvdList with `LeasesItem` items.
                    local_interface: local_interface
                    locked_address: Subclass of AvdModel.

                """

    class AgentsItem(AvdModel):
        """Subclass of AvdModel."""

        class EnvironmentVariablesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "value": {"type": str}}
            name: str
            """Environment variable name."""
            value: str
            """Environment variable value."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, value: str | UndefinedType = Undefined) -> None:
                    """
                    EnvironmentVariablesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Environment variable name.
                        value: Environment variable value.

                    """

        class EnvironmentVariables(AvdIndexedList[str, EnvironmentVariablesItem]):
            """Subclass of AvdIndexedList with `EnvironmentVariablesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        EnvironmentVariables._item_type = EnvironmentVariablesItem

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "environment_variables": {"type": EnvironmentVariables},
            "shutdown": {"type": bool},
            "shutdown_supervisor_active": {"type": bool},
            "shutdown_supervisor_standby": {"type": bool},
        }
        name: str
        """Agent name."""
        environment_variables: EnvironmentVariables
        """Subclass of AvdIndexedList with `EnvironmentVariablesItem` items. Primary key is `name` (`str`)."""
        shutdown: bool | None
        """Shutdown the agent process."""
        shutdown_supervisor_active: bool | None
        """Shutdown the agent process for active supervisors."""
        shutdown_supervisor_standby: bool | None
        """Shutdown the agent process for standby supervisors."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                environment_variables: EnvironmentVariables | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                shutdown_supervisor_active: bool | None | UndefinedType = Undefined,
                shutdown_supervisor_standby: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                AgentsItem.


                Subclass of AvdModel.

                Args:
                    name: Agent name.
                    environment_variables: Subclass of AvdIndexedList with `EnvironmentVariablesItem` items. Primary key is `name` (`str`).
                    shutdown: Shutdown the agent process.
                    shutdown_supervisor_active: Shutdown the agent process for active supervisors.
                    shutdown_supervisor_standby: Shutdown the agent process for standby supervisors.

                """

    class Agents(AvdIndexedList[str, AgentsItem]):
        """Subclass of AvdIndexedList with `AgentsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Agents._item_type = AgentsItem

    class ApplicationTrafficRecognition(AvdModel):
        """Subclass of AvdModel."""

        class CategoriesItem(AvdModel):
            """Subclass of AvdModel."""

            class ApplicationsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "service": {"type": str}}
                name: str
                """Application name."""
                service: Literal["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"] | None
                """
                Service Name.
                Specific service to target for this application.
                If no service is specified, all
                supported services of the application are matched.
                Not all valid values are valid for all
                applications, check on EOS CLI.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        service: Literal["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"]
                        | None
                        | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ApplicationsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Application name.
                            service:
                               Service Name.
                               Specific service to target for this application.
                               If no service is specified, all
                               supported services of the application are matched.
                               Not all valid values are valid for all
                               applications, check on EOS CLI.

                        """

            class Applications(AvdList[ApplicationsItem]):
                """Subclass of AvdList with `ApplicationsItem` items."""

            Applications._item_type = ApplicationsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "applications": {"type": Applications}}
            name: str
            """Category name."""
            applications: Applications
            """
            List of applications.

            Subclass of AvdList with `ApplicationsItem` items.
            """

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, applications: Applications | UndefinedType = Undefined) -> None:
                    """
                    CategoriesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Category name.
                        applications:
                           List of applications.

                           Subclass of AvdList with `ApplicationsItem` items.

                    """

        class Categories(AvdIndexedList[str, CategoriesItem]):
            """Subclass of AvdIndexedList with `CategoriesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Categories._item_type = CategoriesItem

        class FieldSets(AvdModel):
            """Subclass of AvdModel."""

            class L4PortsItem(AvdModel):
                """Subclass of AvdModel."""

                class PortValues(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                PortValues._item_type = str

                _fields: ClassVar[dict] = {"name": {"type": str}, "port_values": {"type": PortValues}}
                name: str
                """L4 port field-set name."""
                port_values: PortValues
                """Subclass of AvdList with `str` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, port_values: PortValues | UndefinedType = Undefined) -> None:
                        """
                        L4PortsItem.


                        Subclass of AvdModel.

                        Args:
                            name: L4 port field-set name.
                            port_values: Subclass of AvdList with `str` items.

                        """

            class L4Ports(AvdIndexedList[str, L4PortsItem]):
                """Subclass of AvdIndexedList with `L4PortsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            L4Ports._item_type = L4PortsItem

            class Ipv4PrefixesItem(AvdModel):
                """Subclass of AvdModel."""

                class PrefixValues(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                PrefixValues._item_type = str

                _fields: ClassVar[dict] = {"name": {"type": str}, "prefix_values": {"type": PrefixValues}}
                name: str
                """IPv4 prefix field-set name."""
                prefix_values: PrefixValues
                """Subclass of AvdList with `str` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, prefix_values: PrefixValues | UndefinedType = Undefined) -> None:
                        """
                        Ipv4PrefixesItem.


                        Subclass of AvdModel.

                        Args:
                            name: IPv4 prefix field-set name.
                            prefix_values: Subclass of AvdList with `str` items.

                        """

            class Ipv4Prefixes(AvdIndexedList[str, Ipv4PrefixesItem]):
                """Subclass of AvdIndexedList with `Ipv4PrefixesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Ipv4Prefixes._item_type = Ipv4PrefixesItem

            _fields: ClassVar[dict] = {"l4_ports": {"type": L4Ports}, "ipv4_prefixes": {"type": Ipv4Prefixes}}
            l4_ports: L4Ports
            """
            L4 port field-set.

            Subclass of AvdIndexedList with `L4PortsItem` items. Primary key is `name`
            (`str`).
            """
            ipv4_prefixes: Ipv4Prefixes
            """
            IPv4 prefix field set.

            Subclass of AvdIndexedList with `Ipv4PrefixesItem` items. Primary key is
            `name` (`str`).
            """

            if TYPE_CHECKING:

                def __init__(self, *, l4_ports: L4Ports | UndefinedType = Undefined, ipv4_prefixes: Ipv4Prefixes | UndefinedType = Undefined) -> None:
                    """
                    FieldSets.


                    Subclass of AvdModel.

                    Args:
                        l4_ports:
                           L4 port field-set.

                           Subclass of AvdIndexedList with `L4PortsItem` items. Primary key is `name`
                           (`str`).
                        ipv4_prefixes:
                           IPv4 prefix field set.

                           Subclass of AvdIndexedList with `Ipv4PrefixesItem` items. Primary key is
                           `name` (`str`).

                    """

        class Applications(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4ApplicationsItem(AvdModel):
                """Subclass of AvdModel."""

                class DscpRanges(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                DscpRanges._item_type = str

                class Protocols(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Protocols._item_type = str

                class ProtocolRanges(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                ProtocolRanges._item_type = str

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "src_prefix_set_name": {"type": str},
                    "dest_prefix_set_name": {"type": str},
                    "dscp_ranges": {"type": DscpRanges},
                    "protocols": {"type": Protocols},
                    "protocol_ranges": {"type": ProtocolRanges},
                    "udp_src_port_set_name": {"type": str},
                    "tcp_src_port_set_name": {"type": str},
                    "udp_dest_port_set_name": {"type": str},
                    "tcp_dest_port_set_name": {"type": str},
                }
                name: str
                """Application name."""
                src_prefix_set_name: str | None
                """Source prefix set name."""
                dest_prefix_set_name: str | None
                """Destination prefix set name."""
                dscp_ranges: DscpRanges
                """
                Accept DSCP value(s) or range(s).
                DSCP values can be between 0 and 63.
                Other valid values are cs0 to
                cs7, af11-13, af21-23, af31-33, af41-af43 and ef.
                Note: The values are not sorted so the list items
                need to be supplied in the right order to match the CLI if required.

                Subclass of AvdList with `str`
                items.
                """
                protocols: Protocols
                """
                List of protocols to consider for this application.
                To use port field-sets (source, destination or
                both), the list
                must contain only one or two protocols, either `tcp` or `udp`.
                When using both
                protocols, one line is rendered for each in the configuration,
                hence the field-sets must have the
                same value for `tcp_src_port_set_name` and
                `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                and `udp_dest_port_set_name`
                if set in order to generate valid configuration in EOS.

                Subclass of
                AvdList with `str` items.
                """
                protocol_ranges: ProtocolRanges
                """
                Accept protocol value(s) or range(s).
                Protocol values can be between 1 and 255.

                Subclass of AvdList
                with `str` items.
                """
                udp_src_port_set_name: str | None
                """
                Name of field set for UDP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `tcp_src_port_set_name`.
                """
                tcp_src_port_set_name: str | None
                """
                Name of field set for TCP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `udp_src_port_set_name`.
                """
                udp_dest_port_set_name: str | None
                """
                Name of field set for UDP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `tcp_dest_port_set_name`.
                """
                tcp_dest_port_set_name: str | None
                """
                Name of field set for TCP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `udp_dest_port_set_name`.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        src_prefix_set_name: str | None | UndefinedType = Undefined,
                        dest_prefix_set_name: str | None | UndefinedType = Undefined,
                        dscp_ranges: DscpRanges | UndefinedType = Undefined,
                        protocols: Protocols | UndefinedType = Undefined,
                        protocol_ranges: ProtocolRanges | UndefinedType = Undefined,
                        udp_src_port_set_name: str | None | UndefinedType = Undefined,
                        tcp_src_port_set_name: str | None | UndefinedType = Undefined,
                        udp_dest_port_set_name: str | None | UndefinedType = Undefined,
                        tcp_dest_port_set_name: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4ApplicationsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Application name.
                            src_prefix_set_name: Source prefix set name.
                            dest_prefix_set_name: Destination prefix set name.
                            dscp_ranges:
                               Accept DSCP value(s) or range(s).
                               DSCP values can be between 0 and 63.
                               Other valid values are cs0 to
                               cs7, af11-13, af21-23, af31-33, af41-af43 and ef.
                               Note: The values are not sorted so the list items
                               need to be supplied in the right order to match the CLI if required.

                               Subclass of AvdList with `str`
                               items.
                            protocols:
                               List of protocols to consider for this application.
                               To use port field-sets (source, destination or
                               both), the list
                               must contain only one or two protocols, either `tcp` or `udp`.
                               When using both
                               protocols, one line is rendered for each in the configuration,
                               hence the field-sets must have the
                               same value for `tcp_src_port_set_name` and
                               `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                               and `udp_dest_port_set_name`
                               if set in order to generate valid configuration in EOS.

                               Subclass of
                               AvdList with `str` items.
                            protocol_ranges:
                               Accept protocol value(s) or range(s).
                               Protocol values can be between 1 and 255.

                               Subclass of AvdList
                               with `str` items.
                            udp_src_port_set_name:
                               Name of field set for UDP source ports.
                               When the `protocols` list contain both `tcp` and `udp`, this
                               key value
                               must be the same as `tcp_src_port_set_name`.
                            tcp_src_port_set_name:
                               Name of field set for TCP source ports.
                               When the `protocols` list contain both `tcp` and `udp`, this
                               key value
                               must be the same as `udp_src_port_set_name`.
                            udp_dest_port_set_name:
                               Name of field set for UDP destination ports.
                               When the `protocols` list contain both `tcp` and `udp`,
                               this key value
                               must be the same as `tcp_dest_port_set_name`.
                            tcp_dest_port_set_name:
                               Name of field set for TCP destination ports.
                               When the `protocols` list contain both `tcp` and `udp`,
                               this key value
                               must be the same as `udp_dest_port_set_name`.

                        """

            class Ipv4Applications(AvdIndexedList[str, Ipv4ApplicationsItem]):
                """Subclass of AvdIndexedList with `Ipv4ApplicationsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Ipv4Applications._item_type = Ipv4ApplicationsItem

            class L4ApplicationsItem(AvdModel):
                """Subclass of AvdModel."""

                class Protocols(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Protocols._item_type = str

                class ProtocolRanges(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                ProtocolRanges._item_type = str

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "protocols": {"type": Protocols},
                    "protocol_ranges": {"type": ProtocolRanges},
                    "udp_src_port_set_name": {"type": str},
                    "tcp_src_port_set_name": {"type": str},
                    "udp_dest_port_set_name": {"type": str},
                    "tcp_dest_port_set_name": {"type": str},
                }
                name: str
                """Application name."""
                protocols: Protocols
                """
                List of protocols to consider for this application.
                To use port field-sets (source, destination or
                both), the list
                must contain only one or two protocols, either `tcp` or `udp`.
                When using both
                protocols, one line is rendered for each in the configuration,
                hence the field-sets must have the
                same value for `tcp_src_port_set_name` and
                `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                and `udp_dest_port_set_name`
                if set in order to generate valid configuration in EOS.

                Subclass of
                AvdList with `str` items.
                """
                protocol_ranges: ProtocolRanges
                """
                Accept protocol value(s) or range(s).
                Protocol values can be between 1 and 255.

                Subclass of AvdList
                with `str` items.
                """
                udp_src_port_set_name: str | None
                """
                Name of field set for UDP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `tcp_src_port_set_name`.
                """
                tcp_src_port_set_name: str | None
                """
                Name of field set for TCP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `udp_src_port_set_name`.
                """
                udp_dest_port_set_name: str | None
                """
                Name of field set for UDP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `tcp_dest_port_set_name`.
                """
                tcp_dest_port_set_name: str | None
                """
                Name of field set for TCP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `udp_dest_port_set_name`.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        protocols: Protocols | UndefinedType = Undefined,
                        protocol_ranges: ProtocolRanges | UndefinedType = Undefined,
                        udp_src_port_set_name: str | None | UndefinedType = Undefined,
                        tcp_src_port_set_name: str | None | UndefinedType = Undefined,
                        udp_dest_port_set_name: str | None | UndefinedType = Undefined,
                        tcp_dest_port_set_name: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        L4ApplicationsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Application name.
                            protocols:
                               List of protocols to consider for this application.
                               To use port field-sets (source, destination or
                               both), the list
                               must contain only one or two protocols, either `tcp` or `udp`.
                               When using both
                               protocols, one line is rendered for each in the configuration,
                               hence the field-sets must have the
                               same value for `tcp_src_port_set_name` and
                               `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                               and `udp_dest_port_set_name`
                               if set in order to generate valid configuration in EOS.

                               Subclass of
                               AvdList with `str` items.
                            protocol_ranges:
                               Accept protocol value(s) or range(s).
                               Protocol values can be between 1 and 255.

                               Subclass of AvdList
                               with `str` items.
                            udp_src_port_set_name:
                               Name of field set for UDP source ports.
                               When the `protocols` list contain both `tcp` and `udp`, this
                               key value
                               must be the same as `tcp_src_port_set_name`.
                            tcp_src_port_set_name:
                               Name of field set for TCP source ports.
                               When the `protocols` list contain both `tcp` and `udp`, this
                               key value
                               must be the same as `udp_src_port_set_name`.
                            udp_dest_port_set_name:
                               Name of field set for UDP destination ports.
                               When the `protocols` list contain both `tcp` and `udp`,
                               this key value
                               must be the same as `tcp_dest_port_set_name`.
                            tcp_dest_port_set_name:
                               Name of field set for TCP destination ports.
                               When the `protocols` list contain both `tcp` and `udp`,
                               this key value
                               must be the same as `udp_dest_port_set_name`.

                        """

            class L4Applications(AvdIndexedList[str, L4ApplicationsItem]):
                """Subclass of AvdIndexedList with `L4ApplicationsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            L4Applications._item_type = L4ApplicationsItem

            _fields: ClassVar[dict] = {"ipv4_applications": {"type": Ipv4Applications}, "l4_applications": {"type": L4Applications}}
            ipv4_applications: Ipv4Applications
            """
            List of user defined IPv4 applications. The name should be unique over all defined applications
            (ipv4 and l4).

            Subclass of AvdIndexedList with `Ipv4ApplicationsItem` items. Primary key is `name`
            (`str`).
            """
            l4_applications: L4Applications
            """
            List of user defined L4 applications. The name should be unique over all defined applications (ipv4
            and l4).

            Subclass of AvdIndexedList with `L4ApplicationsItem` items. Primary key is `name` (`str`).
            """

            if TYPE_CHECKING:

                def __init__(
                    self, *, ipv4_applications: Ipv4Applications | UndefinedType = Undefined, l4_applications: L4Applications | UndefinedType = Undefined
                ) -> None:
                    """
                    Applications.


                    Subclass of AvdModel.

                    Args:
                        ipv4_applications:
                           List of user defined IPv4 applications. The name should be unique over all defined applications
                           (ipv4 and l4).

                           Subclass of AvdIndexedList with `Ipv4ApplicationsItem` items. Primary key is `name`
                           (`str`).
                        l4_applications:
                           List of user defined L4 applications. The name should be unique over all defined applications (ipv4
                           and l4).

                           Subclass of AvdIndexedList with `L4ApplicationsItem` items. Primary key is `name` (`str`).

                    """

        class ApplicationProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class ApplicationsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "service": {"type": str}}
                name: str
                """Application Name."""
                service: Literal["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"] | None
                """
                Service Name.
                Specific service to target for this application.
                If no service is specified, all
                supported services of the application are matched.
                Not all valid values are valid for all
                applications, check on EOS CLI.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        service: Literal["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"]
                        | None
                        | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ApplicationsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Application Name.
                            service:
                               Service Name.
                               Specific service to target for this application.
                               If no service is specified, all
                               supported services of the application are matched.
                               Not all valid values are valid for all
                               applications, check on EOS CLI.

                        """

            class Applications(AvdList[ApplicationsItem]):
                """Subclass of AvdList with `ApplicationsItem` items."""

            Applications._item_type = ApplicationsItem

            class ApplicationTransports(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            ApplicationTransports._item_type = str

            class CategoriesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "service": {"type": str}}
                name: str
                """Name of a category."""
                service: Literal["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"] | None
                """
                Service Name.
                Specific service to target for this application.
                If no service is specified, all
                supported services of the application are matched.
                Not all valid values are valid for all
                applications, check on EOS CLI.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        service: Literal["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"]
                        | None
                        | UndefinedType = Undefined,
                    ) -> None:
                        """
                        CategoriesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Name of a category.
                            service:
                               Service Name.
                               Specific service to target for this application.
                               If no service is specified, all
                               supported services of the application are matched.
                               Not all valid values are valid for all
                               applications, check on EOS CLI.

                        """

            class Categories(AvdList[CategoriesItem]):
                """Subclass of AvdList with `CategoriesItem` items."""

            Categories._item_type = CategoriesItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "applications": {"type": Applications},
                "application_transports": {"type": ApplicationTransports},
                "categories": {"type": Categories},
            }
            name: str
            """Application Profile name."""
            applications: Applications
            """
            List of applications part of the application profile.

            Subclass of AvdList with `ApplicationsItem`
            items.
            """
            application_transports: ApplicationTransports
            """
            List of transport protocols.

            Subclass of AvdList with `str` items.
            """
            categories: Categories
            """
            Categories under this application profile.

            Subclass of AvdList with `CategoriesItem` items.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    applications: Applications | UndefinedType = Undefined,
                    application_transports: ApplicationTransports | UndefinedType = Undefined,
                    categories: Categories | UndefinedType = Undefined,
                ) -> None:
                    """
                    ApplicationProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Application Profile name.
                        applications:
                           List of applications part of the application profile.

                           Subclass of AvdList with `ApplicationsItem`
                           items.
                        application_transports:
                           List of transport protocols.

                           Subclass of AvdList with `str` items.
                        categories:
                           Categories under this application profile.

                           Subclass of AvdList with `CategoriesItem` items.

                    """

        class ApplicationProfiles(AvdIndexedList[str, ApplicationProfilesItem]):
            """Subclass of AvdIndexedList with `ApplicationProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        ApplicationProfiles._item_type = ApplicationProfilesItem

        _fields: ClassVar[dict] = {
            "categories": {"type": Categories},
            "field_sets": {"type": FieldSets},
            "applications": {"type": Applications},
            "application_profiles": {"type": ApplicationProfiles},
        }
        categories: Categories
        """
        List of categories.

        Subclass of AvdIndexedList with `CategoriesItem` items. Primary key is `name`
        (`str`).
        """
        field_sets: FieldSets
        """Subclass of AvdModel."""
        applications: Applications
        """Subclass of AvdModel."""
        application_profiles: ApplicationProfiles
        """
        Group of applications.

        Subclass of AvdIndexedList with `ApplicationProfilesItem` items. Primary key
        is `name` (`str`).
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                categories: Categories | UndefinedType = Undefined,
                field_sets: FieldSets | UndefinedType = Undefined,
                applications: Applications | UndefinedType = Undefined,
                application_profiles: ApplicationProfiles | UndefinedType = Undefined,
            ) -> None:
                """
                ApplicationTrafficRecognition.


                Subclass of AvdModel.

                Args:
                    categories:
                       List of categories.

                       Subclass of AvdIndexedList with `CategoriesItem` items. Primary key is `name`
                       (`str`).
                    field_sets: Subclass of AvdModel.
                    applications: Subclass of AvdModel.
                    application_profiles:
                       Group of applications.

                       Subclass of AvdIndexedList with `ApplicationProfilesItem` items. Primary key
                       is `name` (`str`).

                """

    class Arp(AvdModel):
        """Subclass of AvdModel."""

        class Persistent(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "refresh_delay": {"type": int}}
            enabled: bool
            """Restore the ARP cache after reboot."""
            refresh_delay: int | None
            """Time to wait in seconds before refreshing the ARP cache after reboot (EOS default 600)."""

            if TYPE_CHECKING:

                def __init__(self, *, enabled: bool | UndefinedType = Undefined, refresh_delay: int | None | UndefinedType = Undefined) -> None:
                    """
                    Persistent.


                    Subclass of AvdModel.

                    Args:
                        enabled: Restore the ARP cache after reboot.
                        refresh_delay: Time to wait in seconds before refreshing the ARP cache after reboot (EOS default 600).

                    """

        class Aging(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"timeout_default": {"type": int}}
            timeout_default: int | None
            """Timeout in seconds."""

            if TYPE_CHECKING:

                def __init__(self, *, timeout_default: int | None | UndefinedType = Undefined) -> None:
                    """
                    Aging.


                    Subclass of AvdModel.

                    Args:
                        timeout_default: Timeout in seconds.

                    """

        class StaticEntriesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4_address": {"type": str}, "vrf": {"type": str}, "mac_address": {"type": str}}
            ipv4_address: str
            """ARP entry IPv4 address."""
            vrf: str | None
            """ARP entry VRF."""
            mac_address: str
            """ARP entry MAC address."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4_address: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    mac_address: str | UndefinedType = Undefined,
                ) -> None:
                    """
                    StaticEntriesItem.


                    Subclass of AvdModel.

                    Args:
                        ipv4_address: ARP entry IPv4 address.
                        vrf: ARP entry VRF.
                        mac_address: ARP entry MAC address.

                    """

        class StaticEntries(AvdList[StaticEntriesItem]):
            """Subclass of AvdList with `StaticEntriesItem` items."""

        StaticEntries._item_type = StaticEntriesItem

        _fields: ClassVar[dict] = {"persistent": {"type": Persistent}, "aging": {"type": Aging}, "static_entries": {"type": StaticEntries}}
        persistent: Persistent
        """Subclass of AvdModel."""
        aging: Aging
        """Subclass of AvdModel."""
        static_entries: StaticEntries
        """
        Static ARP entries.

        Subclass of AvdList with `StaticEntriesItem` items.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                persistent: Persistent | UndefinedType = Undefined,
                aging: Aging | UndefinedType = Undefined,
                static_entries: StaticEntries | UndefinedType = Undefined,
            ) -> None:
                """
                Arp.


                Subclass of AvdModel.

                Args:
                    persistent: Subclass of AvdModel.
                    aging: Subclass of AvdModel.
                    static_entries:
                       Static ARP entries.

                       Subclass of AvdList with `StaticEntriesItem` items.

                """

    class AsPath(AvdModel):
        """Subclass of AvdModel."""

        class AccessListsItem(AvdModel):
            """Subclass of AvdModel."""

            class EntriesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"type": {"type": str}, "match": {"type": str}, "origin": {"type": str, "default": "any"}}
                type: Literal["permit", "deny"] | None
                match: str | None
                """Regex To Match."""
                origin: Literal["any", "egp", "igp", "incomplete"]
                """Default value: `"any"`"""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        type: Literal["permit", "deny"] | None | UndefinedType = Undefined,
                        match: str | None | UndefinedType = Undefined,
                        origin: Literal["any", "egp", "igp", "incomplete"] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        EntriesItem.


                        Subclass of AvdModel.

                        Args:
                            type: type
                            match: Regex To Match.
                            origin: origin

                        """

            class Entries(AvdList[EntriesItem]):
                """Subclass of AvdList with `EntriesItem` items."""

            Entries._item_type = EntriesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "entries": {"type": Entries}}
            name: str
            """Access List Name."""
            entries: Entries
            """Subclass of AvdList with `EntriesItem` items."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, entries: Entries | UndefinedType = Undefined) -> None:
                    """
                    AccessListsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Access List Name.
                        entries: Subclass of AvdList with `EntriesItem` items.

                    """

        class AccessLists(AvdIndexedList[str, AccessListsItem]):
            """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        AccessLists._item_type = AccessListsItem

        _fields: ClassVar[dict] = {"regex_mode": {"type": str}, "access_lists": {"type": AccessLists}}
        regex_mode: Literal["asn", "string"] | None
        access_lists: AccessLists
        """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self, *, regex_mode: Literal["asn", "string"] | None | UndefinedType = Undefined, access_lists: AccessLists | UndefinedType = Undefined
            ) -> None:
                """
                AsPath.


                Subclass of AvdModel.

                Args:
                    regex_mode: regex_mode
                    access_lists: Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`).

                """

    class Banners(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"login": {"type": str}, "motd": {"type": str}}
        login: str | None
        """Multiline string ending with EOF on the last line."""
        motd: str | None
        """Multiline string ending with EOF on the last line."""

        if TYPE_CHECKING:

            def __init__(self, *, login: str | None | UndefinedType = Undefined, motd: str | None | UndefinedType = Undefined) -> None:
                """
                Banners.


                Subclass of AvdModel.

                Args:
                    login: Multiline string ending with EOF on the last line.
                    motd: Multiline string ending with EOF on the last line.

                """

    class BgpGroupsItem(AvdModel):
        """Subclass of AvdModel."""

        class Neighbors(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Neighbors._item_type = str

        class BgpMaintenanceProfiles(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        BgpMaintenanceProfiles._item_type = str

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "vrf": {"type": str},
            "neighbors": {"type": Neighbors},
            "bgp_maintenance_profiles": {"type": BgpMaintenanceProfiles},
        }
        name: str
        """Group Name."""
        vrf: str | None
        neighbors: Neighbors
        """Subclass of AvdList with `str` items."""
        bgp_maintenance_profiles: BgpMaintenanceProfiles
        """Subclass of AvdList with `str` items."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                bgp_maintenance_profiles: BgpMaintenanceProfiles | UndefinedType = Undefined,
            ) -> None:
                """
                BgpGroupsItem.


                Subclass of AvdModel.

                Args:
                    name: Group Name.
                    vrf: vrf
                    neighbors: Subclass of AvdList with `str` items.
                    bgp_maintenance_profiles: Subclass of AvdList with `str` items.

                """

    class BgpGroups(AvdIndexedList[str, BgpGroupsItem]):
        """Subclass of AvdIndexedList with `BgpGroupsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    BgpGroups._item_type = BgpGroupsItem

    class Boot(AvdModel):
        """Subclass of AvdModel."""

        class Secret(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"hash_algorithm": {"type": str, "default": "sha512"}, "key": {"type": str}}
            hash_algorithm: Literal["md5", "sha512"]
            """Default value: `"sha512"`"""
            key: str | None
            """Hashed Password."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, hash_algorithm: Literal["md5", "sha512"] | UndefinedType = Undefined, key: str | None | UndefinedType = Undefined
                ) -> None:
                    """
                    Secret.


                    Subclass of AvdModel.

                    Args:
                        hash_algorithm: hash_algorithm
                        key: Hashed Password.

                    """

        _fields: ClassVar[dict] = {"secret": {"type": Secret}}
        secret: Secret
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, secret: Secret | UndefinedType = Undefined) -> None:
                """
                Boot.


                Subclass of AvdModel.

                Args:
                    secret: Subclass of AvdModel.

                """

    class Cfm(AvdModel):
        """Subclass of AvdModel."""

        class DomainsItem(AvdModel):
            """Subclass of AvdModel."""

            class AssociationsItem(AvdModel):
                """Subclass of AvdModel."""

                class EndPointsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"id": {"type": int}, "remote_end_point": {"type": str}, "interface": {"type": str}}
                    id: int
                    """Local maintenance endpoint ID."""
                    remote_end_point: str | None
                    """
                    Remote maintenance endpoint ID(s) or range(s) of remote maintenance endpoint ID(s).
                    The range is
                    from 1 to 8191.
                    """
                    interface: str | None
                    """
                    Specifies the interface on which to configure the local maintenance endpoint.
                    Supported types
                    include Ethernet sub-interfaces, InternalRecirc, and Port-Channel link aggregation groups (LAGs).
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            remote_end_point: str | None | UndefinedType = Undefined,
                            interface: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            EndPointsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Local maintenance endpoint ID.
                                remote_end_point:
                                   Remote maintenance endpoint ID(s) or range(s) of remote maintenance endpoint ID(s).
                                   The range is
                                   from 1 to 8191.
                                interface:
                                   Specifies the interface on which to configure the local maintenance endpoint.
                                   Supported types
                                   include Ethernet sub-interfaces, InternalRecirc, and Port-Channel link aggregation groups (LAGs).

                            """

                class EndPoints(AvdIndexedList[int, EndPointsItem]):
                    """Subclass of AvdIndexedList with `EndPointsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                EndPoints._item_type = EndPointsItem

                class RemoteEndPointsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"id": {"type": int}, "mac_address": {"type": str}}
                    id: int
                    """Configure remote maintenance endpoint ID."""
                    mac_address: str | None
                    """MAC address of the RMEP."""

                    if TYPE_CHECKING:

                        def __init__(self, *, id: int | UndefinedType = Undefined, mac_address: str | None | UndefinedType = Undefined) -> None:
                            """
                            RemoteEndPointsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure remote maintenance endpoint ID.
                                mac_address: MAC address of the RMEP.

                            """

                class RemoteEndPoints(AvdIndexedList[int, RemoteEndPointsItem]):
                    """Subclass of AvdIndexedList with `RemoteEndPointsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                RemoteEndPoints._item_type = RemoteEndPointsItem

                _fields: ClassVar[dict] = {
                    "id": {"type": int},
                    "direction": {"type": str},
                    "end_points": {"type": EndPoints},
                    "profile": {"type": str},
                    "remote_end_points": {"type": RemoteEndPoints},
                    "vlan": {"type": int},
                }
                id: int
                """Maintenance association ID."""
                direction: Literal["up", "down"] | None
                """Local maintenance endpoint direction."""
                end_points: EndPoints
                """
                Configure the maintenance endpoint(MEP).

                Subclass of AvdIndexedList with `EndPointsItem` items.
                Primary key is `id` (`int`).
                """
                profile: str | None
                """Apply connectivity fault management profile."""
                remote_end_points: RemoteEndPoints
                """
                Configure the remote maintenance endpoint(RMEP).

                Subclass of AvdIndexedList with
                `RemoteEndPointsItem` items. Primary key is `id` (`int`).
                """
                vlan: int | None
                """Set VLAN in the maintenance association."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: int | UndefinedType = Undefined,
                        direction: Literal["up", "down"] | None | UndefinedType = Undefined,
                        end_points: EndPoints | UndefinedType = Undefined,
                        profile: str | None | UndefinedType = Undefined,
                        remote_end_points: RemoteEndPoints | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AssociationsItem.


                        Subclass of AvdModel.

                        Args:
                            id: Maintenance association ID.
                            direction: Local maintenance endpoint direction.
                            end_points:
                               Configure the maintenance endpoint(MEP).

                               Subclass of AvdIndexedList with `EndPointsItem` items.
                               Primary key is `id` (`int`).
                            profile: Apply connectivity fault management profile.
                            remote_end_points:
                               Configure the remote maintenance endpoint(RMEP).

                               Subclass of AvdIndexedList with
                               `RemoteEndPointsItem` items. Primary key is `id` (`int`).
                            vlan: Set VLAN in the maintenance association.

                        """

            class Associations(AvdIndexedList[int, AssociationsItem]):
                """Subclass of AvdIndexedList with `AssociationsItem` items. Primary key is `id` (`int`)."""

                _primary_key: ClassVar[str] = "id"

            Associations._item_type = AssociationsItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "level": {"type": int},
                "associations": {"type": Associations},
                "intermediate_point": {"type": bool},
            }
            name: str
            """CFM domain name."""
            level: int
            """Maintenance domain level."""
            associations: Associations
            """
            List of maintenance associations.

            Subclass of AvdIndexedList with `AssociationsItem` items. Primary
            key is `id` (`int`).
            """
            intermediate_point: bool | None
            """Configure the device as a maintenance intermediate point."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    level: int | UndefinedType = Undefined,
                    associations: Associations | UndefinedType = Undefined,
                    intermediate_point: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    DomainsItem.


                    Subclass of AvdModel.

                    Args:
                        name: CFM domain name.
                        level: Maintenance domain level.
                        associations:
                           List of maintenance associations.

                           Subclass of AvdIndexedList with `AssociationsItem` items. Primary
                           key is `id` (`int`).
                        intermediate_point: Configure the device as a maintenance intermediate point.

                    """

        class Domains(AvdIndexedList[str, DomainsItem]):
            """Subclass of AvdIndexedList with `DomainsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Domains._item_type = DomainsItem

        class MeasurementLoss(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"inband": {"type": bool}, "synthetic": {"type": bool}}
            inband: bool | None
            """Enable hardware-assisted support for OAM loss measurement."""
            synthetic: bool | None
            """Enable hardware-assisted support for OAM synthetic loss measurement."""

            if TYPE_CHECKING:

                def __init__(self, *, inband: bool | None | UndefinedType = Undefined, synthetic: bool | None | UndefinedType = Undefined) -> None:
                    """
                    MeasurementLoss.


                    Subclass of AvdModel.

                    Args:
                        inband: Enable hardware-assisted support for OAM loss measurement.
                        synthetic: Enable hardware-assisted support for OAM synthetic loss measurement.

                    """

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class AlarmIndication(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "client_domain_level": {"type": int}, "tx_interval": {"type": str}}
                enabled: bool | None
                """Enable sending of alarm indication signal (AIS) packets."""
                client_domain_level: int | None
                """Client maintenance domain level for which to send AIS packets."""
                tx_interval: Literal["1 seconds", "1 minutes"] | None
                """Transmission interval for AIS packets."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        client_domain_level: int | None | UndefinedType = Undefined,
                        tx_interval: Literal["1 seconds", "1 minutes"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AlarmIndication.


                        Subclass of AvdModel.

                        Args:
                            enabled: Enable sending of alarm indication signal (AIS) packets.
                            client_domain_level: Client maintenance domain level for which to send AIS packets.
                            tx_interval: Transmission interval for AIS packets.

                        """

            class ContinuityCheck(AvdModel):
                """Subclass of AvdModel."""

                class AlarmDefects(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                AlarmDefects._item_type = str

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "qos_cos": {"type": int},
                    "tx_interval": {"type": str},
                    "alarm_defects": {"type": AlarmDefects},
                }
                enabled: bool | None
                """Enable the continuity check protocol to monitor connectivity."""
                qos_cos: int | None
                """Set the class of service (CoS) value for CFM frames."""
                tx_interval: Literal["3.33 milliseconds", "10 milliseconds", "100 milliseconds", "1 seconds", "10 seconds", "1 minutes", "10 minutes"] | None
                """Set the transmission interval for continuity check messages (CCMs)."""
                alarm_defects: AlarmDefects
                """
                Defines alarm indication signal protocol parameters. Supported options:
                - rdi-ccm: Raise alarms on
                continuity check messages (CCMs) with the remote defect indication (RDI) bit set.
                - loc-state: Raise
                alarms on loss of connectivity (LOC).
                - error-ccm: Raise alarms on invalid continuity check messages
                (CCMs).
                - cross-connection: Raise alarms on cross-connection defects.

                Subclass of AvdList with
                `str` items.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        qos_cos: int | None | UndefinedType = Undefined,
                        tx_interval: Literal["3.33 milliseconds", "10 milliseconds", "100 milliseconds", "1 seconds", "10 seconds", "1 minutes", "10 minutes"]
                        | None
                        | UndefinedType = Undefined,
                        alarm_defects: AlarmDefects | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ContinuityCheck.


                        Subclass of AvdModel.

                        Args:
                            enabled: Enable the continuity check protocol to monitor connectivity.
                            qos_cos: Set the class of service (CoS) value for CFM frames.
                            tx_interval: Set the transmission interval for continuity check messages (CCMs).
                            alarm_defects:
                               Defines alarm indication signal protocol parameters. Supported options:
                               - rdi-ccm: Raise alarms on
                               continuity check messages (CCMs) with the remote defect indication (RDI) bit set.
                               - loc-state: Raise
                               alarms on loss of connectivity (LOC).
                               - error-ccm: Raise alarms on invalid continuity check messages
                               (CCMs).
                               - cross-connection: Raise alarms on cross-connection defects.

                               Subclass of AvdList with
                               `str` items.

                        """

            class Measurement(AvdModel):
                """Subclass of AvdModel."""

                class Delay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"single_ended": {"type": bool}, "qos_cos": {"type": int}, "tx_interval": {"type": str}}
                    single_ended: bool | None
                    """Enable single-ended delay measurement."""
                    qos_cos: int | None
                    """Set the class of service (CoS) value for CFM frames."""
                    tx_interval: str | None
                    """
                    Interval in milliseconds between successive measurement frames.
                    The range is from 3.33 to 600000.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            single_ended: bool | None | UndefinedType = Undefined,
                            qos_cos: int | None | UndefinedType = Undefined,
                            tx_interval: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Delay.


                            Subclass of AvdModel.

                            Args:
                                single_ended: Enable single-ended delay measurement.
                                qos_cos: Set the class of service (CoS) value for CFM frames.
                                tx_interval:
                                   Interval in milliseconds between successive measurement frames.
                                   The range is from 3.33 to 600000.

                            """

                class Loss(AvdModel):
                    """Subclass of AvdModel."""

                    class Synthetic(AvdModel):
                        """Subclass of AvdModel."""

                        class TxInterval(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"interval": {"type": str}, "period_frames": {"type": int}}
                            interval: str
                            """
                            Interval in milliseconds between successive measurement frames.
                            The range is from 3.33 to 600000.
                            """
                            period_frames: int | None
                            """Synthetic loss measurement transmission frames."""

                            if TYPE_CHECKING:

                                def __init__(self, *, interval: str | UndefinedType = Undefined, period_frames: int | None | UndefinedType = Undefined) -> None:
                                    """
                                    TxInterval.


                                    Subclass of AvdModel.

                                    Args:
                                        interval:
                                           Interval in milliseconds between successive measurement frames.
                                           The range is from 3.33 to 600000.
                                        period_frames: Synthetic loss measurement transmission frames.

                                    """

                        _fields: ClassVar[dict] = {"single_ended": {"type": bool}, "qos_cos": {"type": str}, "tx_interval": {"type": TxInterval}}
                        single_ended: bool | None
                        """Enable single-ended synthetic loss measurement."""
                        qos_cos: str | None
                        """Set the class of service (CoS) value or a range of values (0-7) for synthetic loss measurement."""
                        tx_interval: TxInterval
                        """Subclass of AvdModel."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                single_ended: bool | None | UndefinedType = Undefined,
                                qos_cos: str | None | UndefinedType = Undefined,
                                tx_interval: TxInterval | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Synthetic.


                                Subclass of AvdModel.

                                Args:
                                    single_ended: Enable single-ended synthetic loss measurement.
                                    qos_cos: Set the class of service (CoS) value or a range of values (0-7) for synthetic loss measurement.
                                    tx_interval: Subclass of AvdModel.

                                """

                    _fields: ClassVar[dict] = {
                        "single_ended": {"type": bool},
                        "qos_cos": {"type": int},
                        "tx_interval": {"type": str},
                        "synthetic": {"type": Synthetic},
                    }
                    single_ended: bool | None
                    """Enable single-ended loss measurement."""
                    qos_cos: int | None
                    """Set the class of service (CoS) value for CFM frames."""
                    tx_interval: str | None
                    """
                    Interval in milliseconds between successive measurement frames.
                    The range is from 3.33 to 600000.
                    """
                    synthetic: Synthetic
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            single_ended: bool | None | UndefinedType = Undefined,
                            qos_cos: int | None | UndefinedType = Undefined,
                            tx_interval: str | None | UndefinedType = Undefined,
                            synthetic: Synthetic | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Loss.


                            Subclass of AvdModel.

                            Args:
                                single_ended: Enable single-ended loss measurement.
                                qos_cos: Set the class of service (CoS) value for CFM frames.
                                tx_interval:
                                   Interval in milliseconds between successive measurement frames.
                                   The range is from 3.33 to 600000.
                                synthetic: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {"delay": {"type": Delay}, "loss": {"type": Loss}}
                delay: Delay
                """Subclass of AvdModel."""
                loss: Loss
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, delay: Delay | UndefinedType = Undefined, loss: Loss | UndefinedType = Undefined) -> None:
                        """
                        Measurement.


                        Subclass of AvdModel.

                        Args:
                            delay: Subclass of AvdModel.
                            loss: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "alarm_indication": {"type": AlarmIndication},
                "continuity_check": {"type": ContinuityCheck},
                "measurement": {"type": Measurement},
            }
            name: str
            """CFM profile name."""
            alarm_indication: AlarmIndication
            """Subclass of AvdModel."""
            continuity_check: ContinuityCheck
            """Subclass of AvdModel."""
            measurement: Measurement
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    alarm_indication: AlarmIndication | UndefinedType = Undefined,
                    continuity_check: ContinuityCheck | UndefinedType = Undefined,
                    measurement: Measurement | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: CFM profile name.
                        alarm_indication: Subclass of AvdModel.
                        continuity_check: Subclass of AvdModel.
                        measurement: Subclass of AvdModel.

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        _fields: ClassVar[dict] = {
            "continuity_check_loc_state_action_disable_interface_routing": {"type": bool},
            "domains": {"type": Domains},
            "measurement_loss": {"type": MeasurementLoss},
            "profiles": {"type": Profiles},
        }
        continuity_check_loc_state_action_disable_interface_routing: bool | None
        """
        Disable routing on interfaces where a loss of connectivity (LOC) defect is detected.
        This prevents
        traffic from being routed to a faulty link.
        """
        domains: Domains
        """Subclass of AvdIndexedList with `DomainsItem` items. Primary key is `name` (`str`)."""
        measurement_loss: MeasurementLoss
        """
        Configure Ethernet OAM loss measurement functions.

        Subclass of AvdModel.
        """
        profiles: Profiles
        """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                continuity_check_loc_state_action_disable_interface_routing: bool | None | UndefinedType = Undefined,
                domains: Domains | UndefinedType = Undefined,
                measurement_loss: MeasurementLoss | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
            ) -> None:
                """
                Cfm.


                Subclass of AvdModel.

                Args:
                    continuity_check_loc_state_action_disable_interface_routing:
                       Disable routing on interfaces where a loss of connectivity (LOC) defect is detected.
                       This prevents
                       traffic from being routed to a faulty link.
                    domains: Subclass of AvdIndexedList with `DomainsItem` items. Primary key is `name` (`str`).
                    measurement_loss:
                       Configure Ethernet OAM loss measurement functions.

                       Subclass of AvdModel.
                    profiles: Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`).

                """

    class ClassMaps(AvdModel):
        """Subclass of AvdModel."""

        class PbrItem(AvdModel):
            """Subclass of AvdModel."""

            class Ip(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"access_group": {"type": str}}
                access_group: str | None
                """Standard Access-List Name."""

                if TYPE_CHECKING:

                    def __init__(self, *, access_group: str | None | UndefinedType = Undefined) -> None:
                        """
                        Ip.


                        Subclass of AvdModel.

                        Args:
                            access_group: Standard Access-List Name.

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "ip": {"type": Ip}}
            name: str
            """Class-Map Name."""
            ip: Ip
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, ip: Ip | UndefinedType = Undefined) -> None:
                    """
                    PbrItem.


                    Subclass of AvdModel.

                    Args:
                        name: Class-Map Name.
                        ip: Subclass of AvdModel.

                    """

        class Pbr(AvdIndexedList[str, PbrItem]):
            """Subclass of AvdIndexedList with `PbrItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Pbr._item_type = PbrItem

        class QosItem(AvdModel):
            """Subclass of AvdModel."""

            class Ip(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"access_group": {"type": str}}
                access_group: str | None
                """IPv4 Access-List Name."""

                if TYPE_CHECKING:

                    def __init__(self, *, access_group: str | None | UndefinedType = Undefined) -> None:
                        """
                        Ip.


                        Subclass of AvdModel.

                        Args:
                            access_group: IPv4 Access-List Name.

                        """

            class Ipv6(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"access_group": {"type": str}}
                access_group: str | None
                """IPv6 Access-List Name."""

                if TYPE_CHECKING:

                    def __init__(self, *, access_group: str | None | UndefinedType = Undefined) -> None:
                        """
                        Ipv6.


                        Subclass of AvdModel.

                        Args:
                            access_group: IPv6 Access-List Name.

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "vlan": {"type": str},
                "cos": {"type": str},
                "ip": {"type": Ip},
                "ipv6": {"type": Ipv6},
                "dscp": {"type": str},
                "ecn": {"type": str},
            }
            name: str
            """Class-Map Name."""
            vlan: str | None
            """VLAN value(s) or range(s) of VLAN values."""
            cos: str | None
            """CoS value(s) or range(s) of CoS values."""
            ip: Ip
            """Subclass of AvdModel."""
            ipv6: Ipv6
            """Subclass of AvdModel."""
            dscp: str | None
            """
            Match packets based on the DSCP value(s).
            Accepted formats:
              - Single AF/CS/EF DSCP name like
            "af12".
              - Single decimal DSCP value. Example: "23".
              - Range of decimal DSCP values. Examples:
            "1,3-10".
            """
            ecn: Literal["ce", "ect", "ect-ce", "non-ect"] | None
            """
            Match packets based on the ECN value.
            Accepted values:
              - non-ect (matches 00).
              - ect (matches 01
            an 10).
              - ce (matches 11).
              - ect-ce (matches 01, 10 and 11).
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    vlan: str | None | UndefinedType = Undefined,
                    cos: str | None | UndefinedType = Undefined,
                    ip: Ip | UndefinedType = Undefined,
                    ipv6: Ipv6 | UndefinedType = Undefined,
                    dscp: str | None | UndefinedType = Undefined,
                    ecn: Literal["ce", "ect", "ect-ce", "non-ect"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    QosItem.


                    Subclass of AvdModel.

                    Args:
                        name: Class-Map Name.
                        vlan: VLAN value(s) or range(s) of VLAN values.
                        cos: CoS value(s) or range(s) of CoS values.
                        ip: Subclass of AvdModel.
                        ipv6: Subclass of AvdModel.
                        dscp:
                           Match packets based on the DSCP value(s).
                           Accepted formats:
                             - Single AF/CS/EF DSCP name like
                           "af12".
                             - Single decimal DSCP value. Example: "23".
                             - Range of decimal DSCP values. Examples:  # fmt: skip
                           "1,3-10".
                        ecn:
                           Match packets based on the ECN value.
                           Accepted values:
                             - non-ect (matches 00).
                             - ect (matches 01
                           an 10).
                             - ce (matches 11).
                             - ect-ce (matches 01, 10 and 11).

                    """

        class Qos(AvdIndexedList[str, QosItem]):
            """Subclass of AvdIndexedList with `QosItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Qos._item_type = QosItem

        _fields: ClassVar[dict] = {"pbr": {"type": Pbr}, "qos": {"type": Qos}}
        pbr: Pbr
        """Subclass of AvdIndexedList with `PbrItem` items. Primary key is `name` (`str`)."""
        qos: Qos
        """
        The keys `vlan`, `cos`, `ip`, `ipv6`, `dscp`, `ecn` are mutually exclusive,
        except `dscp` and `ecn`
        which can be given separate or together.

        Subclass of AvdIndexedList with `QosItem` items. Primary
        key is `name` (`str`).
        """

        if TYPE_CHECKING:

            def __init__(self, *, pbr: Pbr | UndefinedType = Undefined, qos: Qos | UndefinedType = Undefined) -> None:
                """
                ClassMaps.


                Subclass of AvdModel.

                Args:
                    pbr: Subclass of AvdIndexedList with `PbrItem` items. Primary key is `name` (`str`).
                    qos:
                       The keys `vlan`, `cos`, `ip`, `ipv6`, `dscp`, `ecn` are mutually exclusive,
                       except `dscp` and `ecn`
                       which can be given separate or together.

                       Subclass of AvdIndexedList with `QosItem` items. Primary
                       key is `name` (`str`).

                """

    class Clock(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"timezone": {"type": str}}
        timezone: str | None

        if TYPE_CHECKING:

            def __init__(self, *, timezone: str | None | UndefinedType = Undefined) -> None:
                """
                Clock.


                Subclass of AvdModel.

                Args:
                    timezone: timezone

                """

    class CommunityListsItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "action": {"type": str}}
        name: str
        """Community-list Name."""
        action: str
        """
        Action as string.
        Example: "permit GSHUT 65123:123"
        """

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, action: str | UndefinedType = Undefined) -> None:
                """
                CommunityListsItem.


                Subclass of AvdModel.

                Args:
                    name: Community-list Name.
                    action:
                       Action as string.
                       Example: "permit GSHUT 65123:123"

                """

    class CommunityLists(AvdIndexedList[str, CommunityListsItem]):
        """Subclass of AvdIndexedList with `CommunityListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    CommunityLists._item_type = CommunityListsItem

    class CustomTemplates(AvdList[str]):
        """Subclass of AvdList with `str` items."""

    CustomTemplates._item_type = str

    class Cvx(AvdModel):
        """Subclass of AvdModel."""

        class PeerHosts(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        PeerHosts._item_type = str

        class Services(AvdModel):
            """Subclass of AvdModel."""

            class Mcs(AvdModel):
                """Subclass of AvdModel."""

                class Redis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"password": {"type": str}, "password_type": {"type": str, "default": "7"}}
                    password: str | None
                    """Hashed password using the password_type."""
                    password_type: Literal["0", "7", "8a"]
                    """Default value: `"7"`"""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, password: str | None | UndefinedType = Undefined, password_type: Literal["0", "7", "8a"] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Redis.


                            Subclass of AvdModel.

                            Args:
                                password: Hashed password using the password_type.
                                password_type: password_type

                            """

                _fields: ClassVar[dict] = {"redis": {"type": Redis}, "shutdown": {"type": bool}}
                redis: Redis
                """Subclass of AvdModel."""
                shutdown: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, redis: Redis | UndefinedType = Undefined, shutdown: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Mcs.


                        Subclass of AvdModel.

                        Args:
                            redis: Subclass of AvdModel.
                            shutdown: shutdown

                        """

            class Vxlan(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"shutdown": {"type": bool}, "vtep_mac_learning": {"type": str}}
                shutdown: bool | None
                vtep_mac_learning: Literal["control-plane", "data-plane"] | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        shutdown: bool | None | UndefinedType = Undefined,
                        vtep_mac_learning: Literal["control-plane", "data-plane"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Vxlan.


                        Subclass of AvdModel.

                        Args:
                            shutdown: shutdown
                            vtep_mac_learning: vtep_mac_learning

                        """

            _fields: ClassVar[dict] = {"mcs": {"type": Mcs}, "vxlan": {"type": Vxlan}}
            mcs: Mcs
            """Subclass of AvdModel."""
            vxlan: Vxlan
            """
            VXLAN Controller service.

            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(self, *, mcs: Mcs | UndefinedType = Undefined, vxlan: Vxlan | UndefinedType = Undefined) -> None:
                    """
                    Services.


                    Subclass of AvdModel.

                    Args:
                        mcs: Subclass of AvdModel.
                        vxlan:
                           VXLAN Controller service.

                           Subclass of AvdModel.

                    """

        _fields: ClassVar[dict] = {"shutdown": {"type": bool}, "peer_hosts": {"type": PeerHosts}, "services": {"type": Services}}
        shutdown: bool | None
        peer_hosts: PeerHosts
        """Subclass of AvdList with `str` items."""
        services: Services
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                shutdown: bool | None | UndefinedType = Undefined,
                peer_hosts: PeerHosts | UndefinedType = Undefined,
                services: Services | UndefinedType = Undefined,
            ) -> None:
                """
                Cvx.


                Subclass of AvdModel.

                Args:
                    shutdown: shutdown
                    peer_hosts: Subclass of AvdList with `str` items.
                    services: Subclass of AvdModel.

                """

    class DaemonTerminattr(AvdModel):
        """Subclass of AvdModel."""

        class Cvaddrs(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Cvaddrs._item_type = str

        class ClustersItem(AvdModel):
            """Subclass of AvdModel."""

            class Cvaddrs(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Cvaddrs._item_type = str

            class Cvauth(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "method": {"type": str},
                    "key": {"type": str},
                    "token_file": {"type": str},
                    "cert_file": {"type": str},
                    "ca_file": {"type": str},
                    "key_file": {"type": str},
                }
                method: Literal["token", "token-secure", "key", "certs"] | None
                key: str | None
                token_file: str | None
                """
                Token file path.
                e.g. "/tmp/token"
                """
                cert_file: str | None
                """
                Client certificate file path.
                e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
                """
                ca_file: str | None
                """
                CA certificate file path (on-prem only).
                e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
                """
                key_file: str | None
                """
                Client certificate key file path.
                e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        method: Literal["token", "token-secure", "key", "certs"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        token_file: str | None | UndefinedType = Undefined,
                        cert_file: str | None | UndefinedType = Undefined,
                        ca_file: str | None | UndefinedType = Undefined,
                        key_file: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Cvauth.


                        Subclass of AvdModel.

                        Args:
                            method: method
                            key: key
                            token_file:
                               Token file path.
                               e.g. "/tmp/token"
                            cert_file:
                               Client certificate file path.
                               e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
                            ca_file:
                               CA certificate file path (on-prem only).
                               e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
                            key_file:
                               Client certificate key file path.
                               e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "cvaddrs": {"type": Cvaddrs},
                "cvauth": {"type": Cvauth},
                "cvobscurekeyfile": {"type": bool},
                "cvproxy": {"type": str},
                "cvsourceip": {"type": str},
                "cvsourceintf": {"type": str},
                "cvvrf": {"type": str},
            }
            name: str
            """Cluster Name."""
            cvaddrs: Cvaddrs
            """
            Streaming address(es) for CloudVision cluster.
            - TCP 9910 is used for CV on-prem
            - TCP 443 is used
            for CV as a Service


            Subclass of AvdList with `str` items.
            """
            cvauth: Cvauth
            """
            Authentication scheme used to connect to CloudVision.


            Subclass of AvdModel.
            """
            cvobscurekeyfile: bool | None
            """Encrypt the private key used for authentication to CloudVision."""
            cvproxy: str | None
            """
            Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
            the cloud.
            The expected form is http://[user:password@]ip:port, e.g.:
            `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
            """
            cvsourceip: str | None
            """Set source IP address in case of in-band management."""
            cvsourceintf: str | None
            """
            Set source interface in case of in-band management. Available as of TerminAttr v1.23.0.
            The
            interface name is case sensitive and has to match the interface name in the running-config,
            e.g.:Vlan100.
            """
            cvvrf: str | None
            """The VRF to use to connect to CloudVision."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    cvaddrs: Cvaddrs | UndefinedType = Undefined,
                    cvauth: Cvauth | UndefinedType = Undefined,
                    cvobscurekeyfile: bool | None | UndefinedType = Undefined,
                    cvproxy: str | None | UndefinedType = Undefined,
                    cvsourceip: str | None | UndefinedType = Undefined,
                    cvsourceintf: str | None | UndefinedType = Undefined,
                    cvvrf: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ClustersItem.


                    Subclass of AvdModel.

                    Args:
                        name: Cluster Name.
                        cvaddrs:
                           Streaming address(es) for CloudVision cluster.
                           - TCP 9910 is used for CV on-prem
                           - TCP 443 is used
                           for CV as a Service


                           Subclass of AvdList with `str` items.
                        cvauth:
                           Authentication scheme used to connect to CloudVision.


                           Subclass of AvdModel.
                        cvobscurekeyfile: Encrypt the private key used for authentication to CloudVision.
                        cvproxy:
                           Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
                           the cloud.
                           The expected form is http://[user:password@]ip:port, e.g.:
                           `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
                        cvsourceip: Set source IP address in case of in-band management.
                        cvsourceintf:
                           Set source interface in case of in-band management. Available as of TerminAttr v1.23.0.
                           The
                           interface name is case sensitive and has to match the interface name in the running-config,
                           e.g.:Vlan100.
                        cvvrf: The VRF to use to connect to CloudVision.

                    """

        class Clusters(AvdIndexedList[str, ClustersItem]):
            """Subclass of AvdIndexedList with `ClustersItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Clusters._item_type = ClustersItem

        class Cvauth(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "method": {"type": str},
                "key": {"type": str},
                "token_file": {"type": str},
                "cert_file": {"type": str},
                "ca_file": {"type": str},
                "key_file": {"type": str},
            }
            method: Literal["token", "token-secure", "key", "certs"] | None
            key: str | None
            token_file: str | None
            """
            Token file path.
            e.g. "/tmp/token"
            """
            cert_file: str | None
            """
            Client certificate file path.
            e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
            """
            ca_file: str | None
            """
            CA certificate file path (on-prem only).
            e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
            """
            key_file: str | None
            """
            Client certificate key file path.
            e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    method: Literal["token", "token-secure", "key", "certs"] | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    token_file: str | None | UndefinedType = Undefined,
                    cert_file: str | None | UndefinedType = Undefined,
                    ca_file: str | None | UndefinedType = Undefined,
                    key_file: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Cvauth.


                    Subclass of AvdModel.

                    Args:
                        method: method
                        key: key
                        token_file:
                           Token file path.
                           e.g. "/tmp/token"
                        cert_file:
                           Client certificate file path.
                           e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
                        ca_file:
                           CA certificate file path (on-prem only).
                           e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
                        key_file:
                           Client certificate key file path.
                           e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"

                    """

        _fields: ClassVar[dict] = {
            "cvaddrs": {"type": Cvaddrs},
            "clusters": {"type": Clusters},
            "cvauth": {"type": Cvauth},
            "cvobscurekeyfile": {"type": bool},
            "cvproxy": {"type": str},
            "cvsourceip": {"type": str},
            "cvsourceintf": {"type": str},
            "cvvrf": {"type": str},
            "cvgnmi": {"type": bool},
            "disable_aaa": {"type": bool},
            "grpcaddr": {"type": str},
            "grpcreadonly": {"type": bool},
            "ingestexclude": {"type": str},
            "smashexcludes": {"type": str},
            "taillogs": {"type": str},
            "ecodhcpaddr": {"type": str},
            "ipfix": {"type": bool},
            "ipfixaddr": {"type": str},
            "sflow": {"type": bool},
            "sflowaddr": {"type": str},
            "cvconfig": {"type": bool},
        }
        cvaddrs: Cvaddrs
        """
        Streaming address(es) for CloudVision single cluster.
        - TCP 9910 is used for CV on-prem
        - TCP 443 is
        used for CV as a Service


        Subclass of AvdList with `str` items.
        """
        clusters: Clusters
        """
        Multiple CloudVision clusters.


        Subclass of AvdIndexedList with `ClustersItem` items. Primary key
        is `name` (`str`).
        """
        cvauth: Cvauth
        """
        Authentication scheme used to connect to CloudVision.


        Subclass of AvdModel.
        """
        cvobscurekeyfile: bool | None
        """Encrypt the private key used for authentication to CloudVision."""
        cvproxy: str | None
        """
        Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
        the cloud.
        The expected form is http://[user:password@]ip:port, e.g.:
        `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
        """
        cvsourceip: str | None
        """Set source IP address in case of in-band management."""
        cvsourceintf: str | None
        """
        Set source interface in case of in-band management.
        The interface name is case sensitive and has to
        match the interface name in the running-config, e.g.:Vlan100.
        """
        cvvrf: str | None
        """The VRF to use to connect to CloudVision."""
        cvgnmi: bool | None
        """Stream states from EOS gNMI servers (Openconfig) to CloudVision. Available as of TerminAttr v1.13.1."""
        disable_aaa: bool | None
        """
        Disable AAA authorization and accounting.
        When setting this flag, all commands pushed from
        CloudVision are applied directly to the CLI without authorization.
        """
        grpcaddr: str | None
        """
        Set the gRPC server address, the default is 127.0.0.1:6042.
        e.g. "MGMT/0.0.0.0:6042"
        """
        grpcreadonly: bool | None
        """gNMI read-only mode - Disable gnmi.Set()."""
        ingestexclude: str | None
        """
        Exclude paths from Sysdb on the ingest side.
        e.g. "/Sysdb/cell/1/agent,/Sysdb/cell/2/agent"
        """
        smashexcludes: str | None
        """
        Exclude paths from the shared memory table.
        e.g. "ale,flexCounter,hardware,kni,pulse,strata"
        """
        taillogs: str | None
        """
        Enable log file collection; /var/log/messages is streamed by default if no path is set.
        e.g.
        "/var/log/messages"
        """
        ecodhcpaddr: str | None
        """
        ECO DHCP Collector address or ECO DHCP Fingerprint listening address in standalone mode (default
        "127.0.0.1:67").
        """
        ipfix: bool | None
        """
        Enable IPFIX provider (TerminAttr default is true).
        This flag is enabled by default and does not
        have to be added to the daemon configuration.
        """
        ipfixaddr: str | None
        """
        ECO IPFIX Collector address to listen on to receive IPFIX packets (TerminAttr default
        "127.0.0.1:4739").
        """
        sflow: bool | None
        """Enable sFlow provider (TerminAttr default is true)."""
        sflowaddr: str | None
        """
        ECO sFlow Collector address to listen on to receive sFlow packets (TerminAttr default
        "127.0.0.1:6343").
        """
        cvconfig: bool | None
        """Subscribe to dynamic device configuration from CloudVision (TerminAttr default is false)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                cvaddrs: Cvaddrs | UndefinedType = Undefined,
                clusters: Clusters | UndefinedType = Undefined,
                cvauth: Cvauth | UndefinedType = Undefined,
                cvobscurekeyfile: bool | None | UndefinedType = Undefined,
                cvproxy: str | None | UndefinedType = Undefined,
                cvsourceip: str | None | UndefinedType = Undefined,
                cvsourceintf: str | None | UndefinedType = Undefined,
                cvvrf: str | None | UndefinedType = Undefined,
                cvgnmi: bool | None | UndefinedType = Undefined,
                disable_aaa: bool | None | UndefinedType = Undefined,
                grpcaddr: str | None | UndefinedType = Undefined,
                grpcreadonly: bool | None | UndefinedType = Undefined,
                ingestexclude: str | None | UndefinedType = Undefined,
                smashexcludes: str | None | UndefinedType = Undefined,
                taillogs: str | None | UndefinedType = Undefined,
                ecodhcpaddr: str | None | UndefinedType = Undefined,
                ipfix: bool | None | UndefinedType = Undefined,
                ipfixaddr: str | None | UndefinedType = Undefined,
                sflow: bool | None | UndefinedType = Undefined,
                sflowaddr: str | None | UndefinedType = Undefined,
                cvconfig: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                DaemonTerminattr.


                Subclass of AvdModel.

                Args:
                    cvaddrs:
                       Streaming address(es) for CloudVision single cluster.
                       - TCP 9910 is used for CV on-prem
                       - TCP 443 is
                       used for CV as a Service


                       Subclass of AvdList with `str` items.
                    clusters:
                       Multiple CloudVision clusters.


                       Subclass of AvdIndexedList with `ClustersItem` items. Primary key
                       is `name` (`str`).
                    cvauth:
                       Authentication scheme used to connect to CloudVision.


                       Subclass of AvdModel.
                    cvobscurekeyfile: Encrypt the private key used for authentication to CloudVision.
                    cvproxy:
                       Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
                       the cloud.
                       The expected form is http://[user:password@]ip:port, e.g.:
                       `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
                    cvsourceip: Set source IP address in case of in-band management.
                    cvsourceintf:
                       Set source interface in case of in-band management.
                       The interface name is case sensitive and has to
                       match the interface name in the running-config, e.g.:Vlan100.
                    cvvrf: The VRF to use to connect to CloudVision.
                    cvgnmi: Stream states from EOS gNMI servers (Openconfig) to CloudVision. Available as of TerminAttr v1.13.1.
                    disable_aaa:
                       Disable AAA authorization and accounting.
                       When setting this flag, all commands pushed from
                       CloudVision are applied directly to the CLI without authorization.
                    grpcaddr:
                       Set the gRPC server address, the default is 127.0.0.1:6042.
                       e.g. "MGMT/0.0.0.0:6042"
                    grpcreadonly: gNMI read-only mode - Disable gnmi.Set().
                    ingestexclude:
                       Exclude paths from Sysdb on the ingest side.
                       e.g. "/Sysdb/cell/1/agent,/Sysdb/cell/2/agent"
                    smashexcludes:
                       Exclude paths from the shared memory table.
                       e.g. "ale,flexCounter,hardware,kni,pulse,strata"
                    taillogs:
                       Enable log file collection; /var/log/messages is streamed by default if no path is set.
                       e.g.
                       "/var/log/messages"
                    ecodhcpaddr:
                       ECO DHCP Collector address or ECO DHCP Fingerprint listening address in standalone mode (default
                       "127.0.0.1:67").
                    ipfix:
                       Enable IPFIX provider (TerminAttr default is true).
                       This flag is enabled by default and does not
                       have to be added to the daemon configuration.
                    ipfixaddr:
                       ECO IPFIX Collector address to listen on to receive IPFIX packets (TerminAttr default
                       "127.0.0.1:4739").
                    sflow: Enable sFlow provider (TerminAttr default is true).
                    sflowaddr:
                       ECO sFlow Collector address to listen on to receive sFlow packets (TerminAttr default
                       "127.0.0.1:6343").
                    cvconfig: Subscribe to dynamic device configuration from CloudVision (TerminAttr default is false).

                """

    class DaemonsItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "exec": {"type": str}, "enabled": {"type": bool, "default": True}}
        name: str
        """Daemon Name."""
        exec: str
        """command to run as a daemon."""
        enabled: bool
        """Default value: `True`"""

        if TYPE_CHECKING:

            def __init__(
                self, *, name: str | UndefinedType = Undefined, exec: str | UndefinedType = Undefined, enabled: bool | UndefinedType = Undefined
            ) -> None:
                """
                DaemonsItem.


                Subclass of AvdModel.

                Args:
                    name: Daemon Name.
                    exec: command to run as a daemon.
                    enabled: enabled

                """

    class Daemons(AvdIndexedList[str, DaemonsItem]):
        """Subclass of AvdIndexedList with `DaemonsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Daemons._item_type = DaemonsItem

    class DhcpRelay(AvdModel):
        """Subclass of AvdModel."""

        class Servers(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Servers._item_type = str

        _fields: ClassVar[dict] = {"servers": {"type": Servers}, "tunnel_requests_disabled": {"type": bool}, "mlag_peerlink_requests_disabled": {"type": bool}}
        servers: Servers
        """Subclass of AvdList with `str` items."""
        tunnel_requests_disabled: bool | None
        mlag_peerlink_requests_disabled: bool | None

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                servers: Servers | UndefinedType = Undefined,
                tunnel_requests_disabled: bool | None | UndefinedType = Undefined,
                mlag_peerlink_requests_disabled: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                DhcpRelay.


                Subclass of AvdModel.

                Args:
                    servers: Subclass of AvdList with `str` items.
                    tunnel_requests_disabled: tunnel_requests_disabled
                    mlag_peerlink_requests_disabled: mlag_peerlink_requests_disabled

                """

    class DhcpServersItem(AvdModel):
        """Subclass of AvdModel."""

        class LeaseTimeIpv4(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"days": {"type": int}, "hours": {"type": int}, "minutes": {"type": int}}
            days: int
            hours: int
            minutes: int

            if TYPE_CHECKING:

                def __init__(
                    self, *, days: int | UndefinedType = Undefined, hours: int | UndefinedType = Undefined, minutes: int | UndefinedType = Undefined
                ) -> None:
                    """
                    LeaseTimeIpv4.


                    Subclass of AvdModel.

                    Args:
                        days: days
                        hours: hours
                        minutes: minutes

                    """

        class LeaseTimeIpv6(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"days": {"type": int}, "hours": {"type": int}, "minutes": {"type": int}}
            days: int
            hours: int
            minutes: int

            if TYPE_CHECKING:

                def __init__(
                    self, *, days: int | UndefinedType = Undefined, hours: int | UndefinedType = Undefined, minutes: int | UndefinedType = Undefined
                ) -> None:
                    """
                    LeaseTimeIpv6.


                    Subclass of AvdModel.

                    Args:
                        days: days
                        hours: hours
                        minutes: minutes

                    """

        class DnsServersIpv4(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        DnsServersIpv4._item_type = str

        class DnsServersIpv6(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        DnsServersIpv6._item_type = str

        class TftpServer(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"file_ipv4": {"type": str}, "file_ipv6": {"type": str}}
            file_ipv4: str | None
            """Name of TFTP file for IPv4 clients."""
            file_ipv6: str | None
            """Name of TFTP file for IPv6 clients."""

            if TYPE_CHECKING:

                def __init__(self, *, file_ipv4: str | None | UndefinedType = Undefined, file_ipv6: str | None | UndefinedType = Undefined) -> None:
                    """
                    TftpServer.


                    Subclass of AvdModel.

                    Args:
                        file_ipv4: Name of TFTP file for IPv4 clients.
                        file_ipv6: Name of TFTP file for IPv6 clients.

                    """

        class Ipv4VendorOptionsItem(AvdModel):
            """Subclass of AvdModel."""

            class SubOptionsItem(AvdModel):
                """Subclass of AvdModel."""

                class ArrayIpv4Address(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                ArrayIpv4Address._item_type = str

                _fields: ClassVar[dict] = {
                    "code": {"type": int},
                    "string": {"type": str},
                    "ipv4_address": {"type": str},
                    "array_ipv4_address": {"type": ArrayIpv4Address},
                }
                code: int
                string: str | None
                """
                String value for suboption data.
                Only one of `string`, `ipv4_address` and `array_ipv4_address`
                variables should be used for any one suboption.
                The order of precedence if multiple of these
                variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                """
                ipv4_address: str | None
                """
                IPv4 address value for suboption data.
                Only one of `string`, `ipv4_address` and `array_ipv4_address`
                variables should be used for any one suboption.
                The order of precedence if multiple of these
                variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                """
                array_ipv4_address: ArrayIpv4Address
                """
                Array of IPv4 addresses for suboption data.
                Only one of `string`, `ipv4_address` and
                `array_ipv4_address` variables should be used for any one suboption.
                The order of precedence if
                multiple of these variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                Subclass of AvdList with `str` items.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        code: int | UndefinedType = Undefined,
                        string: str | None | UndefinedType = Undefined,
                        ipv4_address: str | None | UndefinedType = Undefined,
                        array_ipv4_address: ArrayIpv4Address | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SubOptionsItem.


                        Subclass of AvdModel.

                        Args:
                            code: code
                            string:
                               String value for suboption data.
                               Only one of `string`, `ipv4_address` and `array_ipv4_address`
                               variables should be used for any one suboption.
                               The order of precedence if multiple of these
                               variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                            ipv4_address:
                               IPv4 address value for suboption data.
                               Only one of `string`, `ipv4_address` and `array_ipv4_address`
                               variables should be used for any one suboption.
                               The order of precedence if multiple of these
                               variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                            array_ipv4_address:
                               Array of IPv4 addresses for suboption data.
                               Only one of `string`, `ipv4_address` and
                               `array_ipv4_address` variables should be used for any one suboption.
                               The order of precedence if
                               multiple of these variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                               Subclass of AvdList with `str` items.

                        """

            class SubOptions(AvdIndexedList[int, SubOptionsItem]):
                """Subclass of AvdIndexedList with `SubOptionsItem` items. Primary key is `code` (`int`)."""

                _primary_key: ClassVar[str] = "code"

            SubOptions._item_type = SubOptionsItem

            _fields: ClassVar[dict] = {"vendor_id": {"type": str}, "sub_options": {"type": SubOptions}}
            vendor_id: str
            sub_options: SubOptions
            """Subclass of AvdIndexedList with `SubOptionsItem` items. Primary key is `code` (`int`)."""

            if TYPE_CHECKING:

                def __init__(self, *, vendor_id: str | UndefinedType = Undefined, sub_options: SubOptions | UndefinedType = Undefined) -> None:
                    """
                    Ipv4VendorOptionsItem.


                    Subclass of AvdModel.

                    Args:
                        vendor_id: vendor_id
                        sub_options: Subclass of AvdIndexedList with `SubOptionsItem` items. Primary key is `code` (`int`).

                    """

        class Ipv4VendorOptions(AvdIndexedList[str, Ipv4VendorOptionsItem]):
            """Subclass of AvdIndexedList with `Ipv4VendorOptionsItem` items. Primary key is `vendor_id` (`str`)."""

            _primary_key: ClassVar[str] = "vendor_id"

        Ipv4VendorOptions._item_type = Ipv4VendorOptionsItem

        class SubnetsItem(AvdModel):
            """Subclass of AvdModel."""

            class DnsServers(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            DnsServers._item_type = str

            class RangesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"start": {"type": str}, "end": {"type": str}}
                start: str
                end: str

                if TYPE_CHECKING:

                    def __init__(self, *, start: str | UndefinedType = Undefined, end: str | UndefinedType = Undefined) -> None:
                        """
                        RangesItem.


                        Subclass of AvdModel.

                        Args:
                            start: start
                            end: end

                        """

            class Ranges(AvdList[RangesItem]):
                """Subclass of AvdList with `RangesItem` items."""

            Ranges._item_type = RangesItem

            class LeaseTime(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"days": {"type": int}, "hours": {"type": int}, "minutes": {"type": int}}
                days: int
                hours: int
                minutes: int

                if TYPE_CHECKING:

                    def __init__(
                        self, *, days: int | UndefinedType = Undefined, hours: int | UndefinedType = Undefined, minutes: int | UndefinedType = Undefined
                    ) -> None:
                        """
                        LeaseTime.


                        Subclass of AvdModel.

                        Args:
                            days: days
                            hours: hours
                            minutes: minutes

                        """

            class ReservationsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "mac_address": {"type": str},
                    "hostname": {"type": str},
                    "ipv4_address": {"type": str},
                    "ipv6_address": {"type": str},
                }
                mac_address: str
                """Ethernet address in format - HHHH.HHHH.HHHH"""
                hostname: str | None
                ipv4_address: str | None
                """
                Valid IPv4 address from the given subnet.
                This should only be used within an IPv4 subnet.
                """
                ipv6_address: str | None
                """
                Valid IPv6 address from the given subnet.
                This should only be used within an IPv6 subnet.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mac_address: str | UndefinedType = Undefined,
                        hostname: str | None | UndefinedType = Undefined,
                        ipv4_address: str | None | UndefinedType = Undefined,
                        ipv6_address: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ReservationsItem.


                        Subclass of AvdModel.

                        Args:
                            mac_address: Ethernet address in format - HHHH.HHHH.HHHH
                            hostname: hostname
                            ipv4_address:
                               Valid IPv4 address from the given subnet.
                               This should only be used within an IPv4 subnet.
                            ipv6_address:
                               Valid IPv6 address from the given subnet.
                               This should only be used within an IPv6 subnet.

                        """

            class Reservations(AvdIndexedList[str, ReservationsItem]):
                """Subclass of AvdIndexedList with `ReservationsItem` items. Primary key is `mac_address` (`str`)."""

                _primary_key: ClassVar[str] = "mac_address"

            Reservations._item_type = ReservationsItem

            _fields: ClassVar[dict] = {
                "subnet": {"type": str},
                "name": {"type": str},
                "default_gateway": {"type": str},
                "dns_servers": {"type": DnsServers},
                "ranges": {"type": Ranges},
                "lease_time": {"type": LeaseTime},
                "reservations": {"type": Reservations},
            }
            subnet: str
            """IPv4/IPv6 subnet."""
            name: str | None
            default_gateway: str | None
            dns_servers: DnsServers
            """Subclass of AvdList with `str` items."""
            ranges: Ranges
            """Subclass of AvdList with `RangesItem` items."""
            lease_time: LeaseTime
            """Subclass of AvdModel."""
            reservations: Reservations
            """
            DHCP client reservations.

            Subclass of AvdIndexedList with `ReservationsItem` items. Primary key is
            `mac_address` (`str`).
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    subnet: str | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    default_gateway: str | None | UndefinedType = Undefined,
                    dns_servers: DnsServers | UndefinedType = Undefined,
                    ranges: Ranges | UndefinedType = Undefined,
                    lease_time: LeaseTime | UndefinedType = Undefined,
                    reservations: Reservations | UndefinedType = Undefined,
                ) -> None:
                    """
                    SubnetsItem.


                    Subclass of AvdModel.

                    Args:
                        subnet: IPv4/IPv6 subnet.
                        name: name
                        default_gateway: default_gateway
                        dns_servers: Subclass of AvdList with `str` items.
                        ranges: Subclass of AvdList with `RangesItem` items.
                        lease_time: Subclass of AvdModel.
                        reservations:
                           DHCP client reservations.

                           Subclass of AvdIndexedList with `ReservationsItem` items. Primary key is
                           `mac_address` (`str`).

                    """

        class Subnets(AvdIndexedList[str, SubnetsItem]):
            """Subclass of AvdIndexedList with `SubnetsItem` items. Primary key is `subnet` (`str`)."""

            _primary_key: ClassVar[str] = "subnet"

        Subnets._item_type = SubnetsItem

        _fields: ClassVar[dict] = {
            "disabled": {"type": bool},
            "vrf": {"type": str},
            "lease_time_ipv4": {"type": LeaseTimeIpv4},
            "lease_time_ipv6": {"type": LeaseTimeIpv6},
            "dns_domain_name_ipv4": {"type": str},
            "dns_domain_name_ipv6": {"type": str},
            "dns_servers_ipv4": {"type": DnsServersIpv4},
            "dns_servers_ipv6": {"type": DnsServersIpv6},
            "tftp_server": {"type": TftpServer},
            "ipv4_vendor_options": {"type": Ipv4VendorOptions},
            "subnets": {"type": Subnets},
            "eos_cli": {"type": str},
        }
        disabled: bool | None
        vrf: str
        """VRF in which to configure the DHCP server, use `default` to indicate default VRF."""
        lease_time_ipv4: LeaseTimeIpv4
        """Subclass of AvdModel."""
        lease_time_ipv6: LeaseTimeIpv6
        """Subclass of AvdModel."""
        dns_domain_name_ipv4: str | None
        dns_domain_name_ipv6: str | None
        dns_servers_ipv4: DnsServersIpv4
        """
        List of DNS servers for IPv4 clients.

        Subclass of AvdList with `str` items.
        """
        dns_servers_ipv6: DnsServersIpv6
        """
        List of DNS servers for IPv6 clients.

        Subclass of AvdList with `str` items.
        """
        tftp_server: TftpServer
        """Subclass of AvdModel."""
        ipv4_vendor_options: Ipv4VendorOptions
        """Subclass of AvdIndexedList with `Ipv4VendorOptionsItem` items. Primary key is `vendor_id` (`str`)."""
        subnets: Subnets
        """Subclass of AvdIndexedList with `SubnetsItem` items. Primary key is `subnet` (`str`)."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the dhcp server in the final EOS configuration."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                disabled: bool | None | UndefinedType = Undefined,
                vrf: str | UndefinedType = Undefined,
                lease_time_ipv4: LeaseTimeIpv4 | UndefinedType = Undefined,
                lease_time_ipv6: LeaseTimeIpv6 | UndefinedType = Undefined,
                dns_domain_name_ipv4: str | None | UndefinedType = Undefined,
                dns_domain_name_ipv6: str | None | UndefinedType = Undefined,
                dns_servers_ipv4: DnsServersIpv4 | UndefinedType = Undefined,
                dns_servers_ipv6: DnsServersIpv6 | UndefinedType = Undefined,
                tftp_server: TftpServer | UndefinedType = Undefined,
                ipv4_vendor_options: Ipv4VendorOptions | UndefinedType = Undefined,
                subnets: Subnets | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                DhcpServersItem.


                Subclass of AvdModel.

                Args:
                    disabled: disabled
                    vrf: VRF in which to configure the DHCP server, use `default` to indicate default VRF.
                    lease_time_ipv4: Subclass of AvdModel.
                    lease_time_ipv6: Subclass of AvdModel.
                    dns_domain_name_ipv4: dns_domain_name_ipv4
                    dns_domain_name_ipv6: dns_domain_name_ipv6
                    dns_servers_ipv4:
                       List of DNS servers for IPv4 clients.

                       Subclass of AvdList with `str` items.
                    dns_servers_ipv6:
                       List of DNS servers for IPv6 clients.

                       Subclass of AvdList with `str` items.
                    tftp_server: Subclass of AvdModel.
                    ipv4_vendor_options: Subclass of AvdIndexedList with `Ipv4VendorOptionsItem` items. Primary key is `vendor_id` (`str`).
                    subnets: Subclass of AvdIndexedList with `SubnetsItem` items. Primary key is `subnet` (`str`).
                    eos_cli: Multiline EOS CLI rendered directly on the dhcp server in the final EOS configuration.

                """

    class DhcpServers(AvdIndexedList[str, DhcpServersItem]):
        """Subclass of AvdIndexedList with `DhcpServersItem` items. Primary key is `vrf` (`str`)."""

        _primary_key: ClassVar[str] = "vrf"

    DhcpServers._item_type = DhcpServersItem

    class DomainList(AvdList[str]):
        """Subclass of AvdList with `str` items."""

    DomainList._item_type = str

    class Dot1x(AvdModel):
        """Subclass of AvdModel."""

        class MacBasedAuthentication(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"delay": {"type": int}, "hold_period": {"type": int}}
            delay: int | None
            hold_period: int | None

            if TYPE_CHECKING:

                def __init__(self, *, delay: int | None | UndefinedType = Undefined, hold_period: int | None | UndefinedType = Undefined) -> None:
                    """
                    MacBasedAuthentication.


                    Subclass of AvdModel.

                    Args:
                        delay: delay
                        hold_period: hold_period

                    """

        class RadiusAvPairUsernameFormat(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"delimiter": {"type": str}, "mac_string_case": {"type": str}}
            delimiter: Literal["colon", "hyphen", "none", "period"]
            """Delimiter to use in MAC address string."""
            mac_string_case: Literal["lowercase", "uppercase"]
            """MAC address string in lowercase/uppercase."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    delimiter: Literal["colon", "hyphen", "none", "period"] | UndefinedType = Undefined,
                    mac_string_case: Literal["lowercase", "uppercase"] | UndefinedType = Undefined,
                ) -> None:
                    """
                    RadiusAvPairUsernameFormat.


                    Subclass of AvdModel.

                    Args:
                        delimiter: Delimiter to use in MAC address string.
                        mac_string_case: MAC address string in lowercase/uppercase.

                    """

        class RadiusAvPair(AvdModel):
            """Subclass of AvdModel."""

            class Lldp(AvdModel):
                """Subclass of AvdModel."""

                class SystemName(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "auth_only": {"type": bool}}
                    enabled: bool
                    auth_only: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, auth_only: bool | None | UndefinedType = Undefined) -> None:
                            """
                            SystemName.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                auth_only: auth_only

                            """

                class SystemDescription(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "auth_only": {"type": bool}}
                    enabled: bool
                    auth_only: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, auth_only: bool | None | UndefinedType = Undefined) -> None:
                            """
                            SystemDescription.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                auth_only: auth_only

                            """

                _fields: ClassVar[dict] = {"system_name": {"type": SystemName}, "system_description": {"type": SystemDescription}}
                system_name: SystemName
                """
                LLDP system name (LLDP TLV 5) av-pair.

                Subclass of AvdModel.
                """
                system_description: SystemDescription
                """
                LLDP system description (LLDP TLV 6) av-pair.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self, *, system_name: SystemName | UndefinedType = Undefined, system_description: SystemDescription | UndefinedType = Undefined
                    ) -> None:
                        """
                        Lldp.


                        Subclass of AvdModel.

                        Args:
                            system_name:
                               LLDP system name (LLDP TLV 5) av-pair.

                               Subclass of AvdModel.
                            system_description:
                               LLDP system description (LLDP TLV 6) av-pair.

                               Subclass of AvdModel.

                        """

            class Dhcp(AvdModel):
                """Subclass of AvdModel."""

                class Hostname(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "auth_only": {"type": bool}}
                    enabled: bool
                    auth_only: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, auth_only: bool | None | UndefinedType = Undefined) -> None:
                            """
                            Hostname.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                auth_only: auth_only

                            """

                class ParameterRequestList(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "auth_only": {"type": bool}}
                    enabled: bool
                    auth_only: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, auth_only: bool | None | UndefinedType = Undefined) -> None:
                            """
                            ParameterRequestList.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                auth_only: auth_only

                            """

                class VendorClassId(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "auth_only": {"type": bool}}
                    enabled: bool
                    auth_only: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, auth_only: bool | None | UndefinedType = Undefined) -> None:
                            """
                            VendorClassId.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                auth_only: auth_only

                            """

                _fields: ClassVar[dict] = {
                    "hostname": {"type": Hostname},
                    "parameter_request_list": {"type": ParameterRequestList},
                    "vendor_class_id": {"type": VendorClassId},
                }
                hostname: Hostname
                """
                Hostname (DHCP Option 12).

                Subclass of AvdModel.
                """
                parameter_request_list: ParameterRequestList
                """
                Parameters requested by host (DHCP Option 55).

                Subclass of AvdModel.
                """
                vendor_class_id: VendorClassId
                """
                Vendor class identifier (DHCP Option 60).

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        hostname: Hostname | UndefinedType = Undefined,
                        parameter_request_list: ParameterRequestList | UndefinedType = Undefined,
                        vendor_class_id: VendorClassId | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dhcp.


                        Subclass of AvdModel.

                        Args:
                            hostname:
                               Hostname (DHCP Option 12).

                               Subclass of AvdModel.
                            parameter_request_list:
                               Parameters requested by host (DHCP Option 55).

                               Subclass of AvdModel.
                            vendor_class_id:
                               Vendor class identifier (DHCP Option 60).

                               Subclass of AvdModel.

                        """

            class FilterId(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"delimiter_period": {"type": bool}, "ipv4_ipv6_required": {"type": bool}, "multiple": {"type": bool}}
                delimiter_period: bool | None
                """Use period as the delimiter."""
                ipv4_ipv6_required: bool | None
                """Enable filters for IPv4 and IPv6 traffic."""
                multiple: bool | None
                """Multiple attribute."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        delimiter_period: bool | None | UndefinedType = Undefined,
                        ipv4_ipv6_required: bool | None | UndefinedType = Undefined,
                        multiple: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        FilterId.


                        Subclass of AvdModel.

                        Args:
                            delimiter_period: Use period as the delimiter.
                            ipv4_ipv6_required: Enable filters for IPv4 and IPv6 traffic.
                            multiple: Multiple attribute.

                        """

            _fields: ClassVar[dict] = {
                "service_type": {"type": bool},
                "framed_mtu": {"type": int},
                "lldp": {"type": Lldp},
                "dhcp": {"type": Dhcp},
                "filter_id": {"type": FilterId},
            }
            service_type: bool | None
            framed_mtu: int | None
            lldp: Lldp
            """Subclass of AvdModel."""
            dhcp: Dhcp
            """Subclass of AvdModel."""
            filter_id: FilterId
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    service_type: bool | None | UndefinedType = Undefined,
                    framed_mtu: int | None | UndefinedType = Undefined,
                    lldp: Lldp | UndefinedType = Undefined,
                    dhcp: Dhcp | UndefinedType = Undefined,
                    filter_id: FilterId | UndefinedType = Undefined,
                ) -> None:
                    """
                    RadiusAvPair.


                    Subclass of AvdModel.

                    Args:
                        service_type: service_type
                        framed_mtu: framed_mtu
                        lldp: Subclass of AvdModel.
                        dhcp: Subclass of AvdModel.
                        filter_id: Subclass of AvdModel.

                    """

        class Aaa(AvdModel):
            """Subclass of AvdModel."""

            class Unresponsive(AvdModel):
                """Subclass of AvdModel."""

                class Action(AvdModel):
                    """Subclass of AvdModel."""

                    class CachedResultsTimeout(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"time_duration": {"type": int}, "time_duration_unit": {"type": str}}
                        time_duration: int | None
                        """
                        Enable caching for a specific duration -
                        <1-10000>      duration in days
                        <1-14400000>   duration in
                        minutes
                        <1-240000>     duration in hours
                        <1-864000000>  duration in seconds
                        """
                        time_duration_unit: Literal["days", "hours", "minutes", "seconds"]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                time_duration: int | None | UndefinedType = Undefined,
                                time_duration_unit: Literal["days", "hours", "minutes", "seconds"] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                CachedResultsTimeout.


                                Subclass of AvdModel.

                                Args:
                                    time_duration:
                                       Enable caching for a specific duration -
                                       <1-10000>      duration in days
                                       <1-14400000>   duration in
                                       minutes
                                       <1-240000>     duration in hours
                                       <1-864000000>  duration in seconds
                                    time_duration_unit: time_duration_unit

                                """

                    _fields: ClassVar[dict] = {
                        "apply_cached_results": {"type": bool},
                        "cached_results_timeout": {"type": CachedResultsTimeout},
                        "apply_alternate": {"type": bool},
                        "traffic_allow": {"type": bool},
                        "traffic_allow_vlan": {"type": int},
                    }
                    apply_cached_results: bool | None
                    """Use results from a previous AAA response."""
                    cached_results_timeout: CachedResultsTimeout
                    """Subclass of AvdModel."""
                    apply_alternate: bool | None
                    """
                    Apply alternate action if primary action fails.
                    eg. aaa unresponsive action apply cached-results
                    else traffic allow
                    """
                    traffic_allow: bool | None
                    """Set action for supplicant traffic when AAA times out."""
                    traffic_allow_vlan: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            apply_cached_results: bool | None | UndefinedType = Undefined,
                            cached_results_timeout: CachedResultsTimeout | UndefinedType = Undefined,
                            apply_alternate: bool | None | UndefinedType = Undefined,
                            traffic_allow: bool | None | UndefinedType = Undefined,
                            traffic_allow_vlan: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Action.


                            Subclass of AvdModel.

                            Args:
                                apply_cached_results: Use results from a previous AAA response.
                                cached_results_timeout: Subclass of AvdModel.
                                apply_alternate:
                                   Apply alternate action if primary action fails.
                                   eg. aaa unresponsive action apply cached-results
                                   else traffic allow
                                traffic_allow: Set action for supplicant traffic when AAA times out.
                                traffic_allow_vlan: traffic_allow_vlan

                            """

                class PhoneAction(AvdModel):
                    """Subclass of AvdModel."""

                    class CachedResultsTimeout(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"time_duration": {"type": int}, "time_duration_unit": {"type": str}}
                        time_duration: int | None
                        """
                        Enable caching for a specific duration -
                        <1-10000>      duration in days
                        <1-14400000>   duration in
                        minutes
                        <1-240000>     duration in hours
                        <1-864000000>  duration in seconds
                        """
                        time_duration_unit: Literal["days", "hours", "minutes", "seconds"]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                time_duration: int | None | UndefinedType = Undefined,
                                time_duration_unit: Literal["days", "hours", "minutes", "seconds"] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                CachedResultsTimeout.


                                Subclass of AvdModel.

                                Args:
                                    time_duration:
                                       Enable caching for a specific duration -
                                       <1-10000>      duration in days
                                       <1-14400000>   duration in
                                       minutes
                                       <1-240000>     duration in hours
                                       <1-864000000>  duration in seconds
                                    time_duration_unit: time_duration_unit

                                """

                    _fields: ClassVar[dict] = {
                        "apply_cached_results": {"type": bool},
                        "cached_results_timeout": {"type": CachedResultsTimeout},
                        "apply_alternate": {"type": bool},
                        "traffic_allow": {"type": bool},
                    }
                    apply_cached_results: bool | None
                    """Use results from a previous AAA response."""
                    cached_results_timeout: CachedResultsTimeout
                    """Subclass of AvdModel."""
                    apply_alternate: bool | None
                    """
                    Apply alternate action if primary action fails.
                    eg. aaa unresponsive phone action apply cached-
                    results else traffic allow
                    """
                    traffic_allow: bool | None
                    """Set action for supplicant traffic when AAA times out."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            apply_cached_results: bool | None | UndefinedType = Undefined,
                            cached_results_timeout: CachedResultsTimeout | UndefinedType = Undefined,
                            apply_alternate: bool | None | UndefinedType = Undefined,
                            traffic_allow: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            PhoneAction.


                            Subclass of AvdModel.

                            Args:
                                apply_cached_results: Use results from a previous AAA response.
                                cached_results_timeout: Subclass of AvdModel.
                                apply_alternate:
                                   Apply alternate action if primary action fails.
                                   eg. aaa unresponsive phone action apply cached-
                                   results else traffic allow
                                traffic_allow: Set action for supplicant traffic when AAA times out.

                            """

                _fields: ClassVar[dict] = {
                    "eap_response": {"type": str},
                    "action": {"type": Action},
                    "phone_action": {"type": PhoneAction},
                    "recovery_action_reauthenticate": {"type": bool},
                }
                eap_response: Literal["success", "disabled"] | None
                """EAP response to send."""
                action: Action
                """
                Set action for supplicant when AAA times out.

                Subclass of AvdModel.
                """
                phone_action: PhoneAction
                """
                Set action for supplicant when AAA times out.

                Subclass of AvdModel.
                """
                recovery_action_reauthenticate: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        eap_response: Literal["success", "disabled"] | None | UndefinedType = Undefined,
                        action: Action | UndefinedType = Undefined,
                        phone_action: PhoneAction | UndefinedType = Undefined,
                        recovery_action_reauthenticate: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Unresponsive.


                        Subclass of AvdModel.

                        Args:
                            eap_response: EAP response to send.
                            action:
                               Set action for supplicant when AAA times out.

                               Subclass of AvdModel.
                            phone_action:
                               Set action for supplicant when AAA times out.

                               Subclass of AvdModel.
                            recovery_action_reauthenticate: recovery_action_reauthenticate

                        """

            _fields: ClassVar[dict] = {"unresponsive": {"type": Unresponsive}, "accounting_update_interval": {"type": int}}
            unresponsive: Unresponsive
            """
            Configure AAA timeout options.

            Subclass of AvdModel.
            """
            accounting_update_interval: int | None
            """Interval period in seconds."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, unresponsive: Unresponsive | UndefinedType = Undefined, accounting_update_interval: int | None | UndefinedType = Undefined
                ) -> None:
                    """
                    Aaa.


                    Subclass of AvdModel.

                    Args:
                        unresponsive:
                           Configure AAA timeout options.

                           Subclass of AvdModel.
                        accounting_update_interval: Interval period in seconds.

                    """

        class CaptivePortal(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "url": {"type": str},
                "ssl_profile": {"type": str},
                "start_limit_infinite": {"type": bool},
                "access_list_ipv4": {"type": str},
            }
            enabled: bool
            url: str | None
            """
            Supported URL type:
              - http: http://<hostname>[:<port>]
              - https: https://<hostname>[:<port>]
            """
            ssl_profile: str | None
            start_limit_infinite: bool | None
            """Set captive-portal start limit to infinite."""
            access_list_ipv4: str | None
            """Standard access-list name."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    url: str | None | UndefinedType = Undefined,
                    ssl_profile: str | None | UndefinedType = Undefined,
                    start_limit_infinite: bool | None | UndefinedType = Undefined,
                    access_list_ipv4: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    CaptivePortal.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        url:
                           Supported URL type:
                             - http: http://<hostname>[:<port>]
                             - https: https://<hostname>[:<port>]
                        ssl_profile: ssl_profile
                        start_limit_infinite: Set captive-portal start limit to infinite.
                        access_list_ipv4: Standard access-list name.

                    """

        class Supplicant(AvdModel):
            """Subclass of AvdModel."""

            class ProfilesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "eap_method": {"type": str},
                    "identity": {"type": str},
                    "passphrase_type": {"type": str, "default": "7"},
                    "passphrase": {"type": str},
                    "ssl_profile": {"type": str},
                }
                name: str
                eap_method: Literal["fast", "tls"] | None
                """
                Extensible Authentication Protocol method:
                  - EAP Flexible Authentication via Secure Tunneling.
                  -
                EAP with Transport Layer Security.
                """
                identity: str | None
                """User identity."""
                passphrase_type: Literal["0", "7", "8a"]
                """Default value: `"7"`"""
                passphrase: str | None
                """Extensible Authentication Protocol password."""
                ssl_profile: str | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        eap_method: Literal["fast", "tls"] | None | UndefinedType = Undefined,
                        identity: str | None | UndefinedType = Undefined,
                        passphrase_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                        passphrase: str | None | UndefinedType = Undefined,
                        ssl_profile: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ProfilesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            eap_method:
                               Extensible Authentication Protocol method:
                                 - EAP Flexible Authentication via Secure Tunneling.
                                 -
                               EAP with Transport Layer Security.
                            identity: User identity.
                            passphrase_type: passphrase_type
                            passphrase: Extensible Authentication Protocol password.
                            ssl_profile: ssl_profile

                        """

            class Profiles(AvdIndexedList[str, ProfilesItem]):
                """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Profiles._item_type = ProfilesItem

            _fields: ClassVar[dict] = {"profiles": {"type": Profiles}, "logging": {"type": bool}, "disconnect_cached_results_timeout": {"type": int}}
            profiles: Profiles
            """
            Dot1x supplicant profiles.

            Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is
            `name` (`str`).
            """
            logging: bool | None
            """Enable supplicant logging."""
            disconnect_cached_results_timeout: int | None
            """Timeout in seconds for removing a disconnected supplicant."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    profiles: Profiles | UndefinedType = Undefined,
                    logging: bool | None | UndefinedType = Undefined,
                    disconnect_cached_results_timeout: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Supplicant.


                    Subclass of AvdModel.

                    Args:
                        profiles:
                           Dot1x supplicant profiles.

                           Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is
                           `name` (`str`).
                        logging: Enable supplicant logging.
                        disconnect_cached_results_timeout: Timeout in seconds for removing a disconnected supplicant.

                    """

        class VlanAssignmentGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "members": {"type": str}}
            name: str
            members: str
            """VLAN value(s) or range(s) of VLAN values."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, members: str | UndefinedType = Undefined) -> None:
                    """
                    VlanAssignmentGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        members: VLAN value(s) or range(s) of VLAN values.

                    """

        class VlanAssignmentGroups(AvdIndexedList[str, VlanAssignmentGroupsItem]):
            """Subclass of AvdIndexedList with `VlanAssignmentGroupsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        VlanAssignmentGroups._item_type = VlanAssignmentGroupsItem

        _fields: ClassVar[dict] = {
            "system_auth_control": {"type": bool},
            "protocol_lldp_bypass": {"type": bool},
            "protocol_bpdu_bypass": {"type": bool},
            "dynamic_authorization": {"type": bool},
            "statistics_packets_dropped": {"type": bool},
            "mac_based_authentication": {"type": MacBasedAuthentication},
            "radius_av_pair_username_format": {"type": RadiusAvPairUsernameFormat},
            "radius_av_pair": {"type": RadiusAvPair},
            "aaa": {"type": Aaa},
            "captive_portal": {"type": CaptivePortal},
            "supplicant": {"type": Supplicant},
            "vlan_assignment_groups": {"type": VlanAssignmentGroups},
        }
        system_auth_control: bool | None
        protocol_lldp_bypass: bool | None
        protocol_bpdu_bypass: bool | None
        dynamic_authorization: bool | None
        statistics_packets_dropped: bool | None
        """Enable the 802.1X port authentication dropped data packet statistics."""
        mac_based_authentication: MacBasedAuthentication
        """Subclass of AvdModel."""
        radius_av_pair_username_format: RadiusAvPairUsernameFormat
        """
        RADIUS AV-pair username settings.

        Subclass of AvdModel.
        """
        radius_av_pair: RadiusAvPair
        """Subclass of AvdModel."""
        aaa: Aaa
        """
        Configure AAA parameters.

        Subclass of AvdModel.
        """
        captive_portal: CaptivePortal
        """
        Web authentication feature authenticates a supplicant through a web page, referred to as a captive
        portal.

        Subclass of AvdModel.
        """
        supplicant: Supplicant
        """Subclass of AvdModel."""
        vlan_assignment_groups: VlanAssignmentGroups
        """Subclass of AvdIndexedList with `VlanAssignmentGroupsItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                system_auth_control: bool | None | UndefinedType = Undefined,
                protocol_lldp_bypass: bool | None | UndefinedType = Undefined,
                protocol_bpdu_bypass: bool | None | UndefinedType = Undefined,
                dynamic_authorization: bool | None | UndefinedType = Undefined,
                statistics_packets_dropped: bool | None | UndefinedType = Undefined,
                mac_based_authentication: MacBasedAuthentication | UndefinedType = Undefined,
                radius_av_pair_username_format: RadiusAvPairUsernameFormat | UndefinedType = Undefined,
                radius_av_pair: RadiusAvPair | UndefinedType = Undefined,
                aaa: Aaa | UndefinedType = Undefined,
                captive_portal: CaptivePortal | UndefinedType = Undefined,
                supplicant: Supplicant | UndefinedType = Undefined,
                vlan_assignment_groups: VlanAssignmentGroups | UndefinedType = Undefined,
            ) -> None:
                """
                Dot1x.


                Subclass of AvdModel.

                Args:
                    system_auth_control: system_auth_control
                    protocol_lldp_bypass: protocol_lldp_bypass
                    protocol_bpdu_bypass: protocol_bpdu_bypass
                    dynamic_authorization: dynamic_authorization
                    statistics_packets_dropped: Enable the 802.1X port authentication dropped data packet statistics.
                    mac_based_authentication: Subclass of AvdModel.
                    radius_av_pair_username_format:
                       RADIUS AV-pair username settings.

                       Subclass of AvdModel.
                    radius_av_pair: Subclass of AvdModel.
                    aaa:
                       Configure AAA parameters.

                       Subclass of AvdModel.
                    captive_portal:
                       Web authentication feature authenticates a supplicant through a web page, referred to as a captive
                       portal.

                       Subclass of AvdModel.
                    supplicant: Subclass of AvdModel.
                    vlan_assignment_groups: Subclass of AvdIndexedList with `VlanAssignmentGroupsItem` items. Primary key is `name` (`str`).

                """

    class DpsInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class FlowTracker(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sampled": {"type": str}, "hardware": {"type": str}}
            sampled: str | None
            """Sampled flow tracker name."""
            hardware: str | None
            """Hardware flow tracker name,"""

            if TYPE_CHECKING:

                def __init__(self, *, sampled: str | None | UndefinedType = Undefined, hardware: str | None | UndefinedType = Undefined) -> None:
                    """
                    FlowTracker.


                    Subclass of AvdModel.

                    Args:
                        sampled: Sampled flow tracker name.
                        hardware: Hardware flow tracker name,

                    """

        class TcpMssCeiling(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4": {"type": int}, "ipv6": {"type": int}, "direction": {"type": str}}
            ipv4: int | None
            """Segment Size for IPv4."""
            ipv6: int | None
            """Segment Size for IPv6."""
            direction: Literal["ingress", "egress"] | None
            """Optional direction ('ingress', 'egress')  for tcp mss ceiling."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4: int | None | UndefinedType = Undefined,
                    ipv6: int | None | UndefinedType = Undefined,
                    direction: Literal["ingress", "egress"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TcpMssCeiling.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Segment Size for IPv4.
                        ipv6: Segment Size for IPv6.
                        direction: Optional direction ('ingress', 'egress')  for tcp mss ceiling.

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "mtu": {"type": int},
            "ip_address": {"type": str},
            "flow_tracker": {"type": FlowTracker},
            "tcp_mss_ceiling": {"type": TcpMssCeiling},
            "eos_cli": {"type": str},
        }
        name: Literal["Dps1"]
        """"Dps1" is currently the only supported interface."""
        description: str | None
        shutdown: bool | None
        mtu: int | None
        """Maximum Transmission Unit in bytes."""
        ip_address: str | None
        """IPv4 address/mask."""
        flow_tracker: FlowTracker
        """Subclass of AvdModel."""
        tcp_mss_ceiling: TcpMssCeiling
        """Subclass of AvdModel."""
        eos_cli: str | None
        """Multiline String with EOS CLI rendered directly on the Dps interface in the final EOS configuration."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: Literal["Dps1"] | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                flow_tracker: FlowTracker | UndefinedType = Undefined,
                tcp_mss_ceiling: TcpMssCeiling | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                DpsInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: "Dps1" is currently the only supported interface.
                    description: description
                    shutdown: shutdown
                    mtu: Maximum Transmission Unit in bytes.
                    ip_address: IPv4 address/mask.
                    flow_tracker: Subclass of AvdModel.
                    tcp_mss_ceiling: Subclass of AvdModel.
                    eos_cli: Multiline String with EOS CLI rendered directly on the Dps interface in the final EOS configuration.

                """

    class DpsInterfaces(AvdIndexedList[str, DpsInterfacesItem]):
        """Subclass of AvdIndexedList with `DpsInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    DpsInterfaces._item_type = DpsInterfacesItem

    class DynamicPrefixListsItem(AvdModel):
        """Subclass of AvdModel."""

        class PrefixList(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4": {"type": str}, "ipv6": {"type": str}}
            ipv4: str | None
            """Prefix-list name."""
            ipv6: str | None
            """Prefix-list name."""

            if TYPE_CHECKING:

                def __init__(self, *, ipv4: str | None | UndefinedType = Undefined, ipv6: str | None | UndefinedType = Undefined) -> None:
                    """
                    PrefixList.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Prefix-list name.
                        ipv6: Prefix-list name.

                    """

        _fields: ClassVar[dict] = {"name": {"type": str}, "match_map": {"type": str}, "prefix_list": {"type": PrefixList}}
        name: str | None
        """Dynamic prefix-list name."""
        match_map: str | None
        """Route-map name."""
        prefix_list: PrefixList
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | None | UndefinedType = Undefined,
                match_map: str | None | UndefinedType = Undefined,
                prefix_list: PrefixList | UndefinedType = Undefined,
            ) -> None:
                """
                DynamicPrefixListsItem.


                Subclass of AvdModel.

                Args:
                    name: Dynamic prefix-list name.
                    match_map: Route-map name.
                    prefix_list: Subclass of AvdModel.

                """

    class DynamicPrefixLists(AvdList[DynamicPrefixListsItem]):
        """Subclass of AvdList with `DynamicPrefixListsItem` items."""

    DynamicPrefixLists._item_type = DynamicPrefixListsItem

    class EnablePassword(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"disabled": {"type": bool}, "hash_algorithm": {"type": str}, "key": {"type": str}}
        disabled: bool | None
        """Set to `true` to configure `no enable password` which is the EOS default."""
        hash_algorithm: Literal["md5", "sha512"] | None
        key: str | None
        """
        Must be the hash of the password using the specified algorithm.
        By default EOS salts the password,
        so the simplest is to generate the hash on an EOS device.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                disabled: bool | None | UndefinedType = Undefined,
                hash_algorithm: Literal["md5", "sha512"] | None | UndefinedType = Undefined,
                key: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                EnablePassword.


                Subclass of AvdModel.

                Args:
                    disabled: Set to `true` to configure `no enable password` which is the EOS default.
                    hash_algorithm: hash_algorithm
                    key:
                       Must be the hash of the password using the specified algorithm.
                       By default EOS salts the password,
                       so the simplest is to generate the hash on an EOS device.

                """

    class EosCliConfigGenConfiguration(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"enable": {"type": bool, "default": True}, "hide_passwords": {"type": bool, "default": False}}
        enable: bool
        """
        Generate device EOS configurations.

        Default value: `True`
        """
        hide_passwords: bool
        """
        Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
        the configuration if true.

        Default value: `False`
        """

        if TYPE_CHECKING:

            def __init__(self, *, enable: bool | UndefinedType = Undefined, hide_passwords: bool | UndefinedType = Undefined) -> None:
                """
                EosCliConfigGenConfiguration.


                Subclass of AvdModel.

                Args:
                    enable: Generate device EOS configurations.
                    hide_passwords:
                       Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
                       the configuration if true.

                """

    class EosCliConfigGenDocumentation(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "enable": {"type": bool, "default": True},
            "hide_passwords": {"type": bool, "default": True},
            "toc": {"type": bool, "default": True},
        }
        enable: bool
        """
        Generate device Markdown documentation.

        Default value: `True`
        """
        hide_passwords: bool
        """
        Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
        the documentation if true.

        Default value: `True`
        """
        toc: bool
        """
        Generate the table of content(TOC) on device documentation.

        Default value: `True`
        """

        if TYPE_CHECKING:

            def __init__(
                self, *, enable: bool | UndefinedType = Undefined, hide_passwords: bool | UndefinedType = Undefined, toc: bool | UndefinedType = Undefined
            ) -> None:
                """
                EosCliConfigGenDocumentation.


                Subclass of AvdModel.

                Args:
                    enable: Generate device Markdown documentation.
                    hide_passwords:
                       Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
                       the documentation if true.
                    toc: Generate the table of content(TOC) on device documentation.

                """

    class Errdisable(AvdModel):
        """Subclass of AvdModel."""

        class Detect(AvdModel):
            """Subclass of AvdModel."""

            class Causes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Causes._item_type = str

            _fields: ClassVar[dict] = {"causes": {"type": Causes}}
            causes: Causes
            """Subclass of AvdList with `str` items."""

            if TYPE_CHECKING:

                def __init__(self, *, causes: Causes | UndefinedType = Undefined) -> None:
                    """
                    Detect.


                    Subclass of AvdModel.

                    Args:
                        causes: Subclass of AvdList with `str` items.

                    """

        class Recovery(AvdModel):
            """Subclass of AvdModel."""

            class Causes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Causes._item_type = str

            _fields: ClassVar[dict] = {"causes": {"type": Causes}, "interval": {"type": int, "default": 300}}
            causes: Causes
            """Subclass of AvdList with `str` items."""
            interval: int
            """
            Interval in seconds.

            Default value: `300`
            """

            if TYPE_CHECKING:

                def __init__(self, *, causes: Causes | UndefinedType = Undefined, interval: int | UndefinedType = Undefined) -> None:
                    """
                    Recovery.


                    Subclass of AvdModel.

                    Args:
                        causes: Subclass of AvdList with `str` items.
                        interval: Interval in seconds.

                    """

        _fields: ClassVar[dict] = {"detect": {"type": Detect}, "recovery": {"type": Recovery}}
        detect: Detect
        """Subclass of AvdModel."""
        recovery: Recovery
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, detect: Detect | UndefinedType = Undefined, recovery: Recovery | UndefinedType = Undefined) -> None:
                """
                Errdisable.


                Subclass of AvdModel.

                Args:
                    detect: Subclass of AvdModel.
                    recovery: Subclass of AvdModel.

                """

    class EthernetInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class Phone(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"trunk": {"type": str}, "vlan": {"type": int}}
            trunk: Literal["tagged", "tagged phone", "untagged", "untagged phone"] | None
            vlan: int | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    trunk: Literal["tagged", "tagged phone", "untagged", "untagged phone"] | None | UndefinedType = Undefined,
                    vlan: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Phone.


                    Subclass of AvdModel.

                    Args:
                        trunk: trunk
                        vlan: vlan

                    """

        class L2Protocol(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"encapsulation_dot1q_vlan": {"type": int}, "forwarding_profile": {"type": str}}
            encapsulation_dot1q_vlan: int | None
            """Vlan tag to configure on sub-interface."""
            forwarding_profile: str | None
            """L2 protocol forwarding profile."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined, forwarding_profile: str | None | UndefinedType = Undefined
                ) -> None:
                    """
                    L2Protocol.


                    Subclass of AvdModel.

                    Args:
                        encapsulation_dot1q_vlan: Vlan tag to configure on sub-interface.
                        forwarding_profile: L2 protocol forwarding profile.

                    """

        class TrunkGroups(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        TrunkGroups._item_type = str

        class AddressLocking(AvdModel):
            """Subclass of AvdModel."""

            class AddressFamily(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4": {"type": bool}, "ipv6": {"type": bool}}
                ipv4: bool | None
                """Enable/disable address locking for IPv4."""
                ipv6: bool | None
                """Enable/disable address locking for IPv6."""

                if TYPE_CHECKING:

                    def __init__(self, *, ipv4: bool | None | UndefinedType = Undefined, ipv6: bool | None | UndefinedType = Undefined) -> None:
                        """
                        AddressFamily.


                        Subclass of AvdModel.

                        Args:
                            ipv4: Enable/disable address locking for IPv4.
                            ipv6: Enable/disable address locking for IPv6.

                        """

            _fields: ClassVar[dict] = {
                "ipv4": {"type": bool},
                "ipv6": {"type": bool},
                "address_family": {"type": AddressFamily},
                "ipv4_enforcement_disabled": {"type": bool},
            }
            ipv4: bool | None
            """
            Enable address locking for IPv4.
            For EOS version 4.31 and above, the `address_family.ipv4` parameter
            should be used instead.
            """
            ipv6: bool | None
            """
            Enable address locking for IPv6.
            For EOS version 4.31 and above, the `address_family.ipv6` parameter
            should be used instead.
            """
            address_family: AddressFamily
            """
            Configure address locking per address family.
            The `address_locking.ipv4/ipv6` and
            `address_locking.address_family.ipv4/ipv6` are mutually exclusive and
            `address_locking.address_family.ipv4/ipv6` take precedence.
            Introduced in EOS 4.31.0F.

            Subclass of
            AvdModel.
            """
            ipv4_enforcement_disabled: bool | None
            """Disable enforcement for IPv4 locked addresses."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4: bool | None | UndefinedType = Undefined,
                    ipv6: bool | None | UndefinedType = Undefined,
                    address_family: AddressFamily | UndefinedType = Undefined,
                    ipv4_enforcement_disabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressLocking.


                    Subclass of AvdModel.

                    Args:
                        ipv4:
                           Enable address locking for IPv4.
                           For EOS version 4.31 and above, the `address_family.ipv4` parameter
                           should be used instead.
                        ipv6:
                           Enable address locking for IPv6.
                           For EOS version 4.31 and above, the `address_family.ipv6` parameter
                           should be used instead.
                        address_family:
                           Configure address locking per address family.
                           The `address_locking.ipv4/ipv6` and
                           `address_locking.address_family.ipv4/ipv6` are mutually exclusive and
                           `address_locking.address_family.ipv4/ipv6` take precedence.
                           Introduced in EOS 4.31.0F.

                           Subclass of
                           AvdModel.
                        ipv4_enforcement_disabled: Disable enforcement for IPv4 locked addresses.

                    """

        class Flowcontrol(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"received": {"type": str}}
            received: Literal["desired", "on", "off"] | None

            if TYPE_CHECKING:

                def __init__(self, *, received: Literal["desired", "on", "off"] | None | UndefinedType = Undefined) -> None:
                    """
                    Flowcontrol.


                    Subclass of AvdModel.

                    Args:
                        received: received

                    """

        class FlowTracker(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sampled": {"type": str}, "hardware": {"type": str}}
            sampled: str | None
            """Sampled flow tracker name."""
            hardware: str | None
            """Hardware flow tracker name."""

            if TYPE_CHECKING:

                def __init__(self, *, sampled: str | None | UndefinedType = Undefined, hardware: str | None | UndefinedType = Undefined) -> None:
                    """
                    FlowTracker.


                    Subclass of AvdModel.

                    Args:
                        sampled: Sampled flow tracker name.
                        hardware: Hardware flow tracker name.

                    """

        class ErrorCorrectionEncoding(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool, "default": True}, "fire_code": {"type": bool}, "reed_solomon": {"type": bool}}
            enabled: bool
            """Default value: `True`"""
            fire_code: bool | None
            reed_solomon: bool | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    fire_code: bool | None | UndefinedType = Undefined,
                    reed_solomon: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ErrorCorrectionEncoding.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        fire_code: fire_code
                        reed_solomon: reed_solomon

                    """

        class LinkTrackingGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "direction": {"type": str}}
            name: str
            """Group name."""
            direction: Literal["upstream", "downstream"] | None

            if TYPE_CHECKING:

                def __init__(
                    self, *, name: str | UndefinedType = Undefined, direction: Literal["upstream", "downstream"] | None | UndefinedType = Undefined
                ) -> None:
                    """
                    LinkTrackingGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Group name.
                        direction: direction

                    """

        class LinkTrackingGroups(AvdIndexedList[str, LinkTrackingGroupsItem]):
            """Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        LinkTrackingGroups._item_type = LinkTrackingGroupsItem

        class LinkTracking(AvdModel):
            """Subclass of AvdModel."""

            class Groups(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Groups._item_type = str

            _fields: ClassVar[dict] = {"direction": {"type": str}, "groups": {"type": Groups}}
            direction: Literal["upstream", "downstream"] | None
            groups: Groups
            """
            Link state group(s) an interface belongs to.

            Subclass of AvdList with `str` items.
            """

            if TYPE_CHECKING:

                def __init__(
                    self, *, direction: Literal["upstream", "downstream"] | None | UndefinedType = Undefined, groups: Groups | UndefinedType = Undefined
                ) -> None:
                    """
                    LinkTracking.


                    Subclass of AvdModel.

                    Args:
                        direction: direction
                        groups:
                           Link state group(s) an interface belongs to.

                           Subclass of AvdList with `str` items.

                    """

        class EvpnEthernetSegment(AvdModel):
            """Subclass of AvdModel."""

            class DesignatedForwarderElection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "algorithm": {"type": str},
                    "preference_value": {"type": int},
                    "dont_preempt": {"type": bool},
                    "hold_time": {"type": int},
                    "subsequent_hold_time": {"type": int},
                    "candidate_reachability_required": {"type": bool},
                }
                algorithm: Literal["modulus", "preference"] | None
                preference_value: int | None
                """Preference_value is only used when "algorithm" is "preference"."""
                dont_preempt: bool | None
                """Dont_preempt is only used when "algorithm" is "preference"."""
                hold_time: int | None
                subsequent_hold_time: int | None
                candidate_reachability_required: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        algorithm: Literal["modulus", "preference"] | None | UndefinedType = Undefined,
                        preference_value: int | None | UndefinedType = Undefined,
                        dont_preempt: bool | None | UndefinedType = Undefined,
                        hold_time: int | None | UndefinedType = Undefined,
                        subsequent_hold_time: int | None | UndefinedType = Undefined,
                        candidate_reachability_required: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DesignatedForwarderElection.


                        Subclass of AvdModel.

                        Args:
                            algorithm: algorithm
                            preference_value: Preference_value is only used when "algorithm" is "preference".
                            dont_preempt: Dont_preempt is only used when "algorithm" is "preference".
                            hold_time: hold_time
                            subsequent_hold_time: subsequent_hold_time
                            candidate_reachability_required: candidate_reachability_required

                        """

            class Mpls(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"shared_index": {"type": int}, "tunnel_flood_filter_time": {"type": int}}
                shared_index: int | None
                tunnel_flood_filter_time: int | None

                if TYPE_CHECKING:

                    def __init__(
                        self, *, shared_index: int | None | UndefinedType = Undefined, tunnel_flood_filter_time: int | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        Mpls.


                        Subclass of AvdModel.

                        Args:
                            shared_index: shared_index
                            tunnel_flood_filter_time: tunnel_flood_filter_time

                        """

            _fields: ClassVar[dict] = {
                "identifier": {"type": str},
                "redundancy": {"type": str},
                "designated_forwarder_election": {"type": DesignatedForwarderElection},
                "mpls": {"type": Mpls},
                "route_target": {"type": str},
            }
            identifier: str | None
            """EVPN Ethernet Segment Identifier (Type 1 format)."""
            redundancy: Literal["all-active", "single-active"] | None
            designated_forwarder_election: DesignatedForwarderElection
            """Subclass of AvdModel."""
            mpls: Mpls
            """Subclass of AvdModel."""
            route_target: str | None
            """EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    identifier: str | None | UndefinedType = Undefined,
                    redundancy: Literal["all-active", "single-active"] | None | UndefinedType = Undefined,
                    designated_forwarder_election: DesignatedForwarderElection | UndefinedType = Undefined,
                    mpls: Mpls | UndefinedType = Undefined,
                    route_target: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    EvpnEthernetSegment.


                    Subclass of AvdModel.

                    Args:
                        identifier: EVPN Ethernet Segment Identifier (Type 1 format).
                        redundancy: redundancy
                        designated_forwarder_election: Subclass of AvdModel.
                        mpls: Subclass of AvdModel.
                        route_target: EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx.

                    """

        class EncapsulationDot1q(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"vlan": {"type": int}, "inner_vlan": {"type": int}}
            vlan: int
            """VLAD ID."""
            inner_vlan: int | None
            """Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS."""

            if TYPE_CHECKING:

                def __init__(self, *, vlan: int | UndefinedType = Undefined, inner_vlan: int | None | UndefinedType = Undefined) -> None:
                    """
                    EncapsulationDot1q.


                    Subclass of AvdModel.

                    Args:
                        vlan: VLAD ID.
                        inner_vlan: Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS.

                    """

        class EncapsulationVlan(AvdModel):
            """Subclass of AvdModel."""

            class Client(AvdModel):
                """Subclass of AvdModel."""

                class Dot1q(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"vlan": {"type": int}, "outer": {"type": int}, "inner": {"type": int}}
                    vlan: int | None
                    """Client VLAN ID."""
                    outer: int | None
                    """Client Outer VLAN ID."""
                    inner: int | None
                    """Client Inner VLAN ID."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            vlan: int | None | UndefinedType = Undefined,
                            outer: int | None | UndefinedType = Undefined,
                            inner: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dot1q.


                            Subclass of AvdModel.

                            Args:
                                vlan: Client VLAN ID.
                                outer: Client Outer VLAN ID.
                                inner: Client Inner VLAN ID.

                            """

                _fields: ClassVar[dict] = {
                    "dot1q": {"type": Dot1q},
                    "unmatched": {"type": bool},
                    "encapsulation": {"type": str},
                    "vlan": {"type": int},
                    "outer_vlan": {"type": int},
                    "inner_vlan": {"type": int},
                    "inner_encapsulation": {"type": str},
                }
                dot1q: Dot1q
                """Subclass of AvdModel."""
                unmatched: bool | None
                encapsulation: Literal["dot1q", "dot1ad", "unmatched", "untagged"] | None
                vlan: int | None
                """Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                outer_vlan: int | None
                """Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_vlan: int | None
                """Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_encapsulation: Literal["dot1q", "dot1ad"] | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dot1q: Dot1q | UndefinedType = Undefined,
                        unmatched: bool | None | UndefinedType = Undefined,
                        encapsulation: Literal["dot1q", "dot1ad", "unmatched", "untagged"] | None | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                        outer_vlan: int | None | UndefinedType = Undefined,
                        inner_vlan: int | None | UndefinedType = Undefined,
                        inner_encapsulation: Literal["dot1q", "dot1ad"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Client.


                        Subclass of AvdModel.

                        Args:
                            dot1q: Subclass of AvdModel.
                            unmatched: unmatched
                            encapsulation: encapsulation
                            vlan: Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                            outer_vlan: Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                            inner_vlan: Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                            inner_encapsulation: inner_encapsulation

                        """

            class Network(AvdModel):
                """Subclass of AvdModel."""

                class Dot1q(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"vlan": {"type": int}, "outer": {"type": int}, "inner": {"type": int}}
                    vlan: int | None
                    """Network VLAN ID."""
                    outer: int | None
                    """Network outer VLAN ID."""
                    inner: int | None
                    """Network inner VLAN ID."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            vlan: int | None | UndefinedType = Undefined,
                            outer: int | None | UndefinedType = Undefined,
                            inner: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dot1q.


                            Subclass of AvdModel.

                            Args:
                                vlan: Network VLAN ID.
                                outer: Network outer VLAN ID.
                                inner: Network inner VLAN ID.

                            """

                _fields: ClassVar[dict] = {
                    "dot1q": {"type": Dot1q},
                    "client": {"type": bool},
                    "encapsulation": {"type": str},
                    "vlan": {"type": int},
                    "outer_vlan": {"type": int},
                    "inner_vlan": {"type": int},
                    "inner_encapsulation": {"type": str},
                }
                dot1q: Dot1q
                """Subclass of AvdModel."""
                client: bool | None
                encapsulation: Literal["dot1q", "dot1ad", "client", "client inner", "untagged"] | None
                """
                `untagged` (no encapsulation) is applicable for `untagged` client only.
                `client` and `client inner`
                (retain client encapsulation) is not applicable for `untagged` client.
                """
                vlan: int | None
                """Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                outer_vlan: int | None
                """Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_vlan: int | None
                """Network inner VLAN ID.  Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_encapsulation: Literal["dot1q", "dot1ad"] | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dot1q: Dot1q | UndefinedType = Undefined,
                        client: bool | None | UndefinedType = Undefined,
                        encapsulation: Literal["dot1q", "dot1ad", "client", "client inner", "untagged"] | None | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                        outer_vlan: int | None | UndefinedType = Undefined,
                        inner_vlan: int | None | UndefinedType = Undefined,
                        inner_encapsulation: Literal["dot1q", "dot1ad"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Network.


                        Subclass of AvdModel.

                        Args:
                            dot1q: Subclass of AvdModel.
                            client: client
                            encapsulation:
                               `untagged` (no encapsulation) is applicable for `untagged` client only.
                               `client` and `client inner`
                               (retain client encapsulation) is not applicable for `untagged` client.
                            vlan: Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                            outer_vlan: Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                            inner_vlan: Network inner VLAN ID.  Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                            inner_encapsulation: inner_encapsulation

                        """

            _fields: ClassVar[dict] = {"client": {"type": Client}, "network": {"type": Network}}
            client: Client
            """Subclass of AvdModel."""
            network: Network
            """
            Network encapsulations are all optional and skipped if using client unmatched.

            Subclass of
            AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(self, *, client: Client | UndefinedType = Undefined, network: Network | UndefinedType = Undefined) -> None:
                    """
                    EncapsulationVlan.


                    Subclass of AvdModel.

                    Args:
                        client: Subclass of AvdModel.
                        network:
                           Network encapsulations are all optional and skipped if using client unmatched.

                           Subclass of
                           AvdModel.

                    """

        class IpAddressSecondaries(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        IpAddressSecondaries._item_type = str

        class IpHelpersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ip_helper": {"type": str}, "source_interface": {"type": str}, "vrf": {"type": str}}
            ip_helper: str
            source_interface: str | None
            """Source interface name."""
            vrf: str | None
            """VRF name."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ip_helper: str | UndefinedType = Undefined,
                    source_interface: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpHelpersItem.


                    Subclass of AvdModel.

                    Args:
                        ip_helper: ip_helper
                        source_interface: Source interface name.
                        vrf: VRF name.

                    """

        class IpHelpers(AvdIndexedList[str, IpHelpersItem]):
            """Subclass of AvdIndexedList with `IpHelpersItem` items. Primary key is `ip_helper` (`str`)."""

            _primary_key: ClassVar[str] = "ip_helper"

        IpHelpers._item_type = IpHelpersItem

        class IpNat(AvdModel):
            """Subclass of AvdModel."""

            class Destination(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"access_list": {"type": str}, "comment": {"type": str}, "pool_name": {"type": str}, "priority": {"type": int}}
                    access_list: str
                    comment: str | None
                    pool_name: str
                    priority: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            pool_name: str | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                pool_name: pool_name
                                priority: priority

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, dynamic: Dynamic | UndefinedType = Undefined, static: Static | UndefinedType = Undefined) -> None:
                        """
                        Destination.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.

                        """

            class Source(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "nat_type": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                    }
                    access_list: str
                    comment: str | None
                    nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"]
                    pool_name: str | None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"] | UndefinedType = Undefined,
                            pool_name: str | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                nat_type: nat_type
                                pool_name:
                                   required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                                   ignored if 'nat_type' is
                                   overload.
                                priority: priority

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, dynamic: Dynamic | UndefinedType = Undefined, static: Static | UndefinedType = Undefined) -> None:
                        """
                        Source.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.

                        """

            _fields: ClassVar[dict] = {"service_profile": {"type": str}, "destination": {"type": Destination}, "source": {"type": Source}}
            service_profile: str | None
            """NAT interface profile."""
            destination: Destination
            """Subclass of AvdModel."""
            source: Source
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    service_profile: str | None | UndefinedType = Undefined,
                    destination: Destination | UndefinedType = Undefined,
                    source: Source | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpNat.


                    Subclass of AvdModel.

                    Args:
                        service_profile: NAT interface profile.
                        destination: Subclass of AvdModel.
                        source: Subclass of AvdModel.

                    """

        class Ipv6NdPrefixesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "ipv6_prefix": {"type": str},
                "valid_lifetime": {"type": str},
                "preferred_lifetime": {"type": str},
                "no_autoconfig_flag": {"type": bool},
            }
            ipv6_prefix: str
            valid_lifetime: str | None
            """Infinite or lifetime in seconds."""
            preferred_lifetime: str | None
            """Infinite or lifetime in seconds."""
            no_autoconfig_flag: bool | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv6_prefix: str | UndefinedType = Undefined,
                    valid_lifetime: str | None | UndefinedType = Undefined,
                    preferred_lifetime: str | None | UndefinedType = Undefined,
                    no_autoconfig_flag: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6NdPrefixesItem.


                    Subclass of AvdModel.

                    Args:
                        ipv6_prefix: ipv6_prefix
                        valid_lifetime: Infinite or lifetime in seconds.
                        preferred_lifetime: Infinite or lifetime in seconds.
                        no_autoconfig_flag: no_autoconfig_flag

                    """

        class Ipv6NdPrefixes(AvdIndexedList[str, Ipv6NdPrefixesItem]):
            """Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`)."""

            _primary_key: ClassVar[str] = "ipv6_prefix"

        Ipv6NdPrefixes._item_type = Ipv6NdPrefixesItem

        class Ipv6DhcpRelayDestinationsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "address": {"type": str},
                "vrf": {"type": str},
                "local_interface": {"type": str},
                "source_address": {"type": str},
                "link_address": {"type": str},
            }
            address: str
            """DHCP server's IPv6 address."""
            vrf: str | None
            local_interface: str | None
            """Local interface to communicate with DHCP server - mutually exclusive to source_address."""
            source_address: str | None
            """Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface."""
            link_address: str | None
            """Override the default link address specified in the relayed DHCP packet."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    address: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    source_address: str | None | UndefinedType = Undefined,
                    link_address: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6DhcpRelayDestinationsItem.


                    Subclass of AvdModel.

                    Args:
                        address: DHCP server's IPv6 address.
                        vrf: vrf
                        local_interface: Local interface to communicate with DHCP server - mutually exclusive to source_address.
                        source_address: Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface.
                        link_address: Override the default link address specified in the relayed DHCP packet.

                    """

        class Ipv6DhcpRelayDestinations(AvdIndexedList[str, Ipv6DhcpRelayDestinationsItem]):
            """
            Subclass of AvdIndexedList with `Ipv6DhcpRelayDestinationsItem` items. Primary key is `address`
            (`str`).
            """

            _primary_key: ClassVar[str] = "address"

        Ipv6DhcpRelayDestinations._item_type = Ipv6DhcpRelayDestinationsItem

        class Multicast(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class BoundariesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"boundary": {"type": str}, "out": {"type": bool}}
                    boundary: str | None
                    """ACL name or multicast IP subnet."""
                    out: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, boundary: str | None | UndefinedType = Undefined, out: bool | None | UndefinedType = Undefined) -> None:
                            """
                            BoundariesItem.


                            Subclass of AvdModel.

                            Args:
                                boundary: ACL name or multicast IP subnet.
                                out: out

                            """

                class Boundaries(AvdList[BoundariesItem]):
                    """Subclass of AvdList with `BoundariesItem` items."""

                Boundaries._item_type = BoundariesItem

                _fields: ClassVar[dict] = {"boundaries": {"type": Boundaries}, "static": {"type": bool}}
                boundaries: Boundaries
                """Subclass of AvdList with `BoundariesItem` items."""
                static: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, boundaries: Boundaries | UndefinedType = Undefined, static: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            boundaries: Subclass of AvdList with `BoundariesItem` items.
                            static: static

                        """

            class Ipv6(AvdModel):
                """Subclass of AvdModel."""

                class BoundariesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"boundary": {"type": str}}
                    boundary: str | None
                    """ACL name or multicast IP subnet."""

                    if TYPE_CHECKING:

                        def __init__(self, *, boundary: str | None | UndefinedType = Undefined) -> None:
                            """
                            BoundariesItem.


                            Subclass of AvdModel.

                            Args:
                                boundary: ACL name or multicast IP subnet.

                            """

                class Boundaries(AvdList[BoundariesItem]):
                    """Subclass of AvdList with `BoundariesItem` items."""

                Boundaries._item_type = BoundariesItem

                _fields: ClassVar[dict] = {"boundaries": {"type": Boundaries}, "static": {"type": bool}}
                boundaries: Boundaries
                """Subclass of AvdList with `BoundariesItem` items."""
                static: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, boundaries: Boundaries | UndefinedType = Undefined, static: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Ipv6.


                        Subclass of AvdModel.

                        Args:
                            boundaries: Subclass of AvdList with `BoundariesItem` items.
                            static: static

                        """

            _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}}
            ipv4: Ipv4
            """Subclass of AvdModel."""
            ipv6: Ipv6
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, ipv4: Ipv4 | UndefinedType = Undefined, ipv6: Ipv6 | UndefinedType = Undefined) -> None:
                    """
                    Multicast.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Subclass of AvdModel.
                        ipv6: Subclass of AvdModel.

                    """

        class OspfMessageDigestKeysItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": int}, "hash_algorithm": {"type": str}, "key": {"type": str}}
            id: int
            hash_algorithm: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None
            key: str | None
            """Encrypted password - only type 7 supported."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    hash_algorithm: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    OspfMessageDigestKeysItem.


                    Subclass of AvdModel.

                    Args:
                        id: id
                        hash_algorithm: hash_algorithm
                        key: Encrypted password - only type 7 supported.

                    """

        class OspfMessageDigestKeys(AvdIndexedList[int, OspfMessageDigestKeysItem]):
            """Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        OspfMessageDigestKeys._item_type = OspfMessageDigestKeysItem

        class Pim(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class Hello(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"count": {"type": str}, "interval": {"type": int}}
                    count: str | None
                    """Number of missed hellos after which the neighbor expires. Range <1.5-65535>."""
                    interval: int | None
                    """PIM hello interval in seconds."""

                    if TYPE_CHECKING:

                        def __init__(self, *, count: str | None | UndefinedType = Undefined, interval: int | None | UndefinedType = Undefined) -> None:
                            """
                            Hello.


                            Subclass of AvdModel.

                            Args:
                                count: Number of missed hellos after which the neighbor expires. Range <1.5-65535>.
                                interval: PIM hello interval in seconds.

                            """

                _fields: ClassVar[dict] = {
                    "border_router": {"type": bool},
                    "dr_priority": {"type": int},
                    "sparse_mode": {"type": bool},
                    "bfd": {"type": bool},
                    "bidirectional": {"type": bool},
                    "neighbor_filter": {"type": str},
                    "hello": {"type": Hello},
                }
                border_router: bool | None
                """Configure PIM border router. EOS default is false."""
                dr_priority: int | None
                sparse_mode: bool | None
                bfd: bool | None
                """Set the default for whether Bidirectional Forwarding Detection is enabled for PIM."""
                bidirectional: bool | None
                neighbor_filter: str | None
                """Standard access list name."""
                hello: Hello
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        border_router: bool | None | UndefinedType = Undefined,
                        dr_priority: int | None | UndefinedType = Undefined,
                        sparse_mode: bool | None | UndefinedType = Undefined,
                        bfd: bool | None | UndefinedType = Undefined,
                        bidirectional: bool | None | UndefinedType = Undefined,
                        neighbor_filter: str | None | UndefinedType = Undefined,
                        hello: Hello | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            border_router: Configure PIM border router. EOS default is false.
                            dr_priority: dr_priority
                            sparse_mode: sparse_mode
                            bfd: Set the default for whether Bidirectional Forwarding Detection is enabled for PIM.
                            bidirectional: bidirectional
                            neighbor_filter: Standard access list name.
                            hello: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}}
            ipv4: Ipv4
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, ipv4: Ipv4 | UndefinedType = Undefined) -> None:
                    """
                    Pim.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Subclass of AvdModel.

                    """

        class MacSecurity(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"profile": {"type": str}}
            profile: str | None

            if TYPE_CHECKING:

                def __init__(self, *, profile: str | None | UndefinedType = Undefined) -> None:
                    """
                    MacSecurity.


                    Subclass of AvdModel.

                    Args:
                        profile: profile

                    """

        class TcpMssCeiling(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "ipv4_segment_size": {"type": int},
                "ipv4": {"type": int},
                "ipv6_segment_size": {"type": int},
                "ipv6": {"type": int},
                "direction": {"type": str},
            }
            ipv4_segment_size: int | None
            ipv4: int | None
            ipv6_segment_size: int | None
            ipv6: int | None
            direction: Literal["egress", "ingress"] | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4_segment_size: int | None | UndefinedType = Undefined,
                    ipv4: int | None | UndefinedType = Undefined,
                    ipv6_segment_size: int | None | UndefinedType = Undefined,
                    ipv6: int | None | UndefinedType = Undefined,
                    direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TcpMssCeiling.


                    Subclass of AvdModel.

                    Args:
                        ipv4_segment_size: ipv4_segment_size
                        ipv4: ipv4
                        ipv6_segment_size: ipv6_segment_size
                        ipv6: ipv6
                        direction: direction

                    """

        class ChannelGroup(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": int}, "mode": {"type": str}}
            id: int | None
            mode: Literal["on", "active", "passive"] | None

            if TYPE_CHECKING:

                def __init__(
                    self, *, id: int | None | UndefinedType = Undefined, mode: Literal["on", "active", "passive"] | None | UndefinedType = Undefined
                ) -> None:
                    """
                    ChannelGroup.


                    Subclass of AvdModel.

                    Args:
                        id: id
                        mode: mode

                    """

        class IsisAuthentication(AvdModel):
            """Subclass of AvdModel."""

            class Both(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}}
                    key_id: int

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Both.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.

                        """

            class Level1(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}}
                    key_id: int

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level1.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.

                        """

            class Level2(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}}
                    key_id: int

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level2.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.

                        """

            _fields: ClassVar[dict] = {"both": {"type": Both}, "level_1": {"type": Level1}, "level_2": {"type": Level2}}
            both: Both
            """
            Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
            'level_2' settings.

            Subclass of AvdModel.
            """
            level_1: Level1
            """
            Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """
            level_2: Level2
            """
            Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self, *, both: Both | UndefinedType = Undefined, level_1: Level1 | UndefinedType = Undefined, level_2: Level2 | UndefinedType = Undefined
                ) -> None:
                    """
                    IsisAuthentication.


                    Subclass of AvdModel.

                    Args:
                        both:
                           Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
                           'level_2' settings.

                           Subclass of AvdModel.
                        level_1:
                           Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.
                        level_2:
                           Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.

                    """

        class Poe(AvdModel):
            """Subclass of AvdModel."""

            class Reboot(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"action": {"type": str}}
                action: Literal["maintain", "power-off"] | None
                """PoE action for interface."""

                if TYPE_CHECKING:

                    def __init__(self, *, action: Literal["maintain", "power-off"] | None | UndefinedType = Undefined) -> None:
                        """
                        Reboot.


                        Subclass of AvdModel.

                        Args:
                            action: PoE action for interface.

                        """

            class LinkDown(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"action": {"type": str}, "power_off_delay": {"type": int}}
                action: Literal["maintain", "power-off"] | None
                """PoE action for interface."""
                power_off_delay: int | None
                """
                Number of seconds to delay shutting the power off after a link down event occurs. Default value is 5
                seconds in EOS.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        action: Literal["maintain", "power-off"] | None | UndefinedType = Undefined,
                        power_off_delay: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LinkDown.


                        Subclass of AvdModel.

                        Args:
                            action: PoE action for interface.
                            power_off_delay:
                               Number of seconds to delay shutting the power off after a link down event occurs. Default value is 5
                               seconds in EOS.

                        """

            class Shutdown(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"action": {"type": str}}
                action: Literal["maintain", "power-off"] | None
                """PoE action for interface."""

                if TYPE_CHECKING:

                    def __init__(self, *, action: Literal["maintain", "power-off"] | None | UndefinedType = Undefined) -> None:
                        """
                        Shutdown.


                        Subclass of AvdModel.

                        Args:
                            action: PoE action for interface.

                        """

            class Limit(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"field_class": {"type": int}, "watts": {"type": str}, "fixed": {"type": bool}}
                _field_to_key_map: ClassVar[dict] = {"field_class": "class"}
                _key_to_field_map: ClassVar[dict] = {"class": "field_class"}
                field_class: int | None
                watts: str | None
                fixed: bool | None
                """Set to ignore hardware classification."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        field_class: int | None | UndefinedType = Undefined,
                        watts: str | None | UndefinedType = Undefined,
                        fixed: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Limit.


                        Subclass of AvdModel.

                        Args:
                            field_class: field_class
                            watts: watts
                            fixed: Set to ignore hardware classification.

                        """

            _fields: ClassVar[dict] = {
                "disabled": {"type": bool, "default": False},
                "priority": {"type": str},
                "reboot": {"type": Reboot},
                "link_down": {"type": LinkDown},
                "shutdown": {"type": Shutdown},
                "limit": {"type": Limit},
                "negotiation_lldp": {"type": bool},
                "legacy_detect": {"type": bool},
            }
            disabled: bool
            """
            Disable PoE on a POE capable port. PoE is enabled on all ports that support it by default in EOS.

            Default value: `False`
            """
            priority: Literal["critical", "high", "medium", "low"] | None
            """Prioritize a port's power in the event that one of the switch's power supplies loses power."""
            reboot: Reboot
            """
            Set the PoE power behavior for a PoE port when the system is rebooted.

            Subclass of AvdModel.
            """
            link_down: LinkDown
            """
            Set the PoE power behavior for a PoE port when the port goes down.

            Subclass of AvdModel.
            """
            shutdown: Shutdown
            """
            Set the PoE power behavior for a PoE port when the port is admin down.

            Subclass of AvdModel.
            """
            limit: Limit
            """
            Override the hardware-negotiated power limit using either wattage or a power class. Note that if
            using a power class, AVD will automatically convert the class value to the wattage value
            corresponding to that power class.

            Subclass of AvdModel.
            """
            negotiation_lldp: bool | None
            """
            Disable to prevent port from negotiating power with powered devices over LLDP. Enabled by default in
            EOS.
            """
            legacy_detect: bool | None
            """
            Allow a subset of legacy devices to work with the PoE switch. Disabled by default in EOS because it
            can cause false positive detections.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    disabled: bool | UndefinedType = Undefined,
                    priority: Literal["critical", "high", "medium", "low"] | None | UndefinedType = Undefined,
                    reboot: Reboot | UndefinedType = Undefined,
                    link_down: LinkDown | UndefinedType = Undefined,
                    shutdown: Shutdown | UndefinedType = Undefined,
                    limit: Limit | UndefinedType = Undefined,
                    negotiation_lldp: bool | None | UndefinedType = Undefined,
                    legacy_detect: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Poe.


                    Subclass of AvdModel.

                    Args:
                        disabled: Disable PoE on a POE capable port. PoE is enabled on all ports that support it by default in EOS.
                        priority: Prioritize a port's power in the event that one of the switch's power supplies loses power.
                        reboot:
                           Set the PoE power behavior for a PoE port when the system is rebooted.

                           Subclass of AvdModel.
                        link_down:
                           Set the PoE power behavior for a PoE port when the port goes down.

                           Subclass of AvdModel.
                        shutdown:
                           Set the PoE power behavior for a PoE port when the port is admin down.

                           Subclass of AvdModel.
                        limit:
                           Override the hardware-negotiated power limit using either wattage or a power class. Note that if
                           using a power class, AVD will automatically convert the class value to the wattage value
                           corresponding to that power class.

                           Subclass of AvdModel.
                        negotiation_lldp:
                           Disable to prevent port from negotiating power with powered devices over LLDP. Enabled by default in
                           EOS.
                        legacy_detect:
                           Allow a subset of legacy devices to work with the PoE switch. Disabled by default in EOS because it
                           can cause false positive detections.

                    """

        class Ptp(AvdModel):
            """Subclass of AvdModel."""

            class Announce(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "timeout": {"type": int}}
                interval: int | None
                timeout: int | None

                if TYPE_CHECKING:

                    def __init__(self, *, interval: int | None | UndefinedType = Undefined, timeout: int | None | UndefinedType = Undefined) -> None:
                        """
                        Announce.


                        Subclass of AvdModel.

                        Args:
                            interval: interval
                            timeout: timeout

                        """

            class Profile(AvdModel):
                """Subclass of AvdModel."""

                class G82751(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"destination_mac_address": {"type": str}}
                    destination_mac_address: Literal["forwardable", "non-forwardable"] | None

                    if TYPE_CHECKING:

                        def __init__(self, *, destination_mac_address: Literal["forwardable", "non-forwardable"] | None | UndefinedType = Undefined) -> None:
                            """
                            G82751.


                            Subclass of AvdModel.

                            Args:
                                destination_mac_address: destination_mac_address

                            """

                _fields: ClassVar[dict] = {"g8275_1": {"type": G82751}}
                g8275_1: G82751
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, g8275_1: G82751 | UndefinedType = Undefined) -> None:
                        """
                        Profile.


                        Subclass of AvdModel.

                        Args:
                            g8275_1: Subclass of AvdModel.

                        """

            class SyncMessage(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}}
                interval: int | None

                if TYPE_CHECKING:

                    def __init__(self, *, interval: int | None | UndefinedType = Undefined) -> None:
                        """
                        SyncMessage.


                        Subclass of AvdModel.

                        Args:
                            interval: interval

                        """

            _fields: ClassVar[dict] = {
                "enable": {"type": bool},
                "announce": {"type": Announce},
                "delay_req": {"type": int},
                "delay_mechanism": {"type": str},
                "profile": {"type": Profile},
                "sync_message": {"type": SyncMessage},
                "role": {"type": str},
                "vlan": {"type": str},
                "transport": {"type": str},
            }
            enable: bool | None
            announce: Announce
            """Subclass of AvdModel."""
            delay_req: int | None
            delay_mechanism: Literal["e2e", "p2p"] | None
            profile: Profile
            """Subclass of AvdModel."""
            sync_message: SyncMessage
            """Subclass of AvdModel."""
            role: Literal["master", "dynamic"] | None
            vlan: str | None
            """VLAN can be 'all' or list of vlans as string."""
            transport: Literal["ipv4", "ipv6", "layer2"] | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enable: bool | None | UndefinedType = Undefined,
                    announce: Announce | UndefinedType = Undefined,
                    delay_req: int | None | UndefinedType = Undefined,
                    delay_mechanism: Literal["e2e", "p2p"] | None | UndefinedType = Undefined,
                    profile: Profile | UndefinedType = Undefined,
                    sync_message: SyncMessage | UndefinedType = Undefined,
                    role: Literal["master", "dynamic"] | None | UndefinedType = Undefined,
                    vlan: str | None | UndefinedType = Undefined,
                    transport: Literal["ipv4", "ipv6", "layer2"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ptp.


                    Subclass of AvdModel.

                    Args:
                        enable: enable
                        announce: Subclass of AvdModel.
                        delay_req: delay_req
                        delay_mechanism: delay_mechanism
                        profile: Subclass of AvdModel.
                        sync_message: Subclass of AvdModel.
                        role: role
                        vlan: VLAN can be 'all' or list of vlans as string.
                        transport: transport

                    """

        class StormControl(AvdModel):
            """Subclass of AvdModel."""

            class All(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """

                if TYPE_CHECKING:

                    def __init__(self, *, level: str | None | UndefinedType = Undefined, unit: Literal["percent", "pps"] | UndefinedType = Undefined) -> None:
                        """
                        All.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.

                        """

            class Broadcast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """

                if TYPE_CHECKING:

                    def __init__(self, *, level: str | None | UndefinedType = Undefined, unit: Literal["percent", "pps"] | UndefinedType = Undefined) -> None:
                        """
                        Broadcast.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.

                        """

            class Multicast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """

                if TYPE_CHECKING:

                    def __init__(self, *, level: str | None | UndefinedType = Undefined, unit: Literal["percent", "pps"] | UndefinedType = Undefined) -> None:
                        """
                        Multicast.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.

                        """

            class UnknownUnicast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """

                if TYPE_CHECKING:

                    def __init__(self, *, level: str | None | UndefinedType = Undefined, unit: Literal["percent", "pps"] | UndefinedType = Undefined) -> None:
                        """
                        UnknownUnicast.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.

                        """

            _fields: ClassVar[dict] = {
                "all": {"type": All},
                "broadcast": {"type": Broadcast},
                "multicast": {"type": Multicast},
                "unknown_unicast": {"type": UnknownUnicast},
            }
            all: All
            """Subclass of AvdModel."""
            broadcast: Broadcast
            """Subclass of AvdModel."""
            multicast: Multicast
            """Subclass of AvdModel."""
            unknown_unicast: UnknownUnicast
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    all: All | UndefinedType = Undefined,
                    broadcast: Broadcast | UndefinedType = Undefined,
                    multicast: Multicast | UndefinedType = Undefined,
                    unknown_unicast: UnknownUnicast | UndefinedType = Undefined,
                ) -> None:
                    """
                    StormControl.


                    Subclass of AvdModel.

                    Args:
                        all: Subclass of AvdModel.
                        broadcast: Subclass of AvdModel.
                        multicast: Subclass of AvdModel.
                        unknown_unicast: Subclass of AvdModel.

                    """

        class Logging(AvdModel):
            """Subclass of AvdModel."""

            class Event(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "link_status": {"type": bool},
                    "congestion_drops": {"type": bool},
                    "spanning_tree": {"type": bool},
                    "storm_control_discards": {"type": bool},
                }
                link_status: bool | None
                congestion_drops: bool | None
                spanning_tree: bool | None
                storm_control_discards: bool | None
                """Discards due to storm-control."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        link_status: bool | None | UndefinedType = Undefined,
                        congestion_drops: bool | None | UndefinedType = Undefined,
                        spanning_tree: bool | None | UndefinedType = Undefined,
                        storm_control_discards: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Event.


                        Subclass of AvdModel.

                        Args:
                            link_status: link_status
                            congestion_drops: congestion_drops
                            spanning_tree: spanning_tree
                            storm_control_discards: Discards due to storm-control.

                        """

            _fields: ClassVar[dict] = {"event": {"type": Event}}
            event: Event
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, event: Event | UndefinedType = Undefined) -> None:
                    """
                    Logging.


                    Subclass of AvdModel.

                    Args:
                        event: Subclass of AvdModel.

                    """

        class Lldp(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"transmit": {"type": bool}, "receive": {"type": bool}, "ztp_vlan": {"type": int}}
            transmit: bool | None
            receive: bool | None
            ztp_vlan: int | None
            """ZTP vlan number."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    transmit: bool | None | UndefinedType = Undefined,
                    receive: bool | None | UndefinedType = Undefined,
                    ztp_vlan: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Lldp.


                    Subclass of AvdModel.

                    Args:
                        transmit: transmit
                        receive: receive
                        ztp_vlan: ZTP vlan number.

                    """

        class VlanTranslationsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"field_from": {"type": str}, "to": {"type": int}, "direction": {"type": str, "default": "both"}}
            _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
            _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
            field_from: str | None
            """List of vlans as string (only one vlan if direction is "both")."""
            to: int | None
            """VLAN ID."""
            direction: Literal["in", "out", "both"]
            """Default value: `"both"`"""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    field_from: str | None | UndefinedType = Undefined,
                    to: int | None | UndefinedType = Undefined,
                    direction: Literal["in", "out", "both"] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VlanTranslationsItem.


                    Subclass of AvdModel.

                    Args:
                        field_from: List of vlans as string (only one vlan if direction is "both").
                        to: VLAN ID.
                        direction: direction

                    """

        class VlanTranslations(AvdList[VlanTranslationsItem]):
            """Subclass of AvdList with `VlanTranslationsItem` items."""

        VlanTranslations._item_type = VlanTranslationsItem

        class Dot1x(AvdModel):
            """Subclass of AvdModel."""

            class Pae(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"mode": {"type": str}, "supplicant_profile": {"type": str}}
                mode: Literal["authenticator", "supplicant"] | None
                supplicant_profile: str | None
                """Supplicant profile name."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mode: Literal["authenticator", "supplicant"] | None | UndefinedType = Undefined,
                        supplicant_profile: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Pae.


                        Subclass of AvdModel.

                        Args:
                            mode: mode
                            supplicant_profile: Supplicant profile name.

                        """

            class AuthenticationFailure(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"action": {"type": str}, "allow_vlan": {"type": int}}
                action: Literal["allow", "drop"] | None
                allow_vlan: int | None

                if TYPE_CHECKING:

                    def __init__(
                        self, *, action: Literal["allow", "drop"] | None | UndefinedType = Undefined, allow_vlan: int | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        AuthenticationFailure.


                        Subclass of AvdModel.

                        Args:
                            action: action
                            allow_vlan: allow_vlan

                        """

            class HostMode(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"mode": {"type": str}, "multi_host_authenticated": {"type": bool}}
                mode: Literal["multi-host", "single-host"] | None
                multi_host_authenticated: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mode: Literal["multi-host", "single-host"] | None | UndefinedType = Undefined,
                        multi_host_authenticated: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        HostMode.


                        Subclass of AvdModel.

                        Args:
                            mode: mode
                            multi_host_authenticated: multi_host_authenticated

                        """

            class MacBasedAuthentication(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "always": {"type": bool}, "host_mode_common": {"type": bool}}
                enabled: bool | None
                always: bool | None
                host_mode_common: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        always: bool | None | UndefinedType = Undefined,
                        host_mode_common: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MacBasedAuthentication.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            always: always
                            host_mode_common: host_mode_common

                        """

            class Timeout(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "idle_host": {"type": int},
                    "quiet_period": {"type": int},
                    "reauth_period": {"type": str},
                    "reauth_timeout_ignore": {"type": bool},
                    "tx_period": {"type": int},
                }
                idle_host: int | None
                quiet_period: int | None
                reauth_period: str | None
                """Value can be 60-4294967295 or 'server'."""
                reauth_timeout_ignore: bool | None
                tx_period: int | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        idle_host: int | None | UndefinedType = Undefined,
                        quiet_period: int | None | UndefinedType = Undefined,
                        reauth_period: str | None | UndefinedType = Undefined,
                        reauth_timeout_ignore: bool | None | UndefinedType = Undefined,
                        tx_period: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Timeout.


                        Subclass of AvdModel.

                        Args:
                            idle_host: idle_host
                            quiet_period: quiet_period
                            reauth_period: Value can be 60-4294967295 or 'server'.
                            reauth_timeout_ignore: reauth_timeout_ignore
                            tx_period: tx_period

                        """

            class Unauthorized(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"access_vlan_membership_egress": {"type": bool}, "native_vlan_membership_egress": {"type": bool}}
                access_vlan_membership_egress: bool | None
                native_vlan_membership_egress: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        access_vlan_membership_egress: bool | None | UndefinedType = Undefined,
                        native_vlan_membership_egress: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Unauthorized.


                        Subclass of AvdModel.

                        Args:
                            access_vlan_membership_egress: access_vlan_membership_egress
                            native_vlan_membership_egress: native_vlan_membership_egress

                        """

            class Eapol(AvdModel):
                """Subclass of AvdModel."""

                class AuthenticationFailureFallbackMba(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "timeout": {"type": int}}
                    enabled: bool | None
                    timeout: int | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, timeout: int | None | UndefinedType = Undefined) -> None:
                            """
                            AuthenticationFailureFallbackMba.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                timeout: timeout

                            """

                _fields: ClassVar[dict] = {"disabled": {"type": bool}, "authentication_failure_fallback_mba": {"type": AuthenticationFailureFallbackMba}}
                disabled: bool | None
                authentication_failure_fallback_mba: AuthenticationFailureFallbackMba
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        disabled: bool | None | UndefinedType = Undefined,
                        authentication_failure_fallback_mba: AuthenticationFailureFallbackMba | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Eapol.


                        Subclass of AvdModel.

                        Args:
                            disabled: disabled
                            authentication_failure_fallback_mba: Subclass of AvdModel.

                        """

            class Aaa(AvdModel):
                """Subclass of AvdModel."""

                class Unresponsive(AvdModel):
                    """Subclass of AvdModel."""

                    class Action(AvdModel):
                        """Subclass of AvdModel."""

                        class CachedResultsTimeout(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"time_duration": {"type": int}, "time_duration_unit": {"type": str}}
                            time_duration: int | None
                            """
                            Enable caching for a specific duration -
                            <1-10000>      duration in days
                            <1-14400000>   duration in
                            minutes
                            <1-240000>     duration in hours
                            <1-864000000>  duration in seconds
                            """
                            time_duration_unit: Literal["days", "hours", "minutes", "seconds"]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    time_duration: int | None | UndefinedType = Undefined,
                                    time_duration_unit: Literal["days", "hours", "minutes", "seconds"] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    CachedResultsTimeout.


                                    Subclass of AvdModel.

                                    Args:
                                        time_duration:
                                           Enable caching for a specific duration -
                                           <1-10000>      duration in days
                                           <1-14400000>   duration in
                                           minutes
                                           <1-240000>     duration in hours
                                           <1-864000000>  duration in seconds
                                        time_duration_unit: time_duration_unit

                                    """

                        _fields: ClassVar[dict] = {
                            "traffic_allow_access_list": {"type": str},
                            "apply_cached_results": {"type": bool},
                            "cached_results_timeout": {"type": CachedResultsTimeout},
                            "apply_alternate": {"type": bool},
                            "traffic_allow": {"type": bool},
                            "traffic_allow_vlan": {"type": int},
                        }
                        traffic_allow_access_list: str | None
                        """Name of standard access-list to apply when AAA times out."""
                        apply_cached_results: bool | None
                        """Use results from a previous AAA response."""
                        cached_results_timeout: CachedResultsTimeout
                        """Subclass of AvdModel."""
                        apply_alternate: bool | None
                        """
                        Apply alternate action if primary action fails.
                        eg. aaa unresponsive action apply cached-results
                        else traffic allow
                        """
                        traffic_allow: bool | None
                        """Set action for supplicant traffic when AAA times out."""
                        traffic_allow_vlan: int | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                traffic_allow_access_list: str | None | UndefinedType = Undefined,
                                apply_cached_results: bool | None | UndefinedType = Undefined,
                                cached_results_timeout: CachedResultsTimeout | UndefinedType = Undefined,
                                apply_alternate: bool | None | UndefinedType = Undefined,
                                traffic_allow: bool | None | UndefinedType = Undefined,
                                traffic_allow_vlan: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Action.


                                Subclass of AvdModel.

                                Args:
                                    traffic_allow_access_list: Name of standard access-list to apply when AAA times out.
                                    apply_cached_results: Use results from a previous AAA response.
                                    cached_results_timeout: Subclass of AvdModel.
                                    apply_alternate:
                                       Apply alternate action if primary action fails.
                                       eg. aaa unresponsive action apply cached-results
                                       else traffic allow
                                    traffic_allow: Set action for supplicant traffic when AAA times out.
                                    traffic_allow_vlan: traffic_allow_vlan

                                """

                    class PhoneAction(AvdModel):
                        """Subclass of AvdModel."""

                        class CachedResultsTimeout(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"time_duration": {"type": int}, "time_duration_unit": {"type": str}}
                            time_duration: int | None
                            """
                            Enable caching for a specific duration -
                            <1-10000>      duration in days
                            <1-14400000>   duration in
                            minutes
                            <1-240000>     duration in hours
                            <1-864000000>  duration in seconds
                            """
                            time_duration_unit: Literal["days", "hours", "minutes", "seconds"]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    time_duration: int | None | UndefinedType = Undefined,
                                    time_duration_unit: Literal["days", "hours", "minutes", "seconds"] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    CachedResultsTimeout.


                                    Subclass of AvdModel.

                                    Args:
                                        time_duration:
                                           Enable caching for a specific duration -
                                           <1-10000>      duration in days
                                           <1-14400000>   duration in
                                           minutes
                                           <1-240000>     duration in hours
                                           <1-864000000>  duration in seconds
                                        time_duration_unit: time_duration_unit

                                    """

                        _fields: ClassVar[dict] = {
                            "apply_cached_results": {"type": bool},
                            "cached_results_timeout": {"type": CachedResultsTimeout},
                            "apply_alternate": {"type": bool},
                            "traffic_allow": {"type": bool},
                        }
                        apply_cached_results: bool | None
                        """Use results from a previous AAA response."""
                        cached_results_timeout: CachedResultsTimeout
                        """Subclass of AvdModel."""
                        apply_alternate: bool | None
                        """
                        Apply alternate action if primary action fails.
                        eg. aaa unresponsive phone action apply cached-
                        results else traffic allow
                        """
                        traffic_allow: bool | None
                        """Set action for supplicant traffic when AAA times out."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                apply_cached_results: bool | None | UndefinedType = Undefined,
                                cached_results_timeout: CachedResultsTimeout | UndefinedType = Undefined,
                                apply_alternate: bool | None | UndefinedType = Undefined,
                                traffic_allow: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                PhoneAction.


                                Subclass of AvdModel.

                                Args:
                                    apply_cached_results: Use results from a previous AAA response.
                                    cached_results_timeout: Subclass of AvdModel.
                                    apply_alternate:
                                       Apply alternate action if primary action fails.
                                       eg. aaa unresponsive phone action apply cached-
                                       results else traffic allow
                                    traffic_allow: Set action for supplicant traffic when AAA times out.

                                """

                    _fields: ClassVar[dict] = {"eap_response": {"type": str}, "action": {"type": Action}, "phone_action": {"type": PhoneAction}}
                    eap_response: Literal["success", "disabled"] | None
                    """EAP response to send. EOS default is `success`."""
                    action: Action
                    """
                    Set action for supplicant when AAA times out.

                    Subclass of AvdModel.
                    """
                    phone_action: PhoneAction
                    """
                    Set action for supplicant when AAA times out.

                    Subclass of AvdModel.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            eap_response: Literal["success", "disabled"] | None | UndefinedType = Undefined,
                            action: Action | UndefinedType = Undefined,
                            phone_action: PhoneAction | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Unresponsive.


                            Subclass of AvdModel.

                            Args:
                                eap_response: EAP response to send. EOS default is `success`.
                                action:
                                   Set action for supplicant when AAA times out.

                                   Subclass of AvdModel.
                                phone_action:
                                   Set action for supplicant when AAA times out.

                                   Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {"unresponsive": {"type": Unresponsive}}
                unresponsive: Unresponsive
                """
                Configure AAA timeout options.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, unresponsive: Unresponsive | UndefinedType = Undefined) -> None:
                        """
                        Aaa.


                        Subclass of AvdModel.

                        Args:
                            unresponsive:
                               Configure AAA timeout options.

                               Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "port_control": {"type": str},
                "port_control_force_authorized_phone": {"type": bool},
                "reauthentication": {"type": bool},
                "pae": {"type": Pae},
                "authentication_failure": {"type": AuthenticationFailure},
                "host_mode": {"type": HostMode},
                "mac_based_authentication": {"type": MacBasedAuthentication},
                "mac_based_access_list": {"type": bool},
                "timeout": {"type": Timeout},
                "reauthorization_request_limit": {"type": int},
                "unauthorized": {"type": Unauthorized},
                "eapol": {"type": Eapol},
                "aaa": {"type": Aaa},
            }
            port_control: Literal["auto", "force-authorized", "force-unauthorized"] | None
            port_control_force_authorized_phone: bool | None
            reauthentication: bool | None
            pae: Pae
            """Subclass of AvdModel."""
            authentication_failure: AuthenticationFailure
            """Subclass of AvdModel."""
            host_mode: HostMode
            """Subclass of AvdModel."""
            mac_based_authentication: MacBasedAuthentication
            """Subclass of AvdModel."""
            mac_based_access_list: bool | None
            """Operate interface in per-mac access-list mode."""
            timeout: Timeout
            """Subclass of AvdModel."""
            reauthorization_request_limit: int | None
            unauthorized: Unauthorized
            """Subclass of AvdModel."""
            eapol: Eapol
            """Subclass of AvdModel."""
            aaa: Aaa
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    port_control: Literal["auto", "force-authorized", "force-unauthorized"] | None | UndefinedType = Undefined,
                    port_control_force_authorized_phone: bool | None | UndefinedType = Undefined,
                    reauthentication: bool | None | UndefinedType = Undefined,
                    pae: Pae | UndefinedType = Undefined,
                    authentication_failure: AuthenticationFailure | UndefinedType = Undefined,
                    host_mode: HostMode | UndefinedType = Undefined,
                    mac_based_authentication: MacBasedAuthentication | UndefinedType = Undefined,
                    mac_based_access_list: bool | None | UndefinedType = Undefined,
                    timeout: Timeout | UndefinedType = Undefined,
                    reauthorization_request_limit: int | None | UndefinedType = Undefined,
                    unauthorized: Unauthorized | UndefinedType = Undefined,
                    eapol: Eapol | UndefinedType = Undefined,
                    aaa: Aaa | UndefinedType = Undefined,
                ) -> None:
                    """
                    Dot1x.


                    Subclass of AvdModel.

                    Args:
                        port_control: port_control
                        port_control_force_authorized_phone: port_control_force_authorized_phone
                        reauthentication: reauthentication
                        pae: Subclass of AvdModel.
                        authentication_failure: Subclass of AvdModel.
                        host_mode: Subclass of AvdModel.
                        mac_based_authentication: Subclass of AvdModel.
                        mac_based_access_list: Operate interface in per-mac access-list mode.
                        timeout: Subclass of AvdModel.
                        reauthorization_request_limit: reauthorization_request_limit
                        unauthorized: Subclass of AvdModel.
                        eapol: Subclass of AvdModel.
                        aaa: Subclass of AvdModel.

                    """

        class Shape(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"rate": {"type": str}}
            rate: str | None
            """
            Rate in kbps, pps or percent.
            Supported options are platform dependent.
            Examples:
            - "5000 kbps"
            -
            "1000 pps"
            - "20 percent"
            """

            if TYPE_CHECKING:

                def __init__(self, *, rate: str | None | UndefinedType = Undefined) -> None:
                    """
                    Shape.


                    Subclass of AvdModel.

                    Args:
                        rate:
                           Rate in kbps, pps or percent.
                           Supported options are platform dependent.
                           Examples:  # fmt: skip
                           - "5000 kbps"
                           -
                           "1000 pps"
                           - "20 percent"

                    """

        class Qos(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"trust": {"type": str}, "dscp": {"type": int}, "cos": {"type": int}}
            trust: Literal["dscp", "cos", "disabled"] | None
            dscp: int | None
            """DSCP value."""
            cos: int | None
            """COS value."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    trust: Literal["dscp", "cos", "disabled"] | None | UndefinedType = Undefined,
                    dscp: int | None | UndefinedType = Undefined,
                    cos: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Qos.


                    Subclass of AvdModel.

                    Args:
                        trust: trust
                        dscp: DSCP value.
                        cos: COS value.

                    """

        class SpanningTreeBpduguardRateLimit(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "count": {"type": int}, "interval": {"type": int}}
            enabled: bool | None
            """Enable/Disable rate limiter on this port."""
            count: int | None
            """Max number of BPDUs per timer interval."""
            interval: int | None
            """Number of seconds in the BPDU input rate limiter timer."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    count: int | None | UndefinedType = Undefined,
                    interval: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SpanningTreeBpduguardRateLimit.


                    Subclass of AvdModel.

                    Args:
                        enabled: Enable/Disable rate limiter on this port.
                        count: Max number of BPDUs per timer interval.
                        interval: Number of seconds in the BPDU input rate limiter timer.

                    """

        class PriorityFlowControl(AvdModel):
            """Subclass of AvdModel."""

            class PrioritiesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"priority": {"type": int}, "no_drop": {"type": bool}}
                priority: int
                no_drop: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, priority: int | UndefinedType = Undefined, no_drop: bool | None | UndefinedType = Undefined) -> None:
                        """
                        PrioritiesItem.


                        Subclass of AvdModel.

                        Args:
                            priority: priority
                            no_drop: no_drop

                        """

            class Priorities(AvdIndexedList[int, PrioritiesItem]):
                """Subclass of AvdIndexedList with `PrioritiesItem` items. Primary key is `priority` (`int`)."""

                _primary_key: ClassVar[str] = "priority"

            Priorities._item_type = PrioritiesItem

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "priorities": {"type": Priorities}}
            enabled: bool | None
            priorities: Priorities
            """Subclass of AvdIndexedList with `PrioritiesItem` items. Primary key is `priority` (`int`)."""

            if TYPE_CHECKING:

                def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, priorities: Priorities | UndefinedType = Undefined) -> None:
                    """
                    PriorityFlowControl.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        priorities: Subclass of AvdIndexedList with `PrioritiesItem` items. Primary key is `priority` (`int`).

                    """

        class Bfd(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"echo": {"type": bool}, "interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}}
            echo: bool | None
            interval: int | None
            """Interval in milliseconds."""
            min_rx: int | None
            """Rate in milliseconds."""
            multiplier: int | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    echo: bool | None | UndefinedType = Undefined,
                    interval: int | None | UndefinedType = Undefined,
                    min_rx: int | None | UndefinedType = Undefined,
                    multiplier: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bfd.


                    Subclass of AvdModel.

                    Args:
                        echo: echo
                        interval: Interval in milliseconds.
                        min_rx: Rate in milliseconds.
                        multiplier: multiplier

                    """

        class ServicePolicy(AvdModel):
            """Subclass of AvdModel."""

            class Pbr(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"input": {"type": str}}
                input: str | None
                """Policy Based Routing Policy-map name."""

                if TYPE_CHECKING:

                    def __init__(self, *, input: str | None | UndefinedType = Undefined) -> None:
                        """
                        Pbr.


                        Subclass of AvdModel.

                        Args:
                            input: Policy Based Routing Policy-map name.

                        """

            class Qos(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"input": {"type": str}}
                input: str
                """Quality of Service Policy-map name."""

                if TYPE_CHECKING:

                    def __init__(self, *, input: str | UndefinedType = Undefined) -> None:
                        """
                        Qos.


                        Subclass of AvdModel.

                        Args:
                            input: Quality of Service Policy-map name.

                        """

            _fields: ClassVar[dict] = {"pbr": {"type": Pbr}, "qos": {"type": Qos}}
            pbr: Pbr
            """Subclass of AvdModel."""
            qos: Qos
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, pbr: Pbr | UndefinedType = Undefined, qos: Qos | UndefinedType = Undefined) -> None:
                    """
                    ServicePolicy.


                    Subclass of AvdModel.

                    Args:
                        pbr: Subclass of AvdModel.
                        qos: Subclass of AvdModel.

                    """

        class Mpls(AvdModel):
            """Subclass of AvdModel."""

            class Ldp(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interface": {"type": bool}, "igp_sync": {"type": bool}}
                interface: bool | None
                igp_sync: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, interface: bool | None | UndefinedType = Undefined, igp_sync: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Ldp.


                        Subclass of AvdModel.

                        Args:
                            interface: interface
                            igp_sync: igp_sync

                        """

            _fields: ClassVar[dict] = {"ip": {"type": bool}, "ldp": {"type": Ldp}}
            ip: bool | None
            ldp: Ldp
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, ip: bool | None | UndefinedType = Undefined, ldp: Ldp | UndefinedType = Undefined) -> None:
                    """
                    Mpls.


                    Subclass of AvdModel.

                    Args:
                        ip: ip
                        ldp: Subclass of AvdModel.

                    """

        class LacpTimer(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"mode": {"type": str}, "multiplier": {"type": int}}
            mode: Literal["fast", "normal"] | None
            multiplier: int | None

            if TYPE_CHECKING:

                def __init__(
                    self, *, mode: Literal["fast", "normal"] | None | UndefinedType = Undefined, multiplier: int | None | UndefinedType = Undefined
                ) -> None:
                    """
                    LacpTimer.


                    Subclass of AvdModel.

                    Args:
                        mode: mode
                        multiplier: multiplier

                    """

        class Transceiver(AvdModel):
            """Subclass of AvdModel."""

            class Media(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"override": {"type": str}}
                override: str | None
                """Transceiver type."""

                if TYPE_CHECKING:

                    def __init__(self, *, override: str | None | UndefinedType = Undefined) -> None:
                        """
                        Media.


                        Subclass of AvdModel.

                        Args:
                            override: Transceiver type.

                        """

            class ApplicationOverrideLanesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"override": {"type": int}, "first_lane": {"type": int}, "last_lane": {"type": int}}
                override: int
                first_lane: int
                """Set the start value of host lanes for which overrides should be applied."""
                last_lane: int | None
                """Set the last value of host lanes for which overrides should be applied."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        override: int | UndefinedType = Undefined,
                        first_lane: int | UndefinedType = Undefined,
                        last_lane: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ApplicationOverrideLanesItem.


                        Subclass of AvdModel.

                        Args:
                            override: override
                            first_lane: Set the start value of host lanes for which overrides should be applied.
                            last_lane: Set the last value of host lanes for which overrides should be applied.

                        """

            class ApplicationOverrideLanes(AvdList[ApplicationOverrideLanesItem]):
                """Subclass of AvdList with `ApplicationOverrideLanesItem` items."""

            ApplicationOverrideLanes._item_type = ApplicationOverrideLanesItem

            _fields: ClassVar[dict] = {
                "frequency": {"type": str},
                "frequency_unit": {"type": str},
                "media": {"type": Media},
                "application_override": {"type": str},
                "application_override_lanes": {"type": ApplicationOverrideLanes},
            }
            frequency: str | None
            """Transceiver Laser Frequency in GHz (min 190000, max 200000)."""
            frequency_unit: Literal["ghz"] | None
            """Unit of Transceiver Laser Frequency."""
            media: Media
            """Subclass of AvdModel."""
            application_override: Literal["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "100gbase-srbd"] | None
            """
            Set CMIS transceiver application.
            '100gbase-srbd' should not be used in conjunction with
            `application_override_lanes`.
            """
            application_override_lanes: ApplicationOverrideLanes
            """
            Set CMIS transceiver applications with lanes. The ranges of `lanes` should not overlap.

            Subclass of
            AvdList with `ApplicationOverrideLanesItem` items.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    frequency: str | None | UndefinedType = Undefined,
                    frequency_unit: Literal["ghz"] | None | UndefinedType = Undefined,
                    media: Media | UndefinedType = Undefined,
                    application_override: Literal["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "100gbase-srbd"]
                    | None
                    | UndefinedType = Undefined,
                    application_override_lanes: ApplicationOverrideLanes | UndefinedType = Undefined,
                ) -> None:
                    """
                    Transceiver.


                    Subclass of AvdModel.

                    Args:
                        frequency: Transceiver Laser Frequency in GHz (min 190000, max 200000).
                        frequency_unit: Unit of Transceiver Laser Frequency.
                        media: Subclass of AvdModel.
                        application_override:
                           Set CMIS transceiver application.
                           '100gbase-srbd' should not be used in conjunction with
                           `application_override_lanes`.
                        application_override_lanes:
                           Set CMIS transceiver applications with lanes. The ranges of `lanes` should not overlap.

                           Subclass of
                           AvdList with `ApplicationOverrideLanesItem` items.

                    """

        class TrafficPolicy(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"input": {"type": str}, "output": {"type": str}}
            input: str | None
            """Ingress traffic policy."""
            output: str | None
            """Egress traffic policy."""

            if TYPE_CHECKING:

                def __init__(self, *, input: str | None | UndefinedType = Undefined, output: str | None | UndefinedType = Undefined) -> None:
                    """
                    TrafficPolicy.


                    Subclass of AvdModel.

                    Args:
                        input: Ingress traffic policy.
                        output: Egress traffic policy.

                    """

        class Bgp(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"session_tracker": {"type": str}}
            session_tracker: str | None
            """Name of session tracker."""

            if TYPE_CHECKING:

                def __init__(self, *, session_tracker: str | None | UndefinedType = Undefined) -> None:
                    """
                    Bgp.


                    Subclass of AvdModel.

                    Args:
                        session_tracker: Name of session tracker.

                    """

        class IpIgmpHostProxy(AvdModel):
            """Subclass of AvdModel."""

            class GroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class ExcludeItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}}
                    source: str

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | UndefinedType = Undefined) -> None:
                            """
                            ExcludeItem.


                            Subclass of AvdModel.

                            Args:
                                source: source

                            """

                class Exclude(AvdIndexedList[str, ExcludeItem]):
                    """Subclass of AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`)."""

                    _primary_key: ClassVar[str] = "source"

                Exclude._item_type = ExcludeItem

                class IncludeItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}}
                    source: str

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | UndefinedType = Undefined) -> None:
                            """
                            IncludeItem.


                            Subclass of AvdModel.

                            Args:
                                source: source

                            """

                class Include(AvdIndexedList[str, IncludeItem]):
                    """Subclass of AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`)."""

                    _primary_key: ClassVar[str] = "source"

                Include._item_type = IncludeItem

                _fields: ClassVar[dict] = {"group": {"type": str}, "exclude": {"type": Exclude}, "include": {"type": Include}}
                group: str
                """Multicast Address."""
                exclude: Exclude
                """
                The same source must not be present both in `exclude` and `include` list.

                Subclass of
                AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`).
                """
                include: Include
                """
                The same source must not be present both in `exclude` and `include` list.

                Subclass of
                AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`).
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        group: str | UndefinedType = Undefined,
                        exclude: Exclude | UndefinedType = Undefined,
                        include: Include | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GroupsItem.


                        Subclass of AvdModel.

                        Args:
                            group: Multicast Address.
                            exclude:
                               The same source must not be present both in `exclude` and `include` list.

                               Subclass of
                               AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`).
                            include:
                               The same source must not be present both in `exclude` and `include` list.

                               Subclass of
                               AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`).

                        """

            class Groups(AvdIndexedList[str, GroupsItem]):
                """Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`)."""

                _primary_key: ClassVar[str] = "group"

            Groups._item_type = GroupsItem

            class AccessListsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}}
                name: str

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined) -> None:
                        """
                        AccessListsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name

                        """

            class AccessLists(AvdIndexedList[str, AccessListsItem]):
                """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            AccessLists._item_type = AccessListsItem

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "groups": {"type": Groups},
                "report_interval": {"type": int},
                "access_lists": {"type": AccessLists},
                "version": {"type": int},
            }
            enabled: bool | None
            groups: Groups
            """Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`)."""
            report_interval: int | None
            """Time interval between unsolicited reports."""
            access_lists: AccessLists
            """
            Non-standard Access List name.

            Subclass of AvdIndexedList with `AccessListsItem` items. Primary key
            is `name` (`str`).
            """
            version: int | None
            """IGMP version on IGMP host-proxy interface."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    groups: Groups | UndefinedType = Undefined,
                    report_interval: int | None | UndefinedType = Undefined,
                    access_lists: AccessLists | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpIgmpHostProxy.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        groups: Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`).
                        report_interval: Time interval between unsolicited reports.
                        access_lists:
                           Non-standard Access List name.

                           Subclass of AvdIndexedList with `AccessListsItem` items. Primary key
                           is `name` (`str`).
                        version: IGMP version on IGMP host-proxy interface.

                    """

        class Sflow(AvdModel):
            """Subclass of AvdModel."""

            class Egress(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enable": {"type": bool}, "unmodified_enable": {"type": bool}}
                enable: bool | None
                unmodified_enable: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, enable: bool | None | UndefinedType = Undefined, unmodified_enable: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Egress.


                        Subclass of AvdModel.

                        Args:
                            enable: enable
                            unmodified_enable: unmodified_enable

                        """

            _fields: ClassVar[dict] = {"enable": {"type": bool}, "egress": {"type": Egress}}
            enable: bool | None
            egress: Egress
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, enable: bool | None | UndefinedType = Undefined, egress: Egress | UndefinedType = Undefined) -> None:
                    """
                    Sflow.


                    Subclass of AvdModel.

                    Args:
                        enable: enable
                        egress: Subclass of AvdModel.

                    """

        class SyncE(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enable": {"type": bool}, "priority": {"type": str}}
            enable: bool | None
            priority: str | None
            """
            The priority is used to influence the reference clock selection. The EOS default priority is 127.
            The priority can be configured to any integer between 1-255, or set to `disabled`.
            """

            if TYPE_CHECKING:

                def __init__(self, *, enable: bool | None | UndefinedType = Undefined, priority: str | None | UndefinedType = Undefined) -> None:
                    """
                    SyncE.


                    Subclass of AvdModel.

                    Args:
                        enable: enable
                        priority:
                           The priority is used to influence the reference clock selection. The EOS default priority is 127.
                           The priority can be configured to any integer between 1-255, or set to `disabled`.

                    """

        class UcTxQueuesItem(AvdModel):
            """Subclass of AvdModel."""

            class RandomDetect(AvdModel):
                """Subclass of AvdModel."""

                class Ecn(AvdModel):
                    """Subclass of AvdModel."""

                    class Threshold(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "units": {"type": str},
                            "min": {"type": int},
                            "max": {"type": int},
                            "max_probability": {"type": int},
                            "weight": {"type": int},
                        }
                        units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"]
                        """Indicate the units to be used for the threshold values."""
                        min: int
                        """Set the random-detect ECN minimum-threshold."""
                        max: int
                        """Set the random-detect ECN maximum-threshold."""
                        max_probability: int | None
                        """Set the random-detect ECN max-mark-probability."""
                        weight: int | None
                        """Set the random-detect ECN weight."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"] | UndefinedType = Undefined,
                                min: int | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                max_probability: int | None | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Threshold.


                                Subclass of AvdModel.

                                Args:
                                    units: Indicate the units to be used for the threshold values.
                                    min: Set the random-detect ECN minimum-threshold.
                                    max: Set the random-detect ECN maximum-threshold.
                                    max_probability: Set the random-detect ECN max-mark-probability.
                                    weight: Set the random-detect ECN weight.

                                """

                    _fields: ClassVar[dict] = {"count": {"type": bool}, "threshold": {"type": Threshold}}
                    count: bool | None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, count: bool | None | UndefinedType = Undefined, threshold: Threshold | UndefinedType = Undefined) -> None:
                            """
                            Ecn.


                            Subclass of AvdModel.

                            Args:
                                count: Enable counter for random-detect ECNs.
                                threshold: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {"ecn": {"type": Ecn}}
                ecn: Ecn
                """
                Explicit Congestion Notification.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, ecn: Ecn | UndefinedType = Undefined) -> None:
                        """
                        RandomDetect.


                        Subclass of AvdModel.

                        Args:
                            ecn:
                               Explicit Congestion Notification.

                               Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"id": {"type": int}, "random_detect": {"type": RandomDetect}}
            id: int
            """TX-Queue ID."""
            random_detect: RandomDetect
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, id: int | UndefinedType = Undefined, random_detect: RandomDetect | UndefinedType = Undefined) -> None:
                    """
                    UcTxQueuesItem.


                    Subclass of AvdModel.

                    Args:
                        id: TX-Queue ID.
                        random_detect: Subclass of AvdModel.

                    """

        class UcTxQueues(AvdIndexedList[int, UcTxQueuesItem]):
            """Subclass of AvdIndexedList with `UcTxQueuesItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        UcTxQueues._item_type = UcTxQueuesItem

        class TxQueuesItem(AvdModel):
            """Subclass of AvdModel."""

            class RandomDetect(AvdModel):
                """Subclass of AvdModel."""

                class Ecn(AvdModel):
                    """Subclass of AvdModel."""

                    class Threshold(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "units": {"type": str},
                            "min": {"type": int},
                            "max": {"type": int},
                            "max_probability": {"type": int},
                            "weight": {"type": int},
                        }
                        units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"]
                        """Indicate the units to be used for the threshold values."""
                        min: int | None
                        """Set the random-detect ECN minimum-threshold."""
                        max: int
                        """Set the random-detect ECN maximum-threshold."""
                        max_probability: int
                        """Set the random-detect ECN max-mark-probability."""
                        weight: int | None
                        """Set the random-detect ECN weight."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"] | UndefinedType = Undefined,
                                min: int | None | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                max_probability: int | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Threshold.


                                Subclass of AvdModel.

                                Args:
                                    units: Indicate the units to be used for the threshold values.
                                    min: Set the random-detect ECN minimum-threshold.
                                    max: Set the random-detect ECN maximum-threshold.
                                    max_probability: Set the random-detect ECN max-mark-probability.
                                    weight: Set the random-detect ECN weight.

                                """

                    _fields: ClassVar[dict] = {"count": {"type": bool}, "threshold": {"type": Threshold}}
                    count: bool | None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, count: bool | None | UndefinedType = Undefined, threshold: Threshold | UndefinedType = Undefined) -> None:
                            """
                            Ecn.


                            Subclass of AvdModel.

                            Args:
                                count: Enable counter for random-detect ECNs.
                                threshold: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {"ecn": {"type": Ecn}}
                ecn: Ecn
                """
                Explicit Congestion Notification.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, ecn: Ecn | UndefinedType = Undefined) -> None:
                        """
                        RandomDetect.


                        Subclass of AvdModel.

                        Args:
                            ecn:
                               Explicit Congestion Notification.

                               Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"id": {"type": int}, "scheduler_profile_responsive": {"type": bool}, "random_detect": {"type": RandomDetect}}
            id: int
            """TX-Queue ID."""
            scheduler_profile_responsive: bool | None
            """Set scheduler profile to optimize latency at the expense of burstiness."""
            random_detect: RandomDetect
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    scheduler_profile_responsive: bool | None | UndefinedType = Undefined,
                    random_detect: RandomDetect | UndefinedType = Undefined,
                ) -> None:
                    """
                    TxQueuesItem.


                    Subclass of AvdModel.

                    Args:
                        id: TX-Queue ID.
                        scheduler_profile_responsive: Set scheduler profile to optimize latency at the expense of burstiness.
                        random_detect: Subclass of AvdModel.

                    """

        class TxQueues(AvdIndexedList[int, TxQueuesItem]):
            """Subclass of AvdIndexedList with `TxQueuesItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        TxQueues._item_type = TxQueuesItem

        class VrrpIdsItem(AvdModel):
            """Subclass of AvdModel."""

            class Advertisement(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}}
                interval: int | None
                """Interval in seconds."""

                if TYPE_CHECKING:

                    def __init__(self, *, interval: int | None | UndefinedType = Undefined) -> None:
                        """
                        Advertisement.


                        Subclass of AvdModel.

                        Args:
                            interval: Interval in seconds.

                        """

            class Preempt(AvdModel):
                """Subclass of AvdModel."""

                class Delay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"minimum": {"type": int}, "reload": {"type": int}}
                    minimum: int | None
                    """Minimum preempt delay in seconds."""
                    reload: int | None
                    """Reload preempt delay in seconds."""

                    if TYPE_CHECKING:

                        def __init__(self, *, minimum: int | None | UndefinedType = Undefined, reload: int | None | UndefinedType = Undefined) -> None:
                            """
                            Delay.


                            Subclass of AvdModel.

                            Args:
                                minimum: Minimum preempt delay in seconds.
                                reload: Reload preempt delay in seconds.

                            """

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "delay": {"type": Delay}}
                enabled: bool
                delay: Delay
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | UndefinedType = Undefined, delay: Delay | UndefinedType = Undefined) -> None:
                        """
                        Preempt.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            delay: Subclass of AvdModel.

                        """

            class Timers(AvdModel):
                """Subclass of AvdModel."""

                class Delay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"reload": {"type": int}}
                    reload: int | None
                    """Delay after reload in seconds."""

                    if TYPE_CHECKING:

                        def __init__(self, *, reload: int | None | UndefinedType = Undefined) -> None:
                            """
                            Delay.


                            Subclass of AvdModel.

                            Args:
                                reload: Delay after reload in seconds.

                            """

                _fields: ClassVar[dict] = {"delay": {"type": Delay}}
                delay: Delay
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, delay: Delay | UndefinedType = Undefined) -> None:
                        """
                        Timers.


                        Subclass of AvdModel.

                        Args:
                            delay: Subclass of AvdModel.

                        """

            class TrackedObjectItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "decrement": {"type": int}, "shutdown": {"type": bool}}
                name: str
                """Tracked object name."""
                decrement: int | None
                """Decrement VRRP priority by 1-254."""
                shutdown: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        decrement: int | None | UndefinedType = Undefined,
                        shutdown: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrackedObjectItem.


                        Subclass of AvdModel.

                        Args:
                            name: Tracked object name.
                            decrement: Decrement VRRP priority by 1-254.
                            shutdown: shutdown

                        """

            class TrackedObject(AvdIndexedList[str, TrackedObjectItem]):
                """Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            TrackedObject._item_type = TrackedObjectItem

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class SecondaryAddresses(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                SecondaryAddresses._item_type = str

                _fields: ClassVar[dict] = {"address": {"type": str}, "secondary_addresses": {"type": SecondaryAddresses}, "version": {"type": int}}
                address: str
                """Virtual IPv4 address."""
                secondary_addresses: SecondaryAddresses
                """
                Additional VRRP IPv4 addresses.

                Subclass of AvdList with `str` items.
                """
                version: Literal[2, 3] | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        address: str | UndefinedType = Undefined,
                        secondary_addresses: SecondaryAddresses | UndefinedType = Undefined,
                        version: Literal[2, 3] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            address: Virtual IPv4 address.
                            secondary_addresses:
                               Additional VRRP IPv4 addresses.

                               Subclass of AvdList with `str` items.
                            version: version

                        """

            class Ipv6(AvdModel):
                """Subclass of AvdModel."""

                class Addresses(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Addresses._item_type = str

                _fields: ClassVar[dict] = {"address": {"type": str}, "addresses": {"type": Addresses}}
                address: str | None
                """Virtual IPv6 address."""
                addresses: Addresses
                """
                Virtual IPv6 addresses.

                Subclass of AvdList with `str` items.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, address: str | None | UndefinedType = Undefined, addresses: Addresses | UndefinedType = Undefined) -> None:
                        """
                        Ipv6.


                        Subclass of AvdModel.

                        Args:
                            address: Virtual IPv6 address.
                            addresses:
                               Virtual IPv6 addresses.

                               Subclass of AvdList with `str` items.

                        """

            class PeerAuthentication(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"mode": {"type": str}, "key": {"type": str}, "key_type": {"type": str}}
                mode: Literal["text", "ietf-md5"]
                """Authentication mode."""
                key: str
                """Authentication key."""
                key_type: Literal["0", "7", "8a"] | None
                """Authentication key type."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mode: Literal["text", "ietf-md5"] | UndefinedType = Undefined,
                        key: str | UndefinedType = Undefined,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerAuthentication.


                        Subclass of AvdModel.

                        Args:
                            mode: Authentication mode.
                            key: Authentication key.
                            key_type: Authentication key type.

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "priority_level": {"type": int},
                "advertisement": {"type": Advertisement},
                "preempt": {"type": Preempt},
                "timers": {"type": Timers},
                "tracked_object": {"type": TrackedObject},
                "ipv4": {"type": Ipv4},
                "ipv6": {"type": Ipv6},
                "peer_authentication": {"type": PeerAuthentication},
            }
            id: int
            """VRID."""
            priority_level: int | None
            """Instance priority."""
            advertisement: Advertisement
            """Subclass of AvdModel."""
            preempt: Preempt
            """Subclass of AvdModel."""
            timers: Timers
            """Subclass of AvdModel."""
            tracked_object: TrackedObject
            """Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`)."""
            ipv4: Ipv4
            """Subclass of AvdModel."""
            ipv6: Ipv6
            """Subclass of AvdModel."""
            peer_authentication: PeerAuthentication
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    priority_level: int | None | UndefinedType = Undefined,
                    advertisement: Advertisement | UndefinedType = Undefined,
                    preempt: Preempt | UndefinedType = Undefined,
                    timers: Timers | UndefinedType = Undefined,
                    tracked_object: TrackedObject | UndefinedType = Undefined,
                    ipv4: Ipv4 | UndefinedType = Undefined,
                    ipv6: Ipv6 | UndefinedType = Undefined,
                    peer_authentication: PeerAuthentication | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrrpIdsItem.


                    Subclass of AvdModel.

                    Args:
                        id: VRID.
                        priority_level: Instance priority.
                        advertisement: Subclass of AvdModel.
                        preempt: Subclass of AvdModel.
                        timers: Subclass of AvdModel.
                        tracked_object: Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`).
                        ipv4: Subclass of AvdModel.
                        ipv6: Subclass of AvdModel.
                        peer_authentication: Subclass of AvdModel.

                    """

        class VrrpIds(AvdIndexedList[int, VrrpIdsItem]):
            """Subclass of AvdIndexedList with `VrrpIdsItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        VrrpIds._item_type = VrrpIdsItem

        class Switchport(AvdModel):
            """Subclass of AvdModel."""

            class Trunk(AvdModel):
                """Subclass of AvdModel."""

                class Groups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Groups._item_type = str

                _fields: ClassVar[dict] = {
                    "allowed_vlan": {"type": str},
                    "native_vlan": {"type": int},
                    "native_vlan_tag": {"type": bool},
                    "private_vlan_secondary": {"type": bool},
                    "groups": {"type": Groups},
                }
                allowed_vlan: str | None
                """
                VLAN ID or range(s) of VLAN IDs.
                Warning: This should not be combined with
                `ethernet_interfaces[].mode = trunk` and `ethernet_interface[].vlans`.
                """
                native_vlan: int | None
                """
                Set native VLAN when interface is in trunking mode.
                Warning: This should not be combined with
                `ethernet_interfaces[].native_vlan`.
                """
                native_vlan_tag: bool | None
                """
                If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                Warning: This
                should not be combined with `ethernet_interfaces[].native_vlan_tag`.
                """
                private_vlan_secondary: bool | None
                """
                Enable secondary VLAN mapping for a private vlan.
                Warning: This should not be combined with
                `ethernet_ineterfaces[].trunk_private_vlan_secondary`.
                """
                groups: Groups
                """
                Warning: This should not be combined with `ethernet_ineterfaces[].trunk_groups`.


                Subclass of
                AvdList with `str` items.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        allowed_vlan: str | None | UndefinedType = Undefined,
                        native_vlan: int | None | UndefinedType = Undefined,
                        native_vlan_tag: bool | None | UndefinedType = Undefined,
                        private_vlan_secondary: bool | None | UndefinedType = Undefined,
                        groups: Groups | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Trunk.


                        Subclass of AvdModel.

                        Args:
                            allowed_vlan:
                               VLAN ID or range(s) of VLAN IDs.
                               Warning: This should not be combined with
                               `ethernet_interfaces[].mode = trunk` and `ethernet_interface[].vlans`.
                            native_vlan:
                               Set native VLAN when interface is in trunking mode.
                               Warning: This should not be combined with
                               `ethernet_interfaces[].native_vlan`.
                            native_vlan_tag:
                               If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                               Warning: This
                               should not be combined with `ethernet_interfaces[].native_vlan_tag`.
                            private_vlan_secondary:
                               Enable secondary VLAN mapping for a private vlan.
                               Warning: This should not be combined with
                               `ethernet_ineterfaces[].trunk_private_vlan_secondary`.
                            groups:
                               Warning: This should not be combined with `ethernet_ineterfaces[].trunk_groups`.


                               Subclass of
                               AvdList with `str` items.

                        """

            class Phone(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"vlan": {"type": int}, "trunk": {"type": str}}
                vlan: int | None
                """Warning: This should not be combined with `ethernet_interfaces[].phone.vlan`."""
                trunk: Literal["tagged", "tagged phone", "untagged", "untagged phone"] | None
                """Warning: This should not be combined with `ethernet_interfaces[].phone.trunk`."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        vlan: int | None | UndefinedType = Undefined,
                        trunk: Literal["tagged", "tagged phone", "untagged", "untagged phone"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Phone.


                        Subclass of AvdModel.

                        Args:
                            vlan: Warning: This should not be combined with `ethernet_interfaces[].phone.vlan`.
                            trunk: Warning: This should not be combined with `ethernet_interfaces[].phone.trunk`.

                        """

            class Dot1q(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ethertype": {"type": int}, "vlan_tag": {"type": str}}
                ethertype: int | None
                """Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames."""
                vlan_tag: Literal["disallowed", "required"] | None
                """Allow/disallow VLAN tagged frames."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ethertype: int | None | UndefinedType = Undefined,
                        vlan_tag: Literal["disallowed", "required"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dot1q.


                        Subclass of AvdModel.

                        Args:
                            ethertype: Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames.
                            vlan_tag: Allow/disallow VLAN tagged frames.

                        """

            class VlanTranslations(AvdModel):
                """Subclass of AvdModel."""

                class DirectionInItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "field_from": {"type": str},
                        "to": {"type": int},
                        "dot1q_tunnel": {"type": bool},
                        "inner_vlan_from": {"type": int},
                    }
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None
                    inner_vlan_from: int | None
                    """Inner VLAN ID to map from."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | UndefinedType = Undefined,
                            to: int | UndefinedType = Undefined,
                            dot1q_tunnel: bool | None | UndefinedType = Undefined,
                            inner_vlan_from: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionInItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                                to: VLAN ID to map to.
                                dot1q_tunnel: dot1q_tunnel
                                inner_vlan_from: Inner VLAN ID to map from.

                            """

                class DirectionIn(AvdList[DirectionInItem]):
                    """Subclass of AvdList with `DirectionInItem` items."""

                DirectionIn._item_type = DirectionInItem

                class DirectionOutItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "field_from": {"type": str},
                        "to": {"type": int},
                        "dot1q_tunnel_to": {"type": str},
                        "inner_vlan_to": {"type": int},
                    }
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int | None
                    """VLAN ID to map to."""
                    dot1q_tunnel_to: str | None
                    """
                    VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                    This takes precedence over `to` and
                    `inner_vlan_to`.
                    """
                    inner_vlan_to: int | None
                    """Inner VLAN ID to map to."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | UndefinedType = Undefined,
                            to: int | None | UndefinedType = Undefined,
                            dot1q_tunnel_to: str | None | UndefinedType = Undefined,
                            inner_vlan_to: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionOutItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                                to: VLAN ID to map to.
                                dot1q_tunnel_to:
                                   VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                                   This takes precedence over `to` and
                                   `inner_vlan_to`.
                                inner_vlan_to: Inner VLAN ID to map to.

                            """

                class DirectionOut(AvdList[DirectionOutItem]):
                    """Subclass of AvdList with `DirectionOutItem` items."""

                DirectionOut._item_type = DirectionOutItem

                class DirectionBothItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "field_from": {"type": str},
                        "to": {"type": int},
                        "dot1q_tunnel": {"type": bool},
                        "inner_vlan_from": {"type": int},
                        "network": {"type": bool},
                    }
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None
                    inner_vlan_from: int | None
                    """Inner VLAN ID to map from."""
                    network: bool | None
                    """
                    Enable use of network-side VLAN ID.
                    This setting can only be enabled when `inner_vlan_from` is
                    defined.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | UndefinedType = Undefined,
                            to: int | UndefinedType = Undefined,
                            dot1q_tunnel: bool | None | UndefinedType = Undefined,
                            inner_vlan_from: int | None | UndefinedType = Undefined,
                            network: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionBothItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                                to: VLAN ID to map to.
                                dot1q_tunnel: dot1q_tunnel
                                inner_vlan_from: Inner VLAN ID to map from.
                                network:
                                   Enable use of network-side VLAN ID.
                                   This setting can only be enabled when `inner_vlan_from` is
                                   defined.

                            """

                class DirectionBoth(AvdList[DirectionBothItem]):
                    """Subclass of AvdList with `DirectionBothItem` items."""

                DirectionBoth._item_type = DirectionBothItem

                _fields: ClassVar[dict] = {
                    "in_required": {"type": bool},
                    "out_required": {"type": bool},
                    "direction_in": {"type": DirectionIn},
                    "direction_out": {"type": DirectionOut},
                    "direction_both": {"type": DirectionBoth},
                }
                in_required: bool | None
                """Drop the ingress traffic that do not match any VLAN mapping."""
                out_required: bool | None
                """Drop the egress traffic that do not match any VLAN mapping."""
                direction_in: DirectionIn
                """
                Map ingress traffic only.

                Subclass of AvdList with `DirectionInItem` items.
                """
                direction_out: DirectionOut
                """
                Map egress traffic only.

                Subclass of AvdList with `DirectionOutItem` items.
                """
                direction_both: DirectionBoth
                """
                Map both egress and ingress traffic.

                Subclass of AvdList with `DirectionBothItem` items.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        in_required: bool | None | UndefinedType = Undefined,
                        out_required: bool | None | UndefinedType = Undefined,
                        direction_in: DirectionIn | UndefinedType = Undefined,
                        direction_out: DirectionOut | UndefinedType = Undefined,
                        direction_both: DirectionBoth | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VlanTranslations.


                        Subclass of AvdModel.

                        Args:
                            in_required: Drop the ingress traffic that do not match any VLAN mapping.
                            out_required: Drop the egress traffic that do not match any VLAN mapping.
                            direction_in:
                               Map ingress traffic only.

                               Subclass of AvdList with `DirectionInItem` items.
                            direction_out:
                               Map egress traffic only.

                               Subclass of AvdList with `DirectionOutItem` items.
                            direction_both:
                               Map both egress and ingress traffic.

                               Subclass of AvdList with `DirectionBothItem` items.

                        """

            class BackupLink(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interface": {"type": str}, "prefer_vlan": {"type": str}}
                interface: str | None
                """Backup interface. Example - Ethernet4, Vlan10 etc."""
                prefer_vlan: str | None
                """VLANs to carry on the backup interface (1-4094)."""

                if TYPE_CHECKING:

                    def __init__(self, *, interface: str | None | UndefinedType = Undefined, prefer_vlan: str | None | UndefinedType = Undefined) -> None:
                        """
                        BackupLink.


                        Subclass of AvdModel.

                        Args:
                            interface: Backup interface. Example - Ethernet4, Vlan10 etc.
                            prefer_vlan: VLANs to carry on the backup interface (1-4094).

                        """

            class Backup(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "dest_macaddr": {"type": str},
                    "initial_mac_move_delay": {"type": int},
                    "mac_move_burst": {"type": int},
                    "mac_move_burst_interval": {"type": int},
                    "preemption_delay": {"type": int},
                }
                dest_macaddr: str | None
                """
                Destination MAC address for MAC move updates.
                The mac address should be multicast or broadcast.
                Example: 01:00:00:00:00:00
                """
                initial_mac_move_delay: int | None
                """Initial MAC move delay in milliseconds."""
                mac_move_burst: int | None
                """Size of MAC move bursts."""
                mac_move_burst_interval: int | None
                """MAC move burst interval in milliseconds."""
                preemption_delay: int | None
                """Preemption delay in milliseconds."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dest_macaddr: str | None | UndefinedType = Undefined,
                        initial_mac_move_delay: int | None | UndefinedType = Undefined,
                        mac_move_burst: int | None | UndefinedType = Undefined,
                        mac_move_burst_interval: int | None | UndefinedType = Undefined,
                        preemption_delay: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Backup.


                        Subclass of AvdModel.

                        Args:
                            dest_macaddr:
                               Destination MAC address for MAC move updates.
                               The mac address should be multicast or broadcast.
                               Example: 01:00:00:00:00:00
                            initial_mac_move_delay: Initial MAC move delay in milliseconds.
                            mac_move_burst: Size of MAC move bursts.
                            mac_move_burst_interval: MAC move burst interval in milliseconds.
                            preemption_delay: Preemption delay in milliseconds.

                        """

            class PortSecurity(AvdModel):
                """Subclass of AvdModel."""

                class MacAddressMaximum(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"disabled": {"type": bool}, "limit": {"type": int}}
                    disabled: bool | None
                    """Disable port level check for port security (only in violation 'shutdown' mode)."""
                    limit: int | None
                    """MAC address limit."""

                    if TYPE_CHECKING:

                        def __init__(self, *, disabled: bool | None | UndefinedType = Undefined, limit: int | None | UndefinedType = Undefined) -> None:
                            """
                            MacAddressMaximum.


                            Subclass of AvdModel.

                            Args:
                                disabled: Disable port level check for port security (only in violation 'shutdown' mode).
                                limit: MAC address limit.

                            """

                class Violation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"mode": {"type": str}, "protect_log": {"type": bool}}
                    mode: Literal["shutdown", "protect"] | None
                    """Configure port security mode."""
                    protect_log: bool | None
                    """Log new addresses seen after limit is reached in protect mode."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            mode: Literal["shutdown", "protect"] | None | UndefinedType = Undefined,
                            protect_log: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Violation.


                            Subclass of AvdModel.

                            Args:
                                mode: Configure port security mode.
                                protect_log: Log new addresses seen after limit is reached in protect mode.

                            """

                class VlansItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"range": {"type": str}, "mac_address_maximum": {"type": int}}
                    range: str
                    """
                    VLAN ID or range(s) of VLAN IDs, <1-4094>.
                    Example:
                      - 3
                      - 1,3
                      - 1-10
                    """
                    mac_address_maximum: int

                    if TYPE_CHECKING:

                        def __init__(self, *, range: str | UndefinedType = Undefined, mac_address_maximum: int | UndefinedType = Undefined) -> None:
                            """
                            VlansItem.


                            Subclass of AvdModel.

                            Args:
                                range:
                                   VLAN ID or range(s) of VLAN IDs, <1-4094>.
                                   Example:  # fmt: skip
                                     - 3
                                     - 1,3
                                     - 1-10
                                mac_address_maximum: mac_address_maximum

                            """

                class Vlans(AvdIndexedList[str, VlansItem]):
                    """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `range` (`str`)."""

                    _primary_key: ClassVar[str] = "range"

                Vlans._item_type = VlansItem

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "mac_address_maximum": {"type": MacAddressMaximum},
                    "violation": {"type": Violation},
                    "vlan_default_mac_address_maximum": {"type": int},
                    "vlans": {"type": Vlans},
                }
                enabled: bool | None
                mac_address_maximum: MacAddressMaximum
                """
                Maximum number of MAC addresses allowed on the interface.

                Subclass of AvdModel.
                """
                violation: Violation
                """
                Configure violation mode (shutdown or protect), EOS default is 'shutdown'.

                Subclass of AvdModel.
                """
                vlan_default_mac_address_maximum: int | None
                """Default maximum MAC addresses for all VLANs on this interface."""
                vlans: Vlans
                """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `range` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        mac_address_maximum: MacAddressMaximum | UndefinedType = Undefined,
                        violation: Violation | UndefinedType = Undefined,
                        vlan_default_mac_address_maximum: int | None | UndefinedType = Undefined,
                        vlans: Vlans | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PortSecurity.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            mac_address_maximum:
                               Maximum number of MAC addresses allowed on the interface.

                               Subclass of AvdModel.
                            violation:
                               Configure violation mode (shutdown or protect), EOS default is 'shutdown'.

                               Subclass of AvdModel.
                            vlan_default_mac_address_maximum: Default maximum MAC addresses for all VLANs on this interface.
                            vlans: Subclass of AvdIndexedList with `VlansItem` items. Primary key is `range` (`str`).

                        """

            class Tap(AvdModel):
                """Subclass of AvdModel."""

                class Default(AvdModel):
                    """Subclass of AvdModel."""

                    class Groups(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Groups._item_type = str

                    class Interfaces(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Interfaces._item_type = str

                    class NexthopGroups(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    NexthopGroups._item_type = str

                    _fields: ClassVar[dict] = {"groups": {"type": Groups}, "interfaces": {"type": Interfaces}, "nexthop_groups": {"type": NexthopGroups}}
                    groups: Groups
                    """
                    Tap group names for the interface.

                    Subclass of AvdList with `str` items.
                    """
                    interfaces: Interfaces
                    """
                    Interfaces like -  Ethernet1, InternalRecirc1, Port-Channel1, Recirc-Channel1.

                    Subclass of AvdList
                    with `str` items.
                    """
                    nexthop_groups: NexthopGroups
                    """
                    Default nexthop-group names.

                    Subclass of AvdList with `str` items.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            groups: Groups | UndefinedType = Undefined,
                            interfaces: Interfaces | UndefinedType = Undefined,
                            nexthop_groups: NexthopGroups | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Default.


                            Subclass of AvdModel.

                            Args:
                                groups:
                                   Tap group names for the interface.

                                   Subclass of AvdList with `str` items.
                                interfaces:
                                   Interfaces like -  Ethernet1, InternalRecirc1, Port-Channel1, Recirc-Channel1.

                                   Subclass of AvdList
                                   with `str` items.
                                nexthop_groups:
                                   Default nexthop-group names.

                                   Subclass of AvdList with `str` items.

                            """

                class Identity(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"id": {"type": int}, "inner_vlan": {"type": int}}
                    id: int | None
                    """Tap port VLAN ID (1-4094) or DzGRE extended ID (1-65535)."""
                    inner_vlan: int | None
                    """Tap port inner VLAN ID. Only applicable if `id` is a VLAN ID (1-4094)."""

                    if TYPE_CHECKING:

                        def __init__(self, *, id: int | None | UndefinedType = Undefined, inner_vlan: int | None | UndefinedType = Undefined) -> None:
                            """
                            Identity.


                            Subclass of AvdModel.

                            Args:
                                id: Tap port VLAN ID (1-4094) or DzGRE extended ID (1-65535).
                                inner_vlan: Tap port inner VLAN ID. Only applicable if `id` is a VLAN ID (1-4094).

                            """

                class Truncation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "size": {"type": int}}
                    enabled: bool | None
                    size: int | None
                    """Ingress packet truncation size in bytes."""

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, size: int | None | UndefinedType = Undefined) -> None:
                            """
                            Truncation.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                size: Ingress packet truncation size in bytes.

                            """

                class MacAddress(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}, "destination": {"type": str}}
                    source: str | None
                    """MAC address for the source."""
                    destination: str | None
                    """MAC address for the destination."""

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | None | UndefinedType = Undefined, destination: str | None | UndefinedType = Undefined) -> None:
                            """
                            MacAddress.


                            Subclass of AvdModel.

                            Args:
                                source: MAC address for the source.
                                destination: MAC address for the destination.

                            """

                class Encapsulation(AvdModel):
                    """Subclass of AvdModel."""

                    class Gre(AvdModel):
                        """Subclass of AvdModel."""

                        class ProtocolsItem(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "protocol": {"type": str},
                                "strip": {"type": bool},
                                "feature_header_length": {"type": int},
                                "re_encapsulation_ethernet_header": {"type": bool},
                            }
                            protocol: str
                            """
                            Protocol type in GRE header.
                            Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                            "0x0".
                            """
                            strip: bool | None
                            """This is a required key to strip GRE encapsulation header with protocols."""
                            feature_header_length: int | None
                            """
                            Feature header length in bytes.
                            Note: This setting does not appear in the EOS running-config for
                            protocol 0x0.
                            """
                            re_encapsulation_ethernet_header: bool | None
                            """
                            Extra ethernet header to prepend to the terminated packet.
                            Note: This setting does not appear in the
                            EOS running-config for protocol 0x0.
                            """

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    protocol: str | UndefinedType = Undefined,
                                    strip: bool | None | UndefinedType = Undefined,
                                    feature_header_length: int | None | UndefinedType = Undefined,
                                    re_encapsulation_ethernet_header: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    ProtocolsItem.


                                    Subclass of AvdModel.

                                    Args:
                                        protocol:
                                           Protocol type in GRE header.
                                           Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                                           "0x0".
                                        strip: This is a required key to strip GRE encapsulation header with protocols.
                                        feature_header_length:
                                           Feature header length in bytes.
                                           Note: This setting does not appear in the EOS running-config for
                                           protocol 0x0.
                                        re_encapsulation_ethernet_header:
                                           Extra ethernet header to prepend to the terminated packet.
                                           Note: This setting does not appear in the
                                           EOS running-config for protocol 0x0.

                                    """

                        class Protocols(AvdIndexedList[str, ProtocolsItem]):
                            """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                            _primary_key: ClassVar[str] = "protocol"

                        Protocols._item_type = ProtocolsItem

                        class DestinationsItem(AvdModel):
                            """Subclass of AvdModel."""

                            class ProtocolsItem(AvdModel):
                                """Subclass of AvdModel."""

                                _fields: ClassVar[dict] = {
                                    "protocol": {"type": str},
                                    "strip": {"type": bool},
                                    "feature_header_length": {"type": int},
                                    "re_encapsulation_ethernet_header": {"type": bool},
                                }
                                protocol: str
                                """
                                Protocol type in GRE header.
                                Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                                "0x0".
                                """
                                strip: bool | None
                                """This is a required key to strip GRE encapsulation header for specific destination with protocols."""
                                feature_header_length: int | None
                                """
                                Feature header length in bytes.
                                Note: This setting does not appear in the EOS running-config for
                                protocol 0x0.
                                """
                                re_encapsulation_ethernet_header: bool | None
                                """
                                Extra ethernet header to prepend to the terminated packet.
                                Note: This setting does not appear in the
                                EOS running-config for protocol 0x0.
                                """

                                if TYPE_CHECKING:

                                    def __init__(
                                        self,
                                        *,
                                        protocol: str | UndefinedType = Undefined,
                                        strip: bool | None | UndefinedType = Undefined,
                                        feature_header_length: int | None | UndefinedType = Undefined,
                                        re_encapsulation_ethernet_header: bool | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        ProtocolsItem.


                                        Subclass of AvdModel.

                                        Args:
                                            protocol:
                                               Protocol type in GRE header.
                                               Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                                               "0x0".
                                            strip: This is a required key to strip GRE encapsulation header for specific destination with protocols.
                                            feature_header_length:
                                               Feature header length in bytes.
                                               Note: This setting does not appear in the EOS running-config for
                                               protocol 0x0.
                                            re_encapsulation_ethernet_header:
                                               Extra ethernet header to prepend to the terminated packet.
                                               Note: This setting does not appear in the
                                               EOS running-config for protocol 0x0.

                                        """

                            class Protocols(AvdIndexedList[str, ProtocolsItem]):
                                """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                                _primary_key: ClassVar[str] = "protocol"

                            Protocols._item_type = ProtocolsItem

                            _fields: ClassVar[dict] = {
                                "destination": {"type": str},
                                "source": {"type": str},
                                "strip": {"type": bool},
                                "protocols": {"type": Protocols},
                            }
                            destination: str
                            """Destination IP address of tunnel packets."""
                            source: str | None
                            """
                            Source IP address of tunnel packets. Applied only when destination is defined. When not defined; any
                            GRE packet that matches the `destination` is terminated.
                            """
                            strip: bool | None
                            """Strip GRE encapsulation header for specific destination."""
                            protocols: Protocols
                            """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    destination: str | UndefinedType = Undefined,
                                    source: str | None | UndefinedType = Undefined,
                                    strip: bool | None | UndefinedType = Undefined,
                                    protocols: Protocols | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    DestinationsItem.


                                    Subclass of AvdModel.

                                    Args:
                                        destination: Destination IP address of tunnel packets.
                                        source:
                                           Source IP address of tunnel packets. Applied only when destination is defined. When not defined; any
                                           GRE packet that matches the `destination` is terminated.
                                        strip: Strip GRE encapsulation header for specific destination.
                                        protocols: Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`).

                                    """

                        class Destinations(AvdIndexedList[str, DestinationsItem]):
                            """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`)."""

                            _primary_key: ClassVar[str] = "destination"

                        Destinations._item_type = DestinationsItem

                        _fields: ClassVar[dict] = {"strip": {"type": bool}, "protocols": {"type": Protocols}, "destinations": {"type": Destinations}}
                        strip: bool | None
                        """Strip GRE encapsulation header for all GRE tunnels."""
                        protocols: Protocols
                        """
                        Protocols for all destinations; destination-specific protocols should be set under the
                        `destinations[].protocols` key.

                        Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key
                        is `protocol` (`str`).
                        """
                        destinations: Destinations
                        """
                        In EOS, `gre.strip` and `destinations.destination/source.strip` (without defining protocols) are
                        mutually exclusive.

                        Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is
                        `destination` (`str`).
                        """

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                strip: bool | None | UndefinedType = Undefined,
                                protocols: Protocols | UndefinedType = Undefined,
                                destinations: Destinations | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Gre.


                                Subclass of AvdModel.

                                Args:
                                    strip: Strip GRE encapsulation header for all GRE tunnels.
                                    protocols:
                                       Protocols for all destinations; destination-specific protocols should be set under the
                                       `destinations[].protocols` key.

                                       Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key
                                       is `protocol` (`str`).
                                    destinations:
                                       In EOS, `gre.strip` and `destinations.destination/source.strip` (without defining protocols) are
                                       mutually exclusive.

                                       Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is
                                       `destination` (`str`).

                                """

                    _fields: ClassVar[dict] = {"vxlan_strip": {"type": bool}, "gre": {"type": Gre}}
                    vxlan_strip: bool | None
                    """
                    Strip VXLAN encapsulation header.
                    `encapsulation.vxlan_strip` and `mpls_pop_all` are mutually
                    exclusive.
                    `mpls_pop_all` takes precedence.
                    """
                    gre: Gre
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, vxlan_strip: bool | None | UndefinedType = Undefined, gre: Gre | UndefinedType = Undefined) -> None:
                            """
                            Encapsulation.


                            Subclass of AvdModel.

                            Args:
                                vxlan_strip:
                                   Strip VXLAN encapsulation header.
                                   `encapsulation.vxlan_strip` and `mpls_pop_all` are mutually
                                   exclusive.
                                   `mpls_pop_all` takes precedence.
                                gre: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {
                    "allowed_vlan": {"type": str},
                    "default": {"type": Default},
                    "identity": {"type": Identity},
                    "mpls_pop_all": {"type": bool},
                    "native_vlan": {"type": int},
                    "truncation": {"type": Truncation},
                    "mac_address": {"type": MacAddress},
                    "encapsulation": {"type": Encapsulation},
                }
                allowed_vlan: str | None
                """VLAN ID or range(s) of VLAN IDs within range 1-4094."""
                default: Default
                """
                Default tap destination config.

                Subclass of AvdModel.
                """
                identity: Identity
                """Subclass of AvdModel."""
                mpls_pop_all: bool | None
                """Pop all MPLS labels."""
                native_vlan: int | None
                """Native VLAN ID when interface is in tap mode."""
                truncation: Truncation
                """Subclass of AvdModel."""
                mac_address: MacAddress
                """Subclass of AvdModel."""
                encapsulation: Encapsulation
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        allowed_vlan: str | None | UndefinedType = Undefined,
                        default: Default | UndefinedType = Undefined,
                        identity: Identity | UndefinedType = Undefined,
                        mpls_pop_all: bool | None | UndefinedType = Undefined,
                        native_vlan: int | None | UndefinedType = Undefined,
                        truncation: Truncation | UndefinedType = Undefined,
                        mac_address: MacAddress | UndefinedType = Undefined,
                        encapsulation: Encapsulation | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Tap.


                        Subclass of AvdModel.

                        Args:
                            allowed_vlan: VLAN ID or range(s) of VLAN IDs within range 1-4094.
                            default:
                               Default tap destination config.

                               Subclass of AvdModel.
                            identity: Subclass of AvdModel.
                            mpls_pop_all: Pop all MPLS labels.
                            native_vlan: Native VLAN ID when interface is in tap mode.
                            truncation: Subclass of AvdModel.
                            mac_address: Subclass of AvdModel.
                            encapsulation: Subclass of AvdModel.

                        """

            class Tool(AvdModel):
                """Subclass of AvdModel."""

                class Encapsulation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"dot1br_strip": {"type": bool}, "vn_tag_strip": {"type": bool}}
                    dot1br_strip: bool | None
                    """Remove a 802.1 BR tag in packet header. 'mpls_pop_all' takes precedence over 'dot1br_strip' in EOS."""
                    vn_tag_strip: bool | None
                    """Remove a VN-tag in packet header. 'mpls_pop_all' takes precedence over 'vn_tag_strip' in EOS."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, dot1br_strip: bool | None | UndefinedType = Undefined, vn_tag_strip: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            Encapsulation.


                            Subclass of AvdModel.

                            Args:
                                dot1br_strip: Remove a 802.1 BR tag in packet header. 'mpls_pop_all' takes precedence over 'dot1br_strip' in EOS.
                                vn_tag_strip: Remove a VN-tag in packet header. 'mpls_pop_all' takes precedence over 'vn_tag_strip' in EOS.

                            """

                class Identity(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"tag": {"type": str}, "dot1q_dzgre_source": {"type": str}, "qinq_dzgre_source": {"type": str}}
                    tag: Literal["dot1q", "qinq"] | None
                    dot1q_dzgre_source: Literal["policy", "port"] | None
                    qinq_dzgre_source: Literal["policy inner port", "port inner policy"] | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            tag: Literal["dot1q", "qinq"] | None | UndefinedType = Undefined,
                            dot1q_dzgre_source: Literal["policy", "port"] | None | UndefinedType = Undefined,
                            qinq_dzgre_source: Literal["policy inner port", "port inner policy"] | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Identity.


                            Subclass of AvdModel.

                            Args:
                                tag: tag
                                dot1q_dzgre_source: dot1q_dzgre_source
                                qinq_dzgre_source: qinq_dzgre_source

                            """

                class Groups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Groups._item_type = str

                _fields: ClassVar[dict] = {
                    "mpls_pop_all": {"type": bool},
                    "encapsulation": {"type": Encapsulation},
                    "allowed_vlan": {"type": str},
                    "identity": {"type": Identity},
                    "groups": {"type": Groups},
                    "dot1q_remove_outer_vlan_tag": {"type": str},
                }
                mpls_pop_all: bool | None
                """Pop all MPLS labels."""
                encapsulation: Encapsulation
                """Subclass of AvdModel."""
                allowed_vlan: str | None
                """VLAN ID or range of VLAN IDs within range 1-4094."""
                identity: Identity
                """Subclass of AvdModel."""
                groups: Groups
                """
                Tool groups for the interface.

                Subclass of AvdList with `str` items.
                """
                dot1q_remove_outer_vlan_tag: str | None
                """
                Indices of vlan tags to be removed.
                Range: 1-2
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mpls_pop_all: bool | None | UndefinedType = Undefined,
                        encapsulation: Encapsulation | UndefinedType = Undefined,
                        allowed_vlan: str | None | UndefinedType = Undefined,
                        identity: Identity | UndefinedType = Undefined,
                        groups: Groups | UndefinedType = Undefined,
                        dot1q_remove_outer_vlan_tag: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Tool.


                        Subclass of AvdModel.

                        Args:
                            mpls_pop_all: Pop all MPLS labels.
                            encapsulation: Subclass of AvdModel.
                            allowed_vlan: VLAN ID or range of VLAN IDs within range 1-4094.
                            identity: Subclass of AvdModel.
                            groups:
                               Tool groups for the interface.

                               Subclass of AvdList with `str` items.
                            dot1q_remove_outer_vlan_tag:
                               Indices of vlan tags to be removed.
                               Range: 1-2

                        """

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "mode": {"type": str},
                "access_vlan": {"type": int},
                "trunk": {"type": Trunk},
                "phone": {"type": Phone},
                "pvlan_mapping": {"type": str},
                "dot1q": {"type": Dot1q},
                "source_interface": {"type": str},
                "vlan_translations": {"type": VlanTranslations},
                "vlan_forwarding_accept_all": {"type": bool},
                "backup_link": {"type": BackupLink},
                "backup": {"type": Backup},
                "port_security": {"type": PortSecurity},
                "tap": {"type": Tap},
                "tool": {"type": Tool},
            }
            enabled: bool | None
            """Warning: This should not be combined with `ethernet_interfaces[].type = routed`."""
            mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone", "tap", "tool", "tap-tool"] | None
            """Warning: This should not be combined with `ethernet_interfaces[].mode`."""
            access_vlan: int | None
            """
            Set VLAN when interface is in access mode.
            Warning: This should not be combined with
            `ethernet_interfaces[].mode = access/dot1q-tunnel` and `ethernet_interface[].vlans`.
            """
            trunk: Trunk
            """Subclass of AvdModel."""
            phone: Phone
            """
            Warning: This should not be combined with `ethernet_interfaces[].phone`.

            Subclass of AvdModel.
            """
            pvlan_mapping: str | None
            """
            Secondary VLAN IDs of the private VLAN mapping.
            Warning: This should not be combined with
            `ethernet_interfaces[].pvlan_mapping`.
            """
            dot1q: Dot1q
            """Subclass of AvdModel."""
            source_interface: Literal["tx", "tx multicast"] | None
            """
            tx: Allow bridged traffic to go out of the source interface.
            tx multicast: Allow multicast traffic
            only to go out of the source interface.
            """
            vlan_translations: VlanTranslations
            """
            VLAN Translation mappings.
            Warning: This should not be combined with
            `ethernet_interfaces[].vlan_translations`.

            Subclass of AvdModel.
            """
            vlan_forwarding_accept_all: bool | None
            backup_link: BackupLink
            """Subclass of AvdModel."""
            backup: Backup
            """
            The `backup_link` is required for this setting.

            Subclass of AvdModel.
            """
            port_security: PortSecurity
            """Subclass of AvdModel."""
            tap: Tap
            """
            In tap mode, the interface operates as a tap port.
            Tap ports receive traffic for replication on one
            or more tool ports.
            This setting applies only to parent interfaces.

            Subclass of AvdModel.
            """
            tool: Tool
            """
            In tool mode, the interface operates as a tool port.
            Tool ports replicate traffic received by tap
            ports.
            This setting applies only to parent interfaces.

            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone", "tap", "tool", "tap-tool"] | None | UndefinedType = Undefined,
                    access_vlan: int | None | UndefinedType = Undefined,
                    trunk: Trunk | UndefinedType = Undefined,
                    phone: Phone | UndefinedType = Undefined,
                    pvlan_mapping: str | None | UndefinedType = Undefined,
                    dot1q: Dot1q | UndefinedType = Undefined,
                    source_interface: Literal["tx", "tx multicast"] | None | UndefinedType = Undefined,
                    vlan_translations: VlanTranslations | UndefinedType = Undefined,
                    vlan_forwarding_accept_all: bool | None | UndefinedType = Undefined,
                    backup_link: BackupLink | UndefinedType = Undefined,
                    backup: Backup | UndefinedType = Undefined,
                    port_security: PortSecurity | UndefinedType = Undefined,
                    tap: Tap | UndefinedType = Undefined,
                    tool: Tool | UndefinedType = Undefined,
                ) -> None:
                    """
                    Switchport.


                    Subclass of AvdModel.

                    Args:
                        enabled: Warning: This should not be combined with `ethernet_interfaces[].type = routed`.
                        mode: Warning: This should not be combined with `ethernet_interfaces[].mode`.
                        access_vlan:
                           Set VLAN when interface is in access mode.
                           Warning: This should not be combined with
                           `ethernet_interfaces[].mode = access/dot1q-tunnel` and `ethernet_interface[].vlans`.
                        trunk: Subclass of AvdModel.
                        phone:
                           Warning: This should not be combined with `ethernet_interfaces[].phone`.

                           Subclass of AvdModel.
                        pvlan_mapping:
                           Secondary VLAN IDs of the private VLAN mapping.
                           Warning: This should not be combined with
                           `ethernet_interfaces[].pvlan_mapping`.
                        dot1q: Subclass of AvdModel.
                        source_interface:
                           tx: Allow bridged traffic to go out of the source interface.
                           tx multicast: Allow multicast traffic
                           only to go out of the source interface.
                        vlan_translations:
                           VLAN Translation mappings.
                           Warning: This should not be combined with
                           `ethernet_interfaces[].vlan_translations`.

                           Subclass of AvdModel.
                        vlan_forwarding_accept_all: vlan_forwarding_accept_all
                        backup_link: Subclass of AvdModel.
                        backup:
                           The `backup_link` is required for this setting.

                           Subclass of AvdModel.
                        port_security: Subclass of AvdModel.
                        tap:
                           In tap mode, the interface operates as a tap port.
                           Tap ports receive traffic for replication on one
                           or more tool ports.
                           This setting applies only to parent interfaces.

                           Subclass of AvdModel.
                        tool:
                           In tool mode, the interface operates as a tool port.
                           Tool ports replicate traffic received by tap
                           ports.
                           This setting applies only to parent interfaces.

                           Subclass of AvdModel.

                    """

        class TrafficEngineering(AvdModel):
            """Subclass of AvdModel."""

            class AdministrativeGroups(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            AdministrativeGroups._item_type = str

            class Srlgs(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Srlgs._item_type = str

            class Bandwidth(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"number": {"type": int}, "unit": {"type": str}}
                number: int
                unit: Literal["gbps", "mbps", "percent"]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, number: int | UndefinedType = Undefined, unit: Literal["gbps", "mbps", "percent"] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bandwidth.


                        Subclass of AvdModel.

                        Args:
                            number: number
                            unit: unit

                        """

            class MinDelayStatic(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"number": {"type": int}, "unit": {"type": str}}
                number: int
                """
                Valid values are 1-16777215 microseconds. This is regardless of whether the specified unit is
                milliseconds or microseconds.
                """
                unit: Literal["microseconds", "milliseconds"]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, number: int | UndefinedType = Undefined, unit: Literal["microseconds", "milliseconds"] | UndefinedType = Undefined
                    ) -> None:
                        """
                        MinDelayStatic.


                        Subclass of AvdModel.

                        Args:
                            number:
                               Valid values are 1-16777215 microseconds. This is regardless of whether the specified unit is
                               milliseconds or microseconds.
                            unit: unit

                        """

            class MinDelayDynamic(AvdModel):
                """Subclass of AvdModel."""

                class TwampLightFallback(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"number": {"type": int}, "unit": {"type": str}}
                    number: int
                    """
                    Valid values are 1-16777215 microseconds.
                    This is regardless of whether the specified unit is
                    milliseconds or microseconds.
                    """
                    unit: Literal["microseconds", "milliseconds"]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, number: int | UndefinedType = Undefined, unit: Literal["microseconds", "milliseconds"] | UndefinedType = Undefined
                        ) -> None:
                            """
                            TwampLightFallback.


                            Subclass of AvdModel.

                            Args:
                                number:
                                   Valid values are 1-16777215 microseconds.
                                   This is regardless of whether the specified unit is
                                   milliseconds or microseconds.
                                unit: unit

                            """

                _fields: ClassVar[dict] = {"twamp_light_fallback": {"type": TwampLightFallback}}
                twamp_light_fallback: TwampLightFallback
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, twamp_light_fallback: TwampLightFallback | UndefinedType = Undefined) -> None:
                        """
                        MinDelayDynamic.


                        Subclass of AvdModel.

                        Args:
                            twamp_light_fallback: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "administrative_groups": {"type": AdministrativeGroups},
                "srlgs": {"type": Srlgs},
                "srlg": {"type": str},
                "metric": {"type": int},
                "bandwidth": {"type": Bandwidth},
                "min_delay_static": {"type": MinDelayStatic},
                "min_delay_dynamic": {"type": MinDelayDynamic},
            }
            enabled: bool | None
            """Whether to enable traffic-engineering on this interface."""
            administrative_groups: AdministrativeGroups
            """
            List of traffic-engineering administrative groups, valid values are names, ranges 0-127, or single
            integers 0-127.

            Subclass of AvdList with `str` items.
            """
            srlgs: Srlgs
            """
            List of SRLGs.

            Subclass of AvdList with `str` items.
            """
            srlg: str | None
            """SRLG name or number."""
            metric: int | None
            bandwidth: Bandwidth
            """
            Interface maximum reservable bandwidth.

            Subclass of AvdModel.
            """
            min_delay_static: MinDelayStatic
            """
            Mutually exclusive with min_delay_dynamic, if both are defined min_delay_static takes precedence.
            Subclass of AvdModel.
            """
            min_delay_dynamic: MinDelayDynamic
            """
            Mutually exclusive with min_delay_static, if both are defined min_delay_static takes precedence.
            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    administrative_groups: AdministrativeGroups | UndefinedType = Undefined,
                    srlgs: Srlgs | UndefinedType = Undefined,
                    srlg: str | None | UndefinedType = Undefined,
                    metric: int | None | UndefinedType = Undefined,
                    bandwidth: Bandwidth | UndefinedType = Undefined,
                    min_delay_static: MinDelayStatic | UndefinedType = Undefined,
                    min_delay_dynamic: MinDelayDynamic | UndefinedType = Undefined,
                ) -> None:
                    """
                    TrafficEngineering.


                    Subclass of AvdModel.

                    Args:
                        enabled: Whether to enable traffic-engineering on this interface.
                        administrative_groups:
                           List of traffic-engineering administrative groups, valid values are names, ranges 0-127, or single
                           integers 0-127.

                           Subclass of AvdList with `str` items.
                        srlgs:
                           List of SRLGs.

                           Subclass of AvdList with `str` items.
                        srlg: SRLG name or number.
                        metric: metric
                        bandwidth:
                           Interface maximum reservable bandwidth.

                           Subclass of AvdModel.
                        min_delay_static:
                           Mutually exclusive with min_delay_dynamic, if both are defined min_delay_static takes precedence.
                           Subclass of AvdModel.
                        min_delay_dynamic:
                           Mutually exclusive with min_delay_static, if both are defined min_delay_static takes precedence.
                           Subclass of AvdModel.

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "comment": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "load_interval": {"type": int},
            "speed": {"type": str},
            "mtu": {"type": int},
            "l2_mtu": {"type": int},
            "l2_mru": {"type": int},
            "vlans": {"type": str},
            "native_vlan": {"type": int},
            "native_vlan_tag": {"type": bool},
            "mode": {"type": str},
            "phone": {"type": Phone},
            "arp_gratuitous_accept": {"type": bool},
            "l2_protocol": {"type": L2Protocol},
            "mac_timestamp": {"type": str},
            "trunk_groups": {"type": TrunkGroups},
            "type": {"type": str},
            "snmp_trap_link_change": {"type": bool},
            "address_locking": {"type": AddressLocking},
            "flowcontrol": {"type": Flowcontrol},
            "vrf": {"type": str},
            "flow_tracker": {"type": FlowTracker},
            "error_correction_encoding": {"type": ErrorCorrectionEncoding},
            "link_tracking_groups": {"type": LinkTrackingGroups},
            "link_tracking": {"type": LinkTracking},
            "evpn_ethernet_segment": {"type": EvpnEthernetSegment},
            "encapsulation_dot1q_vlan": {"type": int},
            "encapsulation_dot1q": {"type": EncapsulationDot1q},
            "encapsulation_vlan": {"type": EncapsulationVlan},
            "vlan_id": {"type": int},
            "ip_address": {"type": str},
            "ip_address_secondaries": {"type": IpAddressSecondaries},
            "ip_verify_unicast_source_reachable_via": {"type": str},
            "dhcp_client_accept_default_route": {"type": bool},
            "dhcp_server_ipv4": {"type": bool},
            "dhcp_server_ipv6": {"type": bool},
            "ip_helpers": {"type": IpHelpers},
            "ip_nat": {"type": IpNat},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "ipv6_address_link_local": {"type": str},
            "ipv6_nd_ra_disabled": {"type": bool},
            "ipv6_nd_managed_config_flag": {"type": bool},
            "ipv6_nd_prefixes": {"type": Ipv6NdPrefixes},
            "ipv6_dhcp_relay_destinations": {"type": Ipv6DhcpRelayDestinations},
            "access_group_in": {"type": str},
            "access_group_out": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "ipv6_access_group_out": {"type": str},
            "mac_access_group_in": {"type": str},
            "mac_access_group_out": {"type": str},
            "multicast": {"type": Multicast},
            "ospf_network_point_to_point": {"type": bool},
            "ospf_area": {"type": str},
            "ospf_cost": {"type": int},
            "ospf_authentication": {"type": str},
            "ospf_authentication_key": {"type": str},
            "ospf_message_digest_keys": {"type": OspfMessageDigestKeys},
            "pim": {"type": Pim},
            "mac_security": {"type": MacSecurity},
            "ntp_serve": {"type": bool},
            "tcp_mss_ceiling": {"type": TcpMssCeiling},
            "channel_group": {"type": ChannelGroup},
            "isis_enable": {"type": str},
            "isis_bfd": {"type": bool},
            "isis_passive": {"type": bool},
            "isis_metric": {"type": int},
            "isis_network_point_to_point": {"type": bool},
            "isis_circuit_type": {"type": str},
            "isis_hello_padding": {"type": bool},
            "isis_authentication_mode": {"type": str},
            "isis_authentication_key": {"type": str},
            "isis_authentication": {"type": IsisAuthentication},
            "poe": {"type": Poe},
            "ptp": {"type": Ptp},
            "profile": {"type": str},
            "storm_control": {"type": StormControl},
            "logging": {"type": Logging},
            "lldp": {"type": Lldp},
            "trunk_private_vlan_secondary": {"type": bool},
            "pvlan_mapping": {"type": str},
            "vlan_translations": {"type": VlanTranslations},
            "dot1x": {"type": Dot1x},
            "service_profile": {"type": str},
            "shape": {"type": Shape},
            "qos": {"type": Qos},
            "spanning_tree_bpdufilter": {"type": str},
            "spanning_tree_bpduguard": {"type": str},
            "spanning_tree_bpduguard_rate_limit": {"type": SpanningTreeBpduguardRateLimit},
            "spanning_tree_guard": {"type": str},
            "spanning_tree_portfast": {"type": str},
            "vmtracer": {"type": bool},
            "priority_flow_control": {"type": PriorityFlowControl},
            "bfd": {"type": Bfd},
            "service_policy": {"type": ServicePolicy},
            "mpls": {"type": Mpls},
            "lacp_timer": {"type": LacpTimer},
            "lacp_port_priority": {"type": int},
            "transceiver": {"type": Transceiver},
            "ip_proxy_arp": {"type": bool},
            "traffic_policy": {"type": TrafficPolicy},
            "bgp": {"type": Bgp},
            "ip_igmp_host_proxy": {"type": IpIgmpHostProxy},
            "peer": {"type": str},
            "peer_interface": {"type": str},
            "peer_type": {"type": str},
            "sflow": {"type": Sflow},
            "sync_e": {"type": SyncE},
            "port_profile": {"type": str},
            "uc_tx_queues": {"type": UcTxQueues},
            "tx_queues": {"type": TxQueues},
            "vrrp_ids": {"type": VrrpIds},
            "validate_state": {"type": bool},
            "validate_lldp": {"type": bool},
            "switchport": {"type": Switchport},
            "traffic_engineering": {"type": TrafficEngineering},
            "eos_cli": {"type": str},
        }
        name: str
        comment: str | None
        """Text comment added under ethernet interface."""
        description: str | None
        shutdown: bool | None
        load_interval: int | None
        """Interval in seconds for updating interface counters."""
        speed: str | None
        """
        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
        <interface_speed>`.
        """
        mtu: int | None
        l2_mtu: int | None
        """"l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI."""
        l2_mru: int | None
        """"l2_mru" should only be defined for platforms supporting the "l2 mru" CLI."""
        vlans: str | None
        """
        List of switchport vlans as string.
        For a trunk port this would be a range like "1-200,300".
        For an
        access port this would be a single vlan "123".
        """
        native_vlan: int | None
        native_vlan_tag: bool | None
        """If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence."""
        mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None
        phone: Phone
        """Subclass of AvdModel."""
        arp_gratuitous_accept: bool | None
        """Accept gratuitous ARP."""
        l2_protocol: L2Protocol
        """Subclass of AvdModel."""
        mac_timestamp: Literal["before-fcs", "replace-fcs", "header"] | None
        """
        header: Insert timestamp in ethernet header. Supported on platforms like 7500E/R and 7280E/R.
        before-fcs: Insert timestamp before fcs field. Supported on platforms like 7150.
        replace-fcs:
        Replace fcs field with timestamp.
        """
        trunk_groups: TrunkGroups
        """Subclass of AvdList with `str` items."""
        type: Literal["routed", "switched", "l3dot1q", "l2dot1q", "port-channel-member"] | None
        """
        l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
        The `type = switched/routed` should not be combined with `switchport`.
        """
        snmp_trap_link_change: bool | None
        address_locking: AddressLocking
        """Subclass of AvdModel."""
        flowcontrol: Flowcontrol
        """Subclass of AvdModel."""
        vrf: str | None
        """VRF name."""
        flow_tracker: FlowTracker
        """Subclass of AvdModel."""
        error_correction_encoding: ErrorCorrectionEncoding
        """Subclass of AvdModel."""
        link_tracking_groups: LinkTrackingGroups
        """Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`)."""
        link_tracking: LinkTracking
        """Subclass of AvdModel."""
        evpn_ethernet_segment: EvpnEthernetSegment
        """Subclass of AvdModel."""
        encapsulation_dot1q_vlan: int | None
        """VLAN tag to configure on sub-interface."""
        encapsulation_dot1q: EncapsulationDot1q
        """
        Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
        `ethernet_interfaces[].type: l2dot1q`.

        Subclass of AvdModel.
        """
        encapsulation_vlan: EncapsulationVlan
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `encapsulation_vlan` should not
        be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
        Subclass of AvdModel.
        """
        vlan_id: int | None
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `vlan_id` should not be combined
        with `ethernet_interfaces[].type == l2dot1q`.
        """
        ip_address: str | None
        """IPv4 address/mask or "dhcp"."""
        ip_address_secondaries: IpAddressSecondaries
        """Subclass of AvdList with `str` items."""
        ip_verify_unicast_source_reachable_via: Literal["any", "rx"] | None
        dhcp_client_accept_default_route: bool | None
        """Install default-route obtained via DHCP."""
        dhcp_server_ipv4: bool | None
        """Enable IPv4 DHCP server."""
        dhcp_server_ipv6: bool | None
        """Enable IPv6 DHCP server."""
        ip_helpers: IpHelpers
        """Subclass of AvdIndexedList with `IpHelpersItem` items. Primary key is `ip_helper` (`str`)."""
        ip_nat: IpNat
        """Subclass of AvdModel."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        ipv6_address_link_local: str | None
        """Link local IPv6 address/mask."""
        ipv6_nd_ra_disabled: bool | None
        ipv6_nd_managed_config_flag: bool | None
        ipv6_nd_prefixes: Ipv6NdPrefixes
        """Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`)."""
        ipv6_dhcp_relay_destinations: Ipv6DhcpRelayDestinations
        """
        Subclass of AvdIndexedList with `Ipv6DhcpRelayDestinationsItem` items. Primary key is `address`
        (`str`).
        """
        access_group_in: str | None
        """Access list name."""
        access_group_out: str | None
        """Access list name."""
        ipv6_access_group_in: str | None
        """IPv6 access list name."""
        ipv6_access_group_out: str | None
        """IPv6 access list name."""
        mac_access_group_in: str | None
        """MAC access list name."""
        mac_access_group_out: str | None
        """MAC access list name."""
        multicast: Multicast
        """
        Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
        of both.

        Subclass of AvdModel.
        """
        ospf_network_point_to_point: bool | None
        ospf_area: str | None
        ospf_cost: int | None
        ospf_authentication: Literal["none", "simple", "message-digest"] | None
        ospf_authentication_key: str | None
        """Encrypted password - only type 7 supported."""
        ospf_message_digest_keys: OspfMessageDigestKeys
        """Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`)."""
        pim: Pim
        """Subclass of AvdModel."""
        mac_security: MacSecurity
        """Subclass of AvdModel."""
        ntp_serve: bool | None
        """Enable/disable serving NTP to clients."""
        tcp_mss_ceiling: TcpMssCeiling
        """
        The TCP MSS clamping feature involves clamping the maximum segment size (MSS) in the TCP header
        of
        TCP SYN packets if it exceeds the configured MSS ceiling limit for the interface.

        Subclass of
        AvdModel.
        """
        channel_group: ChannelGroup
        """Subclass of AvdModel."""
        isis_enable: str | None
        """ISIS instance."""
        isis_bfd: bool | None
        """Enable BFD for ISIS."""
        isis_passive: bool | None
        isis_metric: int | None
        isis_network_point_to_point: bool | None
        isis_circuit_type: Literal["level-1-2", "level-1", "level-2"] | None
        isis_hello_padding: bool | None
        isis_authentication_mode: Literal["text", "md5"] | None
        isis_authentication_key: str | None
        """Type-7 encrypted password."""
        isis_authentication: IsisAuthentication
        """
        This key should not be mixed with ethernet_interfaces[].isis_authentication_mode or
        ethernet_interfaces[].isis_authentication_key.

        Subclass of AvdModel.
        """
        poe: Poe
        """Subclass of AvdModel."""
        ptp: Ptp
        """Subclass of AvdModel."""
        profile: str | None
        """Interface profile."""
        storm_control: StormControl
        """Subclass of AvdModel."""
        logging: Logging
        """Subclass of AvdModel."""
        lldp: Lldp
        """Subclass of AvdModel."""
        trunk_private_vlan_secondary: bool | None
        pvlan_mapping: str | None
        """List of vlans as string."""
        vlan_translations: VlanTranslations
        """Subclass of AvdList with `VlanTranslationsItem` items."""
        dot1x: Dot1x
        """
        802.1x

        Subclass of AvdModel.
        """
        service_profile: str | None
        """QOS profile."""
        shape: Shape
        """Subclass of AvdModel."""
        qos: Qos
        """Subclass of AvdModel."""
        spanning_tree_bpdufilter: Literal["enabled", "disabled", "True", "False", "true", "false"] | None
        spanning_tree_bpduguard: Literal["enabled", "disabled", "True", "False", "true", "false"] | None
        spanning_tree_bpduguard_rate_limit: SpanningTreeBpduguardRateLimit
        """Subclass of AvdModel."""
        spanning_tree_guard: Literal["loop", "root", "disabled"] | None
        spanning_tree_portfast: Literal["edge", "network"] | None
        vmtracer: bool | None
        priority_flow_control: PriorityFlowControl
        """Subclass of AvdModel."""
        bfd: Bfd
        """Subclass of AvdModel."""
        service_policy: ServicePolicy
        """Subclass of AvdModel."""
        mpls: Mpls
        """Subclass of AvdModel."""
        lacp_timer: LacpTimer
        """Subclass of AvdModel."""
        lacp_port_priority: int | None
        transceiver: Transceiver
        """Subclass of AvdModel."""
        ip_proxy_arp: bool | None
        traffic_policy: TrafficPolicy
        """Subclass of AvdModel."""
        bgp: Bgp
        """Subclass of AvdModel."""
        ip_igmp_host_proxy: IpIgmpHostProxy
        """Subclass of AvdModel."""
        peer: str | None
        """Key only used for documentation or validation purposes."""
        peer_interface: str | None
        """Key only used for documentation or validation purposes."""
        peer_type: str | None
        """Key only used for documentation or validation purposes."""
        sflow: Sflow
        """Subclass of AvdModel."""
        sync_e: SyncE
        """Subclass of AvdModel."""
        port_profile: str | None
        """Key only used for documentation or validation purposes."""
        uc_tx_queues: UcTxQueues
        """Subclass of AvdIndexedList with `UcTxQueuesItem` items. Primary key is `id` (`int`)."""
        tx_queues: TxQueues
        """Subclass of AvdIndexedList with `TxQueuesItem` items. Primary key is `id` (`int`)."""
        vrrp_ids: VrrpIds
        """
        VRRP model.

        Subclass of AvdIndexedList with `VrrpIdsItem` items. Primary key is `id` (`int`).
        """
        validate_state: bool | None
        """
        Set to false to disable interface state and LLDP topology validation performed by the
        `eos_validate_state` role.
        """
        validate_lldp: bool | None
        """Set to false to disable the LLDP topology validation performed by the `eos_validate_state` role."""
        switchport: Switchport
        """
        This should not be combined with `ethernet_interfaces[].type = switched/routed`.

        Subclass of
        AvdModel.
        """
        traffic_engineering: TrafficEngineering
        """Subclass of AvdModel."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the ethernet interface in the final EOS configuration."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                comment: str | None | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                load_interval: int | None | UndefinedType = Undefined,
                speed: str | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                l2_mtu: int | None | UndefinedType = Undefined,
                l2_mru: int | None | UndefinedType = Undefined,
                vlans: str | None | UndefinedType = Undefined,
                native_vlan: int | None | UndefinedType = Undefined,
                native_vlan_tag: bool | None | UndefinedType = Undefined,
                mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None | UndefinedType = Undefined,
                phone: Phone | UndefinedType = Undefined,
                arp_gratuitous_accept: bool | None | UndefinedType = Undefined,
                l2_protocol: L2Protocol | UndefinedType = Undefined,
                mac_timestamp: Literal["before-fcs", "replace-fcs", "header"] | None | UndefinedType = Undefined,
                trunk_groups: TrunkGroups | UndefinedType = Undefined,
                type: Literal["routed", "switched", "l3dot1q", "l2dot1q", "port-channel-member"] | None | UndefinedType = Undefined,
                snmp_trap_link_change: bool | None | UndefinedType = Undefined,
                address_locking: AddressLocking | UndefinedType = Undefined,
                flowcontrol: Flowcontrol | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                flow_tracker: FlowTracker | UndefinedType = Undefined,
                error_correction_encoding: ErrorCorrectionEncoding | UndefinedType = Undefined,
                link_tracking_groups: LinkTrackingGroups | UndefinedType = Undefined,
                link_tracking: LinkTracking | UndefinedType = Undefined,
                evpn_ethernet_segment: EvpnEthernetSegment | UndefinedType = Undefined,
                encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                encapsulation_dot1q: EncapsulationDot1q | UndefinedType = Undefined,
                encapsulation_vlan: EncapsulationVlan | UndefinedType = Undefined,
                vlan_id: int | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ip_address_secondaries: IpAddressSecondaries | UndefinedType = Undefined,
                ip_verify_unicast_source_reachable_via: Literal["any", "rx"] | None | UndefinedType = Undefined,
                dhcp_client_accept_default_route: bool | None | UndefinedType = Undefined,
                dhcp_server_ipv4: bool | None | UndefinedType = Undefined,
                dhcp_server_ipv6: bool | None | UndefinedType = Undefined,
                ip_helpers: IpHelpers | UndefinedType = Undefined,
                ip_nat: IpNat | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                ipv6_address_link_local: str | None | UndefinedType = Undefined,
                ipv6_nd_ra_disabled: bool | None | UndefinedType = Undefined,
                ipv6_nd_managed_config_flag: bool | None | UndefinedType = Undefined,
                ipv6_nd_prefixes: Ipv6NdPrefixes | UndefinedType = Undefined,
                ipv6_dhcp_relay_destinations: Ipv6DhcpRelayDestinations | UndefinedType = Undefined,
                access_group_in: str | None | UndefinedType = Undefined,
                access_group_out: str | None | UndefinedType = Undefined,
                ipv6_access_group_in: str | None | UndefinedType = Undefined,
                ipv6_access_group_out: str | None | UndefinedType = Undefined,
                mac_access_group_in: str | None | UndefinedType = Undefined,
                mac_access_group_out: str | None | UndefinedType = Undefined,
                multicast: Multicast | UndefinedType = Undefined,
                ospf_network_point_to_point: bool | None | UndefinedType = Undefined,
                ospf_area: str | None | UndefinedType = Undefined,
                ospf_cost: int | None | UndefinedType = Undefined,
                ospf_authentication: Literal["none", "simple", "message-digest"] | None | UndefinedType = Undefined,
                ospf_authentication_key: str | None | UndefinedType = Undefined,
                ospf_message_digest_keys: OspfMessageDigestKeys | UndefinedType = Undefined,
                pim: Pim | UndefinedType = Undefined,
                mac_security: MacSecurity | UndefinedType = Undefined,
                ntp_serve: bool | None | UndefinedType = Undefined,
                tcp_mss_ceiling: TcpMssCeiling | UndefinedType = Undefined,
                channel_group: ChannelGroup | UndefinedType = Undefined,
                isis_enable: str | None | UndefinedType = Undefined,
                isis_bfd: bool | None | UndefinedType = Undefined,
                isis_passive: bool | None | UndefinedType = Undefined,
                isis_metric: int | None | UndefinedType = Undefined,
                isis_network_point_to_point: bool | None | UndefinedType = Undefined,
                isis_circuit_type: Literal["level-1-2", "level-1", "level-2"] | None | UndefinedType = Undefined,
                isis_hello_padding: bool | None | UndefinedType = Undefined,
                isis_authentication_mode: Literal["text", "md5"] | None | UndefinedType = Undefined,
                isis_authentication_key: str | None | UndefinedType = Undefined,
                isis_authentication: IsisAuthentication | UndefinedType = Undefined,
                poe: Poe | UndefinedType = Undefined,
                ptp: Ptp | UndefinedType = Undefined,
                profile: str | None | UndefinedType = Undefined,
                storm_control: StormControl | UndefinedType = Undefined,
                logging: Logging | UndefinedType = Undefined,
                lldp: Lldp | UndefinedType = Undefined,
                trunk_private_vlan_secondary: bool | None | UndefinedType = Undefined,
                pvlan_mapping: str | None | UndefinedType = Undefined,
                vlan_translations: VlanTranslations | UndefinedType = Undefined,
                dot1x: Dot1x | UndefinedType = Undefined,
                service_profile: str | None | UndefinedType = Undefined,
                shape: Shape | UndefinedType = Undefined,
                qos: Qos | UndefinedType = Undefined,
                spanning_tree_bpdufilter: Literal["enabled", "disabled", "True", "False", "true", "false"] | None | UndefinedType = Undefined,
                spanning_tree_bpduguard: Literal["enabled", "disabled", "True", "False", "true", "false"] | None | UndefinedType = Undefined,
                spanning_tree_bpduguard_rate_limit: SpanningTreeBpduguardRateLimit | UndefinedType = Undefined,
                spanning_tree_guard: Literal["loop", "root", "disabled"] | None | UndefinedType = Undefined,
                spanning_tree_portfast: Literal["edge", "network"] | None | UndefinedType = Undefined,
                vmtracer: bool | None | UndefinedType = Undefined,
                priority_flow_control: PriorityFlowControl | UndefinedType = Undefined,
                bfd: Bfd | UndefinedType = Undefined,
                service_policy: ServicePolicy | UndefinedType = Undefined,
                mpls: Mpls | UndefinedType = Undefined,
                lacp_timer: LacpTimer | UndefinedType = Undefined,
                lacp_port_priority: int | None | UndefinedType = Undefined,
                transceiver: Transceiver | UndefinedType = Undefined,
                ip_proxy_arp: bool | None | UndefinedType = Undefined,
                traffic_policy: TrafficPolicy | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                ip_igmp_host_proxy: IpIgmpHostProxy | UndefinedType = Undefined,
                peer: str | None | UndefinedType = Undefined,
                peer_interface: str | None | UndefinedType = Undefined,
                peer_type: str | None | UndefinedType = Undefined,
                sflow: Sflow | UndefinedType = Undefined,
                sync_e: SyncE | UndefinedType = Undefined,
                port_profile: str | None | UndefinedType = Undefined,
                uc_tx_queues: UcTxQueues | UndefinedType = Undefined,
                tx_queues: TxQueues | UndefinedType = Undefined,
                vrrp_ids: VrrpIds | UndefinedType = Undefined,
                validate_state: bool | None | UndefinedType = Undefined,
                validate_lldp: bool | None | UndefinedType = Undefined,
                switchport: Switchport | UndefinedType = Undefined,
                traffic_engineering: TrafficEngineering | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                EthernetInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: name
                    comment: Text comment added under ethernet interface.
                    description: description
                    shutdown: shutdown
                    load_interval: Interval in seconds for updating interface counters.
                    speed:
                       Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                       <interface_speed>`.
                    mtu: mtu
                    l2_mtu: "l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI.
                    l2_mru: "l2_mru" should only be defined for platforms supporting the "l2 mru" CLI.
                    vlans:
                       List of switchport vlans as string.
                       For a trunk port this would be a range like "1-200,300".
                       For an
                       access port this would be a single vlan "123".
                    native_vlan: native_vlan
                    native_vlan_tag: If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                    mode: mode
                    phone: Subclass of AvdModel.
                    arp_gratuitous_accept: Accept gratuitous ARP.
                    l2_protocol: Subclass of AvdModel.
                    mac_timestamp:
                       header: Insert timestamp in ethernet header. Supported on platforms like 7500E/R and 7280E/R.
                       before-fcs: Insert timestamp before fcs field. Supported on platforms like 7150.
                       replace-fcs:
                       Replace fcs field with timestamp.
                    trunk_groups: Subclass of AvdList with `str` items.
                    type:
                       l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
                       The `type = switched/routed` should not be combined with `switchport`.
                    snmp_trap_link_change: snmp_trap_link_change
                    address_locking: Subclass of AvdModel.
                    flowcontrol: Subclass of AvdModel.
                    vrf: VRF name.
                    flow_tracker: Subclass of AvdModel.
                    error_correction_encoding: Subclass of AvdModel.
                    link_tracking_groups: Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`).
                    link_tracking: Subclass of AvdModel.
                    evpn_ethernet_segment: Subclass of AvdModel.
                    encapsulation_dot1q_vlan: VLAN tag to configure on sub-interface.
                    encapsulation_dot1q:
                       Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
                       `ethernet_interfaces[].type: l2dot1q`.

                       Subclass of AvdModel.
                    encapsulation_vlan:
                       This setting can only be applied to sub-interfaces on EOS.
                       Warning: `encapsulation_vlan` should not
                       be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
                       Subclass of AvdModel.
                    vlan_id:
                       This setting can only be applied to sub-interfaces on EOS.
                       Warning: `vlan_id` should not be combined
                       with `ethernet_interfaces[].type == l2dot1q`.
                    ip_address: IPv4 address/mask or "dhcp".
                    ip_address_secondaries: Subclass of AvdList with `str` items.
                    ip_verify_unicast_source_reachable_via: ip_verify_unicast_source_reachable_via
                    dhcp_client_accept_default_route: Install default-route obtained via DHCP.
                    dhcp_server_ipv4: Enable IPv4 DHCP server.
                    dhcp_server_ipv6: Enable IPv6 DHCP server.
                    ip_helpers: Subclass of AvdIndexedList with `IpHelpersItem` items. Primary key is `ip_helper` (`str`).
                    ip_nat: Subclass of AvdModel.
                    ipv6_enable: ipv6_enable
                    ipv6_address: ipv6_address
                    ipv6_address_link_local: Link local IPv6 address/mask.
                    ipv6_nd_ra_disabled: ipv6_nd_ra_disabled
                    ipv6_nd_managed_config_flag: ipv6_nd_managed_config_flag
                    ipv6_nd_prefixes: Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`).
                    ipv6_dhcp_relay_destinations:
                       Subclass of AvdIndexedList with `Ipv6DhcpRelayDestinationsItem` items. Primary key is `address`
                       (`str`).
                    access_group_in: Access list name.
                    access_group_out: Access list name.
                    ipv6_access_group_in: IPv6 access list name.
                    ipv6_access_group_out: IPv6 access list name.
                    mac_access_group_in: MAC access list name.
                    mac_access_group_out: MAC access list name.
                    multicast:
                       Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                       of both.

                       Subclass of AvdModel.
                    ospf_network_point_to_point: ospf_network_point_to_point
                    ospf_area: ospf_area
                    ospf_cost: ospf_cost
                    ospf_authentication: ospf_authentication
                    ospf_authentication_key: Encrypted password - only type 7 supported.
                    ospf_message_digest_keys: Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`).
                    pim: Subclass of AvdModel.
                    mac_security: Subclass of AvdModel.
                    ntp_serve: Enable/disable serving NTP to clients.
                    tcp_mss_ceiling:
                       The TCP MSS clamping feature involves clamping the maximum segment size (MSS) in the TCP header
                       of
                       TCP SYN packets if it exceeds the configured MSS ceiling limit for the interface.

                       Subclass of
                       AvdModel.
                    channel_group: Subclass of AvdModel.
                    isis_enable: ISIS instance.
                    isis_bfd: Enable BFD for ISIS.
                    isis_passive: isis_passive
                    isis_metric: isis_metric
                    isis_network_point_to_point: isis_network_point_to_point
                    isis_circuit_type: isis_circuit_type
                    isis_hello_padding: isis_hello_padding
                    isis_authentication_mode: isis_authentication_mode
                    isis_authentication_key: Type-7 encrypted password.
                    isis_authentication:
                       This key should not be mixed with ethernet_interfaces[].isis_authentication_mode or
                       ethernet_interfaces[].isis_authentication_key.

                       Subclass of AvdModel.
                    poe: Subclass of AvdModel.
                    ptp: Subclass of AvdModel.
                    profile: Interface profile.
                    storm_control: Subclass of AvdModel.
                    logging: Subclass of AvdModel.
                    lldp: Subclass of AvdModel.
                    trunk_private_vlan_secondary: trunk_private_vlan_secondary
                    pvlan_mapping: List of vlans as string.
                    vlan_translations: Subclass of AvdList with `VlanTranslationsItem` items.
                    dot1x:
                       802.1x

                       Subclass of AvdModel.
                    service_profile: QOS profile.
                    shape: Subclass of AvdModel.
                    qos: Subclass of AvdModel.
                    spanning_tree_bpdufilter: spanning_tree_bpdufilter
                    spanning_tree_bpduguard: spanning_tree_bpduguard
                    spanning_tree_bpduguard_rate_limit: Subclass of AvdModel.
                    spanning_tree_guard: spanning_tree_guard
                    spanning_tree_portfast: spanning_tree_portfast
                    vmtracer: vmtracer
                    priority_flow_control: Subclass of AvdModel.
                    bfd: Subclass of AvdModel.
                    service_policy: Subclass of AvdModel.
                    mpls: Subclass of AvdModel.
                    lacp_timer: Subclass of AvdModel.
                    lacp_port_priority: lacp_port_priority
                    transceiver: Subclass of AvdModel.
                    ip_proxy_arp: ip_proxy_arp
                    traffic_policy: Subclass of AvdModel.
                    bgp: Subclass of AvdModel.
                    ip_igmp_host_proxy: Subclass of AvdModel.
                    peer: Key only used for documentation or validation purposes.
                    peer_interface: Key only used for documentation or validation purposes.
                    peer_type: Key only used for documentation or validation purposes.
                    sflow: Subclass of AvdModel.
                    sync_e: Subclass of AvdModel.
                    port_profile: Key only used for documentation or validation purposes.
                    uc_tx_queues: Subclass of AvdIndexedList with `UcTxQueuesItem` items. Primary key is `id` (`int`).
                    tx_queues: Subclass of AvdIndexedList with `TxQueuesItem` items. Primary key is `id` (`int`).
                    vrrp_ids:
                       VRRP model.

                       Subclass of AvdIndexedList with `VrrpIdsItem` items. Primary key is `id` (`int`).
                    validate_state:
                       Set to false to disable interface state and LLDP topology validation performed by the
                       `eos_validate_state` role.
                    validate_lldp: Set to false to disable the LLDP topology validation performed by the `eos_validate_state` role.
                    switchport:
                       This should not be combined with `ethernet_interfaces[].type = switched/routed`.

                       Subclass of
                       AvdModel.
                    traffic_engineering: Subclass of AvdModel.
                    eos_cli: Multiline EOS CLI rendered directly on the ethernet interface in the final EOS configuration.

                """

    class EthernetInterfaces(AvdIndexedList[str, EthernetInterfacesItem]):
        """Subclass of AvdIndexedList with `EthernetInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    EthernetInterfaces._item_type = EthernetInterfacesItem

    class EventHandlersItem(AvdModel):
        """Subclass of AvdModel."""

        class Actions(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"bash_command": {"type": str}, "log": {"type": bool}, "increment_device_health_metric": {"type": str}}
            bash_command: str | None
            """Define BASH command action. Command could be multiline also."""
            log: bool | None
            """Log a message when the event is triggered."""
            increment_device_health_metric: str | None
            """Name of device-health metric."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bash_command: str | None | UndefinedType = Undefined,
                    log: bool | None | UndefinedType = Undefined,
                    increment_device_health_metric: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Actions.


                    Subclass of AvdModel.

                    Args:
                        bash_command: Define BASH command action. Command could be multiline also.
                        log: Log a message when the event is triggered.
                        increment_device_health_metric: Name of device-health metric.

                    """

        class TriggerOnCounters(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"condition": {"type": str}, "granularity_per_source": {"type": bool}, "poll_interval": {"type": int}}
            condition: str | None
            """Set the logical expression to evaluate."""
            granularity_per_source: bool | None
            """
            Set the granularity of event counting for a wildcarded condition.
            Example -
              condition (
            Arad*.IptCrcErrCnt.delta > 100 ) and ( Arad*.UcFifoFullDrop.delta > 100 )
              [* wildcard is used
            here]
            """
            poll_interval: int | None
            """Set the polling interval in seconds."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    condition: str | None | UndefinedType = Undefined,
                    granularity_per_source: bool | None | UndefinedType = Undefined,
                    poll_interval: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TriggerOnCounters.


                    Subclass of AvdModel.

                    Args:
                        condition: Set the logical expression to evaluate.
                        granularity_per_source:
                           Set the granularity of event counting for a wildcarded condition.
                           Example -
                             condition (
                           Arad*.IptCrcErrCnt.delta > 100 ) and ( Arad*.UcFifoFullDrop.delta > 100 )
                             [* wildcard is used
                           here]
                        poll_interval: Set the polling interval in seconds.

                    """

        class TriggerOnLogging(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"poll_interval": {"type": int}, "regex": {"type": str}}
            poll_interval: int | None
            """Set the polling interval in seconds."""
            regex: str | None
            """Regular expression to use for searching log messages."""

            if TYPE_CHECKING:

                def __init__(self, *, poll_interval: int | None | UndefinedType = Undefined, regex: str | None | UndefinedType = Undefined) -> None:
                    """
                    TriggerOnLogging.


                    Subclass of AvdModel.

                    Args:
                        poll_interval: Set the polling interval in seconds.
                        regex: Regular expression to use for searching log messages.

                    """

        class TriggerOnIntf(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"interface": {"type": str}, "ip": {"type": bool}, "ipv6": {"type": bool}, "operstatus": {"type": bool}}
            interface: str
            """
            Interface name.
            Example - Ethernet4
                      Loopback4-6
                      Port-channel4,7
            """
            ip: bool | None
            """Action is triggered upon changes to interface IP address assignment."""
            ipv6: bool | None
            """Action is triggered upon changes to interface ipv6 address assignment."""
            operstatus: bool | None
            """Action is triggered upon changes to interface operStatus."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    interface: str | UndefinedType = Undefined,
                    ip: bool | None | UndefinedType = Undefined,
                    ipv6: bool | None | UndefinedType = Undefined,
                    operstatus: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TriggerOnIntf.


                    Subclass of AvdModel.

                    Args:
                        interface:
                           Interface name.
                           Example - Ethernet4
                                     Loopback4-6
                                     Port-channel4,7
                        ip: Action is triggered upon changes to interface IP address assignment.
                        ipv6: Action is triggered upon changes to interface ipv6 address assignment.
                        operstatus: Action is triggered upon changes to interface operStatus.

                    """

        class TriggerOnMaintenance(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "operation": {"type": str},
                "bgp_peer": {"type": str},
                "action": {"type": str},
                "stage": {"type": str},
                "vrf": {"type": str},
                "interface": {"type": str},
                "unit": {"type": str},
            }
            operation: Literal["enter", "exit"]
            bgp_peer: str | None
            """
            Ipv4/Ipv6 address or peer group name.
            Trigger condition occurs on maintenance operation of specified
            BGP peer.
            """
            action: Literal["after", "before", "all", "begin", "end"]
            """Action for maintenance operation."""
            stage: Literal["bgp", "linkdown", "mlag", "ratemon"] | None
            """Action is triggered after/before specified stage."""
            vrf: str | None
            """VRF name. VRF can be defined for "bgp_peer" only."""
            interface: str | None
            """Trigger condition occurs on maintenance operation of specified interface."""
            unit: str | None
            """Name of unit. Trigger condition occurs on maintenance operation of specified unit"""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    operation: Literal["enter", "exit"] | UndefinedType = Undefined,
                    bgp_peer: str | None | UndefinedType = Undefined,
                    action: Literal["after", "before", "all", "begin", "end"] | UndefinedType = Undefined,
                    stage: Literal["bgp", "linkdown", "mlag", "ratemon"] | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    interface: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TriggerOnMaintenance.


                    Subclass of AvdModel.

                    Args:
                        operation: operation
                        bgp_peer:
                           Ipv4/Ipv6 address or peer group name.
                           Trigger condition occurs on maintenance operation of specified
                           BGP peer.
                        action: Action for maintenance operation.
                        stage: Action is triggered after/before specified stage.
                        vrf: VRF name. VRF can be defined for "bgp_peer" only.
                        interface: Trigger condition occurs on maintenance operation of specified interface.
                        unit: Name of unit. Trigger condition occurs on maintenance operation of specified unit

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "actions": {"type": Actions},
            "delay": {"type": int},
            "trigger": {"type": str},
            "trigger_on_counters": {"type": TriggerOnCounters},
            "trigger_on_logging": {"type": TriggerOnLogging},
            "trigger_on_intf": {"type": TriggerOnIntf},
            "trigger_on_maintenance": {"type": TriggerOnMaintenance},
            "asynchronous": {"type": bool, "default": False},
        }
        name: str
        """Event Handler Name."""
        actions: Actions
        """
        Note: `bash_command` and `log` are mutually exclusive. `bash_command` takes precedence over `log`.
        Subclass of AvdModel.
        """
        delay: int | None
        """Event-handler delay in seconds."""
        trigger: Literal["on-boot", "on-counters", "on-intf", "on-logging", "on-maintenance", "on-startup-config", "vm-tracer vm"] | None
        """Configure event trigger condition."""
        trigger_on_counters: TriggerOnCounters
        """Subclass of AvdModel."""
        trigger_on_logging: TriggerOnLogging
        """Subclass of AvdModel."""
        trigger_on_intf: TriggerOnIntf
        """
        Trigger condition occurs on specified interface changes.
        Note: Any one of the `ip`, `ipv6` and
        `operstatus` key needs to be defined along with the `interface`.

        Subclass of AvdModel.
        """
        trigger_on_maintenance: TriggerOnMaintenance
        """
        Settings required for trigger 'on-maintenance'.

        Subclass of AvdModel.
        """
        asynchronous: bool
        """
        Set the action to be non-blocking.

        Default value: `False`
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                actions: Actions | UndefinedType = Undefined,
                delay: int | None | UndefinedType = Undefined,
                trigger: Literal["on-boot", "on-counters", "on-intf", "on-logging", "on-maintenance", "on-startup-config", "vm-tracer vm"]
                | None
                | UndefinedType = Undefined,
                trigger_on_counters: TriggerOnCounters | UndefinedType = Undefined,
                trigger_on_logging: TriggerOnLogging | UndefinedType = Undefined,
                trigger_on_intf: TriggerOnIntf | UndefinedType = Undefined,
                trigger_on_maintenance: TriggerOnMaintenance | UndefinedType = Undefined,
                asynchronous: bool | UndefinedType = Undefined,
            ) -> None:
                """
                EventHandlersItem.


                Subclass of AvdModel.

                Args:
                    name: Event Handler Name.
                    actions:
                       Note: `bash_command` and `log` are mutually exclusive. `bash_command` takes precedence over `log`.
                       Subclass of AvdModel.
                    delay: Event-handler delay in seconds.
                    trigger: Configure event trigger condition.
                    trigger_on_counters: Subclass of AvdModel.
                    trigger_on_logging: Subclass of AvdModel.
                    trigger_on_intf:
                       Trigger condition occurs on specified interface changes.
                       Note: Any one of the `ip`, `ipv6` and
                       `operstatus` key needs to be defined along with the `interface`.

                       Subclass of AvdModel.
                    trigger_on_maintenance:
                       Settings required for trigger 'on-maintenance'.

                       Subclass of AvdModel.
                    asynchronous: Set the action to be non-blocking.

                """

    class EventHandlers(AvdIndexedList[str, EventHandlersItem]):
        """Subclass of AvdIndexedList with `EventHandlersItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    EventHandlers._item_type = EventHandlersItem

    class EventMonitor(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"enabled": {"type": bool}}
        enabled: bool | None

        if TYPE_CHECKING:

            def __init__(self, *, enabled: bool | None | UndefinedType = Undefined) -> None:
                """
                EventMonitor.


                Subclass of AvdModel.

                Args:
                    enabled: enabled

                """

    class FlowTracking(AvdModel):
        """Subclass of AvdModel."""

        class Sampled(AvdModel):
            """Subclass of AvdModel."""

            class Encapsulation(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4_ipv6": {"type": bool}, "mpls": {"type": bool}}
                ipv4_ipv6: bool | None
                mpls: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, ipv4_ipv6: bool | None | UndefinedType = Undefined, mpls: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Encapsulation.


                        Subclass of AvdModel.

                        Args:
                            ipv4_ipv6: ipv4_ipv6
                            mpls: mpls

                        """

            class HardwareOffload(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4": {"type": bool}, "ipv6": {"type": bool}, "threshold_minimum": {"type": int}}
                ipv4: bool | None
                """Configure hardware offload for IPv4 traffic."""
                ipv6: bool | None
                """Configure hardware offload for IPv6 traffic."""
                threshold_minimum: int | None
                """Minimum number of samples."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ipv4: bool | None | UndefinedType = Undefined,
                        ipv6: bool | None | UndefinedType = Undefined,
                        threshold_minimum: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        HardwareOffload.


                        Subclass of AvdModel.

                        Args:
                            ipv4: Configure hardware offload for IPv4 traffic.
                            ipv6: Configure hardware offload for IPv6 traffic.
                            threshold_minimum: Minimum number of samples.

                        """

            class TrackersItem(AvdModel):
                """Subclass of AvdModel."""

                class RecordExport(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"mpls": {"type": bool}, "on_inactive_timeout": {"type": int}, "on_interval": {"type": int}}
                    mpls: bool | None
                    """Export MPLS forwarding information."""
                    on_inactive_timeout: int | None
                    """Flow record inactive export timeout in milliseconds."""
                    on_interval: int | None
                    """Flow record export interval in milliseconds."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            mpls: bool | None | UndefinedType = Undefined,
                            on_inactive_timeout: int | None | UndefinedType = Undefined,
                            on_interval: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RecordExport.


                            Subclass of AvdModel.

                            Args:
                                mpls: Export MPLS forwarding information.
                                on_inactive_timeout: Flow record inactive export timeout in milliseconds.
                                on_interval: Flow record export interval in milliseconds.

                            """

                class ExportersItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Collector(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"host": {"type": str}, "port": {"type": int}}
                        host: str | None
                        """Collector IPv4 address or IPv6 address or fully qualified domain name."""
                        port: int | None
                        """Collector Port Number."""

                        if TYPE_CHECKING:

                            def __init__(self, *, host: str | None | UndefinedType = Undefined, port: int | None | UndefinedType = Undefined) -> None:
                                """
                                Collector.


                                Subclass of AvdModel.

                                Args:
                                    host: Collector IPv4 address or IPv6 address or fully qualified domain name.
                                    port: Collector Port Number.

                                """

                    class CollectorsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"host": {"type": str}, "port": {"type": int}}
                        host: str
                        """
                        Flow collector name.
                        The collector name can be an IPv4 address, IPv6 address and fully qualified
                        domain name.
                        """
                        port: int | None
                        """Collector Port Number."""

                        if TYPE_CHECKING:

                            def __init__(self, *, host: str | UndefinedType = Undefined, port: int | None | UndefinedType = Undefined) -> None:
                                """
                                CollectorsItem.


                                Subclass of AvdModel.

                                Args:
                                    host:
                                       Flow collector name.
                                       The collector name can be an IPv4 address, IPv6 address and fully qualified
                                       domain name.
                                    port: Collector Port Number.

                                """

                    class Collectors(AvdIndexedList[str, CollectorsItem]):
                        """Subclass of AvdIndexedList with `CollectorsItem` items. Primary key is `host` (`str`)."""

                        _primary_key: ClassVar[str] = "host"

                    Collectors._item_type = CollectorsItem

                    class Format(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"ipfix_version": {"type": int}}
                        ipfix_version: int | None

                        if TYPE_CHECKING:

                            def __init__(self, *, ipfix_version: int | None | UndefinedType = Undefined) -> None:
                                """
                                Format.


                                Subclass of AvdModel.

                                Args:
                                    ipfix_version: ipfix_version

                                """

                    _fields: ClassVar[dict] = {
                        "name": {"type": str},
                        "collector": {"type": Collector},
                        "collectors": {"type": Collectors},
                        "format": {"type": Format},
                        "local_interface": {"type": str},
                        "template_interval": {"type": int},
                    }
                    name: str
                    """Exporter Name."""
                    collector: Collector
                    """Subclass of AvdModel."""
                    collectors: Collectors
                    """Subclass of AvdIndexedList with `CollectorsItem` items. Primary key is `host` (`str`)."""
                    format: Format
                    """Subclass of AvdModel."""
                    local_interface: str | None
                    """Local Source Interface."""
                    template_interval: int | None
                    """Template interval in milliseconds."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            collector: Collector | UndefinedType = Undefined,
                            collectors: Collectors | UndefinedType = Undefined,
                            format: Format | UndefinedType = Undefined,
                            local_interface: str | None | UndefinedType = Undefined,
                            template_interval: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ExportersItem.


                            Subclass of AvdModel.

                            Args:
                                name: Exporter Name.
                                collector: Subclass of AvdModel.
                                collectors: Subclass of AvdIndexedList with `CollectorsItem` items. Primary key is `host` (`str`).
                                format: Subclass of AvdModel.
                                local_interface: Local Source Interface.
                                template_interval: Template interval in milliseconds.

                            """

                class Exporters(AvdIndexedList[str, ExportersItem]):
                    """Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                Exporters._item_type = ExportersItem

                _fields: ClassVar[dict] = {
                    "table_size": {"type": int},
                    "record_export": {"type": RecordExport},
                    "name": {"type": str},
                    "exporters": {"type": Exporters},
                }
                table_size: int | None
                """Maximum number of entries in flow table."""
                record_export: RecordExport
                """Subclass of AvdModel."""
                name: str
                """Tracker Name."""
                exporters: Exporters
                """Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        table_size: int | None | UndefinedType = Undefined,
                        record_export: RecordExport | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        exporters: Exporters | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrackersItem.


                        Subclass of AvdModel.

                        Args:
                            table_size: Maximum number of entries in flow table.
                            record_export: Subclass of AvdModel.
                            name: Tracker Name.
                            exporters: Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`).

                        """

            class Trackers(AvdIndexedList[str, TrackersItem]):
                """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Trackers._item_type = TrackersItem

            _fields: ClassVar[dict] = {
                "encapsulation": {"type": Encapsulation},
                "sample": {"type": int},
                "hardware_offload": {"type": HardwareOffload},
                "trackers": {"type": Trackers},
                "shutdown": {"type": bool},
            }
            encapsulation: Encapsulation
            """Subclass of AvdModel."""
            sample: int | None
            hardware_offload: HardwareOffload
            """Subclass of AvdModel."""
            trackers: Trackers
            """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""
            shutdown: bool | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    encapsulation: Encapsulation | UndefinedType = Undefined,
                    sample: int | None | UndefinedType = Undefined,
                    hardware_offload: HardwareOffload | UndefinedType = Undefined,
                    trackers: Trackers | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Sampled.


                    Subclass of AvdModel.

                    Args:
                        encapsulation: Subclass of AvdModel.
                        sample: sample
                        hardware_offload: Subclass of AvdModel.
                        trackers: Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`).
                        shutdown: shutdown

                    """

        class Hardware(AvdModel):
            """Subclass of AvdModel."""

            class Record(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"format_ipfix_standard_timestamps_counters": {"type": bool}}
                format_ipfix_standard_timestamps_counters: bool | None
                """Enable software export of IPFIX data records."""

                if TYPE_CHECKING:

                    def __init__(self, *, format_ipfix_standard_timestamps_counters: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Record.


                        Subclass of AvdModel.

                        Args:
                            format_ipfix_standard_timestamps_counters: Enable software export of IPFIX data records.

                        """

            class TrackersItem(AvdModel):
                """Subclass of AvdModel."""

                class RecordExport(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"on_inactive_timeout": {"type": int}, "on_interval": {"type": int}}
                    on_inactive_timeout: int | None
                    """Flow record inactive export timeout in milliseconds."""
                    on_interval: int | None
                    """Flow record export interval in milliseconds."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, on_inactive_timeout: int | None | UndefinedType = Undefined, on_interval: int | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            RecordExport.


                            Subclass of AvdModel.

                            Args:
                                on_inactive_timeout: Flow record inactive export timeout in milliseconds.
                                on_interval: Flow record export interval in milliseconds.

                            """

                class ExportersItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Collector(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"host": {"type": str}, "port": {"type": int}}
                        host: str | None
                        """Collector IPv4 address or IPv6 address or fully qualified domain name."""
                        port: int | None
                        """Collector Port Number."""

                        if TYPE_CHECKING:

                            def __init__(self, *, host: str | None | UndefinedType = Undefined, port: int | None | UndefinedType = Undefined) -> None:
                                """
                                Collector.


                                Subclass of AvdModel.

                                Args:
                                    host: Collector IPv4 address or IPv6 address or fully qualified domain name.
                                    port: Collector Port Number.

                                """

                    class CollectorsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"host": {"type": str}, "port": {"type": int}}
                        host: str
                        """
                        Flow collector name.
                        The collector name can be an IPv4 address, IPv6 address and fully qualified
                        domain name.
                        """
                        port: int | None
                        """Collector Port Number."""

                        if TYPE_CHECKING:

                            def __init__(self, *, host: str | UndefinedType = Undefined, port: int | None | UndefinedType = Undefined) -> None:
                                """
                                CollectorsItem.


                                Subclass of AvdModel.

                                Args:
                                    host:
                                       Flow collector name.
                                       The collector name can be an IPv4 address, IPv6 address and fully qualified
                                       domain name.
                                    port: Collector Port Number.

                                """

                    class Collectors(AvdIndexedList[str, CollectorsItem]):
                        """Subclass of AvdIndexedList with `CollectorsItem` items. Primary key is `host` (`str`)."""

                        _primary_key: ClassVar[str] = "host"

                    Collectors._item_type = CollectorsItem

                    class Format(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"ipfix_version": {"type": int}}
                        ipfix_version: int | None

                        if TYPE_CHECKING:

                            def __init__(self, *, ipfix_version: int | None | UndefinedType = Undefined) -> None:
                                """
                                Format.


                                Subclass of AvdModel.

                                Args:
                                    ipfix_version: ipfix_version

                                """

                    _fields: ClassVar[dict] = {
                        "name": {"type": str},
                        "collector": {"type": Collector},
                        "collectors": {"type": Collectors},
                        "format": {"type": Format},
                        "local_interface": {"type": str},
                        "template_interval": {"type": int},
                    }
                    name: str
                    """Exporter Name."""
                    collector: Collector
                    """Subclass of AvdModel."""
                    collectors: Collectors
                    """Subclass of AvdIndexedList with `CollectorsItem` items. Primary key is `host` (`str`)."""
                    format: Format
                    """Subclass of AvdModel."""
                    local_interface: str | None
                    """Local Source Interface."""
                    template_interval: int | None
                    """Template interval in milliseconds."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            collector: Collector | UndefinedType = Undefined,
                            collectors: Collectors | UndefinedType = Undefined,
                            format: Format | UndefinedType = Undefined,
                            local_interface: str | None | UndefinedType = Undefined,
                            template_interval: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ExportersItem.


                            Subclass of AvdModel.

                            Args:
                                name: Exporter Name.
                                collector: Subclass of AvdModel.
                                collectors: Subclass of AvdIndexedList with `CollectorsItem` items. Primary key is `host` (`str`).
                                format: Subclass of AvdModel.
                                local_interface: Local Source Interface.
                                template_interval: Template interval in milliseconds.

                            """

                class Exporters(AvdIndexedList[str, ExportersItem]):
                    """Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                Exporters._item_type = ExportersItem

                _fields: ClassVar[dict] = {"name": {"type": str}, "record_export": {"type": RecordExport}, "exporters": {"type": Exporters}}
                name: str
                """Tracker Name."""
                record_export: RecordExport
                """Subclass of AvdModel."""
                exporters: Exporters
                """Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        record_export: RecordExport | UndefinedType = Undefined,
                        exporters: Exporters | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrackersItem.


                        Subclass of AvdModel.

                        Args:
                            name: Tracker Name.
                            record_export: Subclass of AvdModel.
                            exporters: Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`).

                        """

            class Trackers(AvdIndexedList[str, TrackersItem]):
                """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Trackers._item_type = TrackersItem

            _fields: ClassVar[dict] = {"record": {"type": Record}, "trackers": {"type": Trackers}, "shutdown": {"type": bool}}
            record: Record
            """Subclass of AvdModel."""
            trackers: Trackers
            """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""
            shutdown: bool | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    record: Record | UndefinedType = Undefined,
                    trackers: Trackers | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Hardware.


                    Subclass of AvdModel.

                    Args:
                        record: Subclass of AvdModel.
                        trackers: Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`).
                        shutdown: shutdown

                    """

        class MirrorOnDrop(AvdModel):
            """Subclass of AvdModel."""

            class Encapsulation(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4_ipv6": {"type": bool}, "mpls": {"type": bool}}
                ipv4_ipv6: bool | None
                """
                Set IPv4 and IPv6 encapsulations.
                Both IPv4 and IPv6 encapsulations must be set together.
                """
                mpls: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, ipv4_ipv6: bool | None | UndefinedType = Undefined, mpls: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Encapsulation.


                        Subclass of AvdModel.

                        Args:
                            ipv4_ipv6:
                               Set IPv4 and IPv6 encapsulations.
                               Both IPv4 and IPv6 encapsulations must be set together.
                            mpls: mpls

                        """

            class TrackersItem(AvdModel):
                """Subclass of AvdModel."""

                class RecordExport(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"on_inactive_timeout": {"type": int}, "on_interval": {"type": int}}
                    on_inactive_timeout: int | None
                    """Flow record inactive export timeout in milliseconds."""
                    on_interval: int | None
                    """Flow record export interval in milliseconds."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, on_inactive_timeout: int | None | UndefinedType = Undefined, on_interval: int | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            RecordExport.


                            Subclass of AvdModel.

                            Args:
                                on_inactive_timeout: Flow record inactive export timeout in milliseconds.
                                on_interval: Flow record export interval in milliseconds.

                            """

                class ExportersItem(AvdModel):
                    """Subclass of AvdModel."""

                    class CollectorsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"host": {"type": str}, "port": {"type": int}}
                        host: str
                        """
                        Flow collector name.
                        The collector name can be an IPv4 address, IPv6 address, fully qualified domain
                        name or `"sflow"`.
                        """
                        port: int | None
                        """Collector Port Number."""

                        if TYPE_CHECKING:

                            def __init__(self, *, host: str | UndefinedType = Undefined, port: int | None | UndefinedType = Undefined) -> None:
                                """
                                CollectorsItem.


                                Subclass of AvdModel.

                                Args:
                                    host:
                                       Flow collector name.
                                       The collector name can be an IPv4 address, IPv6 address, fully qualified domain
                                       name or `"sflow"`.
                                    port: Collector Port Number.

                                """

                    class Collectors(AvdIndexedList[str, CollectorsItem]):
                        """Subclass of AvdIndexedList with `CollectorsItem` items. Primary key is `host` (`str`)."""

                        _primary_key: ClassVar[str] = "host"

                    Collectors._item_type = CollectorsItem

                    _fields: ClassVar[dict] = {
                        "name": {"type": str},
                        "collectors": {"type": Collectors},
                        "format": {"type": str},
                        "local_interface": {"type": str},
                        "template_interval": {"type": int},
                        "dscp": {"type": int},
                    }
                    name: str
                    """Exporter Name."""
                    collectors: Collectors
                    """Subclass of AvdIndexedList with `CollectorsItem` items. Primary key is `host` (`str`)."""
                    format: Literal["sflow", "drop-report"] | None
                    """Configure flow export format. Valid values are platform dependent."""
                    local_interface: str | None
                    """Local Source Interface."""
                    template_interval: int | None
                    """Template interval in milliseconds."""
                    dscp: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            collectors: Collectors | UndefinedType = Undefined,
                            format: Literal["sflow", "drop-report"] | None | UndefinedType = Undefined,
                            local_interface: str | None | UndefinedType = Undefined,
                            template_interval: int | None | UndefinedType = Undefined,
                            dscp: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ExportersItem.


                            Subclass of AvdModel.

                            Args:
                                name: Exporter Name.
                                collectors: Subclass of AvdIndexedList with `CollectorsItem` items. Primary key is `host` (`str`).
                                format: Configure flow export format. Valid values are platform dependent.
                                local_interface: Local Source Interface.
                                template_interval: Template interval in milliseconds.
                                dscp: dscp

                            """

                class Exporters(AvdIndexedList[str, ExportersItem]):
                    """Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                Exporters._item_type = ExportersItem

                _fields: ClassVar[dict] = {"name": {"type": str}, "record_export": {"type": RecordExport}, "exporters": {"type": Exporters}}
                name: str
                """Tracker Name."""
                record_export: RecordExport
                """Subclass of AvdModel."""
                exporters: Exporters
                """Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        record_export: RecordExport | UndefinedType = Undefined,
                        exporters: Exporters | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrackersItem.


                        Subclass of AvdModel.

                        Args:
                            name: Tracker Name.
                            record_export: Subclass of AvdModel.
                            exporters: Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`).

                        """

            class Trackers(AvdIndexedList[str, TrackersItem]):
                """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Trackers._item_type = TrackersItem

            _fields: ClassVar[dict] = {
                "encapsulation": {"type": Encapsulation},
                "sample_limit": {"type": int},
                "trackers": {"type": Trackers},
                "shutdown": {"type": bool},
            }
            encapsulation: Encapsulation
            """Subclass of AvdModel."""
            sample_limit: int | None
            """Limit the number of packets sampled."""
            trackers: Trackers
            """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""
            shutdown: bool | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    encapsulation: Encapsulation | UndefinedType = Undefined,
                    sample_limit: int | None | UndefinedType = Undefined,
                    trackers: Trackers | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    MirrorOnDrop.


                    Subclass of AvdModel.

                    Args:
                        encapsulation: Subclass of AvdModel.
                        sample_limit: Limit the number of packets sampled.
                        trackers: Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`).
                        shutdown: shutdown

                    """

        _fields: ClassVar[dict] = {"sampled": {"type": Sampled}, "hardware": {"type": Hardware}, "mirror_on_drop": {"type": MirrorOnDrop}}
        sampled: Sampled
        """Subclass of AvdModel."""
        hardware: Hardware
        """Subclass of AvdModel."""
        mirror_on_drop: MirrorOnDrop
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                sampled: Sampled | UndefinedType = Undefined,
                hardware: Hardware | UndefinedType = Undefined,
                mirror_on_drop: MirrorOnDrop | UndefinedType = Undefined,
            ) -> None:
                """
                FlowTracking.


                Subclass of AvdModel.

                Args:
                    sampled: Subclass of AvdModel.
                    hardware: Subclass of AvdModel.
                    mirror_on_drop: Subclass of AvdModel.

                """

    class Hardware(AvdModel):
        """Subclass of AvdModel."""

        class AccessList(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"mechanism": {"type": str}, "update_default_result_permit": {"type": bool}}
            mechanism: Literal["algomatch", "none", "tcam"] | None
            update_default_result_permit: bool | None
            """Accept the packets when access-list is being updated."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    mechanism: Literal["algomatch", "none", "tcam"] | None | UndefinedType = Undefined,
                    update_default_result_permit: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AccessList.


                    Subclass of AvdModel.

                    Args:
                        mechanism: mechanism
                        update_default_result_permit: Accept the packets when access-list is being updated.

                    """

        class SpeedGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"speed_group": {"type": str}, "serdes": {"type": str}}
            speed_group: str
            serdes: str | None
            """Serdes speed like "10g" or "25g"."""

            if TYPE_CHECKING:

                def __init__(self, *, speed_group: str | UndefinedType = Undefined, serdes: str | None | UndefinedType = Undefined) -> None:
                    """
                    SpeedGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        speed_group: speed_group
                        serdes: Serdes speed like "10g" or "25g".

                    """

        class SpeedGroups(AvdIndexedList[str, SpeedGroupsItem]):
            """Subclass of AvdIndexedList with `SpeedGroupsItem` items. Primary key is `speed_group` (`str`)."""

            _primary_key: ClassVar[str] = "speed_group"

        SpeedGroups._item_type = SpeedGroupsItem

        class PortGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"port_group": {"type": str}, "select": {"type": str}}
            port_group: str
            select: str | None
            """Select Ports to activate"""

            if TYPE_CHECKING:

                def __init__(self, *, port_group: str | UndefinedType = Undefined, select: str | None | UndefinedType = Undefined) -> None:
                    """
                    PortGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        port_group: port_group
                        select: Select Ports to activate

                    """

        class PortGroups(AvdIndexedList[str, PortGroupsItem]):
            """Subclass of AvdIndexedList with `PortGroupsItem` items. Primary key is `port_group` (`str`)."""

            _primary_key: ClassVar[str] = "port_group"

        PortGroups._item_type = PortGroupsItem

        _fields: ClassVar[dict] = {"access_list": {"type": AccessList}, "speed_groups": {"type": SpeedGroups}, "port_groups": {"type": PortGroups}}
        access_list: AccessList
        """Subclass of AvdModel."""
        speed_groups: SpeedGroups
        """Subclass of AvdIndexedList with `SpeedGroupsItem` items. Primary key is `speed_group` (`str`)."""
        port_groups: PortGroups
        """Subclass of AvdIndexedList with `PortGroupsItem` items. Primary key is `port_group` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                access_list: AccessList | UndefinedType = Undefined,
                speed_groups: SpeedGroups | UndefinedType = Undefined,
                port_groups: PortGroups | UndefinedType = Undefined,
            ) -> None:
                """
                Hardware.


                Subclass of AvdModel.

                Args:
                    access_list: Subclass of AvdModel.
                    speed_groups: Subclass of AvdIndexedList with `SpeedGroupsItem` items. Primary key is `speed_group` (`str`).
                    port_groups: Subclass of AvdIndexedList with `PortGroupsItem` items. Primary key is `port_group` (`str`).

                """

    class HardwareCounters(AvdModel):
        """Subclass of AvdModel."""

        class FeaturesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "direction": {"type": str},
                "enabled": {"type": bool, "default": True},
                "address_type": {"type": str},
                "layer3": {"type": bool},
                "vrf": {"type": str},
                "prefix": {"type": str},
                "units_packets": {"type": bool},
            }
            name: Literal[
                "acl",
                "decap-group",
                "directflow",
                "ecn",
                "flow-spec",
                "gre tunnel interface",
                "ip",
                "mpls interface",
                "mpls lfib",
                "mpls tunnel",
                "multicast",
                "nexthop",
                "pbr",
                "pdp",
                "policing interface",
                "qos",
                "qos dual-rate-policer",
                "route",
                "routed-port",
                "segment-security",
                "subinterface",
                "tapagg",
                "traffic-class",
                "traffic-policy",
                "traffic-policy vlan-interface",
                "vlan",
                "vlan-interface",
                "vni decap",
                "vni encap",
                "vtep decap",
                "vtep encap",
            ]
            direction: Literal["in", "out", "cpu"] | None
            """
            Most features support only 'in' and 'out'. Some like traffic-policy support 'cpu'.
            Some features DO
            NOT have any direction.
            This validation IS NOT made by the schemas.
            """
            enabled: bool
            """Default value: `True`"""
            address_type: Literal["ipv4", "ipv6", "mac"] | None
            """
            Supported only for the following features:
            - acl: [ipv4, ipv6, mac] if direction is 'out'
            -
            multicast: [ipv4, ipv6]
            - route: [ipv4, ipv6]
            This validation IS NOT made by the schemas.
            """
            layer3: bool | None
            """Supported only for the 'ip' feature."""
            vrf: str | None
            """
            Supported only for the 'route' feature.
            This validation IS NOT made by the schemas.
            """
            prefix: str | None
            """
            Supported only for the 'route' feature.
            Mandatory for the 'route' feature.
            This validation IS NOT
            made by the schemas.
            """
            units_packets: bool | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: Literal[
                        "acl",
                        "decap-group",
                        "directflow",
                        "ecn",
                        "flow-spec",
                        "gre tunnel interface",
                        "ip",
                        "mpls interface",
                        "mpls lfib",
                        "mpls tunnel",
                        "multicast",
                        "nexthop",
                        "pbr",
                        "pdp",
                        "policing interface",
                        "qos",
                        "qos dual-rate-policer",
                        "route",
                        "routed-port",
                        "segment-security",
                        "subinterface",
                        "tapagg",
                        "traffic-class",
                        "traffic-policy",
                        "traffic-policy vlan-interface",
                        "vlan",
                        "vlan-interface",
                        "vni decap",
                        "vni encap",
                        "vtep decap",
                        "vtep encap",
                    ]
                    | UndefinedType = Undefined,
                    direction: Literal["in", "out", "cpu"] | None | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    address_type: Literal["ipv4", "ipv6", "mac"] | None | UndefinedType = Undefined,
                    layer3: bool | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    prefix: str | None | UndefinedType = Undefined,
                    units_packets: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    FeaturesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        direction:
                           Most features support only 'in' and 'out'. Some like traffic-policy support 'cpu'.
                           Some features DO
                           NOT have any direction.
                           This validation IS NOT made by the schemas.
                        enabled: enabled
                        address_type:
                           Supported only for the following features:
                           - acl: [ipv4, ipv6, mac] if direction is 'out'
                           -
                           multicast: [ipv4, ipv6]
                           - route: [ipv4, ipv6]
                           This validation IS NOT made by the schemas.
                        layer3: Supported only for the 'ip' feature.
                        vrf:
                           Supported only for the 'route' feature.
                           This validation IS NOT made by the schemas.
                        prefix:
                           Supported only for the 'route' feature.
                           Mandatory for the 'route' feature.
                           This validation IS NOT
                           made by the schemas.
                        units_packets: units_packets

                    """

        class Features(AvdList[FeaturesItem]):
            """Subclass of AvdList with `FeaturesItem` items."""

        Features._item_type = FeaturesItem

        _fields: ClassVar[dict] = {"features": {"type": Features}}
        features: Features
        """
        This data model allows to configure the list of hardware counters feature
        available on Arista
        platforms.

        The `name` key accepts a list of valid_values which MUST be updated to support
        new
        feature as they are released in EOS.

        The available values of the different keys like 'direction' or
        'address_type'
        are feature and hardware dependent and this model DOES NOT validate that the
        combinations are valid. It is the responsibility of the user of this data model
        to make sure that
        the rendered CLI is accepted by the targeted device.

        Examples:

          * Use:
            ```yaml
        hardware_counters:
              features:
                - name: ip
                  direction: out
                  layer3:
        true
                  units_packets: true
            ```

            to render:
            ```eos
            hardware counter feature
        ip out layer3 units packets
            ```
          * Use:
            ```yaml
            hardware_counters:
              features:
        - name: route
                  address_type: ipv4
                  vrf: test
                  prefix: 192.168.0.0/24
        ```

            to render:
            ```eos
            hardware counter feature route ipv4 vrf test 192.168.0.0/24
        ```


        Subclass of AvdList with `FeaturesItem` items.
        """

        if TYPE_CHECKING:

            def __init__(self, *, features: Features | UndefinedType = Undefined) -> None:
                """
                HardwareCounters.


                Subclass of AvdModel.

                Args:
                    features:
                       This data model allows to configure the list of hardware counters feature
                       available on Arista
                       platforms.

                       The `name` key accepts a list of valid_values which MUST be updated to support
                       new
                       feature as they are released in EOS.

                       The available values of the different keys like 'direction' or
                       'address_type'
                       are feature and hardware dependent and this model DOES NOT validate that the
                       combinations are valid. It is the responsibility of the user of this data model
                       to make sure that
                       the rendered CLI is accepted by the targeted device.

                       Examples:  # fmt: skip

                         * Use:
                           ```yaml
                       hardware_counters:
                             features:
                               - name: ip
                                 direction: out
                                 layer3:
                       true
                                 units_packets: true
                           ```

                           to render:
                           ```eos
                           hardware counter feature
                       ip out layer3 units packets
                           ```
                         * Use:
                           ```yaml
                           hardware_counters:
                             features:
                       - name: route
                                 address_type: ipv4
                                 vrf: test
                                 prefix: 192.168.0.0/24
                       ```

                           to render:
                           ```eos
                           hardware counter feature route ipv4 vrf test 192.168.0.0/24
                       ```


                       Subclass of AvdList with `FeaturesItem` items.

                """

    class InterfaceDefaults(AvdModel):
        """Subclass of AvdModel."""

        class Ethernet(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"shutdown": {"type": bool}}
            shutdown: bool | None

            if TYPE_CHECKING:

                def __init__(self, *, shutdown: bool | None | UndefinedType = Undefined) -> None:
                    """
                    Ethernet.


                    Subclass of AvdModel.

                    Args:
                        shutdown: shutdown

                    """

        _fields: ClassVar[dict] = {"ethernet": {"type": Ethernet}, "mtu": {"type": int}}
        ethernet: Ethernet
        """Subclass of AvdModel."""
        mtu: int | None

        if TYPE_CHECKING:

            def __init__(self, *, ethernet: Ethernet | UndefinedType = Undefined, mtu: int | None | UndefinedType = Undefined) -> None:
                """
                InterfaceDefaults.


                Subclass of AvdModel.

                Args:
                    ethernet: Subclass of AvdModel.
                    mtu: mtu

                """

    class InterfaceGroupsItem(AvdModel):
        """Subclass of AvdModel."""

        class Interfaces(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Interfaces._item_type = str

        class BgpMaintenanceProfiles(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        BgpMaintenanceProfiles._item_type = str

        class InterfaceMaintenanceProfiles(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        InterfaceMaintenanceProfiles._item_type = str

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "interfaces": {"type": Interfaces},
            "bgp_maintenance_profiles": {"type": BgpMaintenanceProfiles},
            "interface_maintenance_profiles": {"type": InterfaceMaintenanceProfiles},
        }
        name: str
        """Interface-Group name."""
        interfaces: Interfaces
        """Subclass of AvdList with `str` items."""
        bgp_maintenance_profiles: BgpMaintenanceProfiles
        """Subclass of AvdList with `str` items."""
        interface_maintenance_profiles: InterfaceMaintenanceProfiles
        """Subclass of AvdList with `str` items."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                interfaces: Interfaces | UndefinedType = Undefined,
                bgp_maintenance_profiles: BgpMaintenanceProfiles | UndefinedType = Undefined,
                interface_maintenance_profiles: InterfaceMaintenanceProfiles | UndefinedType = Undefined,
            ) -> None:
                """
                InterfaceGroupsItem.


                Subclass of AvdModel.

                Args:
                    name: Interface-Group name.
                    interfaces: Subclass of AvdList with `str` items.
                    bgp_maintenance_profiles: Subclass of AvdList with `str` items.
                    interface_maintenance_profiles: Subclass of AvdList with `str` items.

                """

    class InterfaceGroups(AvdIndexedList[str, InterfaceGroupsItem]):
        """Subclass of AvdIndexedList with `InterfaceGroupsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    InterfaceGroups._item_type = InterfaceGroupsItem

    class InterfaceProfilesItem(AvdModel):
        """Subclass of AvdModel."""

        class Commands(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Commands._item_type = str

        _fields: ClassVar[dict] = {"name": {"type": str}, "commands": {"type": Commands}}
        name: str
        """Interface-Profile Name."""
        commands: Commands
        """Subclass of AvdList with `str` items."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, commands: Commands | UndefinedType = Undefined) -> None:
                """
                InterfaceProfilesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface-Profile Name.
                    commands: Subclass of AvdList with `str` items.

                """

    class InterfaceProfiles(AvdIndexedList[str, InterfaceProfilesItem]):
        """Subclass of AvdIndexedList with `InterfaceProfilesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    InterfaceProfiles._item_type = InterfaceProfilesItem

    class IpAccessListsItem(AvdModel):
        """Subclass of AvdModel."""

        class EntriesItem(AvdModel):
            """Subclass of AvdModel."""

            class SourcePorts(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            SourcePorts._item_type = str

            class DestinationPorts(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            DestinationPorts._item_type = str

            class TcpFlags(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            TcpFlags._item_type = str

            _fields: ClassVar[dict] = {
                "sequence": {"type": int},
                "remark": {"type": str},
                "action": {"type": str},
                "protocol": {"type": str},
                "source": {"type": str},
                "source_ports_match": {"type": str, "default": "eq"},
                "source_ports": {"type": SourcePorts},
                "destination": {"type": str},
                "destination_ports_match": {"type": str, "default": "eq"},
                "destination_ports": {"type": DestinationPorts},
                "tcp_flags": {"type": TcpFlags},
                "fragments": {"type": bool},
                "log": {"type": bool},
                "ttl": {"type": int},
                "ttl_match": {"type": str, "default": "eq"},
                "icmp_type": {"type": str},
                "icmp_code": {"type": str},
                "nexthop_group": {"type": str},
                "tracked": {"type": bool},
                "dscp": {"type": str},
                "vlan_number": {"type": int},
                "vlan_inner": {"type": bool, "default": False},
                "vlan_mask": {"type": str},
            }
            sequence: int | None
            """ACL entry sequence number."""
            remark: str | None
            """
            Comment up to 100 characters.
            If remark is defined, other keys in the ACL entry will be ignored.
            """
            action: Literal["permit", "deny"] | None
            """
            ACL action.
            Required except for remarks.
            """
            protocol: str | None
            """
            "ip", "tcp", "udp", "icmp" or other protocol name or number.
            Required except for remarks.
            """
            source: str | None
            """
            "any", "<ip>/<mask>" or "<ip>".
            "<ip>" without a mask means host.
            Required except for remarks.
            """
            source_ports_match: Literal["eq", "gt", "lt", "neq", "range"]
            """Default value: `"eq"`"""
            source_ports: SourcePorts
            """Subclass of AvdList with `str` items."""
            destination: str | None
            """
            "any", "<ip>/<mask>" or "<ip>".
            "<ip>" without a mask means host.
            Required except for remarks.
            """
            destination_ports_match: Literal["eq", "gt", "lt", "neq", "range"]
            """Default value: `"eq"`"""
            destination_ports: DestinationPorts
            """Subclass of AvdList with `str` items."""
            tcp_flags: TcpFlags
            """Subclass of AvdList with `str` items."""
            fragments: bool | None
            """Match non-head fragment packets."""
            log: bool | None
            """Log matches against this rule."""
            ttl: int | None
            """TTL value."""
            ttl_match: Literal["eq", "gt", "lt", "neq"]
            """Default value: `"eq"`"""
            icmp_type: str | None
            """Message type name/number for ICMP packets."""
            icmp_code: str | None
            """Message code for ICMP packets."""
            nexthop_group: str | None
            """nexthop-group name."""
            tracked: bool | None
            """Match packets in existing ICMP/UDP/TCP connections."""
            dscp: str | None
            """DSCP value or name."""
            vlan_number: int | None
            vlan_inner: bool
            """Default value: `False`"""
            vlan_mask: str | None
            """0x000-0xFFF VLAN mask."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | None | UndefinedType = Undefined,
                    remark: str | None | UndefinedType = Undefined,
                    action: Literal["permit", "deny"] | None | UndefinedType = Undefined,
                    protocol: str | None | UndefinedType = Undefined,
                    source: str | None | UndefinedType = Undefined,
                    source_ports_match: Literal["eq", "gt", "lt", "neq", "range"] | UndefinedType = Undefined,
                    source_ports: SourcePorts | UndefinedType = Undefined,
                    destination: str | None | UndefinedType = Undefined,
                    destination_ports_match: Literal["eq", "gt", "lt", "neq", "range"] | UndefinedType = Undefined,
                    destination_ports: DestinationPorts | UndefinedType = Undefined,
                    tcp_flags: TcpFlags | UndefinedType = Undefined,
                    fragments: bool | None | UndefinedType = Undefined,
                    log: bool | None | UndefinedType = Undefined,
                    ttl: int | None | UndefinedType = Undefined,
                    ttl_match: Literal["eq", "gt", "lt", "neq"] | UndefinedType = Undefined,
                    icmp_type: str | None | UndefinedType = Undefined,
                    icmp_code: str | None | UndefinedType = Undefined,
                    nexthop_group: str | None | UndefinedType = Undefined,
                    tracked: bool | None | UndefinedType = Undefined,
                    dscp: str | None | UndefinedType = Undefined,
                    vlan_number: int | None | UndefinedType = Undefined,
                    vlan_inner: bool | UndefinedType = Undefined,
                    vlan_mask: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    EntriesItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: ACL entry sequence number.
                        remark:
                           Comment up to 100 characters.
                           If remark is defined, other keys in the ACL entry will be ignored.
                        action:
                           ACL action.
                           Required except for remarks.
                        protocol:
                           "ip", "tcp", "udp", "icmp" or other protocol name or number.
                           Required except for remarks.
                        source:
                           "any", "<ip>/<mask>" or "<ip>".
                           "<ip>" without a mask means host.
                           Required except for remarks.
                        source_ports_match: source_ports_match
                        source_ports: Subclass of AvdList with `str` items.
                        destination:
                           "any", "<ip>/<mask>" or "<ip>".
                           "<ip>" without a mask means host.
                           Required except for remarks.
                        destination_ports_match: destination_ports_match
                        destination_ports: Subclass of AvdList with `str` items.
                        tcp_flags: Subclass of AvdList with `str` items.
                        fragments: Match non-head fragment packets.
                        log: Log matches against this rule.
                        ttl: TTL value.
                        ttl_match: ttl_match
                        icmp_type: Message type name/number for ICMP packets.
                        icmp_code: Message code for ICMP packets.
                        nexthop_group: nexthop-group name.
                        tracked: Match packets in existing ICMP/UDP/TCP connections.
                        dscp: DSCP value or name.
                        vlan_number: vlan_number
                        vlan_inner: vlan_inner
                        vlan_mask: 0x000-0xFFF VLAN mask.

                    """

        class Entries(AvdList[EntriesItem]):
            """Subclass of AvdList with `EntriesItem` items."""

        Entries._item_type = EntriesItem

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "entries": {"type": Entries},
            "permit_response_traffic": {"type": str},
        }
        name: str
        """Access-list Name."""
        counters_per_entry: bool | None
        entries: Entries
        """
        ACL Entries.

        Subclass of AvdList with `EntriesItem` items.
        """
        permit_response_traffic: Literal["nat"] | None
        """
        Permit response traffic automatically based on NAT translations.
        Minimum EOS version requirement
        4.32.2F.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                counters_per_entry: bool | None | UndefinedType = Undefined,
                entries: Entries | UndefinedType = Undefined,
                permit_response_traffic: Literal["nat"] | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpAccessListsItem.


                Subclass of AvdModel.

                Args:
                    name: Access-list Name.
                    counters_per_entry: counters_per_entry
                    entries:
                       ACL Entries.

                       Subclass of AvdList with `EntriesItem` items.
                    permit_response_traffic:
                       Permit response traffic automatically based on NAT translations.
                       Minimum EOS version requirement
                       4.32.2F.

                """

    class IpAccessLists(AvdIndexedList[str, IpAccessListsItem]):
        """Subclass of AvdIndexedList with `IpAccessListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    IpAccessLists._item_type = IpAccessListsItem

    class IpCommunityListsItem(AvdModel):
        """Subclass of AvdModel."""

        class EntriesItem(AvdModel):
            """Subclass of AvdModel."""

            class Communities(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Communities._item_type = str

            _fields: ClassVar[dict] = {"action": {"type": str}, "communities": {"type": Communities}, "regexp": {"type": str}}
            action: Literal["permit", "deny"]
            communities: Communities
            """
            If defined, a standard community-list will be configured.
            Supported community strings (case
            insensitive):
            - GSHUT
            - internet
            - local-as
            - no-advertise
            - no-export
            - <1-4294967040>
            - aa:nn
            Subclass of AvdList with `str` items.
            """
            regexp: str | None
            """
            Regular Expression.
            If defined, a regex community-list will be configured.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    action: Literal["permit", "deny"] | UndefinedType = Undefined,
                    communities: Communities | UndefinedType = Undefined,
                    regexp: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    EntriesItem.


                    Subclass of AvdModel.

                    Args:
                        action: action
                        communities:
                           If defined, a standard community-list will be configured.
                           Supported community strings (case
                           insensitive):
                           - GSHUT
                           - internet
                           - local-as
                           - no-advertise
                           - no-export
                           - <1-4294967040>
                           - aa:nn
                           Subclass of AvdList with `str` items.
                        regexp:
                           Regular Expression.
                           If defined, a regex community-list will be configured.

                    """

        class Entries(AvdList[EntriesItem]):
            """Subclass of AvdList with `EntriesItem` items."""

        Entries._item_type = EntriesItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "entries": {"type": Entries}}
        name: str
        """IP Community-list Name."""
        entries: Entries
        """Subclass of AvdList with `EntriesItem` items."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, entries: Entries | UndefinedType = Undefined) -> None:
                """
                IpCommunityListsItem.


                Subclass of AvdModel.

                Args:
                    name: IP Community-list Name.
                    entries: Subclass of AvdList with `EntriesItem` items.

                """

    class IpCommunityLists(AvdIndexedList[str, IpCommunityListsItem]):
        """Subclass of AvdIndexedList with `IpCommunityListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    IpCommunityLists._item_type = IpCommunityListsItem

    class IpDhcpRelay(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"always_on": {"type": bool}, "all_subnets": {"type": bool}, "information_option": {"type": bool}}
        always_on: bool | None
        """DhcpRelay Agent will be in always-on mode."""
        all_subnets: bool | None
        """Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field."""
        information_option: bool | None
        """Insert Option-82 information."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                always_on: bool | None | UndefinedType = Undefined,
                all_subnets: bool | None | UndefinedType = Undefined,
                information_option: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpDhcpRelay.


                Subclass of AvdModel.

                Args:
                    always_on: DhcpRelay Agent will be in always-on mode.
                    all_subnets: Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field.
                    information_option: Insert Option-82 information.

                """

    class IpDhcpSnooping(AvdModel):
        """Subclass of AvdModel."""

        class InformationOption(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "circuit_id_type": {"type": str}, "circuit_id_format": {"type": str}}
            enabled: bool | None
            """Enable insertion of option-82 in DHCP request packets."""
            circuit_id_type: str | None
            """"none" or <0 - 255>."""
            circuit_id_format: Literal["%h:%p", "%p:%v"] | None
            """
            Required if `circuit_id_type` is set.
            - "%h:%p" Hostname and interface name
            - "%p:%v" Interface name
            and VLAN ID
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    circuit_id_type: str | None | UndefinedType = Undefined,
                    circuit_id_format: Literal["%h:%p", "%p:%v"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    InformationOption.


                    Subclass of AvdModel.

                    Args:
                        enabled: Enable insertion of option-82 in DHCP request packets.
                        circuit_id_type: "none" or <0 - 255>.
                        circuit_id_format:
                           Required if `circuit_id_type` is set.
                           - "%h:%p" Hostname and interface name
                           - "%p:%v" Interface name
                           and VLAN ID

                    """

        _fields: ClassVar[dict] = {
            "enabled": {"type": bool},
            "bridging": {"type": bool},
            "information_option": {"type": InformationOption},
            "vlan": {"type": str},
        }
        enabled: bool | None
        bridging: bool | None
        information_option: InformationOption
        """Subclass of AvdModel."""
        vlan: str | None
        """
        VLAN range as string.
        "< vlan_id >, < vlan_id >-< vlan_id >"
        Example: 15,16,17,18
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enabled: bool | None | UndefinedType = Undefined,
                bridging: bool | None | UndefinedType = Undefined,
                information_option: InformationOption | UndefinedType = Undefined,
                vlan: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpDhcpSnooping.


                Subclass of AvdModel.

                Args:
                    enabled: enabled
                    bridging: bridging
                    information_option: Subclass of AvdModel.
                    vlan:
                       VLAN range as string.
                       "< vlan_id >, < vlan_id >-< vlan_id >"
                       Example: 15,16,17,18

                """

    class IpDomainLookup(AvdModel):
        """Subclass of AvdModel."""

        class SourceInterfacesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
            name: str
            """Source Interface."""
            vrf: str | None

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                    """
                    SourceInterfacesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Source Interface.
                        vrf: vrf

                    """

        class SourceInterfaces(AvdIndexedList[str, SourceInterfacesItem]):
            """Subclass of AvdIndexedList with `SourceInterfacesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        SourceInterfaces._item_type = SourceInterfacesItem

        _fields: ClassVar[dict] = {"source_interfaces": {"type": SourceInterfaces}}
        source_interfaces: SourceInterfaces
        """Subclass of AvdIndexedList with `SourceInterfacesItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(self, *, source_interfaces: SourceInterfaces | UndefinedType = Undefined) -> None:
                """
                IpDomainLookup.


                Subclass of AvdModel.

                Args:
                    source_interfaces: Subclass of AvdIndexedList with `SourceInterfacesItem` items. Primary key is `name` (`str`).

                """

    class IpExtcommunityListsItem(AvdModel):
        """Subclass of AvdModel."""

        class EntriesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"type": {"type": str}, "extcommunities": {"type": str}}
            type: Literal["permit", "deny"]
            extcommunities: str
            """
            Communities as string.
            Example: "65000:65000"
            """

            if TYPE_CHECKING:

                def __init__(self, *, type: Literal["permit", "deny"] | UndefinedType = Undefined, extcommunities: str | UndefinedType = Undefined) -> None:
                    """
                    EntriesItem.


                    Subclass of AvdModel.

                    Args:
                        type: type
                        extcommunities:
                           Communities as string.
                           Example: "65000:65000"

                    """

        class Entries(AvdList[EntriesItem]):
            """Subclass of AvdList with `EntriesItem` items."""

        Entries._item_type = EntriesItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "entries": {"type": Entries}}
        name: str
        """Community-list Name."""
        entries: Entries
        """Subclass of AvdList with `EntriesItem` items."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, entries: Entries | UndefinedType = Undefined) -> None:
                """
                IpExtcommunityListsItem.


                Subclass of AvdModel.

                Args:
                    name: Community-list Name.
                    entries: Subclass of AvdList with `EntriesItem` items.

                """

    class IpExtcommunityLists(AvdIndexedList[str, IpExtcommunityListsItem]):
        """Subclass of AvdIndexedList with `IpExtcommunityListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    IpExtcommunityLists._item_type = IpExtcommunityListsItem

    class IpExtcommunityListsRegexpItem(AvdModel):
        """Subclass of AvdModel."""

        class EntriesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"type": {"type": str}, "regexp": {"type": str}}
            type: Literal["permit", "deny"]
            regexp: str
            """Regular Expression."""

            if TYPE_CHECKING:

                def __init__(self, *, type: Literal["permit", "deny"] | UndefinedType = Undefined, regexp: str | UndefinedType = Undefined) -> None:
                    """
                    EntriesItem.


                    Subclass of AvdModel.

                    Args:
                        type: type
                        regexp: Regular Expression.

                    """

        class Entries(AvdList[EntriesItem]):
            """Subclass of AvdList with `EntriesItem` items."""

        Entries._item_type = EntriesItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "entries": {"type": Entries}}
        name: str
        """Community-list Name."""
        entries: Entries
        """Subclass of AvdList with `EntriesItem` items."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, entries: Entries | UndefinedType = Undefined) -> None:
                """
                IpExtcommunityListsRegexpItem.


                Subclass of AvdModel.

                Args:
                    name: Community-list Name.
                    entries: Subclass of AvdList with `EntriesItem` items.

                """

    class IpExtcommunityListsRegexp(AvdIndexedList[str, IpExtcommunityListsRegexpItem]):
        """
        Subclass of AvdIndexedList with `IpExtcommunityListsRegexpItem` items. Primary key is `name`
        (`str`).
        """

        _primary_key: ClassVar[str] = "name"

    IpExtcommunityListsRegexp._item_type = IpExtcommunityListsRegexpItem

    class IpFtpClientSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
        name: str
        """Interface Name."""
        vrf: str | None
        """VRF Name."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                """
                IpFtpClientSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface Name.
                    vrf: VRF Name.

                """

    class IpFtpClientSourceInterfaces(AvdList[IpFtpClientSourceInterfacesItem]):
        """Subclass of AvdList with `IpFtpClientSourceInterfacesItem` items."""

    IpFtpClientSourceInterfaces._item_type = IpFtpClientSourceInterfacesItem

    class IpHardware(AvdModel):
        """Subclass of AvdModel."""

        class Fib(AvdModel):
            """Subclass of AvdModel."""

            class Optimize(AvdModel):
                """Subclass of AvdModel."""

                class Prefixes(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}}
                    profile: Literal["internet", "urpf-internet"] | None

                    if TYPE_CHECKING:

                        def __init__(self, *, profile: Literal["internet", "urpf-internet"] | None | UndefinedType = Undefined) -> None:
                            """
                            Prefixes.


                            Subclass of AvdModel.

                            Args:
                                profile: profile

                            """

                _fields: ClassVar[dict] = {"prefixes": {"type": Prefixes}}
                prefixes: Prefixes
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, prefixes: Prefixes | UndefinedType = Undefined) -> None:
                        """
                        Optimize.


                        Subclass of AvdModel.

                        Args:
                            prefixes: Subclass of AvdModel.

                        """

            class LoadBalanceDistribution(AvdModel):
                """Subclass of AvdModel."""

                class Dynamic(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "flow_set_size": {"type": int}}
                    enabled: bool
                    """Enable dynamic load balancing."""
                    flow_set_size: int | None
                    """
                    Set flow set size. Requires `enabled` key to be set to `true`.
                    1: Allow up to 128 ECMP groups of 256
                    entries each.
                    2: Allow up to 64 ECMP groups of 512 entries each.
                    3: Allow up to 32 ECMP groups of
                    1024 entries each.
                    4: Allow up to 16 ECMP groups of 2048 entries each.
                    5: Allow up to 8 ECMP groups
                    of 4096 entries each.
                    6: Allow up to 4 ECMP groups of 8192 entries each.
                    7: Allow up to 2 ECMP
                    groups of 16384 entries each.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, flow_set_size: int | None | UndefinedType = Undefined) -> None:
                            """
                            Dynamic.


                            Subclass of AvdModel.

                            Args:
                                enabled: Enable dynamic load balancing.
                                flow_set_size:
                                   Set flow set size. Requires `enabled` key to be set to `true`.
                                   1: Allow up to 128 ECMP groups of 256
                                   entries each.
                                   2: Allow up to 64 ECMP groups of 512 entries each.
                                   3: Allow up to 32 ECMP groups of
                                   1024 entries each.
                                   4: Allow up to 16 ECMP groups of 2048 entries each.
                                   5: Allow up to 8 ECMP groups
                                   of 4096 entries each.
                                   6: Allow up to 4 ECMP groups of 8192 entries each.
                                   7: Allow up to 2 ECMP
                                   groups of 16384 entries each.

                            """

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}}
                dynamic: Dynamic
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, dynamic: Dynamic | UndefinedType = Undefined) -> None:
                        """
                        LoadBalanceDistribution.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"optimize": {"type": Optimize}, "load_balance_distribution": {"type": LoadBalanceDistribution}}
            optimize: Optimize
            """Subclass of AvdModel."""
            load_balance_distribution: LoadBalanceDistribution
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, optimize: Optimize | UndefinedType = Undefined, load_balance_distribution: LoadBalanceDistribution | UndefinedType = Undefined
                ) -> None:
                    """
                    Fib.


                    Subclass of AvdModel.

                    Args:
                        optimize: Subclass of AvdModel.
                        load_balance_distribution: Subclass of AvdModel.

                    """

        _fields: ClassVar[dict] = {"fib": {"type": Fib}}
        fib: Fib
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, fib: Fib | UndefinedType = Undefined) -> None:
                """
                IpHardware.


                Subclass of AvdModel.

                Args:
                    fib: Subclass of AvdModel.

                """

    class IpHttpClientSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
        name: str | None
        """Interface Name."""
        vrf: str | None

        if TYPE_CHECKING:

            def __init__(self, *, name: str | None | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                """
                IpHttpClientSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface Name.
                    vrf: vrf

                """

    class IpHttpClientSourceInterfaces(AvdList[IpHttpClientSourceInterfacesItem]):
        """Subclass of AvdList with `IpHttpClientSourceInterfacesItem` items."""

    IpHttpClientSourceInterfaces._item_type = IpHttpClientSourceInterfacesItem

    class IpIgmpSnooping(AvdModel):
        """Subclass of AvdModel."""

        class Querier(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "address": {"type": str},
                "query_interval": {"type": int},
                "max_response_time": {"type": int},
                "last_member_query_interval": {"type": int},
                "last_member_query_count": {"type": int},
                "startup_query_interval": {"type": int},
                "startup_query_count": {"type": int},
                "version": {"type": int},
            }
            enabled: bool | None
            address: str | None
            """IP Address."""
            query_interval: int | None
            max_response_time: int | None
            last_member_query_interval: int | None
            last_member_query_count: int | None
            startup_query_interval: int | None
            startup_query_count: int | None
            version: int | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    address: str | None | UndefinedType = Undefined,
                    query_interval: int | None | UndefinedType = Undefined,
                    max_response_time: int | None | UndefinedType = Undefined,
                    last_member_query_interval: int | None | UndefinedType = Undefined,
                    last_member_query_count: int | None | UndefinedType = Undefined,
                    startup_query_interval: int | None | UndefinedType = Undefined,
                    startup_query_count: int | None | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Querier.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        address: IP Address.
                        query_interval: query_interval
                        max_response_time: max_response_time
                        last_member_query_interval: last_member_query_interval
                        last_member_query_count: last_member_query_count
                        startup_query_interval: startup_query_interval
                        startup_query_count: startup_query_count
                        version: version

                    """

        class VlansItem(AvdModel):
            """Subclass of AvdModel."""

            class Querier(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "address": {"type": str},
                    "query_interval": {"type": int},
                    "max_response_time": {"type": int},
                    "last_member_query_interval": {"type": int},
                    "last_member_query_count": {"type": int},
                    "startup_query_interval": {"type": int},
                    "startup_query_count": {"type": int},
                    "version": {"type": int},
                }
                enabled: bool | None
                address: str | None
                """IP Address."""
                query_interval: int | None
                max_response_time: int | None
                last_member_query_interval: int | None
                last_member_query_count: int | None
                startup_query_interval: int | None
                startup_query_count: int | None
                version: int | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        address: str | None | UndefinedType = Undefined,
                        query_interval: int | None | UndefinedType = Undefined,
                        max_response_time: int | None | UndefinedType = Undefined,
                        last_member_query_interval: int | None | UndefinedType = Undefined,
                        last_member_query_count: int | None | UndefinedType = Undefined,
                        startup_query_interval: int | None | UndefinedType = Undefined,
                        startup_query_count: int | None | UndefinedType = Undefined,
                        version: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Querier.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            address: IP Address.
                            query_interval: query_interval
                            max_response_time: max_response_time
                            last_member_query_interval: last_member_query_interval
                            last_member_query_count: last_member_query_count
                            startup_query_interval: startup_query_interval
                            startup_query_count: startup_query_count
                            version: version

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "enabled": {"type": bool},
                "querier": {"type": Querier},
                "max_groups": {"type": int},
                "fast_leave": {"type": bool},
                "proxy": {"type": bool},
            }
            id: int
            """VLAN ID."""
            enabled: bool | None
            querier: Querier
            """Subclass of AvdModel."""
            max_groups: int | None
            fast_leave: bool | None
            proxy: bool | None
            """Global proxy settings should be enabled before enabling per-vlan."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    querier: Querier | UndefinedType = Undefined,
                    max_groups: int | None | UndefinedType = Undefined,
                    fast_leave: bool | None | UndefinedType = Undefined,
                    proxy: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    VlansItem.


                    Subclass of AvdModel.

                    Args:
                        id: VLAN ID.
                        enabled: enabled
                        querier: Subclass of AvdModel.
                        max_groups: max_groups
                        fast_leave: fast_leave
                        proxy: Global proxy settings should be enabled before enabling per-vlan.

                    """

        class Vlans(AvdIndexedList[int, VlansItem]):
            """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        Vlans._item_type = VlansItem

        _fields: ClassVar[dict] = {
            "globally_enabled": {"type": bool, "default": True},
            "robustness_variable": {"type": int},
            "restart_query_interval": {"type": int},
            "interface_restart_query": {"type": int},
            "fast_leave": {"type": bool},
            "querier": {"type": Querier},
            "proxy": {"type": bool},
            "vlans": {"type": Vlans},
        }
        globally_enabled: bool
        """
        Activate or deactivate IGMP snooping for all vlans where `vlans` allows user to activate /
        deactivate IGMP snooping per vlan.

        Default value: `True`
        """
        robustness_variable: int | None
        restart_query_interval: int | None
        interface_restart_query: int | None
        fast_leave: bool | None
        querier: Querier
        """Subclass of AvdModel."""
        proxy: bool | None
        vlans: Vlans
        """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                globally_enabled: bool | UndefinedType = Undefined,
                robustness_variable: int | None | UndefinedType = Undefined,
                restart_query_interval: int | None | UndefinedType = Undefined,
                interface_restart_query: int | None | UndefinedType = Undefined,
                fast_leave: bool | None | UndefinedType = Undefined,
                querier: Querier | UndefinedType = Undefined,
                proxy: bool | None | UndefinedType = Undefined,
                vlans: Vlans | UndefinedType = Undefined,
            ) -> None:
                """
                IpIgmpSnooping.


                Subclass of AvdModel.

                Args:
                    globally_enabled:
                       Activate or deactivate IGMP snooping for all vlans where `vlans` allows user to activate /
                       deactivate IGMP snooping per vlan.
                    robustness_variable: robustness_variable
                    restart_query_interval: restart_query_interval
                    interface_restart_query: interface_restart_query
                    fast_leave: fast_leave
                    querier: Subclass of AvdModel.
                    proxy: proxy
                    vlans: Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`).

                """

    class IpNameServerGroupsItem(AvdModel):
        """Subclass of AvdModel."""

        class NameServersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ip_address": {"type": str}, "vrf": {"type": str}, "priority": {"type": int}}
            ip_address: str
            """IPv4 or IPv6 address for DNS server."""
            vrf: str
            """VRF Name."""
            priority: int | None
            """Priority value (lower is first)."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, ip_address: str | UndefinedType = Undefined, vrf: str | UndefinedType = Undefined, priority: int | None | UndefinedType = Undefined
                ) -> None:
                    """
                    NameServersItem.


                    Subclass of AvdModel.

                    Args:
                        ip_address: IPv4 or IPv6 address for DNS server.
                        vrf: VRF Name.
                        priority: Priority value (lower is first).

                    """

        class NameServers(AvdList[NameServersItem]):
            """Subclass of AvdList with `NameServersItem` items."""

        NameServers._item_type = NameServersItem

        class IpDomainLists(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        IpDomainLists._item_type = str

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "name_servers": {"type": NameServers},
            "dns_domain": {"type": str},
            "ip_domain_list": {"type": str},
            "ip_domain_lists": {"type": IpDomainLists},
        }
        name: str
        name_servers: NameServers
        """Subclass of AvdList with `NameServersItem` items."""
        dns_domain: str | None
        ip_domain_list: str | None
        """Set domain names to complete unqualified host names."""
        ip_domain_lists: IpDomainLists
        """
        Set domain names to complete unqualified host names.

        Subclass of AvdList with `str` items.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                name_servers: NameServers | UndefinedType = Undefined,
                dns_domain: str | None | UndefinedType = Undefined,
                ip_domain_list: str | None | UndefinedType = Undefined,
                ip_domain_lists: IpDomainLists | UndefinedType = Undefined,
            ) -> None:
                """
                IpNameServerGroupsItem.


                Subclass of AvdModel.

                Args:
                    name: name
                    name_servers: Subclass of AvdList with `NameServersItem` items.
                    dns_domain: dns_domain
                    ip_domain_list: Set domain names to complete unqualified host names.
                    ip_domain_lists:
                       Set domain names to complete unqualified host names.

                       Subclass of AvdList with `str` items.

                """

    class IpNameServerGroups(AvdIndexedList[str, IpNameServerGroupsItem]):
        """Subclass of AvdIndexedList with `IpNameServerGroupsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    IpNameServerGroups._item_type = IpNameServerGroupsItem

    class IpNameServersItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"ip_address": {"type": str}, "vrf": {"type": str}, "priority": {"type": int}}
        ip_address: str
        """IPv4 or IPv6 address for DNS server."""
        vrf: str | None
        """VRF Name."""
        priority: int | None
        """Priority value (lower is first)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                ip_address: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                priority: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpNameServersItem.


                Subclass of AvdModel.

                Args:
                    ip_address: IPv4 or IPv6 address for DNS server.
                    vrf: VRF Name.
                    priority: Priority value (lower is first).

                """

    class IpNameServers(AvdList[IpNameServersItem]):
        """Subclass of AvdList with `IpNameServersItem` items."""

    IpNameServers._item_type = IpNameServersItem

    class IpNat(AvdModel):
        """Subclass of AvdModel."""

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class Destination(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"access_list": {"type": str}, "comment": {"type": str}, "pool_name": {"type": str}, "priority": {"type": int}}
                    access_list: str
                    comment: str | None
                    pool_name: str
                    priority: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            pool_name: str | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                pool_name: pool_name
                                priority: priority

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, dynamic: Dynamic | UndefinedType = Undefined, static: Static | UndefinedType = Undefined) -> None:
                        """
                        Destination.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.

                        """

            class Source(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "nat_type": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                    }
                    access_list: str
                    comment: str | None
                    nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"]
                    pool_name: str | None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"] | UndefinedType = Undefined,
                            pool_name: str | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                nat_type: nat_type
                                pool_name:
                                   required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                                   ignored if 'nat_type' is
                                   overload.
                                priority: priority

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, dynamic: Dynamic | UndefinedType = Undefined, static: Static | UndefinedType = Undefined) -> None:
                        """
                        Source.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "destination": {"type": Destination}, "source": {"type": Source}}
            name: str
            vrf: str | None
            """Specify VRF for NAT profile."""
            destination: Destination
            """Subclass of AvdModel."""
            source: Source
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    destination: Destination | UndefinedType = Undefined,
                    source: Source | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        vrf: Specify VRF for NAT profile.
                        destination: Subclass of AvdModel.
                        source: Subclass of AvdModel.

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        class PoolsItem(AvdModel):
            """Subclass of AvdModel."""

            class RangesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"first_ip": {"type": str}, "last_ip": {"type": str}, "first_port": {"type": int}, "last_port": {"type": int}}
                first_ip: str | None
                """
                IPv4 address.
                Required when `type` is `ip-port` and ignored otherwise.
                """
                last_ip: str | None
                """
                IPv4 address.
                Required when `type` is `ip-port` and ignored otherwise.
                `first_ip` and `last_ip` ip
                addresses should lie in same subnet.
                """
                first_port: int | None
                last_port: int | None
                """
                Required when `first_port` is set.
                `last_port` must be greater than or equal to `first_port`.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        first_ip: str | None | UndefinedType = Undefined,
                        last_ip: str | None | UndefinedType = Undefined,
                        first_port: int | None | UndefinedType = Undefined,
                        last_port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RangesItem.


                        Subclass of AvdModel.

                        Args:
                            first_ip:
                               IPv4 address.
                               Required when `type` is `ip-port` and ignored otherwise.
                            last_ip:
                               IPv4 address.
                               Required when `type` is `ip-port` and ignored otherwise.
                               `first_ip` and `last_ip` ip
                               addresses should lie in same subnet.
                            first_port: first_port
                            last_port:
                               Required when `first_port` is set.
                               `last_port` must be greater than or equal to `first_port`.

                        """

            class Ranges(AvdList[RangesItem]):
                """Subclass of AvdList with `RangesItem` items."""

            Ranges._item_type = RangesItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "type": {"type": str, "default": "ip-port"},
                "prefix_length": {"type": int},
                "ranges": {"type": Ranges},
                "utilization_log_threshold": {"type": int},
            }
            name: str
            type: Literal["ip-port", "port-only"]
            """Default value: `"ip-port"`"""
            prefix_length: int | None
            """It is only used and required when `type` is `ip-port`."""
            ranges: Ranges
            """Subclass of AvdList with `RangesItem` items."""
            utilization_log_threshold: int | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    type: Literal["ip-port", "port-only"] | UndefinedType = Undefined,
                    prefix_length: int | None | UndefinedType = Undefined,
                    ranges: Ranges | UndefinedType = Undefined,
                    utilization_log_threshold: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PoolsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        type: type
                        prefix_length: It is only used and required when `type` is `ip-port`.
                        ranges: Subclass of AvdList with `RangesItem` items.
                        utilization_log_threshold: utilization_log_threshold

                    """

        class Pools(AvdIndexedList[str, PoolsItem]):
            """Subclass of AvdIndexedList with `PoolsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Pools._item_type = PoolsItem

        class Synchronization(AvdModel):
            """Subclass of AvdModel."""

            class PortRange(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"first_port": {"type": int}, "last_port": {"type": int}, "split_disabled": {"type": bool}}
                first_port: int | None
                last_port: int | None
                """>= first_port."""
                split_disabled: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        first_port: int | None | UndefinedType = Undefined,
                        last_port: int | None | UndefinedType = Undefined,
                        split_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PortRange.


                        Subclass of AvdModel.

                        Args:
                            first_port: first_port
                            last_port: >= first_port.
                            split_disabled: split_disabled

                        """

            _fields: ClassVar[dict] = {
                "description": {"type": str},
                "expiry_interval": {"type": int},
                "local_interface": {"type": str},
                "peer_address": {"type": str},
                "port_range": {"type": PortRange},
                "shutdown": {"type": bool},
            }
            description: str | None
            expiry_interval: int | None
            """In seconds."""
            local_interface: str | None
            """EOS interface name."""
            peer_address: str | None
            """IPv4 address."""
            port_range: PortRange
            """Subclass of AvdModel."""
            shutdown: bool | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    description: str | None | UndefinedType = Undefined,
                    expiry_interval: int | None | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    peer_address: str | None | UndefinedType = Undefined,
                    port_range: PortRange | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Synchronization.


                    Subclass of AvdModel.

                    Args:
                        description: description
                        expiry_interval: In seconds.
                        local_interface: EOS interface name.
                        peer_address: IPv4 address.
                        port_range: Subclass of AvdModel.
                        shutdown: shutdown

                    """

        class Translation(AvdModel):
            """Subclass of AvdModel."""

            class AddressSelection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"any": {"type": bool}, "hash_field_source_ip": {"type": bool}}
                any: bool | None
                hash_field_source_ip: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, any: bool | None | UndefinedType = Undefined, hash_field_source_ip: bool | None | UndefinedType = Undefined) -> None:
                        """
                        AddressSelection.


                        Subclass of AvdModel.

                        Args:
                            any: any
                            hash_field_source_ip: hash_field_source_ip

                        """

            class LowMark(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"percentage": {"type": int}, "host_percentage": {"type": int}}
                percentage: int | None
                """Used to render 'ip nat translation low-mark <percentage>'."""
                host_percentage: int | None
                """Used to render 'ip nat translation low-mark <host_percentage> host'."""

                if TYPE_CHECKING:

                    def __init__(self, *, percentage: int | None | UndefinedType = Undefined, host_percentage: int | None | UndefinedType = Undefined) -> None:
                        """
                        LowMark.


                        Subclass of AvdModel.

                        Args:
                            percentage: Used to render 'ip nat translation low-mark <percentage>'.
                            host_percentage: Used to render 'ip nat translation low-mark <host_percentage> host'.

                        """

            class MaxEntries(AvdModel):
                """Subclass of AvdModel."""

                class IpLimitsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ip": {"type": str}, "limit": {"type": int}}
                    ip: str
                    """IPv4 address."""
                    limit: int

                    if TYPE_CHECKING:

                        def __init__(self, *, ip: str | UndefinedType = Undefined, limit: int | UndefinedType = Undefined) -> None:
                            """
                            IpLimitsItem.


                            Subclass of AvdModel.

                            Args:
                                ip: IPv4 address.
                                limit: limit

                            """

                class IpLimits(AvdIndexedList[str, IpLimitsItem]):
                    """Subclass of AvdIndexedList with `IpLimitsItem` items. Primary key is `ip` (`str`)."""

                    _primary_key: ClassVar[str] = "ip"

                IpLimits._item_type = IpLimitsItem

                _fields: ClassVar[dict] = {"limit": {"type": int}, "host_limit": {"type": int}, "ip_limits": {"type": IpLimits}}
                limit: int | None
                host_limit: int | None
                ip_limits: IpLimits
                """Subclass of AvdIndexedList with `IpLimitsItem` items. Primary key is `ip` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        limit: int | None | UndefinedType = Undefined,
                        host_limit: int | None | UndefinedType = Undefined,
                        ip_limits: IpLimits | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MaxEntries.


                        Subclass of AvdModel.

                        Args:
                            limit: limit
                            host_limit: host_limit
                            ip_limits: Subclass of AvdIndexedList with `IpLimitsItem` items. Primary key is `ip` (`str`).

                        """

            class TimeoutsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"protocol": {"type": str}, "timeout": {"type": int}}
                protocol: Literal["tcp", "udp"]
                timeout: int
                """In seconds."""

                if TYPE_CHECKING:

                    def __init__(self, *, protocol: Literal["tcp", "udp"] | UndefinedType = Undefined, timeout: int | UndefinedType = Undefined) -> None:
                        """
                        TimeoutsItem.


                        Subclass of AvdModel.

                        Args:
                            protocol: protocol
                            timeout: In seconds.

                        """

            class Timeouts(AvdIndexedList[str, TimeoutsItem]):
                """Subclass of AvdIndexedList with `TimeoutsItem` items. Primary key is `protocol` (`str`)."""

                _primary_key: ClassVar[str] = "protocol"

            Timeouts._item_type = TimeoutsItem

            _fields: ClassVar[dict] = {
                "address_selection": {"type": AddressSelection},
                "counters": {"type": bool},
                "low_mark": {"type": LowMark},
                "max_entries": {"type": MaxEntries},
                "timeouts": {"type": Timeouts},
            }
            address_selection: AddressSelection
            """Subclass of AvdModel."""
            counters: bool | None
            low_mark: LowMark
            """Subclass of AvdModel."""
            max_entries: MaxEntries
            """Subclass of AvdModel."""
            timeouts: Timeouts
            """Subclass of AvdIndexedList with `TimeoutsItem` items. Primary key is `protocol` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    address_selection: AddressSelection | UndefinedType = Undefined,
                    counters: bool | None | UndefinedType = Undefined,
                    low_mark: LowMark | UndefinedType = Undefined,
                    max_entries: MaxEntries | UndefinedType = Undefined,
                    timeouts: Timeouts | UndefinedType = Undefined,
                ) -> None:
                    """
                    Translation.


                    Subclass of AvdModel.

                    Args:
                        address_selection: Subclass of AvdModel.
                        counters: counters
                        low_mark: Subclass of AvdModel.
                        max_entries: Subclass of AvdModel.
                        timeouts: Subclass of AvdIndexedList with `TimeoutsItem` items. Primary key is `protocol` (`str`).

                    """

        _fields: ClassVar[dict] = {
            "kernel_buffer_size": {"type": int},
            "profiles": {"type": Profiles},
            "pools": {"type": Pools},
            "synchronization": {"type": Synchronization},
            "translation": {"type": Translation},
        }
        kernel_buffer_size: int | None
        """Buffer size in MB."""
        profiles: Profiles
        """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""
        pools: Pools
        """Subclass of AvdIndexedList with `PoolsItem` items. Primary key is `name` (`str`)."""
        synchronization: Synchronization
        """Subclass of AvdModel."""
        translation: Translation
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                kernel_buffer_size: int | None | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
                pools: Pools | UndefinedType = Undefined,
                synchronization: Synchronization | UndefinedType = Undefined,
                translation: Translation | UndefinedType = Undefined,
            ) -> None:
                """
                IpNat.


                Subclass of AvdModel.

                Args:
                    kernel_buffer_size: Buffer size in MB.
                    profiles: Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`).
                    pools: Subclass of AvdIndexedList with `PoolsItem` items. Primary key is `name` (`str`).
                    synchronization: Subclass of AvdModel.
                    translation: Subclass of AvdModel.

                """

    class IpRadiusSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
        name: str | None
        """Interface Name."""
        vrf: str | None
        """VRF Name."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | None | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                """
                IpRadiusSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface Name.
                    vrf: VRF Name.

                """

    class IpRadiusSourceInterfaces(AvdList[IpRadiusSourceInterfacesItem]):
        """Subclass of AvdList with `IpRadiusSourceInterfacesItem` items."""

    IpRadiusSourceInterfaces._item_type = IpRadiusSourceInterfacesItem

    class IpSecurity(AvdModel):
        """Subclass of AvdModel."""

        class IkePoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "local_id": {"type": str},
                "local_id_fqdn": {"type": str},
                "ike_lifetime": {"type": int},
                "encryption": {"type": str},
                "dh_group": {"type": int},
                "integrity": {"type": str},
            }
            name: str
            """Policy name."""
            local_id: str | None
            """
            Local IKE identification.
            Can be an IPv4 or an IPv6 address.
            If both `local_id` and `local_id_fqdn`
            are set, `local_id_fqdn` takes precedence.
            """
            local_id_fqdn: str | None
            """
            Local FQDN or UFQDN IKE identification.
            If both `local_id` and `local_id_fqdn` are set,
            `local_id_fqdn` takes precedence.
            """
            ike_lifetime: int | None
            """IKE lifetime in hours."""
            encryption: Literal["3des", "aes128", "aes256"] | None
            """IKE encryption algorithm."""
            dh_group: Literal[1, 2, 5, 14, 15, 16, 17, 19, 20, 21, 24] | None
            """Diffie-Hellman group for the key exchange."""
            integrity: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None
            """Integrity algorithm."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    local_id: str | None | UndefinedType = Undefined,
                    local_id_fqdn: str | None | UndefinedType = Undefined,
                    ike_lifetime: int | None | UndefinedType = Undefined,
                    encryption: Literal["3des", "aes128", "aes256"] | None | UndefinedType = Undefined,
                    dh_group: Literal[1, 2, 5, 14, 15, 16, 17, 19, 20, 21, 24] | None | UndefinedType = Undefined,
                    integrity: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    IkePoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Policy name.
                        local_id:
                           Local IKE identification.
                           Can be an IPv4 or an IPv6 address.
                           If both `local_id` and `local_id_fqdn`
                           are set, `local_id_fqdn` takes precedence.
                        local_id_fqdn:
                           Local FQDN or UFQDN IKE identification.
                           If both `local_id` and `local_id_fqdn` are set,
                           `local_id_fqdn` takes precedence.
                        ike_lifetime: IKE lifetime in hours.
                        encryption: IKE encryption algorithm.
                        dh_group: Diffie-Hellman group for the key exchange.
                        integrity: Integrity algorithm.

                    """

        class IkePolicies(AvdIndexedList[str, IkePoliciesItem]):
            """Subclass of AvdIndexedList with `IkePoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        IkePolicies._item_type = IkePoliciesItem

        class SaPoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class SaLifetime(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"value": {"type": int}, "unit": {"type": str, "default": "hours"}}
                value: int | None
                """
                Lifetime value for this SA.
                Valid range depends on the unit.
                <1-24>       Lifetime in hours (
                default )
                <1-4000000>  Packet limit in thousands
                <1-6000>     Byte limit in GB ( 1024 MB )
                <1-6144000>  Byte limit in MB ( 1024 KB )
                """
                unit: Literal["gigabytes", "hours", "megabytes", "thousand-packets"]
                """Default value: `"hours"`"""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        value: int | None | UndefinedType = Undefined,
                        unit: Literal["gigabytes", "hours", "megabytes", "thousand-packets"] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SaLifetime.


                        Subclass of AvdModel.

                        Args:
                            value:
                               Lifetime value for this SA.
                               Valid range depends on the unit.
                               <1-24>       Lifetime in hours (
                               default )
                               <1-4000000>  Packet limit in thousands
                               <1-6000>     Byte limit in GB ( 1024 MB )
                               <1-6144000>  Byte limit in MB ( 1024 KB )
                            unit: unit

                        """

            class Esp(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"integrity": {"type": str}, "encryption": {"type": str}}
                integrity: Literal["disabled", "sha1", "sha256", "sha384", "sha512", "md5"] | None
                encryption: Literal["disabled", "aes128", "aes128gcm128", "aes128gcm64", "aes256", "aes256gcm128", "3des"] | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        integrity: Literal["disabled", "sha1", "sha256", "sha384", "sha512", "md5"] | None | UndefinedType = Undefined,
                        encryption: Literal["disabled", "aes128", "aes128gcm128", "aes128gcm64", "aes256", "aes256gcm128", "3des"]
                        | None
                        | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Esp.


                        Subclass of AvdModel.

                        Args:
                            integrity: integrity
                            encryption: encryption

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "sa_lifetime": {"type": SaLifetime}, "esp": {"type": Esp}, "pfs_dh_group": {"type": int}}
            name: str
            """Name of the SA policy."""
            sa_lifetime: SaLifetime
            """Subclass of AvdModel."""
            esp: Esp
            """Subclass of AvdModel."""
            pfs_dh_group: Literal[1, 2, 5, 14, 15, 16, 17, 19, 20, 21, 24] | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    sa_lifetime: SaLifetime | UndefinedType = Undefined,
                    esp: Esp | UndefinedType = Undefined,
                    pfs_dh_group: Literal[1, 2, 5, 14, 15, 16, 17, 19, 20, 21, 24] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SaPoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Name of the SA policy.
                        sa_lifetime: Subclass of AvdModel.
                        esp: Subclass of AvdModel.
                        pfs_dh_group: pfs_dh_group

                    """

        class SaPolicies(AvdIndexedList[str, SaPoliciesItem]):
            """Subclass of AvdIndexedList with `SaPoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        SaPolicies._item_type = SaPoliciesItem

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class Dpd(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "time": {"type": int}, "action": {"type": str}}
                interval: int
                """Interval (in seconds) between keep-alive messages."""
                time: int
                """Time (in seconds) after which the action is applied."""
                action: Literal["clear", "hold", "restart"]
                """
                Action to apply.

                * 'clear': Delete all connections
                * 'hold': Re-negotiate connection on demand
                *
                'restart': Restart connection immediately
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interval: int | UndefinedType = Undefined,
                        time: int | UndefinedType = Undefined,
                        action: Literal["clear", "hold", "restart"] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dpd.


                        Subclass of AvdModel.

                        Args:
                            interval: Interval (in seconds) between keep-alive messages.
                            time: Time (in seconds) after which the action is applied.
                            action:
                               Action to apply.

                               * 'clear': Delete all connections
                               * 'hold': Re-negotiate connection on demand
                               *
                               'restart': Restart connection immediately

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "ike_policy": {"type": str},
                "sa_policy": {"type": str},
                "connection": {"type": str},
                "shared_key": {"type": str},
                "dpd": {"type": Dpd},
                "mode": {"type": str},
                "flow_parallelization_encapsulation_udp": {"type": bool},
            }
            name: str
            """Name of the IPsec profile."""
            ike_policy: str | None
            """Name of the IKE policy to use in this profile."""
            sa_policy: str | None
            """Name of the Security Association to use in this profile."""
            connection: Literal["add", "start", "route"] | None
            """IPsec connection (Initiator/Responder/Dynamic)."""
            shared_key: str | None
            """Encrypted password - only type 7 supported."""
            dpd: Dpd
            """
            Dead Peer Detection.

            Subclass of AvdModel.
            """
            mode: Literal["transport", "tunnel"] | None
            """Ipsec mode type."""
            flow_parallelization_encapsulation_udp: bool | None
            """
            Enable flow parallelization.
            When enabled, multiple cores are used to parallelize the IPsec
            encryption and decryption processing.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    ike_policy: str | None | UndefinedType = Undefined,
                    sa_policy: str | None | UndefinedType = Undefined,
                    connection: Literal["add", "start", "route"] | None | UndefinedType = Undefined,
                    shared_key: str | None | UndefinedType = Undefined,
                    dpd: Dpd | UndefinedType = Undefined,
                    mode: Literal["transport", "tunnel"] | None | UndefinedType = Undefined,
                    flow_parallelization_encapsulation_udp: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Name of the IPsec profile.
                        ike_policy: Name of the IKE policy to use in this profile.
                        sa_policy: Name of the Security Association to use in this profile.
                        connection: IPsec connection (Initiator/Responder/Dynamic).
                        shared_key: Encrypted password - only type 7 supported.
                        dpd:
                           Dead Peer Detection.

                           Subclass of AvdModel.
                        mode: Ipsec mode type.
                        flow_parallelization_encapsulation_udp:
                           Enable flow parallelization.
                           When enabled, multiple cores are used to parallelize the IPsec
                           encryption and decryption processing.

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        class KeyController(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"profile": {"type": str}}
            profile: str | None
            """IPsec profile name to use."""

            if TYPE_CHECKING:

                def __init__(self, *, profile: str | None | UndefinedType = Undefined) -> None:
                    """
                    KeyController.


                    Subclass of AvdModel.

                    Args:
                        profile: IPsec profile name to use.

                    """

        _fields: ClassVar[dict] = {
            "ike_policies": {"type": IkePolicies},
            "sa_policies": {"type": SaPolicies},
            "profiles": {"type": Profiles},
            "key_controller": {"type": KeyController},
            "hardware_encryption_disabled": {"type": bool, "default": False},
            "connection_tx_interface_match_source_ip": {"type": bool},
        }
        ike_policies: IkePolicies
        """
        Internet Security Association and Key Mgmt Protocol.

        Subclass of AvdIndexedList with
        `IkePoliciesItem` items. Primary key is `name` (`str`).
        """
        sa_policies: SaPolicies
        """
        Security Association policies.

        Subclass of AvdIndexedList with `SaPoliciesItem` items. Primary key
        is `name` (`str`).
        """
        profiles: Profiles
        """
        IPSec profiles.

        Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name`
        (`str`).
        """
        key_controller: KeyController
        """Subclass of AvdModel."""
        hardware_encryption_disabled: bool
        """
        Disable hardware encryption.
        An SFE restart is needed for this change to take effect.

        Default value: `False`
        """
        connection_tx_interface_match_source_ip: bool | None
        """Match source interface of the IPsec connection."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                ike_policies: IkePolicies | UndefinedType = Undefined,
                sa_policies: SaPolicies | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
                key_controller: KeyController | UndefinedType = Undefined,
                hardware_encryption_disabled: bool | UndefinedType = Undefined,
                connection_tx_interface_match_source_ip: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpSecurity.


                Subclass of AvdModel.

                Args:
                    ike_policies:
                       Internet Security Association and Key Mgmt Protocol.

                       Subclass of AvdIndexedList with
                       `IkePoliciesItem` items. Primary key is `name` (`str`).
                    sa_policies:
                       Security Association policies.

                       Subclass of AvdIndexedList with `SaPoliciesItem` items. Primary key
                       is `name` (`str`).
                    profiles:
                       IPSec profiles.

                       Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name`
                       (`str`).
                    key_controller: Subclass of AvdModel.
                    hardware_encryption_disabled:
                       Disable hardware encryption.
                       An SFE restart is needed for this change to take effect.
                    connection_tx_interface_match_source_ip: Match source interface of the IPsec connection.

                """

    class IpSshClientSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
        name: str | None
        """Interface Name."""
        vrf: str | None

        if TYPE_CHECKING:

            def __init__(self, *, name: str | None | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                """
                IpSshClientSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface Name.
                    vrf: vrf

                """

    class IpSshClientSourceInterfaces(AvdList[IpSshClientSourceInterfacesItem]):
        """Subclass of AvdList with `IpSshClientSourceInterfacesItem` items."""

    IpSshClientSourceInterfaces._item_type = IpSshClientSourceInterfacesItem

    class IpTacacsSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
        name: str | None
        """Interface name."""
        vrf: str | None

        if TYPE_CHECKING:

            def __init__(self, *, name: str | None | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                """
                IpTacacsSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface name.
                    vrf: vrf

                """

    class IpTacacsSourceInterfaces(AvdList[IpTacacsSourceInterfacesItem]):
        """Subclass of AvdList with `IpTacacsSourceInterfacesItem` items."""

    IpTacacsSourceInterfaces._item_type = IpTacacsSourceInterfacesItem

    class IpTelnetClientSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
        name: str
        """Interface Name."""
        vrf: str | None
        """VRF Name."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                """
                IpTelnetClientSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface Name.
                    vrf: VRF Name.

                """

    class IpTelnetClientSourceInterfaces(AvdList[IpTelnetClientSourceInterfacesItem]):
        """Subclass of AvdList with `IpTelnetClientSourceInterfacesItem` items."""

    IpTelnetClientSourceInterfaces._item_type = IpTelnetClientSourceInterfacesItem

    class IpTftpClientSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
        name: str
        """Interface Name."""
        vrf: str | None
        """VRF Name."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                """
                IpTftpClientSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface Name.
                    vrf: VRF Name.

                """

    class IpTftpClientSourceInterfaces(AvdList[IpTftpClientSourceInterfacesItem]):
        """Subclass of AvdList with `IpTftpClientSourceInterfacesItem` items."""

    IpTftpClientSourceInterfaces._item_type = IpTftpClientSourceInterfacesItem

    class Ipv6AccessListsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}}
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "deny ipv6 any any"
            """

            if TYPE_CHECKING:

                def __init__(self, *, sequence: int | UndefinedType = Undefined, action: str | UndefinedType = Undefined) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        action:
                           Action as string.
                           Example: "deny ipv6 any any"

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "counters_per_entry": {"type": bool}, "sequence_numbers": {"type": SequenceNumbers}}
        name: str
        """IPv6 Access-list Name."""
        counters_per_entry: bool | None
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                counters_per_entry: bool | None | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6AccessListsItem.


                Subclass of AvdModel.

                Args:
                    name: IPv6 Access-list Name.
                    counters_per_entry: counters_per_entry
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).

                """

    class Ipv6AccessLists(AvdIndexedList[str, Ipv6AccessListsItem]):
        """Subclass of AvdIndexedList with `Ipv6AccessListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Ipv6AccessLists._item_type = Ipv6AccessListsItem

    class Ipv6DhcpRelay(AvdModel):
        """Subclass of AvdModel."""

        class Option(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"link_layer_address": {"type": bool}, "remote_id_format": {"type": str}}
            link_layer_address: bool | None
            """Add Option 79 (Link Layer Address Option)."""
            remote_id_format: Literal["%m:%i", "%m:%p"] | None
            """
            Add RemoteID option 37 in format MAC address and interface ID (`%m:%i`) or MAC address and interface
            name (`%m:%p`).
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    link_layer_address: bool | None | UndefinedType = Undefined,
                    remote_id_format: Literal["%m:%i", "%m:%p"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Option.


                    Subclass of AvdModel.

                    Args:
                        link_layer_address: Add Option 79 (Link Layer Address Option).
                        remote_id_format:
                           Add RemoteID option 37 in format MAC address and interface ID (`%m:%i`) or MAC address and interface
                           name (`%m:%p`).

                    """

        _fields: ClassVar[dict] = {"always_on": {"type": bool}, "all_subnets": {"type": bool}, "option": {"type": Option}}
        always_on: bool | None
        """DhcpRelay Agent will be in always-on mode, off by default."""
        all_subnets: bool | None
        """Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field."""
        option: Option
        """
        Insert DHCP Option.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                always_on: bool | None | UndefinedType = Undefined,
                all_subnets: bool | None | UndefinedType = Undefined,
                option: Option | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6DhcpRelay.


                Subclass of AvdModel.

                Args:
                    always_on: DhcpRelay Agent will be in always-on mode, off by default.
                    all_subnets: Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field.
                    option:
                       Insert DHCP Option.

                       Subclass of AvdModel.

                """

    class Ipv6Hardware(AvdModel):
        """Subclass of AvdModel."""

        class Fib(AvdModel):
            """Subclass of AvdModel."""

            class Optimize(AvdModel):
                """Subclass of AvdModel."""

                class Prefixes(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}}
                    profile: str | None
                    """Pre-defined profile 'internet' or user-defined profile name."""

                    if TYPE_CHECKING:

                        def __init__(self, *, profile: str | None | UndefinedType = Undefined) -> None:
                            """
                            Prefixes.


                            Subclass of AvdModel.

                            Args:
                                profile: Pre-defined profile 'internet' or user-defined profile name.

                            """

                _fields: ClassVar[dict] = {"prefixes": {"type": Prefixes}}
                prefixes: Prefixes
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, prefixes: Prefixes | UndefinedType = Undefined) -> None:
                        """
                        Optimize.


                        Subclass of AvdModel.

                        Args:
                            prefixes: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"optimize": {"type": Optimize}}
            optimize: Optimize
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, optimize: Optimize | UndefinedType = Undefined) -> None:
                    """
                    Fib.


                    Subclass of AvdModel.

                    Args:
                        optimize: Subclass of AvdModel.

                    """

        _fields: ClassVar[dict] = {"fib": {"type": Fib}}
        fib: Fib
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, fib: Fib | UndefinedType = Undefined) -> None:
                """
                Ipv6Hardware.


                Subclass of AvdModel.

                Args:
                    fib: Subclass of AvdModel.

                """

    class Ipv6Neighbor(AvdModel):
        """Subclass of AvdModel."""

        class StaticEntriesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv6_address": {"type": str}, "vrf": {"type": str}, "interface": {"type": str}, "mac_address": {"type": str}}
            ipv6_address: str
            """IPv6 address of neighbor."""
            vrf: str | None
            interface: str
            """Interface name."""
            mac_address: str
            """MAC address of neighbor like 'aa:af:12:34:bc:bf'"""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv6_address: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    interface: str | UndefinedType = Undefined,
                    mac_address: str | UndefinedType = Undefined,
                ) -> None:
                    """
                    StaticEntriesItem.


                    Subclass of AvdModel.

                    Args:
                        ipv6_address: IPv6 address of neighbor.
                        vrf: vrf
                        interface: Interface name.
                        mac_address: MAC address of neighbor like 'aa:af:12:34:bc:bf'

                    """

        class StaticEntries(AvdList[StaticEntriesItem]):
            """Subclass of AvdList with `StaticEntriesItem` items."""

        StaticEntries._item_type = StaticEntriesItem

        class Persistent(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "refresh_delay": {"type": int}}
            enabled: bool
            """Restore the IPv6 neighbor cache after reboot."""
            refresh_delay: int | None
            """
            Time to wait in seconds before refreshing the IPv6 neighbor cache after reboot (EOS default 600).
            It
            will require setting the `enabled` key to true.
            """

            if TYPE_CHECKING:

                def __init__(self, *, enabled: bool | UndefinedType = Undefined, refresh_delay: int | None | UndefinedType = Undefined) -> None:
                    """
                    Persistent.


                    Subclass of AvdModel.

                    Args:
                        enabled: Restore the IPv6 neighbor cache after reboot.
                        refresh_delay:
                           Time to wait in seconds before refreshing the IPv6 neighbor cache after reboot (EOS default 600).
                           It
                           will require setting the `enabled` key to true.

                    """

        _fields: ClassVar[dict] = {"static_entries": {"type": StaticEntries}, "persistent": {"type": Persistent}}
        static_entries: StaticEntries
        """
        Static IPv6 neighbor entries.

        Subclass of AvdList with `StaticEntriesItem` items.
        """
        persistent: Persistent
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, static_entries: StaticEntries | UndefinedType = Undefined, persistent: Persistent | UndefinedType = Undefined) -> None:
                """
                Ipv6Neighbor.


                Subclass of AvdModel.

                Args:
                    static_entries:
                       Static IPv6 neighbor entries.

                       Subclass of AvdList with `StaticEntriesItem` items.
                    persistent: Subclass of AvdModel.

                """

    class Ipv6PrefixListsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}}
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "permit 1b11:3a00:22b0:0082::/64 eq 128"
            """

            if TYPE_CHECKING:

                def __init__(self, *, sequence: int | UndefinedType = Undefined, action: str | UndefinedType = Undefined) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        action:
                           Action as string.
                           Example: "permit 1b11:3a00:22b0:0082::/64 eq 128"

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
        name: str
        """Prefix-list Name."""
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, sequence_numbers: SequenceNumbers | UndefinedType = Undefined) -> None:
                """
                Ipv6PrefixListsItem.


                Subclass of AvdModel.

                Args:
                    name: Prefix-list Name.
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).

                """

    class Ipv6PrefixLists(AvdIndexedList[str, Ipv6PrefixListsItem]):
        """Subclass of AvdIndexedList with `Ipv6PrefixListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Ipv6PrefixLists._item_type = Ipv6PrefixListsItem

    class Ipv6RouterOspf(AvdModel):
        """Subclass of AvdModel."""

        class ProcessIdsItem(AvdModel):
            """Subclass of AvdModel."""

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include leaked routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include leaked routes while redistributing.

                            """

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include leaked routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include leaked routes while redistributing.

                            """

                class Isis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool
                    isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    include_leaked: bool | None
                    """Include leaked routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                include_leaked: Include leaked routes while redistributing.

                            """

                class Ospfv3(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include leaked routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include leaked routes while redistributing.

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                    }
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPFv3 routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPFv3 routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPFv3 routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPFv3 routes.
                                match_external:
                                   Redistribute OSPFv3 routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPFv3 routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPFv3 routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map

                            """

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include leaked routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include leaked routes while redistributing.

                            """

                class Dhcp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            Dhcp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                _fields: ClassVar[dict] = {
                    "bgp": {"type": Bgp},
                    "connected": {"type": Connected},
                    "isis": {"type": Isis},
                    "ospfv3": {"type": Ospfv3},
                    "static": {"type": Static},
                    "dhcp": {"type": Dhcp},
                }
                bgp: Bgp
                """Subclass of AvdModel."""
                connected: Connected
                """Subclass of AvdModel."""
                isis: Isis
                """Subclass of AvdModel."""
                ospfv3: Ospfv3
                """Subclass of AvdModel."""
                static: Static
                """Subclass of AvdModel."""
                dhcp: Dhcp
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bgp: Bgp | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        dhcp: Dhcp | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            connected: Subclass of AvdModel.
                            isis: Subclass of AvdModel.
                            ospfv3: Subclass of AvdModel.
                            static: Subclass of AvdModel.
                            dhcp: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "vrf": {"type": str},
                "router_id": {"type": str},
                "redistribute": {"type": Redistribute},
                "auto_cost_reference_bandwidth": {"type": int},
            }
            id: int
            """OSPF process ID."""
            vrf: str | None
            """VRF name for OSPF process. Must be unique across all OSPFv3 instances."""
            router_id: str | None
            """IPv4 Address."""
            redistribute: Redistribute
            """
            Redistribute routes with OSPFv3.

            Subclass of AvdModel.
            """
            auto_cost_reference_bandwidth: int | None
            """Bandwidth in mbps."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    router_id: str | None | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    auto_cost_reference_bandwidth: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProcessIdsItem.


                    Subclass of AvdModel.

                    Args:
                        id: OSPF process ID.
                        vrf: VRF name for OSPF process. Must be unique across all OSPFv3 instances.
                        router_id: IPv4 Address.
                        redistribute:
                           Redistribute routes with OSPFv3.

                           Subclass of AvdModel.
                        auto_cost_reference_bandwidth: Bandwidth in mbps.

                    """

        class ProcessIds(AvdIndexedList[int, ProcessIdsItem]):
            """Subclass of AvdIndexedList with `ProcessIdsItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        ProcessIds._item_type = ProcessIdsItem

        _fields: ClassVar[dict] = {"process_ids": {"type": ProcessIds}}
        process_ids: ProcessIds
        """Subclass of AvdIndexedList with `ProcessIdsItem` items. Primary key is `id` (`int`)."""

        if TYPE_CHECKING:

            def __init__(self, *, process_ids: ProcessIds | UndefinedType = Undefined) -> None:
                """
                Ipv6RouterOspf.


                Subclass of AvdModel.

                Args:
                    process_ids: Subclass of AvdIndexedList with `ProcessIdsItem` items. Primary key is `id` (`int`).

                """

    class Ipv6StandardAccessListsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}}
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "deny ipv6 any any"
            """

            if TYPE_CHECKING:

                def __init__(self, *, sequence: int | UndefinedType = Undefined, action: str | UndefinedType = Undefined) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        action:
                           Action as string.
                           Example: "deny ipv6 any any"

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "counters_per_entry": {"type": bool}, "sequence_numbers": {"type": SequenceNumbers}}
        name: str
        """Access-list Name."""
        counters_per_entry: bool | None
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                counters_per_entry: bool | None | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6StandardAccessListsItem.


                Subclass of AvdModel.

                Args:
                    name: Access-list Name.
                    counters_per_entry: counters_per_entry
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).

                """

    class Ipv6StandardAccessLists(AvdIndexedList[str, Ipv6StandardAccessListsItem]):
        """Subclass of AvdIndexedList with `Ipv6StandardAccessListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Ipv6StandardAccessLists._item_type = Ipv6StandardAccessListsItem

    class Ipv6StaticRoutesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "vrf": {"type": str},
            "destination_address_prefix": {"type": str},
            "prefix": {"type": str},
            "interface": {"type": str},
            "gateway": {"type": str},
            "next_hop": {"type": str},
            "track_bfd": {"type": bool},
            "distance": {"type": int},
            "tag": {"type": int},
            "name": {"type": str},
            "metric": {"type": int},
        }
        vrf: str | None
        destination_address_prefix: str | None
        """IPv6 Network/Mask."""
        prefix: str | None
        """IPv6 Network/Mask."""
        interface: str | None
        gateway: str | None
        """IPv6 Address."""
        next_hop: str | None
        """IPv6 Address."""
        track_bfd: bool | None
        """Track next-hop using BFD."""
        distance: int | None
        tag: int | None
        name: str | None
        """Description."""
        metric: int | None

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                vrf: str | None | UndefinedType = Undefined,
                destination_address_prefix: str | None | UndefinedType = Undefined,
                prefix: str | None | UndefinedType = Undefined,
                interface: str | None | UndefinedType = Undefined,
                gateway: str | None | UndefinedType = Undefined,
                next_hop: str | None | UndefinedType = Undefined,
                track_bfd: bool | None | UndefinedType = Undefined,
                distance: int | None | UndefinedType = Undefined,
                tag: int | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                metric: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6StaticRoutesItem.


                Subclass of AvdModel.

                Args:
                    vrf: vrf
                    destination_address_prefix: IPv6 Network/Mask.
                    prefix: IPv6 Network/Mask.
                    interface: interface
                    gateway: IPv6 Address.
                    next_hop: IPv6 Address.
                    track_bfd: Track next-hop using BFD.
                    distance: distance
                    tag: tag
                    name: Description.
                    metric: metric

                """

    class Ipv6StaticRoutes(AvdList[Ipv6StaticRoutesItem]):
        """Subclass of AvdList with `Ipv6StaticRoutesItem` items."""

    Ipv6StaticRoutes._item_type = Ipv6StaticRoutesItem

    class Kernel(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"software_forwarding_ecmp": {"type": bool}}
        software_forwarding_ecmp: bool | None
        """Program ECMP routes in the kernel."""

        if TYPE_CHECKING:

            def __init__(self, *, software_forwarding_ecmp: bool | None | UndefinedType = Undefined) -> None:
                """
                Kernel.


                Subclass of AvdModel.

                Args:
                    software_forwarding_ecmp: Program ECMP routes in the kernel.

                """

    class L2Protocol(AvdModel):
        """Subclass of AvdModel."""

        class ForwardingProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class ProtocolsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "forward": {"type": bool},
                    "tagged_forward": {"type": bool},
                    "untagged_forward": {"type": bool},
                }
                name: Literal["bfd per-link rfc-7130", "e-lmi", "isis", "lacp", "lldp", "macsec", "pause", "stp"]
                forward: bool | None
                tagged_forward: bool | None
                untagged_forward: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: Literal["bfd per-link rfc-7130", "e-lmi", "isis", "lacp", "lldp", "macsec", "pause", "stp"] | UndefinedType = Undefined,
                        forward: bool | None | UndefinedType = Undefined,
                        tagged_forward: bool | None | UndefinedType = Undefined,
                        untagged_forward: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ProtocolsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            forward: forward
                            tagged_forward: tagged_forward
                            untagged_forward: untagged_forward

                        """

            class Protocols(AvdIndexedList[str, ProtocolsItem]):
                """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Protocols._item_type = ProtocolsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "protocols": {"type": Protocols}}
            name: str
            protocols: Protocols
            """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, protocols: Protocols | UndefinedType = Undefined) -> None:
                    """
                    ForwardingProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        protocols: Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `name` (`str`).

                    """

        class ForwardingProfiles(AvdIndexedList[str, ForwardingProfilesItem]):
            """Subclass of AvdIndexedList with `ForwardingProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        ForwardingProfiles._item_type = ForwardingProfilesItem

        _fields: ClassVar[dict] = {"forwarding_profiles": {"type": ForwardingProfiles}}
        forwarding_profiles: ForwardingProfiles
        """Subclass of AvdIndexedList with `ForwardingProfilesItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(self, *, forwarding_profiles: ForwardingProfiles | UndefinedType = Undefined) -> None:
                """
                L2Protocol.


                Subclass of AvdModel.

                Args:
                    forwarding_profiles: Subclass of AvdIndexedList with `ForwardingProfilesItem` items. Primary key is `name` (`str`).

                """

    class Lacp(AvdModel):
        """Subclass of AvdModel."""

        class PortId(AvdModel):
            """Subclass of AvdModel."""

            class Range(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"begin": {"type": int}, "end": {"type": int}}
                begin: int | None
                """Minimum LACP port-ID range."""
                end: int | None
                """Maximum LACP port-ID range."""

                if TYPE_CHECKING:

                    def __init__(self, *, begin: int | None | UndefinedType = Undefined, end: int | None | UndefinedType = Undefined) -> None:
                        """
                        Range.


                        Subclass of AvdModel.

                        Args:
                            begin: Minimum LACP port-ID range.
                            end: Maximum LACP port-ID range.

                        """

            _fields: ClassVar[dict] = {"range": {"type": Range}}
            range: Range
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, range: Range | UndefinedType = Undefined) -> None:
                    """
                    PortId.


                    Subclass of AvdModel.

                    Args:
                        range: Subclass of AvdModel.

                    """

        class RateLimit(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"default": {"type": bool}}
            default: bool | None
            """Enable LACPDU rate limiting by default on all ports."""

            if TYPE_CHECKING:

                def __init__(self, *, default: bool | None | UndefinedType = Undefined) -> None:
                    """
                    RateLimit.


                    Subclass of AvdModel.

                    Args:
                        default: Enable LACPDU rate limiting by default on all ports.

                    """

        _fields: ClassVar[dict] = {"port_id": {"type": PortId}, "rate_limit": {"type": RateLimit}, "system_priority": {"type": int}}
        port_id: PortId
        """
        LACP port-ID range configuration.

        Subclass of AvdModel.
        """
        rate_limit: RateLimit
        """
        Set LACPDU rate limit options.

        Subclass of AvdModel.
        """
        system_priority: int | None
        """Set local system LACP priority."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                port_id: PortId | UndefinedType = Undefined,
                rate_limit: RateLimit | UndefinedType = Undefined,
                system_priority: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Lacp.


                Subclass of AvdModel.

                Args:
                    port_id:
                       LACP port-ID range configuration.

                       Subclass of AvdModel.
                    rate_limit:
                       Set LACPDU rate limit options.

                       Subclass of AvdModel.
                    system_priority: Set local system LACP priority.

                """

    class LinkTrackingGroupsItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "links_minimum": {"type": int}, "recovery_delay": {"type": int}}
        name: str
        links_minimum: int | None
        recovery_delay: int | None

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                links_minimum: int | None | UndefinedType = Undefined,
                recovery_delay: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                LinkTrackingGroupsItem.


                Subclass of AvdModel.

                Args:
                    name: name
                    links_minimum: links_minimum
                    recovery_delay: recovery_delay

                """

    class LinkTrackingGroups(AvdIndexedList[str, LinkTrackingGroupsItem]):
        """Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    LinkTrackingGroups._item_type = LinkTrackingGroupsItem

    class Lldp(AvdModel):
        """Subclass of AvdModel."""

        class TlvsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "transmit": {"type": bool}}
            name: Literal[
                "link-aggregation",
                "management-address",
                "max-frame-size",
                "med",
                "port-description",
                "port-vlan",
                "power-via-mdi",
                "system-capabilities",
                "system-description",
                "system-name",
                "vlan-name",
            ]
            transmit: bool | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: Literal[
                        "link-aggregation",
                        "management-address",
                        "max-frame-size",
                        "med",
                        "port-description",
                        "port-vlan",
                        "power-via-mdi",
                        "system-capabilities",
                        "system-description",
                        "system-name",
                        "vlan-name",
                    ]
                    | UndefinedType = Undefined,
                    transmit: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TlvsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        transmit: transmit

                    """

        class Tlvs(AvdIndexedList[str, TlvsItem]):
            """Subclass of AvdIndexedList with `TlvsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Tlvs._item_type = TlvsItem

        _fields: ClassVar[dict] = {
            "timer": {"type": int},
            "timer_reinitialization": {"type": int},
            "holdtime": {"type": int},
            "management_address": {"type": str},
            "vrf": {"type": str},
            "receive_packet_tagged_drop": {"type": bool},
            "tlvs": {"type": Tlvs},
            "run": {"type": bool},
        }
        timer: int | None
        timer_reinitialization: int | None
        holdtime: int | None
        management_address: str | None
        vrf: str | None
        receive_packet_tagged_drop: bool | None
        tlvs: Tlvs
        """Subclass of AvdIndexedList with `TlvsItem` items. Primary key is `name` (`str`)."""
        run: bool | None

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                timer: int | None | UndefinedType = Undefined,
                timer_reinitialization: int | None | UndefinedType = Undefined,
                holdtime: int | None | UndefinedType = Undefined,
                management_address: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                receive_packet_tagged_drop: bool | None | UndefinedType = Undefined,
                tlvs: Tlvs | UndefinedType = Undefined,
                run: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Lldp.


                Subclass of AvdModel.

                Args:
                    timer: timer
                    timer_reinitialization: timer_reinitialization
                    holdtime: holdtime
                    management_address: management_address
                    vrf: vrf
                    receive_packet_tagged_drop: receive_packet_tagged_drop
                    tlvs: Subclass of AvdIndexedList with `TlvsItem` items. Primary key is `name` (`str`).
                    run: run

                """

    class LoadBalance(AvdModel):
        """Subclass of AvdModel."""

        class Policies(AvdModel):
            """Subclass of AvdModel."""

            class SandProfilesItem(AvdModel):
                """Subclass of AvdModel."""

                class Fields(AvdModel):
                    """Subclass of AvdModel."""

                    class Udp(AvdModel):
                        """Subclass of AvdModel."""

                        class Match(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"payload_bits": {"type": str}, "pattern": {"type": str}, "hash_payload_bytes": {"type": str}}
                            payload_bits: str
                            """
                            Specifies the bit positions within the UDP payload to match for hashing.
                            Accepts a single bit (e.g.,
                            "12"), a comma-separated list (e.g., "0,3,8"),
                            a range (e.g., "0-15"), or combinations (e.g.,
                            "0-7,9,12-15").
                            Valid values must be in the range 0 to 503.
                            Matching is limited to a maximum of 16
                            bits total.
                            """
                            pattern: str
                            """
                            Bit pattern to match in the UDP payload.
                            The value should be given as an hexadecimal format `0x...`.
                            The valid range is from 0 to (2^N - 1), where N is the number of bits selected in `payload_bits`.
                            """
                            hash_payload_bytes: str
                            """
                            Specifies the UDP payload byte positions to include in the hash after pattern match.
                            Accepts a
                            single byte (e.g., "5"), a comma-separated list (e.g., "0,3,7"),
                            a range (e.g., "0-15"), or a
                            combination (e.g., "0-5,8,12-14").
                            All byte positions must be within the range 0 to 62.
                            """

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    payload_bits: str | UndefinedType = Undefined,
                                    pattern: str | UndefinedType = Undefined,
                                    hash_payload_bytes: str | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Match.


                                    Subclass of AvdModel.

                                    Args:
                                        payload_bits:
                                           Specifies the bit positions within the UDP payload to match for hashing.
                                           Accepts a single bit (e.g.,
                                           "12"), a comma-separated list (e.g., "0,3,8"),
                                           a range (e.g., "0-15"), or combinations (e.g.,
                                           "0-7,9,12-15").
                                           Valid values must be in the range 0 to 503.
                                           Matching is limited to a maximum of 16
                                           bits total.
                                        pattern:
                                           Bit pattern to match in the UDP payload.
                                           The value should be given as an hexadecimal format `0x...`.
                                           The valid range is from 0 to (2^N - 1), where N is the number of bits selected in `payload_bits`.
                                        hash_payload_bytes:
                                           Specifies the UDP payload byte positions to include in the hash after pattern match.
                                           Accepts a
                                           single byte (e.g., "5"), a comma-separated list (e.g., "0,3,7"),
                                           a range (e.g., "0-15"), or a
                                           combination (e.g., "0-5,8,12-14").
                                           All byte positions must be within the range 0 to 62.

                                    """

                        _fields: ClassVar[dict] = {"dst_port": {"type": int}, "payload_bytes": {"type": str}, "match": {"type": Match}}
                        dst_port: int
                        """Use the UDP destination port as a hash input."""
                        payload_bytes: str | None
                        """
                        Specifies the UDP payload bytes to use in hash calculation.
                        Accepts single bytes (e.g., "10"),
                        comma-separated bytes (e.g., "0,1,5"),
                        ranges (e.g., "0-15"), or combinations (e.g.,
                        "0-10,12,15,20-25").
                        Valid values are between 0 and 62.
                        """
                        match: Match
                        """
                        Configuration to match specific bits and define custom payload-based hashing.

                        Subclass of AvdModel.
                        """

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                dst_port: int | UndefinedType = Undefined,
                                payload_bytes: str | None | UndefinedType = Undefined,
                                match: Match | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Udp.


                                Subclass of AvdModel.

                                Args:
                                    dst_port: Use the UDP destination port as a hash input.
                                    payload_bytes:
                                       Specifies the UDP payload bytes to use in hash calculation.
                                       Accepts single bytes (e.g., "10"),
                                       comma-separated bytes (e.g., "0,1,5"),
                                       ranges (e.g., "0-15"), or combinations (e.g.,
                                       "0-10,12,15,20-25").
                                       Valid values are between 0 and 62.
                                    match:
                                       Configuration to match specific bits and define custom payload-based hashing.

                                       Subclass of AvdModel.

                                """

                    _fields: ClassVar[dict] = {"udp": {"type": Udp}}
                    udp: Udp
                    """
                    UDP-specific fields used in the load balancing hash.
                    Requires EOS version 4.33.1F or higher.
                    Subclass of AvdModel.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, udp: Udp | UndefinedType = Undefined) -> None:
                            """
                            Fields.


                            Subclass of AvdModel.

                            Args:
                                udp:
                                   UDP-specific fields used in the load balancing hash.
                                   Requires EOS version 4.33.1F or higher.
                                   Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "fields": {"type": Fields}}
                name: str
                """Unique name of the load-balancing profile."""
                fields: Fields
                """
                Configure packet fields used as input to the hash function for port-channel and ECMP load balancing.
                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, fields: Fields | UndefinedType = Undefined) -> None:
                        """
                        SandProfilesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Unique name of the load-balancing profile.
                            fields:
                               Configure packet fields used as input to the hash function for port-channel and ECMP load balancing.
                               Subclass of AvdModel.

                        """

            class SandProfiles(AvdIndexedList[str, SandProfilesItem]):
                """Subclass of AvdIndexedList with `SandProfilesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            SandProfiles._item_type = SandProfilesItem

            _fields: ClassVar[dict] = {"sand_profiles": {"type": SandProfiles}}
            sand_profiles: SandProfiles
            """
            List of load balancing profiles for SAND-based platforms, used for port-channel and ECMP hashing.
            Subclass of AvdIndexedList with `SandProfilesItem` items. Primary key is `name` (`str`).
            """

            if TYPE_CHECKING:

                def __init__(self, *, sand_profiles: SandProfiles | UndefinedType = Undefined) -> None:
                    """
                    Policies.


                    Subclass of AvdModel.

                    Args:
                        sand_profiles:
                           List of load balancing profiles for SAND-based platforms, used for port-channel and ECMP hashing.
                           Subclass of AvdIndexedList with `SandProfilesItem` items. Primary key is `name` (`str`).

                    """

        class Cluster(AvdModel):
            """Subclass of AvdModel."""

            class Flow(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"monitor": {"type": bool}, "source_learning_aging_timeout": {"type": int}}
                monitor: bool | None
                """Monitor the flows without affecting forwarding."""
                source_learning_aging_timeout: int | None
                """Flow aging timeout in seconds for flow discovery by learning."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, monitor: bool | None | UndefinedType = Undefined, source_learning_aging_timeout: int | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        Flow.


                        Subclass of AvdModel.

                        Args:
                            monitor: Monitor the flows without affecting forwarding.
                            source_learning_aging_timeout: Flow aging timeout in seconds for flow discovery by learning.

                        """

            class PortGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class Flow(AvdModel):
                    """Subclass of AvdModel."""

                    class ExhaustionAction(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"dscp": {"type": int}, "traffic_class": {"type": int}}
                        dscp: int | None
                        """Packet DSCP value."""
                        traffic_class: int | None
                        """Packet traffic-class value."""

                        if TYPE_CHECKING:

                            def __init__(self, *, dscp: int | None | UndefinedType = Undefined, traffic_class: int | None | UndefinedType = Undefined) -> None:
                                """
                                ExhaustionAction.


                                Subclass of AvdModel.

                                Args:
                                    dscp: Packet DSCP value.
                                    traffic_class: Packet traffic-class value.

                                """

                    _fields: ClassVar[dict] = {"limit": {"type": int}, "warning": {"type": int}, "exhaustion_action": {"type": ExhaustionAction}}
                    limit: int | None
                    """Maximum number of flows per port."""
                    warning: int | None
                    """Warning threshold of flows per port group."""
                    exhaustion_action: ExhaustionAction
                    """
                    Forwarding action when flows reach limits.

                    Subclass of AvdModel.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            limit: int | None | UndefinedType = Undefined,
                            warning: int | None | UndefinedType = Undefined,
                            exhaustion_action: ExhaustionAction | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Flow.


                            Subclass of AvdModel.

                            Args:
                                limit: Maximum number of flows per port.
                                warning: Warning threshold of flows per port group.
                                exhaustion_action:
                                   Forwarding action when flows reach limits.

                                   Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {"group": {"type": str}, "balance_factor": {"type": int}, "interface": {"type": str}, "flow": {"type": Flow}}
                group: str
                """Port group name."""
                balance_factor: int | None
                interface: str | None
                """
                Ethernet interface/subinterface name. It could be a `,` separated list or range.
                eg. Ethernet2,
                Ethernet2-5,
                    Ethernet2.2,3.1,
                    Ethernet3.1-2
                """
                flow: Flow
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        group: str | UndefinedType = Undefined,
                        balance_factor: int | None | UndefinedType = Undefined,
                        interface: str | None | UndefinedType = Undefined,
                        flow: Flow | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PortGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            group: Port group name.
                            balance_factor: balance_factor
                            interface:
                               Ethernet interface/subinterface name. It could be a `,` separated list or range.
                               eg. Ethernet2,
                               Ethernet2-5,
                                   Ethernet2.2,3.1,
                                   Ethernet3.1-2
                            flow: Subclass of AvdModel.

                        """

            class PortGroups(AvdIndexedList[str, PortGroupsItem]):
                """Subclass of AvdIndexedList with `PortGroupsItem` items. Primary key is `group` (`str`)."""

                _primary_key: ClassVar[str] = "group"

            PortGroups._item_type = PortGroupsItem

            _fields: ClassVar[dict] = {
                "destination_grouping": {"type": str},
                "prefix_length": {"type": int},
                "forwarding_type": {"type": str},
                "load_balance_method_flow_round_robin": {"type": bool},
                "flow": {"type": Flow},
                "port_groups": {"type": PortGroups},
            }
            destination_grouping: Literal["bgp field-set", "prefix length", "vtep"] | None
            """Perform destination grouping using given setting."""
            prefix_length: int | None
            """
            Network address prefix length for destination grouping using prefix length.
            This setting must be
            defined when `destination_grouping` is set to `prefix length`.
            """
            forwarding_type: Literal["bridged encapsulation vxlan ipv4", "routed ipv4"] | None
            load_balance_method_flow_round_robin: bool | None
            """Enable round-robin load balancing for flow-based traffic."""
            flow: Flow
            """Subclass of AvdModel."""
            port_groups: PortGroups
            """
            Host ports settings.

            Subclass of AvdIndexedList with `PortGroupsItem` items. Primary key is `group`
            (`str`).
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    destination_grouping: Literal["bgp field-set", "prefix length", "vtep"] | None | UndefinedType = Undefined,
                    prefix_length: int | None | UndefinedType = Undefined,
                    forwarding_type: Literal["bridged encapsulation vxlan ipv4", "routed ipv4"] | None | UndefinedType = Undefined,
                    load_balance_method_flow_round_robin: bool | None | UndefinedType = Undefined,
                    flow: Flow | UndefinedType = Undefined,
                    port_groups: PortGroups | UndefinedType = Undefined,
                ) -> None:
                    """
                    Cluster.


                    Subclass of AvdModel.

                    Args:
                        destination_grouping: Perform destination grouping using given setting.
                        prefix_length:
                           Network address prefix length for destination grouping using prefix length.
                           This setting must be
                           defined when `destination_grouping` is set to `prefix length`.
                        forwarding_type: forwarding_type
                        load_balance_method_flow_round_robin: Enable round-robin load balancing for flow-based traffic.
                        flow: Subclass of AvdModel.
                        port_groups:
                           Host ports settings.

                           Subclass of AvdIndexedList with `PortGroupsItem` items. Primary key is `group`
                           (`str`).

                    """

        _fields: ClassVar[dict] = {"policies": {"type": Policies}, "cluster": {"type": Cluster}}
        policies: Policies
        """
        Collection of load balancing policy definitions.

        Subclass of AvdModel.
        """
        cluster: Cluster
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, policies: Policies | UndefinedType = Undefined, cluster: Cluster | UndefinedType = Undefined) -> None:
                """
                LoadBalance.


                Subclass of AvdModel.

                Args:
                    policies:
                       Collection of load balancing policy definitions.

                       Subclass of AvdModel.
                    cluster: Subclass of AvdModel.

                """

    class LoadInterval(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"default": {"type": int}}
        default: int | None
        """Default load interval in seconds."""

        if TYPE_CHECKING:

            def __init__(self, *, default: int | None | UndefinedType = Undefined) -> None:
                """
                LoadInterval.


                Subclass of AvdModel.

                Args:
                    default: Default load interval in seconds.

                """

    class LocalUsersItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "disabled": {"type": bool},
            "privilege": {"type": int},
            "role": {"type": str},
            "sha512_password": {"type": str},
            "no_password": {"type": bool},
            "ssh_key": {"type": str},
            "secondary_ssh_key": {"type": str},
            "shell": {"type": str},
        }
        name: str
        """Username."""
        disabled: bool | None
        """
        If true, the user will be removed and all other settings are ignored.
        Useful for removing the
        default "admin" user.
        """
        privilege: int | None
        """Initial privilege level with local EXEC authorization."""
        role: str | None
        """EOS RBAC Role to be assigned to the user such as "network-admin" or "network-operator"."""
        sha512_password: str | None
        """
        SHA512 Hash of Password.
        Must be the hash of the password. By default EOS salts the password with
        the username, so the simplest is to generate the hash on an EOS device using the same username.
        """
        no_password: bool | None
        """
        If set a password will not be configured for this user. "sha512_password" MUST not be defined for
        this user.
        """
        ssh_key: str | None
        secondary_ssh_key: str | None
        shell: Literal["/bin/bash", "/bin/sh", "/sbin/nologin"] | None
        """Specify shell for the user."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                disabled: bool | None | UndefinedType = Undefined,
                privilege: int | None | UndefinedType = Undefined,
                role: str | None | UndefinedType = Undefined,
                sha512_password: str | None | UndefinedType = Undefined,
                no_password: bool | None | UndefinedType = Undefined,
                ssh_key: str | None | UndefinedType = Undefined,
                secondary_ssh_key: str | None | UndefinedType = Undefined,
                shell: Literal["/bin/bash", "/bin/sh", "/sbin/nologin"] | None | UndefinedType = Undefined,
            ) -> None:
                """
                LocalUsersItem.


                Subclass of AvdModel.

                Args:
                    name: Username.
                    disabled:
                       If true, the user will be removed and all other settings are ignored.
                       Useful for removing the
                       default "admin" user.
                    privilege: Initial privilege level with local EXEC authorization.
                    role: EOS RBAC Role to be assigned to the user such as "network-admin" or "network-operator".
                    sha512_password:
                       SHA512 Hash of Password.
                       Must be the hash of the password. By default EOS salts the password with
                       the username, so the simplest is to generate the hash on an EOS device using the same username.
                    no_password:
                       If set a password will not be configured for this user. "sha512_password" MUST not be defined for
                       this user.
                    ssh_key: ssh_key
                    secondary_ssh_key: secondary_ssh_key
                    shell: Specify shell for the user.

                """

    class LocalUsers(AvdIndexedList[str, LocalUsersItem]):
        """Subclass of AvdIndexedList with `LocalUsersItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    LocalUsers._item_type = LocalUsersItem

    class Logging(AvdModel):
        """Subclass of AvdModel."""

        class Buffered(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"size": {"type": int}, "level": {"type": str}}
            size: int | None
            level: Literal["alerts", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "warnings", "disabled"] | None
            """Buffer logging severity level."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    size: int | None | UndefinedType = Undefined,
                    level: Literal["alerts", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "warnings", "disabled"]
                    | None
                    | UndefinedType = Undefined,
                ) -> None:
                    """
                    Buffered.


                    Subclass of AvdModel.

                    Args:
                        size: size
                        level: Buffer logging severity level.

                    """

        class Synchronous(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"level": {"type": str, "default": "critical"}}
            level: Literal["alerts", "all", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "warnings", "disabled"]
            """
            Synchronous logging severity level.

            Default value: `"critical"`
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    level: Literal["alerts", "all", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "warnings", "disabled"]
                    | UndefinedType = Undefined,
                ) -> None:
                    """
                    Synchronous.


                    Subclass of AvdModel.

                    Args:
                        level: Synchronous logging severity level.

                    """

        class Format(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"timestamp": {"type": str}, "hostname": {"type": str}, "sequence_numbers": {"type": bool}, "rfc5424": {"type": bool}}
            timestamp: (
                Literal["high-resolution", "traditional", "traditional timezone", "traditional year", "traditional timezone year", "traditional year timezone"]
                | None
            )
            """Timestamp format."""
            hostname: Literal["fqdn", "ipv4"] | None
            """Hostname format in syslogs. For hostname _only_, remove the line. (default EOS CLI behaviour)."""
            sequence_numbers: bool | None
            """Add sequence numbers to log messages."""
            rfc5424: bool | None
            """Forward logs in RFC5424 format."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    timestamp: Literal[
                        "high-resolution", "traditional", "traditional timezone", "traditional year", "traditional timezone year", "traditional year timezone"
                    ]
                    | None
                    | UndefinedType = Undefined,
                    hostname: Literal["fqdn", "ipv4"] | None | UndefinedType = Undefined,
                    sequence_numbers: bool | None | UndefinedType = Undefined,
                    rfc5424: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Format.


                    Subclass of AvdModel.

                    Args:
                        timestamp: Timestamp format.
                        hostname: Hostname format in syslogs. For hostname _only_, remove the line. (default EOS CLI behaviour).
                        sequence_numbers: Add sequence numbers to log messages.
                        rfc5424: Forward logs in RFC5424 format.

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class HostsItem(AvdModel):
                """Subclass of AvdModel."""

                class Ports(AvdList[int]):
                    """Subclass of AvdList with `int` items."""

                Ports._item_type = int

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "protocol": {"type": str, "default": "udp"},
                    "ports": {"type": Ports},
                    "ssl_profile": {"type": str},
                }
                name: str
                """Syslog server name."""
                protocol: Literal["tcp", "udp", "tls"]
                """Default value: `"udp"`"""
                ports: Ports
                """Subclass of AvdList with `int` items."""
                ssl_profile: str | None
                """Used when host protocol is 'tls'. Profiles are defined under `management_security.ssl_profiles`."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        protocol: Literal["tcp", "udp", "tls"] | UndefinedType = Undefined,
                        ports: Ports | UndefinedType = Undefined,
                        ssl_profile: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        HostsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Syslog server name.
                            protocol: protocol
                            ports: Subclass of AvdList with `int` items.
                            ssl_profile: Used when host protocol is 'tls'. Profiles are defined under `management_security.ssl_profiles`.

                        """

            class Hosts(AvdIndexedList[str, HostsItem]):
                """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Hosts._item_type = HostsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "source_interface": {"type": str}, "hosts": {"type": Hosts}}
            name: str
            """VRF name."""
            source_interface: str | None
            """Source interface name."""
            hosts: Hosts
            """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    source_interface: str | None | UndefinedType = Undefined,
                    hosts: Hosts | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        source_interface: Source interface name.
                        hosts: Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`).

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class Policy(AvdModel):
            """Subclass of AvdModel."""

            class Match(AvdModel):
                """Subclass of AvdModel."""

                class MatchListsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "action": {"type": str}}
                    name: str
                    """Match list."""
                    action: Literal["discard"] | None

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | UndefinedType = Undefined, action: Literal["discard"] | None | UndefinedType = Undefined) -> None:
                            """
                            MatchListsItem.


                            Subclass of AvdModel.

                            Args:
                                name: Match list.
                                action: action

                            """

                class MatchLists(AvdIndexedList[str, MatchListsItem]):
                    """Subclass of AvdIndexedList with `MatchListsItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                MatchLists._item_type = MatchListsItem

                _fields: ClassVar[dict] = {"match_lists": {"type": MatchLists}}
                match_lists: MatchLists
                """Subclass of AvdIndexedList with `MatchListsItem` items. Primary key is `name` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(self, *, match_lists: MatchLists | UndefinedType = Undefined) -> None:
                        """
                        Match.


                        Subclass of AvdModel.

                        Args:
                            match_lists: Subclass of AvdIndexedList with `MatchListsItem` items. Primary key is `name` (`str`).

                        """

            _fields: ClassVar[dict] = {"match": {"type": Match}}
            match: Match
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, match: Match | UndefinedType = Undefined) -> None:
                    """
                    Policy.


                    Subclass of AvdModel.

                    Args:
                        match: Subclass of AvdModel.

                    """

        class Event(AvdModel):
            """Subclass of AvdModel."""

            class StormControl(AvdModel):
                """Subclass of AvdModel."""

                class Discards(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"field_global": {"type": bool}, "interval": {"type": int}}
                    _field_to_key_map: ClassVar[dict] = {"field_global": "global"}
                    _key_to_field_map: ClassVar[dict] = {"global": "field_global"}
                    field_global: bool | None
                    interval: int | None
                    """Logging interval in seconds."""

                    if TYPE_CHECKING:

                        def __init__(self, *, field_global: bool | None | UndefinedType = Undefined, interval: int | None | UndefinedType = Undefined) -> None:
                            """
                            Discards.


                            Subclass of AvdModel.

                            Args:
                                field_global: field_global
                                interval: Logging interval in seconds.

                            """

                _fields: ClassVar[dict] = {"discards": {"type": Discards}}
                discards: Discards
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, discards: Discards | UndefinedType = Undefined) -> None:
                        """
                        StormControl.


                        Subclass of AvdModel.

                        Args:
                            discards: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "congestion_drops_interval": {"type": int},
                "global_link_status": {"type": bool},
                "storm_control": {"type": StormControl},
            }
            congestion_drops_interval: int | None
            """Logging interval in seconds."""
            global_link_status: bool | None
            storm_control: StormControl
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    congestion_drops_interval: int | None | UndefinedType = Undefined,
                    global_link_status: bool | None | UndefinedType = Undefined,
                    storm_control: StormControl | UndefinedType = Undefined,
                ) -> None:
                    """
                    Event.


                    Subclass of AvdModel.

                    Args:
                        congestion_drops_interval: Logging interval in seconds.
                        global_link_status: global_link_status
                        storm_control: Subclass of AvdModel.

                    """

        class LevelItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"facility": {"type": str}, "severity": {"type": str}}
            facility: str
            severity: (
                Literal[
                    "alerts",
                    "critical",
                    "debugging",
                    "emergencies",
                    "errors",
                    "informational",
                    "notifications",
                    "warnings",
                    "0",
                    "1",
                    "2",
                    "3",
                    "4",
                    "5",
                    "6",
                    "7",
                ]
                | None
            )
            """
            Severity of facility. Below are the supported severities.
            emergencies    System is unusable
            (severity=0)
            alerts         Immediate action needed           (severity=1)
            critical       Critical
            conditions               (severity=2)
            errors         Error conditions                  (severity=3)
            warnings       Warning conditions                (severity=4)
            notifications  Normal but significant
            conditions (severity=5)
            informational  Informational messages            (severity=6)
            debugging
            Debugging messages                (severity=7)
            <0-7>          Severity level value
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    facility: str | UndefinedType = Undefined,
                    severity: Literal[
                        "alerts",
                        "critical",
                        "debugging",
                        "emergencies",
                        "errors",
                        "informational",
                        "notifications",
                        "warnings",
                        "0",
                        "1",
                        "2",
                        "3",
                        "4",
                        "5",
                        "6",
                        "7",
                    ]
                    | None
                    | UndefinedType = Undefined,
                ) -> None:
                    """
                    LevelItem.


                    Subclass of AvdModel.

                    Args:
                        facility: facility
                        severity:
                           Severity of facility. Below are the supported severities.
                           emergencies    System is unusable
                           (severity=0)
                           alerts         Immediate action needed           (severity=1)
                           critical       Critical
                           conditions               (severity=2)
                           errors         Error conditions                  (severity=3)
                           warnings       Warning conditions                (severity=4)
                           notifications  Normal but significant
                           conditions (severity=5)
                           informational  Informational messages            (severity=6)
                           debugging
                           Debugging messages                (severity=7)
                           <0-7>          Severity level value

                    """

        class Level(AvdIndexedList[str, LevelItem]):
            """Subclass of AvdIndexedList with `LevelItem` items. Primary key is `facility` (`str`)."""

            _primary_key: ClassVar[str] = "facility"

        Level._item_type = LevelItem

        _fields: ClassVar[dict] = {
            "console": {"type": str},
            "monitor": {"type": str},
            "buffered": {"type": Buffered},
            "repeat_messages": {"type": bool},
            "trap": {"type": str},
            "synchronous": {"type": Synchronous},
            "format": {"type": Format},
            "facility": {"type": str},
            "source_interface": {"type": str},
            "vrfs": {"type": Vrfs},
            "policy": {"type": Policy},
            "event": {"type": Event},
            "level": {"type": Level},
        }
        console: Literal["debugging", "informational", "notifications", "warnings", "errors", "critical", "alerts", "emergencies", "disabled"] | None
        """Console logging severity level."""
        monitor: Literal["debugging", "informational", "notifications", "warnings", "errors", "critical", "alerts", "emergencies", "disabled"] | None
        """Monitor logging severity level."""
        buffered: Buffered
        """Subclass of AvdModel."""
        repeat_messages: bool | None
        """Summarize concurrent repeat messages."""
        trap: Literal["alerts", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "system", "warnings", "disabled"] | None
        """Trap logging severity level."""
        synchronous: Synchronous
        """Subclass of AvdModel."""
        format: Format
        """Subclass of AvdModel."""
        facility: (
            Literal[
                "auth",
                "cron",
                "daemon",
                "kern",
                "local0",
                "local1",
                "local2",
                "local3",
                "local4",
                "local5",
                "local6",
                "local7",
                "lpr",
                "mail",
                "news",
                "sys9",
                "sys10",
                "sys11",
                "sys12",
                "sys13",
                "sys14",
                "syslog",
                "user",
                "uucp",
            ]
            | None
        )
        source_interface: str | None
        """Source Interface Name."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        policy: Policy
        """Subclass of AvdModel."""
        event: Event
        """Subclass of AvdModel."""
        level: Level
        """
        Configure logging severity.

        Subclass of AvdIndexedList with `LevelItem` items. Primary key is
        `facility` (`str`).
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                console: Literal["debugging", "informational", "notifications", "warnings", "errors", "critical", "alerts", "emergencies", "disabled"]
                | None
                | UndefinedType = Undefined,
                monitor: Literal["debugging", "informational", "notifications", "warnings", "errors", "critical", "alerts", "emergencies", "disabled"]
                | None
                | UndefinedType = Undefined,
                buffered: Buffered | UndefinedType = Undefined,
                repeat_messages: bool | None | UndefinedType = Undefined,
                trap: Literal["alerts", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "system", "warnings", "disabled"]
                | None
                | UndefinedType = Undefined,
                synchronous: Synchronous | UndefinedType = Undefined,
                format: Format | UndefinedType = Undefined,
                facility: Literal[
                    "auth",
                    "cron",
                    "daemon",
                    "kern",
                    "local0",
                    "local1",
                    "local2",
                    "local3",
                    "local4",
                    "local5",
                    "local6",
                    "local7",
                    "lpr",
                    "mail",
                    "news",
                    "sys9",
                    "sys10",
                    "sys11",
                    "sys12",
                    "sys13",
                    "sys14",
                    "syslog",
                    "user",
                    "uucp",
                ]
                | None
                | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                policy: Policy | UndefinedType = Undefined,
                event: Event | UndefinedType = Undefined,
                level: Level | UndefinedType = Undefined,
            ) -> None:
                """
                Logging.


                Subclass of AvdModel.

                Args:
                    console: Console logging severity level.
                    monitor: Monitor logging severity level.
                    buffered: Subclass of AvdModel.
                    repeat_messages: Summarize concurrent repeat messages.
                    trap: Trap logging severity level.
                    synchronous: Subclass of AvdModel.
                    format: Subclass of AvdModel.
                    facility: facility
                    source_interface: Source Interface Name.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    policy: Subclass of AvdModel.
                    event: Subclass of AvdModel.
                    level:
                       Configure logging severity.

                       Subclass of AvdIndexedList with `LevelItem` items. Primary key is
                       `facility` (`str`).

                """

    class LoopbackInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class IpAddressSecondaries(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        IpAddressSecondaries._item_type = str

        class Mpls(AvdModel):
            """Subclass of AvdModel."""

            class Ldp(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interface": {"type": bool}}
                interface: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, interface: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Ldp.


                        Subclass of AvdModel.

                        Args:
                            interface: interface

                        """

            _fields: ClassVar[dict] = {"ldp": {"type": Ldp}}
            ldp: Ldp
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, ldp: Ldp | UndefinedType = Undefined) -> None:
                    """
                    Mpls.


                    Subclass of AvdModel.

                    Args:
                        ldp: Subclass of AvdModel.

                    """

        class NodeSegment(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4_index": {"type": int}, "ipv6_index": {"type": int}}
            ipv4_index: int | None
            ipv6_index: int | None

            if TYPE_CHECKING:

                def __init__(self, *, ipv4_index: int | None | UndefinedType = Undefined, ipv6_index: int | None | UndefinedType = Undefined) -> None:
                    """
                    NodeSegment.


                    Subclass of AvdModel.

                    Args:
                        ipv4_index: ipv4_index
                        ipv6_index: ipv6_index

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "vrf": {"type": str},
            "ip_address": {"type": str},
            "ip_address_secondaries": {"type": IpAddressSecondaries},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "ip_proxy_arp": {"type": bool},
            "ospf_area": {"type": str},
            "mpls": {"type": Mpls},
            "isis_enable": {"type": str},
            "isis_bfd": {"type": bool},
            "isis_passive": {"type": bool},
            "isis_metric": {"type": int},
            "isis_network_point_to_point": {"type": bool},
            "node_segment": {"type": NodeSegment},
            "hardware_forwarding_id": {"type": bool},
            "eos_cli": {"type": str},
        }
        name: str
        """Loopback interface name e.g. "Loopback0"."""
        description: str | None
        shutdown: bool | None
        vrf: str | None
        """VRF name."""
        ip_address: str | None
        """IPv4_address/Mask."""
        ip_address_secondaries: IpAddressSecondaries
        """Subclass of AvdList with `str` items."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6_address/Mask."""
        ip_proxy_arp: bool | None
        ospf_area: str | None
        mpls: Mpls
        """Subclass of AvdModel."""
        isis_enable: str | None
        """ISIS instance name."""
        isis_bfd: bool | None
        """Enable BFD for ISIS."""
        isis_passive: bool | None
        isis_metric: int | None
        isis_network_point_to_point: bool | None
        node_segment: NodeSegment
        """Subclass of AvdModel."""
        hardware_forwarding_id: bool | None
        """Enable hardware forwarding for the VRF where this loopback interface belongs."""
        eos_cli: str | None
        """EOS CLI rendered directly on the loopback interface in the final EOS configuration."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ip_address_secondaries: IpAddressSecondaries | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                ip_proxy_arp: bool | None | UndefinedType = Undefined,
                ospf_area: str | None | UndefinedType = Undefined,
                mpls: Mpls | UndefinedType = Undefined,
                isis_enable: str | None | UndefinedType = Undefined,
                isis_bfd: bool | None | UndefinedType = Undefined,
                isis_passive: bool | None | UndefinedType = Undefined,
                isis_metric: int | None | UndefinedType = Undefined,
                isis_network_point_to_point: bool | None | UndefinedType = Undefined,
                node_segment: NodeSegment | UndefinedType = Undefined,
                hardware_forwarding_id: bool | None | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                LoopbackInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Loopback interface name e.g. "Loopback0".
                    description: description
                    shutdown: shutdown
                    vrf: VRF name.
                    ip_address: IPv4_address/Mask.
                    ip_address_secondaries: Subclass of AvdList with `str` items.
                    ipv6_enable: ipv6_enable
                    ipv6_address: IPv6_address/Mask.
                    ip_proxy_arp: ip_proxy_arp
                    ospf_area: ospf_area
                    mpls: Subclass of AvdModel.
                    isis_enable: ISIS instance name.
                    isis_bfd: Enable BFD for ISIS.
                    isis_passive: isis_passive
                    isis_metric: isis_metric
                    isis_network_point_to_point: isis_network_point_to_point
                    node_segment: Subclass of AvdModel.
                    hardware_forwarding_id: Enable hardware forwarding for the VRF where this loopback interface belongs.
                    eos_cli: EOS CLI rendered directly on the loopback interface in the final EOS configuration.

                """

    class LoopbackInterfaces(AvdIndexedList[str, LoopbackInterfacesItem]):
        """Subclass of AvdIndexedList with `LoopbackInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    LoopbackInterfaces._item_type = LoopbackInterfacesItem

    class MacAccessListsItem(AvdModel):
        """Subclass of AvdModel."""

        class EntriesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}}
            sequence: int | None
            action: str | None

            if TYPE_CHECKING:

                def __init__(self, *, sequence: int | None | UndefinedType = Undefined, action: str | None | UndefinedType = Undefined) -> None:
                    """
                    EntriesItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: sequence
                        action: action

                    """

        class Entries(AvdList[EntriesItem]):
            """Subclass of AvdList with `EntriesItem` items."""

        Entries._item_type = EntriesItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "counters_per_entry": {"type": bool}, "entries": {"type": Entries}}
        name: str
        """MAC Access-list Name."""
        counters_per_entry: bool | None
        entries: Entries
        """Subclass of AvdList with `EntriesItem` items."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                counters_per_entry: bool | None | UndefinedType = Undefined,
                entries: Entries | UndefinedType = Undefined,
            ) -> None:
                """
                MacAccessListsItem.


                Subclass of AvdModel.

                Args:
                    name: MAC Access-list Name.
                    counters_per_entry: counters_per_entry
                    entries: Subclass of AvdList with `EntriesItem` items.

                """

    class MacAccessLists(AvdIndexedList[str, MacAccessListsItem]):
        """Subclass of AvdIndexedList with `MacAccessListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    MacAccessLists._item_type = MacAccessListsItem

    class MacAddressTable(AvdModel):
        """Subclass of AvdModel."""

        class NotificationHostFlap(AvdModel):
            """Subclass of AvdModel."""

            class Detection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"window": {"type": int}, "moves": {"type": int}}
                window: int | None
                moves: int | None

                if TYPE_CHECKING:

                    def __init__(self, *, window: int | None | UndefinedType = Undefined, moves: int | None | UndefinedType = Undefined) -> None:
                        """
                        Detection.


                        Subclass of AvdModel.

                        Args:
                            window: window
                            moves: moves

                        """

            _fields: ClassVar[dict] = {"logging": {"type": bool}, "detection": {"type": Detection}}
            logging: bool | None
            detection: Detection
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, logging: bool | None | UndefinedType = Undefined, detection: Detection | UndefinedType = Undefined) -> None:
                    """
                    NotificationHostFlap.


                    Subclass of AvdModel.

                    Args:
                        logging: logging
                        detection: Subclass of AvdModel.

                    """

        class StaticEntriesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "mac_address": {"type": str},
                "vlan": {"type": int},
                "drop": {"type": bool},
                "interface": {"type": str},
                "eligibility_forwarding": {"type": bool},
            }
            mac_address: str
            """
            The static MAC address to configure.
            The combination of 'mac_address' and 'vlan' must be unique
            across all static entries.
            """
            vlan: int
            """The VLAN ID associated with the MAC address."""
            drop: bool | None
            """
            If true, traffic destined for this MAC address on the specified VLAN will be dropped.
            This option is
            mutually exclusive with 'interface' and takes precedence if both are defined.
            """
            interface: str | None
            """
            The allowed hardware Ethernet interface, LAG interface, or VXLAN tunnel interface associated with
            this MAC address and VLAN.
            This option is mutually exclusive with 'drop'.
            """
            eligibility_forwarding: bool | None
            """
            Enable the ability to forward traffic on the specified interface and VLAN for this MAC address.
            This
            option is only applicable when 'interface' is defined.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    mac_address: str | UndefinedType = Undefined,
                    vlan: int | UndefinedType = Undefined,
                    drop: bool | None | UndefinedType = Undefined,
                    interface: str | None | UndefinedType = Undefined,
                    eligibility_forwarding: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    StaticEntriesItem.


                    Subclass of AvdModel.

                    Args:
                        mac_address:
                           The static MAC address to configure.
                           The combination of 'mac_address' and 'vlan' must be unique
                           across all static entries.
                        vlan: The VLAN ID associated with the MAC address.
                        drop:
                           If true, traffic destined for this MAC address on the specified VLAN will be dropped.
                           This option is
                           mutually exclusive with 'interface' and takes precedence if both are defined.
                        interface:
                           The allowed hardware Ethernet interface, LAG interface, or VXLAN tunnel interface associated with
                           this MAC address and VLAN.
                           This option is mutually exclusive with 'drop'.
                        eligibility_forwarding:
                           Enable the ability to forward traffic on the specified interface and VLAN for this MAC address.
                           This
                           option is only applicable when 'interface' is defined.

                    """

        class StaticEntries(AvdList[StaticEntriesItem]):
            """Subclass of AvdList with `StaticEntriesItem` items."""

        StaticEntries._item_type = StaticEntriesItem

        _fields: ClassVar[dict] = {
            "aging_time": {"type": int},
            "notification_host_flap": {"type": NotificationHostFlap},
            "static_entries": {"type": StaticEntries},
        }
        aging_time: int | None
        """
        Aging time in seconds 10-1000000.
        Enter 0 to disable aging.
        """
        notification_host_flap: NotificationHostFlap
        """Subclass of AvdModel."""
        static_entries: StaticEntries
        """
        Add static MAC address entries.

        Subclass of AvdList with `StaticEntriesItem` items.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                aging_time: int | None | UndefinedType = Undefined,
                notification_host_flap: NotificationHostFlap | UndefinedType = Undefined,
                static_entries: StaticEntries | UndefinedType = Undefined,
            ) -> None:
                """
                MacAddressTable.


                Subclass of AvdModel.

                Args:
                    aging_time:
                       Aging time in seconds 10-1000000.
                       Enter 0 to disable aging.
                    notification_host_flap: Subclass of AvdModel.
                    static_entries:
                       Add static MAC address entries.

                       Subclass of AvdList with `StaticEntriesItem` items.

                """

    class MacSecurity(AvdModel):
        """Subclass of AvdModel."""

        class License(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"license_name": {"type": str}, "license_key": {"type": str}}
            license_name: str
            license_key: str

            if TYPE_CHECKING:

                def __init__(self, *, license_name: str | UndefinedType = Undefined, license_key: str | UndefinedType = Undefined) -> None:
                    """
                    License.


                    Subclass of AvdModel.

                    Args:
                        license_name: license_name
                        license_key: license_key

                    """

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class ConnectionKeysItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"id": {"type": str}, "encrypted_key": {"type": str}, "fallback": {"type": bool}}
                id: str
                encrypted_key: str | None
                fallback: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: str | UndefinedType = Undefined,
                        encrypted_key: str | None | UndefinedType = Undefined,
                        fallback: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ConnectionKeysItem.


                        Subclass of AvdModel.

                        Args:
                            id: id
                            encrypted_key: encrypted_key
                            fallback: fallback

                        """

            class ConnectionKeys(AvdIndexedList[str, ConnectionKeysItem]):
                """Subclass of AvdIndexedList with `ConnectionKeysItem` items. Primary key is `id` (`str`)."""

                _primary_key: ClassVar[str] = "id"

            ConnectionKeys._item_type = ConnectionKeysItem

            class Mka(AvdModel):
                """Subclass of AvdModel."""

                class Session(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"rekey_period": {"type": int}}
                    rekey_period: int | None
                    """Rekey period in seconds."""

                    if TYPE_CHECKING:

                        def __init__(self, *, rekey_period: int | None | UndefinedType = Undefined) -> None:
                            """
                            Session.


                            Subclass of AvdModel.

                            Args:
                                rekey_period: Rekey period in seconds.

                            """

                _fields: ClassVar[dict] = {"key_server_priority": {"type": int}, "session": {"type": Session}}
                key_server_priority: int | None
                session: Session
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, key_server_priority: int | None | UndefinedType = Undefined, session: Session | UndefinedType = Undefined) -> None:
                        """
                        Mka.


                        Subclass of AvdModel.

                        Args:
                            key_server_priority: key_server_priority
                            session: Subclass of AvdModel.

                        """

            class L2Protocols(AvdModel):
                """Subclass of AvdModel."""

                class EthernetFlowControl(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"mode": {"type": str}}
                    mode: Literal["encrypt", "bypass"]

                    if TYPE_CHECKING:

                        def __init__(self, *, mode: Literal["encrypt", "bypass"] | UndefinedType = Undefined) -> None:
                            """
                            EthernetFlowControl.


                            Subclass of AvdModel.

                            Args:
                                mode: mode

                            """

                class Lldp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"mode": {"type": str}}
                    mode: Literal["bypass", "bypass unauthorized"]

                    if TYPE_CHECKING:

                        def __init__(self, *, mode: Literal["bypass", "bypass unauthorized"] | UndefinedType = Undefined) -> None:
                            """
                            Lldp.


                            Subclass of AvdModel.

                            Args:
                                mode: mode

                            """

                _fields: ClassVar[dict] = {"ethernet_flow_control": {"type": EthernetFlowControl}, "lldp": {"type": Lldp}}
                ethernet_flow_control: EthernetFlowControl
                """Subclass of AvdModel."""
                lldp: Lldp
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, ethernet_flow_control: EthernetFlowControl | UndefinedType = Undefined, lldp: Lldp | UndefinedType = Undefined
                    ) -> None:
                        """
                        L2Protocols.


                        Subclass of AvdModel.

                        Args:
                            ethernet_flow_control: Subclass of AvdModel.
                            lldp: Subclass of AvdModel.

                        """

            class TrafficUnprotected(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"action": {"type": str}, "allow_active_sak": {"type": bool}}
                action: Literal["allow", "drop"]
                """Allow/drop the transmit/receive of unprotected traffic."""
                allow_active_sak: bool | None
                """Allow transmit/receive of encrypted traffic using operational SAK and block otherwise."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, action: Literal["allow", "drop"] | UndefinedType = Undefined, allow_active_sak: bool | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        TrafficUnprotected.


                        Subclass of AvdModel.

                        Args:
                            action: Allow/drop the transmit/receive of unprotected traffic.
                            allow_active_sak: Allow transmit/receive of encrypted traffic using operational SAK and block otherwise.

                        """

            class ReplayProtection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"disabled": {"type": bool}, "window": {"type": int}}
                disabled: bool | None
                """Disable replay protection."""
                window: int | None
                """Set replay protection window size."""

                if TYPE_CHECKING:

                    def __init__(self, *, disabled: bool | None | UndefinedType = Undefined, window: int | None | UndefinedType = Undefined) -> None:
                        """
                        ReplayProtection.


                        Subclass of AvdModel.

                        Args:
                            disabled: Disable replay protection.
                            window: Set replay protection window size.

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "cipher": {"type": str},
                "connection_keys": {"type": ConnectionKeys},
                "mka": {"type": Mka},
                "sci": {"type": bool},
                "l2_protocols": {"type": L2Protocols},
                "traffic_unprotected": {"type": TrafficUnprotected},
                "replay_protection": {"type": ReplayProtection},
            }
            name: str
            """Profile-Name."""
            cipher: Literal["aes128-gcm", "aes128-gcm-xpn", "aes256-gcm", "aes256-gcm-xpn"] | None
            connection_keys: ConnectionKeys
            """Subclass of AvdIndexedList with `ConnectionKeysItem` items. Primary key is `id` (`str`)."""
            mka: Mka
            """Subclass of AvdModel."""
            sci: bool | None
            l2_protocols: L2Protocols
            """Subclass of AvdModel."""
            traffic_unprotected: TrafficUnprotected
            """Subclass of AvdModel."""
            replay_protection: ReplayProtection
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    cipher: Literal["aes128-gcm", "aes128-gcm-xpn", "aes256-gcm", "aes256-gcm-xpn"] | None | UndefinedType = Undefined,
                    connection_keys: ConnectionKeys | UndefinedType = Undefined,
                    mka: Mka | UndefinedType = Undefined,
                    sci: bool | None | UndefinedType = Undefined,
                    l2_protocols: L2Protocols | UndefinedType = Undefined,
                    traffic_unprotected: TrafficUnprotected | UndefinedType = Undefined,
                    replay_protection: ReplayProtection | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Profile-Name.
                        cipher: cipher
                        connection_keys: Subclass of AvdIndexedList with `ConnectionKeysItem` items. Primary key is `id` (`str`).
                        mka: Subclass of AvdModel.
                        sci: sci
                        l2_protocols: Subclass of AvdModel.
                        traffic_unprotected: Subclass of AvdModel.
                        replay_protection: Subclass of AvdModel.

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        _fields: ClassVar[dict] = {"license": {"type": License}, "fips_restrictions": {"type": bool}, "profiles": {"type": Profiles}}
        license: License
        """Subclass of AvdModel."""
        fips_restrictions: bool | None
        profiles: Profiles
        """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                license: License | UndefinedType = Undefined,
                fips_restrictions: bool | None | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
            ) -> None:
                """
                MacSecurity.


                Subclass of AvdModel.

                Args:
                    license: Subclass of AvdModel.
                    fips_restrictions: fips_restrictions
                    profiles: Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`).

                """

    class Maintenance(AvdModel):
        """Subclass of AvdModel."""

        class InterfaceProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class RateMonitoring(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"load_interval": {"type": int}, "threshold": {"type": int}}
                load_interval: int | None
                """Load Interval in Seconds."""
                threshold: int | None
                """Threshold in kbps."""

                if TYPE_CHECKING:

                    def __init__(self, *, load_interval: int | None | UndefinedType = Undefined, threshold: int | None | UndefinedType = Undefined) -> None:
                        """
                        RateMonitoring.


                        Subclass of AvdModel.

                        Args:
                            load_interval: Load Interval in Seconds.
                            threshold: Threshold in kbps.

                        """

            class Shutdown(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"max_delay": {"type": int}}
                max_delay: int | None
                """Max delay in seconds."""

                if TYPE_CHECKING:

                    def __init__(self, *, max_delay: int | None | UndefinedType = Undefined) -> None:
                        """
                        Shutdown.


                        Subclass of AvdModel.

                        Args:
                            max_delay: Max delay in seconds.

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "rate_monitoring": {"type": RateMonitoring}, "shutdown": {"type": Shutdown}}
            name: str
            rate_monitoring: RateMonitoring
            """Subclass of AvdModel."""
            shutdown: Shutdown
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    rate_monitoring: RateMonitoring | UndefinedType = Undefined,
                    shutdown: Shutdown | UndefinedType = Undefined,
                ) -> None:
                    """
                    InterfaceProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        rate_monitoring: Subclass of AvdModel.
                        shutdown: Subclass of AvdModel.

                    """

        class InterfaceProfiles(AvdIndexedList[str, InterfaceProfilesItem]):
            """Subclass of AvdIndexedList with `InterfaceProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        InterfaceProfiles._item_type = InterfaceProfilesItem

        class BgpProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class Initiator(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"route_map_inout": {"type": str}}
                route_map_inout: str | None
                """Route Map."""

                if TYPE_CHECKING:

                    def __init__(self, *, route_map_inout: str | None | UndefinedType = Undefined) -> None:
                        """
                        Initiator.


                        Subclass of AvdModel.

                        Args:
                            route_map_inout: Route Map.

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "initiator": {"type": Initiator}}
            name: str
            """BGP Profile Name."""
            initiator: Initiator
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, initiator: Initiator | UndefinedType = Undefined) -> None:
                    """
                    BgpProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: BGP Profile Name.
                        initiator: Subclass of AvdModel.

                    """

        class BgpProfiles(AvdIndexedList[str, BgpProfilesItem]):
            """Subclass of AvdIndexedList with `BgpProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        BgpProfiles._item_type = BgpProfilesItem

        class UnitProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class OnBoot(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"duration": {"type": int}}
                duration: int | None
                """On-boot in seconds."""

                if TYPE_CHECKING:

                    def __init__(self, *, duration: int | None | UndefinedType = Undefined) -> None:
                        """
                        OnBoot.


                        Subclass of AvdModel.

                        Args:
                            duration: On-boot in seconds.

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "on_boot": {"type": OnBoot}}
            name: str
            """Unit Profile Name."""
            on_boot: OnBoot
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, on_boot: OnBoot | UndefinedType = Undefined) -> None:
                    """
                    UnitProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Unit Profile Name.
                        on_boot: Subclass of AvdModel.

                    """

        class UnitProfiles(AvdIndexedList[str, UnitProfilesItem]):
            """Subclass of AvdIndexedList with `UnitProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        UnitProfiles._item_type = UnitProfilesItem

        class UnitsItem(AvdModel):
            """Subclass of AvdModel."""

            class Groups(AvdModel):
                """Subclass of AvdModel."""

                class BgpGroups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                BgpGroups._item_type = str

                class InterfaceGroups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                InterfaceGroups._item_type = str

                _fields: ClassVar[dict] = {"bgp_groups": {"type": BgpGroups}, "interface_groups": {"type": InterfaceGroups}}
                bgp_groups: BgpGroups
                """Subclass of AvdList with `str` items."""
                interface_groups: InterfaceGroups
                """Subclass of AvdList with `str` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, bgp_groups: BgpGroups | UndefinedType = Undefined, interface_groups: InterfaceGroups | UndefinedType = Undefined
                    ) -> None:
                        """
                        Groups.


                        Subclass of AvdModel.

                        Args:
                            bgp_groups: Subclass of AvdList with `str` items.
                            interface_groups: Subclass of AvdList with `str` items.

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "quiesce": {"type": bool}, "profile": {"type": str}, "groups": {"type": Groups}}
            name: str
            """Unit Name."""
            quiesce: bool | None
            profile: str | None
            """Name of Unit Profile."""
            groups: Groups
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    quiesce: bool | None | UndefinedType = Undefined,
                    profile: str | None | UndefinedType = Undefined,
                    groups: Groups | UndefinedType = Undefined,
                ) -> None:
                    """
                    UnitsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Unit Name.
                        quiesce: quiesce
                        profile: Name of Unit Profile.
                        groups: Subclass of AvdModel.

                    """

        class Units(AvdIndexedList[str, UnitsItem]):
            """Subclass of AvdIndexedList with `UnitsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Units._item_type = UnitsItem

        _fields: ClassVar[dict] = {
            "default_interface_profile": {"type": str},
            "default_bgp_profile": {"type": str},
            "default_unit_profile": {"type": str},
            "interface_profiles": {"type": InterfaceProfiles},
            "bgp_profiles": {"type": BgpProfiles},
            "unit_profiles": {"type": UnitProfiles},
            "units": {"type": Units},
        }
        default_interface_profile: str | None
        """Name of default Interface Profile."""
        default_bgp_profile: str | None
        """Name of default BGP Profile."""
        default_unit_profile: str | None
        """Name of default Unit Profile."""
        interface_profiles: InterfaceProfiles
        """Subclass of AvdIndexedList with `InterfaceProfilesItem` items. Primary key is `name` (`str`)."""
        bgp_profiles: BgpProfiles
        """Subclass of AvdIndexedList with `BgpProfilesItem` items. Primary key is `name` (`str`)."""
        unit_profiles: UnitProfiles
        """Subclass of AvdIndexedList with `UnitProfilesItem` items. Primary key is `name` (`str`)."""
        units: Units
        """Subclass of AvdIndexedList with `UnitsItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                default_interface_profile: str | None | UndefinedType = Undefined,
                default_bgp_profile: str | None | UndefinedType = Undefined,
                default_unit_profile: str | None | UndefinedType = Undefined,
                interface_profiles: InterfaceProfiles | UndefinedType = Undefined,
                bgp_profiles: BgpProfiles | UndefinedType = Undefined,
                unit_profiles: UnitProfiles | UndefinedType = Undefined,
                units: Units | UndefinedType = Undefined,
            ) -> None:
                """
                Maintenance.


                Subclass of AvdModel.

                Args:
                    default_interface_profile: Name of default Interface Profile.
                    default_bgp_profile: Name of default BGP Profile.
                    default_unit_profile: Name of default Unit Profile.
                    interface_profiles: Subclass of AvdIndexedList with `InterfaceProfilesItem` items. Primary key is `name` (`str`).
                    bgp_profiles: Subclass of AvdIndexedList with `BgpProfilesItem` items. Primary key is `name` (`str`).
                    unit_profiles: Subclass of AvdIndexedList with `UnitProfilesItem` items. Primary key is `name` (`str`).
                    units: Subclass of AvdIndexedList with `UnitsItem` items. Primary key is `name` (`str`).

                """

    class ManagementAccounts(AvdModel):
        """Subclass of AvdModel."""

        class Password(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"policy": {"type": str}}
            policy: str | None

            if TYPE_CHECKING:

                def __init__(self, *, policy: str | None | UndefinedType = Undefined) -> None:
                    """
                    Password.


                    Subclass of AvdModel.

                    Args:
                        policy: policy

                    """

        _fields: ClassVar[dict] = {"password": {"type": Password}}
        password: Password
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, password: Password | UndefinedType = Undefined) -> None:
                """
                ManagementAccounts.


                Subclass of AvdModel.

                Args:
                    password: Subclass of AvdModel.

                """

    class ManagementApiGnmi(AvdModel):
        """Subclass of AvdModel."""

        class Transport(AvdModel):
            """Subclass of AvdModel."""

            class GrpcItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "ssl_profile": {"type": str},
                    "vrf": {"type": str},
                    "notification_timestamp": {"type": str},
                    "ip_access_group": {"type": str},
                    "port": {"type": int},
                    "authorization_requests": {"type": bool},
                }
                name: str
                """Transport name."""
                ssl_profile: str | None
                """SSL profile name."""
                vrf: str | None
                """VRF name is optional."""
                notification_timestamp: Literal["send-time", "last-change-time"] | None
                """
                Per the gNMI specification, the default timestamp field of a notification message is set to be
                the
                time at which the value of the underlying data source changes or when the reported event takes
                place.
                In order to facilitate integration in legacy environments oriented around polling style
                operations,
                an option to support overriding the timestamp field to the send-time is available from
                EOS 4.27.0F.
                """
                ip_access_group: str | None
                """ACL name."""
                port: int | None
                """
                GNMI port.
                Make sure to update the control-plane ACL accordingly in order for the service to be
                reachable by external applications.
                """
                authorization_requests: bool | None
                """Use per-RPC authorization."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        ssl_profile: str | None | UndefinedType = Undefined,
                        vrf: str | None | UndefinedType = Undefined,
                        notification_timestamp: Literal["send-time", "last-change-time"] | None | UndefinedType = Undefined,
                        ip_access_group: str | None | UndefinedType = Undefined,
                        port: int | None | UndefinedType = Undefined,
                        authorization_requests: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GrpcItem.


                        Subclass of AvdModel.

                        Args:
                            name: Transport name.
                            ssl_profile: SSL profile name.
                            vrf: VRF name is optional.
                            notification_timestamp:
                               Per the gNMI specification, the default timestamp field of a notification message is set to be
                               the
                               time at which the value of the underlying data source changes or when the reported event takes
                               place.
                               In order to facilitate integration in legacy environments oriented around polling style
                               operations,
                               an option to support overriding the timestamp field to the send-time is available from
                               EOS 4.27.0F.
                            ip_access_group: ACL name.
                            port:
                               GNMI port.
                               Make sure to update the control-plane ACL accordingly in order for the service to be
                               reachable by external applications.
                            authorization_requests: Use per-RPC authorization.

                        """

            class Grpc(AvdIndexedList[str, GrpcItem]):
                """Subclass of AvdIndexedList with `GrpcItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Grpc._item_type = GrpcItem

            class GrpcTunnelsItem(AvdModel):
                """Subclass of AvdModel."""

                class Destination(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"address": {"type": str}, "port": {"type": int}}
                    address: str
                    """IP address or hostname."""
                    port: int
                    """TCP Port."""

                    if TYPE_CHECKING:

                        def __init__(self, *, address: str | UndefinedType = Undefined, port: int | UndefinedType = Undefined) -> None:
                            """
                            Destination.


                            Subclass of AvdModel.

                            Args:
                                address: IP address or hostname.
                                port: TCP Port.

                            """

                class LocalInterface(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "port": {"type": int}}
                    name: str
                    """Interface name."""
                    port: int
                    """TCP Port."""

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | UndefinedType = Undefined, port: int | UndefinedType = Undefined) -> None:
                            """
                            LocalInterface.


                            Subclass of AvdModel.

                            Args:
                                name: Interface name.
                                port: TCP Port.

                            """

                class Target(AvdModel):
                    """Subclass of AvdModel."""

                    class TargetIds(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    TargetIds._item_type = str

                    _fields: ClassVar[dict] = {"use_serial_number": {"type": bool}, "target_ids": {"type": TargetIds}}
                    use_serial_number: bool | None
                    """Use serial number as the Target ID."""
                    target_ids: TargetIds
                    """
                    Target IDs as a list.


                    Subclass of AvdList with `str` items.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, use_serial_number: bool | None | UndefinedType = Undefined, target_ids: TargetIds | UndefinedType = Undefined
                        ) -> None:
                            """
                            Target.


                            Subclass of AvdModel.

                            Args:
                                use_serial_number: Use serial number as the Target ID.
                                target_ids:
                                   Target IDs as a list.


                                   Subclass of AvdList with `str` items.

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "shutdown": {"type": bool},
                    "tunnel_ssl_profile": {"type": str},
                    "gnmi_ssl_profile": {"type": str},
                    "vrf": {"type": str},
                    "destination": {"type": Destination},
                    "local_interface": {"type": LocalInterface},
                    "target": {"type": Target},
                }
                name: str
                """Transport name."""
                shutdown: bool | None
                """Operational status of the gRPC tunnel."""
                tunnel_ssl_profile: str | None
                """Tunnel SSL profile name."""
                gnmi_ssl_profile: str | None
                """gNMI SSL profile name."""
                vrf: str | None
                """VRF name."""
                destination: Destination
                """Subclass of AvdModel."""
                local_interface: LocalInterface
                """Subclass of AvdModel."""
                target: Target
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        shutdown: bool | None | UndefinedType = Undefined,
                        tunnel_ssl_profile: str | None | UndefinedType = Undefined,
                        gnmi_ssl_profile: str | None | UndefinedType = Undefined,
                        vrf: str | None | UndefinedType = Undefined,
                        destination: Destination | UndefinedType = Undefined,
                        local_interface: LocalInterface | UndefinedType = Undefined,
                        target: Target | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GrpcTunnelsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Transport name.
                            shutdown: Operational status of the gRPC tunnel.
                            tunnel_ssl_profile: Tunnel SSL profile name.
                            gnmi_ssl_profile: gNMI SSL profile name.
                            vrf: VRF name.
                            destination: Subclass of AvdModel.
                            local_interface: Subclass of AvdModel.
                            target: Subclass of AvdModel.

                        """

            class GrpcTunnels(AvdIndexedList[str, GrpcTunnelsItem]):
                """Subclass of AvdIndexedList with `GrpcTunnelsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            GrpcTunnels._item_type = GrpcTunnelsItem

            _fields: ClassVar[dict] = {"grpc": {"type": Grpc}, "grpc_tunnels": {"type": GrpcTunnels}}
            grpc: Grpc
            """Subclass of AvdIndexedList with `GrpcItem` items. Primary key is `name` (`str`)."""
            grpc_tunnels: GrpcTunnels
            """Subclass of AvdIndexedList with `GrpcTunnelsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(self, *, grpc: Grpc | UndefinedType = Undefined, grpc_tunnels: GrpcTunnels | UndefinedType = Undefined) -> None:
                    """
                    Transport.


                    Subclass of AvdModel.

                    Args:
                        grpc: Subclass of AvdIndexedList with `GrpcItem` items. Primary key is `name` (`str`).
                        grpc_tunnels: Subclass of AvdIndexedList with `GrpcTunnelsItem` items. Primary key is `name` (`str`).

                    """

        _fields: ClassVar[dict] = {"provider": {"type": str, "default": "eos-native"}, "transport": {"type": Transport}}
        provider: str
        """Default value: `"eos-native"`"""
        transport: Transport
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, provider: str | UndefinedType = Undefined, transport: Transport | UndefinedType = Undefined) -> None:
                """
                ManagementApiGnmi.


                Subclass of AvdModel.

                Args:
                    provider: provider
                    transport: Subclass of AvdModel.

                """

    class ManagementApiHttp(AvdModel):
        """Subclass of AvdModel."""

        class EnableVrfsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "access_group": {"type": str}, "ipv6_access_group": {"type": str}}
            name: str
            """VRF Name."""
            access_group: str | None
            """Standard IPv4 ACL name."""
            ipv6_access_group: str | None
            """Standard IPv6 ACL name."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    access_group: str | None | UndefinedType = Undefined,
                    ipv6_access_group: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    EnableVrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF Name.
                        access_group: Standard IPv4 ACL name.
                        ipv6_access_group: Standard IPv6 ACL name.

                    """

        class EnableVrfs(AvdIndexedList[str, EnableVrfsItem]):
            """Subclass of AvdIndexedList with `EnableVrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        EnableVrfs._item_type = EnableVrfsItem

        class ProtocolHttpsCertificate(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"certificate": {"type": str}, "private_key": {"type": str}}
            certificate: str | None
            """Name of certificate; private key must also be specified."""
            private_key: str | None
            """Name of private key; certificate must also be specified."""

            if TYPE_CHECKING:

                def __init__(self, *, certificate: str | None | UndefinedType = Undefined, private_key: str | None | UndefinedType = Undefined) -> None:
                    """
                    ProtocolHttpsCertificate.


                    Subclass of AvdModel.

                    Args:
                        certificate: Name of certificate; private key must also be specified.
                        private_key: Name of private key; certificate must also be specified.

                    """

        _fields: ClassVar[dict] = {
            "enable_http": {"type": bool},
            "enable_https": {"type": bool},
            "enable_unix": {"type": bool},
            "https_ssl_profile": {"type": str},
            "default_services": {"type": bool},
            "enable_vrfs": {"type": EnableVrfs},
            "protocol_https_certificate": {"type": ProtocolHttpsCertificate},
        }
        enable_http: bool | None
        enable_https: bool | None
        enable_unix: bool | None
        https_ssl_profile: str | None
        """SSL Profile Name."""
        default_services: bool | None
        """Enable default services: capi-doc and tapagg."""
        enable_vrfs: EnableVrfs
        """Subclass of AvdIndexedList with `EnableVrfsItem` items. Primary key is `name` (`str`)."""
        protocol_https_certificate: ProtocolHttpsCertificate
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enable_http: bool | None | UndefinedType = Undefined,
                enable_https: bool | None | UndefinedType = Undefined,
                enable_unix: bool | None | UndefinedType = Undefined,
                https_ssl_profile: str | None | UndefinedType = Undefined,
                default_services: bool | None | UndefinedType = Undefined,
                enable_vrfs: EnableVrfs | UndefinedType = Undefined,
                protocol_https_certificate: ProtocolHttpsCertificate | UndefinedType = Undefined,
            ) -> None:
                """
                ManagementApiHttp.


                Subclass of AvdModel.

                Args:
                    enable_http: enable_http
                    enable_https: enable_https
                    enable_unix: enable_unix
                    https_ssl_profile: SSL Profile Name.
                    default_services: Enable default services: capi-doc and tapagg.
                    enable_vrfs: Subclass of AvdIndexedList with `EnableVrfsItem` items. Primary key is `name` (`str`).
                    protocol_https_certificate: Subclass of AvdModel.

                """

    class ManagementApiModels(AvdModel):
        """Subclass of AvdModel."""

        class ProvidersItem(AvdModel):
            """Subclass of AvdModel."""

            class PathsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"path": {"type": str}, "disabled": {"type": bool, "default": False}}
                path: str | None
                disabled: bool
                """Default value: `False`"""

                if TYPE_CHECKING:

                    def __init__(self, *, path: str | None | UndefinedType = Undefined, disabled: bool | UndefinedType = Undefined) -> None:
                        """
                        PathsItem.


                        Subclass of AvdModel.

                        Args:
                            path: path
                            disabled: disabled

                        """

            class Paths(AvdList[PathsItem]):
                """Subclass of AvdList with `PathsItem` items."""

            Paths._item_type = PathsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "paths": {"type": Paths}}
            name: Literal["sysdb", "smash"] | None
            paths: Paths
            """Subclass of AvdList with `PathsItem` items."""

            if TYPE_CHECKING:

                def __init__(self, *, name: Literal["sysdb", "smash"] | None | UndefinedType = Undefined, paths: Paths | UndefinedType = Undefined) -> None:
                    """
                    ProvidersItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        paths: Subclass of AvdList with `PathsItem` items.

                    """

        class Providers(AvdList[ProvidersItem]):
            """Subclass of AvdList with `ProvidersItem` items."""

        Providers._item_type = ProvidersItem

        class Provider(AvdModel):
            """Subclass of AvdModel."""

            class Sysdb(AvdModel):
                """Subclass of AvdModel."""

                class DisabledPaths(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                DisabledPaths._item_type = str

                _fields: ClassVar[dict] = {"disabled_paths": {"type": DisabledPaths}}
                disabled_paths: DisabledPaths
                """
                List of disabled Sysdb paths for Octa.

                Subclass of AvdList with `str` items.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, disabled_paths: DisabledPaths | UndefinedType = Undefined) -> None:
                        """
                        Sysdb.


                        Subclass of AvdModel.

                        Args:
                            disabled_paths:
                               List of disabled Sysdb paths for Octa.

                               Subclass of AvdList with `str` items.

                        """

            class Smash(AvdModel):
                """Subclass of AvdModel."""

                class PathsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"path": {"type": str}, "disabled": {"type": bool}}
                    path: str
                    disabled: bool | None
                    """Disabled Smash path for Octa."""

                    if TYPE_CHECKING:

                        def __init__(self, *, path: str | UndefinedType = Undefined, disabled: bool | None | UndefinedType = Undefined) -> None:
                            """
                            PathsItem.


                            Subclass of AvdModel.

                            Args:
                                path: path
                                disabled: Disabled Smash path for Octa.

                            """

                class Paths(AvdIndexedList[str, PathsItem]):
                    """Subclass of AvdIndexedList with `PathsItem` items. Primary key is `path` (`str`)."""

                    _primary_key: ClassVar[str] = "path"

                Paths._item_type = PathsItem

                _fields: ClassVar[dict] = {"paths": {"type": Paths}}
                paths: Paths
                """
                List of Smash paths.

                Subclass of AvdIndexedList with `PathsItem` items. Primary key is `path`
                (`str`).
                """

                if TYPE_CHECKING:

                    def __init__(self, *, paths: Paths | UndefinedType = Undefined) -> None:
                        """
                        Smash.


                        Subclass of AvdModel.

                        Args:
                            paths:
                               List of Smash paths.

                               Subclass of AvdIndexedList with `PathsItem` items. Primary key is `path`
                               (`str`).

                        """

            class Macsec(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interfaces": {"type": bool}, "mka": {"type": bool}}
                interfaces: bool | None
                """Enable MACsec for interfaces."""
                mka: bool | None
                """Enable MKA for MACsec."""

                if TYPE_CHECKING:

                    def __init__(self, *, interfaces: bool | None | UndefinedType = Undefined, mka: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Macsec.


                        Subclass of AvdModel.

                        Args:
                            interfaces: Enable MACsec for interfaces.
                            mka: Enable MKA for MACsec.

                        """

            _fields: ClassVar[dict] = {"sysdb": {"type": Sysdb}, "smash": {"type": Smash}, "macsec": {"type": Macsec}}
            sysdb: Sysdb
            """
            Sysdb provider configuration.

            Subclass of AvdModel.
            """
            smash: Smash
            """
            Smash provider configuration.

            Subclass of AvdModel.
            """
            macsec: Macsec
            """
            MACsec provider configuration.

            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self, *, sysdb: Sysdb | UndefinedType = Undefined, smash: Smash | UndefinedType = Undefined, macsec: Macsec | UndefinedType = Undefined
                ) -> None:
                    """
                    Provider.


                    Subclass of AvdModel.

                    Args:
                        sysdb:
                           Sysdb provider configuration.

                           Subclass of AvdModel.
                        smash:
                           Smash provider configuration.

                           Subclass of AvdModel.
                        macsec:
                           MACsec provider configuration.

                           Subclass of AvdModel.

                    """

        _fields: ClassVar[dict] = {"providers": {"type": Providers}, "provider": {"type": Provider}}
        providers: Providers
        """Subclass of AvdList with `ProvidersItem` items."""
        provider: Provider
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, providers: Providers | UndefinedType = Undefined, provider: Provider | UndefinedType = Undefined) -> None:
                """
                ManagementApiModels.


                Subclass of AvdModel.

                Args:
                    providers: Subclass of AvdList with `ProvidersItem` items.
                    provider: Subclass of AvdModel.

                """

    class ManagementConsole(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"idle_timeout": {"type": int}}
        idle_timeout: int | None

        if TYPE_CHECKING:

            def __init__(self, *, idle_timeout: int | None | UndefinedType = Undefined) -> None:
                """
                ManagementConsole.


                Subclass of AvdModel.

                Args:
                    idle_timeout: idle_timeout

                """

    class ManagementCvx(AvdModel):
        """Subclass of AvdModel."""

        class ServerHosts(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        ServerHosts._item_type = str

        _fields: ClassVar[dict] = {"shutdown": {"type": bool}, "server_hosts": {"type": ServerHosts}, "source_interface": {"type": str}, "vrf": {"type": str}}
        shutdown: bool | None
        server_hosts: ServerHosts
        """Subclass of AvdList with `str` items."""
        source_interface: str | None
        """Interface name."""
        vrf: str | None
        """VRF Name."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                shutdown: bool | None | UndefinedType = Undefined,
                server_hosts: ServerHosts | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ManagementCvx.


                Subclass of AvdModel.

                Args:
                    shutdown: shutdown
                    server_hosts: Subclass of AvdList with `str` items.
                    source_interface: Interface name.
                    vrf: VRF Name.

                """

    class ManagementDefaults(AvdModel):
        """Subclass of AvdModel."""

        class Secret(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"hash": {"type": str}}
            hash: Literal["md5", "sha512"] | None

            if TYPE_CHECKING:

                def __init__(self, *, hash: Literal["md5", "sha512"] | None | UndefinedType = Undefined) -> None:
                    """
                    Secret.


                    Subclass of AvdModel.

                    Args:
                        hash: hash

                    """

        _fields: ClassVar[dict] = {"secret": {"type": Secret}}
        secret: Secret
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, secret: Secret | UndefinedType = Undefined) -> None:
                """
                ManagementDefaults.


                Subclass of AvdModel.

                Args:
                    secret: Subclass of AvdModel.

                """

    class ManagementInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class Lldp(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"transmit": {"type": bool}, "receive": {"type": bool}, "ztp_vlan": {"type": int}}
            transmit: bool | None
            receive: bool | None
            ztp_vlan: int | None
            """ZTP vlan number."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    transmit: bool | None | UndefinedType = Undefined,
                    receive: bool | None | UndefinedType = Undefined,
                    ztp_vlan: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Lldp.


                    Subclass of AvdModel.

                    Args:
                        transmit: transmit
                        receive: receive
                        ztp_vlan: ZTP vlan number.

                    """

        class Redundancy(AvdModel):
            """Subclass of AvdModel."""

            class Monitor(AvdModel):
                """Subclass of AvdModel."""

                class Neighbor(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ipv6_address": {"type": str}, "interval": {"type": int}, "multiplier": {"type": int}}
                    ipv6_address: str
                    interval: int | None
                    """Interval between neighbor probes in milliseconds."""
                    multiplier: int | None
                    """Number of missed neighbor replies after which it is timed out."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ipv6_address: str | UndefinedType = Undefined,
                            interval: int | None | UndefinedType = Undefined,
                            multiplier: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Neighbor.


                            Subclass of AvdModel.

                            Args:
                                ipv6_address: ipv6_address
                                interval: Interval between neighbor probes in milliseconds.
                                multiplier: Number of missed neighbor replies after which it is timed out.

                            """

                _fields: ClassVar[dict] = {"link_state": {"type": bool}, "neighbor": {"type": Neighbor}}
                link_state: bool | None
                """
                Link state of interface.
                `neighbor` and `link_state` are mutually exclusive and `link_state` takes
                precedence.
                """
                neighbor: Neighbor
                """
                To configure an IPv6 neighbor as monitor, `fallback_delay` must be set as infinity.
                `neighbor` and
                `link_state` are mutually exclusive and `link_state` takes precedence.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, link_state: bool | None | UndefinedType = Undefined, neighbor: Neighbor | UndefinedType = Undefined) -> None:
                        """
                        Monitor.


                        Subclass of AvdModel.

                        Args:
                            link_state:
                               Link state of interface.
                               `neighbor` and `link_state` are mutually exclusive and `link_state` takes
                               precedence.
                            neighbor:
                               To configure an IPv6 neighbor as monitor, `fallback_delay` must be set as infinity.
                               `neighbor` and
                               `link_state` are mutually exclusive and `link_state` takes precedence.

                               Subclass of AvdModel.

                        """

            class Supervisor1(AvdModel):
                """Subclass of AvdModel."""

                class BackupManagementInterfaces(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                BackupManagementInterfaces._item_type = str

                _fields: ClassVar[dict] = {"primary_management_interface": {"type": str}, "backup_management_interfaces": {"type": BackupManagementInterfaces}}
                primary_management_interface: str
                """Primary management interface name like 'Management1/1'."""
                backup_management_interfaces: BackupManagementInterfaces
                """
                Backup management interfaces.

                Subclass of AvdList with `str` items.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        primary_management_interface: str | UndefinedType = Undefined,
                        backup_management_interfaces: BackupManagementInterfaces | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Supervisor1.


                        Subclass of AvdModel.

                        Args:
                            primary_management_interface: Primary management interface name like 'Management1/1'.
                            backup_management_interfaces:
                               Backup management interfaces.

                               Subclass of AvdList with `str` items.

                        """

            class Supervisor2(AvdModel):
                """Subclass of AvdModel."""

                class BackupManagementInterfaces(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                BackupManagementInterfaces._item_type = str

                _fields: ClassVar[dict] = {"primary_management_interface": {"type": str}, "backup_management_interfaces": {"type": BackupManagementInterfaces}}
                primary_management_interface: str
                """Primary management interface name like 'Management1/1'."""
                backup_management_interfaces: BackupManagementInterfaces
                """
                Backup management interfaces.

                Subclass of AvdList with `str` items.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        primary_management_interface: str | UndefinedType = Undefined,
                        backup_management_interfaces: BackupManagementInterfaces | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Supervisor2.


                        Subclass of AvdModel.

                        Args:
                            primary_management_interface: Primary management interface name like 'Management1/1'.
                            backup_management_interfaces:
                               Backup management interfaces.

                               Subclass of AvdList with `str` items.

                        """

            _fields: ClassVar[dict] = {
                "fallback_delay": {"type": str},
                "monitor": {"type": Monitor},
                "supervisor_1": {"type": Supervisor1},
                "supervisor_2": {"type": Supervisor2},
            }
            fallback_delay: str | None
            """
            The duration to wait before falling back to the higher-priority interface.
            Accepts a value between 0
            and 3600 seconds, or the string `infinity` to disable fallback.
            """
            monitor: Monitor
            """Subclass of AvdModel."""
            supervisor_1: Supervisor1
            """
            Configuration for supervisor 1, including its primary and backup management interfaces.

            Subclass of
            AvdModel.
            """
            supervisor_2: Supervisor2
            """
            Configuration for supervisor 2, including its primary and backup management interfaces.

            Subclass of
            AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    fallback_delay: str | None | UndefinedType = Undefined,
                    monitor: Monitor | UndefinedType = Undefined,
                    supervisor_1: Supervisor1 | UndefinedType = Undefined,
                    supervisor_2: Supervisor2 | UndefinedType = Undefined,
                ) -> None:
                    """
                    Redundancy.


                    Subclass of AvdModel.

                    Args:
                        fallback_delay:
                           The duration to wait before falling back to the higher-priority interface.
                           Accepts a value between 0
                           and 3600 seconds, or the string `infinity` to disable fallback.
                        monitor: Subclass of AvdModel.
                        supervisor_1:
                           Configuration for supervisor 1, including its primary and backup management interfaces.

                           Subclass of
                           AvdModel.
                        supervisor_2:
                           Configuration for supervisor 2, including its primary and backup management interfaces.

                           Subclass of
                           AvdModel.

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "speed": {"type": str},
            "mtu": {"type": int},
            "vrf": {"type": str},
            "ip_address": {"type": str},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "type": {"type": str, "default": "oob"},
            "gateway": {"type": str},
            "ipv6_gateway": {"type": str},
            "mac_address": {"type": str},
            "lldp": {"type": Lldp},
            "redundancy": {"type": Redundancy},
            "eos_cli": {"type": str},
        }
        name: str
        """Management Interface Name."""
        description: str | None
        shutdown: bool | None
        speed: str | None
        """
        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
        <interface_speed>`.
        """
        mtu: int | None
        vrf: str | None
        """VRF Name."""
        ip_address: str | None
        """IPv4_address/Mask."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6_address/Mask."""
        type: Literal["oob", "inband"]
        """
        For documentation purposes only.

        Default value: `"oob"`
        """
        gateway: str | None
        """IPv4 address of default gateway in management VRF."""
        ipv6_gateway: str | None
        """IPv6 address of default gateway in management VRF."""
        mac_address: str | None
        """MAC address."""
        lldp: Lldp
        """Subclass of AvdModel."""
        redundancy: Redundancy
        """Subclass of AvdModel."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the management interface in the final EOS configuration."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                speed: str | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                type: Literal["oob", "inband"] | UndefinedType = Undefined,
                gateway: str | None | UndefinedType = Undefined,
                ipv6_gateway: str | None | UndefinedType = Undefined,
                mac_address: str | None | UndefinedType = Undefined,
                lldp: Lldp | UndefinedType = Undefined,
                redundancy: Redundancy | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ManagementInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Management Interface Name.
                    description: description
                    shutdown: shutdown
                    speed:
                       Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                       <interface_speed>`.
                    mtu: mtu
                    vrf: VRF Name.
                    ip_address: IPv4_address/Mask.
                    ipv6_enable: ipv6_enable
                    ipv6_address: IPv6_address/Mask.
                    type: For documentation purposes only.
                    gateway: IPv4 address of default gateway in management VRF.
                    ipv6_gateway: IPv6 address of default gateway in management VRF.
                    mac_address: MAC address.
                    lldp: Subclass of AvdModel.
                    redundancy: Subclass of AvdModel.
                    eos_cli: Multiline EOS CLI rendered directly on the management interface in the final EOS configuration.

                """

    class ManagementInterfaces(AvdIndexedList[str, ManagementInterfacesItem]):
        """Subclass of AvdIndexedList with `ManagementInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    ManagementInterfaces._item_type = ManagementInterfacesItem

    class ManagementSecurity(AvdModel):
        """Subclass of AvdModel."""

        class EntropySources(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "hardware": {"type": bool},
                "haveged": {"type": bool},
                "cpu_jitter": {"type": bool},
                "hardware_exclusive": {"type": bool},
            }
            hardware: bool | None
            """Use a hardware based source."""
            haveged: bool | None
            """Use the HAVEGE algorithm."""
            cpu_jitter: bool | None
            """Use the Jitter RNG algorithm of a CPU based source."""
            hardware_exclusive: bool | None
            """Only use entropy from the hardware source."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    hardware: bool | None | UndefinedType = Undefined,
                    haveged: bool | None | UndefinedType = Undefined,
                    cpu_jitter: bool | None | UndefinedType = Undefined,
                    hardware_exclusive: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    EntropySources.


                    Subclass of AvdModel.

                    Args:
                        hardware: Use a hardware based source.
                        haveged: Use the HAVEGE algorithm.
                        cpu_jitter: Use the Jitter RNG algorithm of a CPU based source.
                        hardware_exclusive: Only use entropy from the hardware source.

                    """

        class SignatureVerification(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "ssl_profile": {"type": str}}
            enabled: bool
            ssl_profile: str | None

            if TYPE_CHECKING:

                def __init__(self, *, enabled: bool | UndefinedType = Undefined, ssl_profile: str | None | UndefinedType = Undefined) -> None:
                    """
                    SignatureVerification.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        ssl_profile: ssl_profile

                    """

        class Password(AvdModel):
            """Subclass of AvdModel."""

            class PoliciesItem(AvdModel):
                """Subclass of AvdModel."""

                class Minimum(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "digits": {"type": int},
                        "length": {"type": int},
                        "lower": {"type": int},
                        "special": {"type": int},
                        "upper": {"type": int},
                    }
                    digits: int | None
                    length: int | None
                    lower: int | None
                    special: int | None
                    upper: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            digits: int | None | UndefinedType = Undefined,
                            length: int | None | UndefinedType = Undefined,
                            lower: int | None | UndefinedType = Undefined,
                            special: int | None | UndefinedType = Undefined,
                            upper: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Minimum.


                            Subclass of AvdModel.

                            Args:
                                digits: digits
                                length: length
                                lower: lower
                                special: special
                                upper: upper

                            """

                class Maximum(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"repetitive": {"type": int}, "sequential": {"type": int}}
                    repetitive: int | None
                    sequential: int | None

                    if TYPE_CHECKING:

                        def __init__(self, *, repetitive: int | None | UndefinedType = Undefined, sequential: int | None | UndefinedType = Undefined) -> None:
                            """
                            Maximum.


                            Subclass of AvdModel.

                            Args:
                                repetitive: repetitive
                                sequential: sequential

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "minimum": {"type": Minimum}, "maximum": {"type": Maximum}}
                name: str
                minimum: Minimum
                """Subclass of AvdModel."""
                maximum: Maximum
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        minimum: Minimum | UndefinedType = Undefined,
                        maximum: Maximum | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PoliciesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            minimum: Subclass of AvdModel.
                            maximum: Subclass of AvdModel.

                        """

            class Policies(AvdIndexedList[str, PoliciesItem]):
                """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Policies._item_type = PoliciesItem

            _fields: ClassVar[dict] = {
                "minimum_length": {"type": int},
                "encryption_key_common": {"type": bool},
                "encryption_reversible": {"type": str},
                "policies": {"type": Policies},
            }
            minimum_length: int | None
            encryption_key_common: bool | None
            encryption_reversible: str | None
            policies: Policies
            """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    minimum_length: int | None | UndefinedType = Undefined,
                    encryption_key_common: bool | None | UndefinedType = Undefined,
                    encryption_reversible: str | None | UndefinedType = Undefined,
                    policies: Policies | UndefinedType = Undefined,
                ) -> None:
                    """
                    Password.


                    Subclass of AvdModel.

                    Args:
                        minimum_length: minimum_length
                        encryption_key_common: encryption_key_common
                        encryption_reversible: encryption_reversible
                        policies: Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).

                    """

        class SslProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class Ciphers(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"v1_0": {"type": str}, "v1_3": {"type": str}}
                v1_0: str | None
                """
                The cipher suites for TLS version 1.0, 1.1 and 1.2.
                Colon (:) separated list of allowed ciphers as a
                string.
                """
                v1_3: str | None
                """
                The cipher suites for TLS version 1.3.
                Colon (:) separated list of allowed ciphers as a string.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, v1_0: str | None | UndefinedType = Undefined, v1_3: str | None | UndefinedType = Undefined) -> None:
                        """
                        Ciphers.


                        Subclass of AvdModel.

                        Args:
                            v1_0:
                               The cipher suites for TLS version 1.0, 1.1 and 1.2.
                               Colon (:) separated list of allowed ciphers as a
                               string.
                            v1_3:
                               The cipher suites for TLS version 1.3.
                               Colon (:) separated list of allowed ciphers as a string.

                        """

            class TrustCertificate(AvdModel):
                """Subclass of AvdModel."""

                class Certificates(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Certificates._item_type = str

                class Requirement(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"basic_constraint_ca": {"type": bool}, "hostname_fqdn": {"type": bool}}
                    basic_constraint_ca: bool | None
                    hostname_fqdn: bool | None
                    """Enforce hostname to be FQDN without wildcard."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, basic_constraint_ca: bool | None | UndefinedType = Undefined, hostname_fqdn: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            Requirement.


                            Subclass of AvdModel.

                            Args:
                                basic_constraint_ca: basic_constraint_ca
                                hostname_fqdn: Enforce hostname to be FQDN without wildcard.

                            """

                _fields: ClassVar[dict] = {
                    "certificates": {"type": Certificates},
                    "requirement": {"type": Requirement},
                    "policy_expiry_date_ignore": {"type": bool},
                    "system": {"type": bool},
                }
                certificates: Certificates
                """
                List of trust certificate names.
                Examples:
                  - test1.crt
                  - test2.crt


                Subclass of AvdList with
                `str` items.
                """
                requirement: Requirement
                """Subclass of AvdModel."""
                policy_expiry_date_ignore: bool | None
                system: bool | None
                """Use system-supplied trust certificates."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        certificates: Certificates | UndefinedType = Undefined,
                        requirement: Requirement | UndefinedType = Undefined,
                        policy_expiry_date_ignore: bool | None | UndefinedType = Undefined,
                        system: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrustCertificate.


                        Subclass of AvdModel.

                        Args:
                            certificates:
                               List of trust certificate names.
                               Examples:  # fmt: skip
                                 - test1.crt
                                 - test2.crt


                               Subclass of AvdList with
                               `str` items.
                            requirement: Subclass of AvdModel.
                            policy_expiry_date_ignore: policy_expiry_date_ignore
                            system: Use system-supplied trust certificates.

                        """

            class ChainCertificate(AvdModel):
                """Subclass of AvdModel."""

                class Certificates(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Certificates._item_type = str

                class Requirement(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"basic_constraint_ca": {"type": bool}, "include_root_ca": {"type": bool}}
                    basic_constraint_ca: bool | None
                    include_root_ca: bool | None

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, basic_constraint_ca: bool | None | UndefinedType = Undefined, include_root_ca: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            Requirement.


                            Subclass of AvdModel.

                            Args:
                                basic_constraint_ca: basic_constraint_ca
                                include_root_ca: include_root_ca

                            """

                _fields: ClassVar[dict] = {"certificates": {"type": Certificates}, "requirement": {"type": Requirement}}
                certificates: Certificates
                """
                List of chain certificate names.
                Examples:
                  - chain1.crt
                  - chain2.crt


                Subclass of AvdList with
                `str` items.
                """
                requirement: Requirement
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, certificates: Certificates | UndefinedType = Undefined, requirement: Requirement | UndefinedType = Undefined) -> None:
                        """
                        ChainCertificate.


                        Subclass of AvdModel.

                        Args:
                            certificates:
                               List of chain certificate names.
                               Examples:  # fmt: skip
                                 - chain1.crt
                                 - chain2.crt


                               Subclass of AvdList with
                               `str` items.
                            requirement: Subclass of AvdModel.

                        """

            class Certificate(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"file": {"type": str}, "key": {"type": str}}
                file: str | None
                key: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, file: str | None | UndefinedType = Undefined, key: str | None | UndefinedType = Undefined) -> None:
                        """
                        Certificate.


                        Subclass of AvdModel.

                        Args:
                            file: file
                            key: key

                        """

            class CertificateRevocationLists(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            CertificateRevocationLists._item_type = str

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "fips_restrictions": {"type": bool},
                "tls_versions": {"type": str},
                "cipher_list": {"type": str},
                "ciphers": {"type": Ciphers},
                "trust_certificate": {"type": TrustCertificate},
                "chain_certificate": {"type": ChainCertificate},
                "certificate": {"type": Certificate},
                "certificate_revocation_lists": {"type": CertificateRevocationLists},
            }
            name: str | None
            fips_restrictions: bool | None
            """Use FIPS compliant algorithms."""
            tls_versions: str | None
            """
            List of allowed TLS versions as string.
            Examples:
              - "1.0"
              - "1.0 1.1"
            """
            cipher_list: str | None
            """
            cipher_list syntax follows the openssl cipher strings format.
            Colon (:) separated list of allowed
            ciphers as a string.
            Not supported on EOS version starting 4.32.0F, use the `ciphers` setting
            instead.
            """
            ciphers: Ciphers
            """
            This setting is applicable to EOS versions 4.32.0F and later.

            Subclass of AvdModel.
            """
            trust_certificate: TrustCertificate
            """Subclass of AvdModel."""
            chain_certificate: ChainCertificate
            """Subclass of AvdModel."""
            certificate: Certificate
            """Subclass of AvdModel."""
            certificate_revocation_lists: CertificateRevocationLists
            """
            List of CRLs (Certificate Revocation List).
            If specified, one CRL needs to be provided for every
            certificate in the chain, even if the revocation list in the CRL is empty.


            Subclass of AvdList
            with `str` items.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    fips_restrictions: bool | None | UndefinedType = Undefined,
                    tls_versions: str | None | UndefinedType = Undefined,
                    cipher_list: str | None | UndefinedType = Undefined,
                    ciphers: Ciphers | UndefinedType = Undefined,
                    trust_certificate: TrustCertificate | UndefinedType = Undefined,
                    chain_certificate: ChainCertificate | UndefinedType = Undefined,
                    certificate: Certificate | UndefinedType = Undefined,
                    certificate_revocation_lists: CertificateRevocationLists | UndefinedType = Undefined,
                ) -> None:
                    """
                    SslProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        fips_restrictions: Use FIPS compliant algorithms.
                        tls_versions:
                           List of allowed TLS versions as string.
                           Examples:  # fmt: skip
                             - "1.0"
                             - "1.0 1.1"
                        cipher_list:
                           cipher_list syntax follows the openssl cipher strings format.
                           Colon (:) separated list of allowed
                           ciphers as a string.
                           Not supported on EOS version starting 4.32.0F, use the `ciphers` setting
                           instead.
                        ciphers:
                           This setting is applicable to EOS versions 4.32.0F and later.

                           Subclass of AvdModel.
                        trust_certificate: Subclass of AvdModel.
                        chain_certificate: Subclass of AvdModel.
                        certificate: Subclass of AvdModel.
                        certificate_revocation_lists:
                           List of CRLs (Certificate Revocation List).
                           If specified, one CRL needs to be provided for every
                           certificate in the chain, even if the revocation list in the CRL is empty.


                           Subclass of AvdList
                           with `str` items.

                    """

        class SslProfiles(AvdList[SslProfilesItem]):
            """Subclass of AvdList with `SslProfilesItem` items."""

        SslProfiles._item_type = SslProfilesItem

        class SharedSecretProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class SecretsItem(AvdModel):
                """Subclass of AvdModel."""

                class ReceiveLifetime(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"infinite": {"type": bool}, "start_date_time": {"type": str}, "end_date_time": {"type": str}}
                    infinite: bool | None
                    start_date_time: str | None
                    """
                    Start date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """
                    end_date_time: str | None
                    """
                    End date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            infinite: bool | None | UndefinedType = Undefined,
                            start_date_time: str | None | UndefinedType = Undefined,
                            end_date_time: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ReceiveLifetime.


                            Subclass of AvdModel.

                            Args:
                                infinite: infinite
                                start_date_time:
                                   Start date and time of lifetime of the secret. End date should be greater than start date.
                                   Formats
                                   supported:
                                   1. mm/dd/yyyy hh:mm:ss
                                   2. yyyy-mm-dd hh:mm:ss
                                   e.g 2024-12-20 10:00:00
                                end_date_time:
                                   End date and time of lifetime of the secret. End date should be greater than start date.
                                   Formats
                                   supported:
                                   1. mm/dd/yyyy hh:mm:ss
                                   2. yyyy-mm-dd hh:mm:ss
                                   e.g 2024-12-20 10:00:00

                            """

                class TransmitLifetime(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"infinite": {"type": bool}, "start_date_time": {"type": str}, "end_date_time": {"type": str}}
                    infinite: bool | None
                    start_date_time: str | None
                    """
                    Start date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """
                    end_date_time: str | None
                    """
                    End date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            infinite: bool | None | UndefinedType = Undefined,
                            start_date_time: str | None | UndefinedType = Undefined,
                            end_date_time: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            TransmitLifetime.


                            Subclass of AvdModel.

                            Args:
                                infinite: infinite
                                start_date_time:
                                   Start date and time of lifetime of the secret. End date should be greater than start date.
                                   Formats
                                   supported:
                                   1. mm/dd/yyyy hh:mm:ss
                                   2. yyyy-mm-dd hh:mm:ss
                                   e.g 2024-12-20 10:00:00
                                end_date_time:
                                   End date and time of lifetime of the secret. End date should be greater than start date.
                                   Formats
                                   supported:
                                   1. mm/dd/yyyy hh:mm:ss
                                   2. yyyy-mm-dd hh:mm:ss
                                   e.g 2024-12-20 10:00:00

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "secret": {"type": str},
                    "secret_type": {"type": str, "default": "7"},
                    "receive_lifetime": {"type": ReceiveLifetime},
                    "transmit_lifetime": {"type": TransmitLifetime},
                    "local_time": {"type": bool},
                }
                name: str
                secret: str
                secret_type: Literal["0", "7", "8a"]
                """Default value: `"7"`"""
                receive_lifetime: ReceiveLifetime
                """Subclass of AvdModel."""
                transmit_lifetime: TransmitLifetime
                """Subclass of AvdModel."""
                local_time: bool | None
                """Configuring secret using the local timezone from system clock. Default is UTC."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        secret: str | UndefinedType = Undefined,
                        secret_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                        receive_lifetime: ReceiveLifetime | UndefinedType = Undefined,
                        transmit_lifetime: TransmitLifetime | UndefinedType = Undefined,
                        local_time: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SecretsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            secret: secret
                            secret_type: secret_type
                            receive_lifetime: Subclass of AvdModel.
                            transmit_lifetime: Subclass of AvdModel.
                            local_time: Configuring secret using the local timezone from system clock. Default is UTC.

                        """

            class Secrets(AvdIndexedList[str, SecretsItem]):
                """Subclass of AvdIndexedList with `SecretsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Secrets._item_type = SecretsItem

            _fields: ClassVar[dict] = {"profile": {"type": str}, "secrets": {"type": Secrets}}
            profile: str
            secrets: Secrets
            """Subclass of AvdIndexedList with `SecretsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(self, *, profile: str | UndefinedType = Undefined, secrets: Secrets | UndefinedType = Undefined) -> None:
                    """
                    SharedSecretProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        profile: profile
                        secrets: Subclass of AvdIndexedList with `SecretsItem` items. Primary key is `name` (`str`).

                    """

        class SharedSecretProfiles(AvdIndexedList[str, SharedSecretProfilesItem]):
            """Subclass of AvdIndexedList with `SharedSecretProfilesItem` items. Primary key is `profile` (`str`)."""

            _primary_key: ClassVar[str] = "profile"

        SharedSecretProfiles._item_type = SharedSecretProfilesItem

        _fields: ClassVar[dict] = {
            "entropy_sources": {"type": EntropySources},
            "signature_verification": {"type": SignatureVerification},
            "password": {"type": Password},
            "ssl_profiles": {"type": SslProfiles},
            "shared_secret_profiles": {"type": SharedSecretProfiles},
        }
        entropy_sources: EntropySources
        """
        Source of entropy.

        Subclass of AvdModel.
        """
        signature_verification: SignatureVerification
        """
        Verify the SWIX signatures.

        Subclass of AvdModel.
        """
        password: Password
        """Subclass of AvdModel."""
        ssl_profiles: SslProfiles
        """Subclass of AvdList with `SslProfilesItem` items."""
        shared_secret_profiles: SharedSecretProfiles
        """Subclass of AvdIndexedList with `SharedSecretProfilesItem` items. Primary key is `profile` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                entropy_sources: EntropySources | UndefinedType = Undefined,
                signature_verification: SignatureVerification | UndefinedType = Undefined,
                password: Password | UndefinedType = Undefined,
                ssl_profiles: SslProfiles | UndefinedType = Undefined,
                shared_secret_profiles: SharedSecretProfiles | UndefinedType = Undefined,
            ) -> None:
                """
                ManagementSecurity.


                Subclass of AvdModel.

                Args:
                    entropy_sources:
                       Source of entropy.

                       Subclass of AvdModel.
                    signature_verification:
                       Verify the SWIX signatures.

                       Subclass of AvdModel.
                    password: Subclass of AvdModel.
                    ssl_profiles: Subclass of AvdList with `SslProfilesItem` items.
                    shared_secret_profiles: Subclass of AvdIndexedList with `SharedSecretProfilesItem` items. Primary key is `profile` (`str`).

                """

    class ManagementSsh(AvdModel):
        """Subclass of AvdModel."""

        class Authentication(AvdModel):
            """Subclass of AvdModel."""

            class Protocols(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Protocols._item_type = str

            _fields: ClassVar[dict] = {"empty_passwords": {"type": str}, "protocols": {"type": Protocols}}
            empty_passwords: Literal["auto", "deny", "permit"] | None
            """Permit or deny empty passwords for SSH authentication."""
            protocols: Protocols
            """
            Allowed SSH authentication methods.

            Subclass of AvdList with `str` items.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    empty_passwords: Literal["auto", "deny", "permit"] | None | UndefinedType = Undefined,
                    protocols: Protocols | UndefinedType = Undefined,
                ) -> None:
                    """
                    Authentication.


                    Subclass of AvdModel.

                    Args:
                        empty_passwords: Permit or deny empty passwords for SSH authentication.
                        protocols:
                           Allowed SSH authentication methods.

                           Subclass of AvdList with `str` items.

                    """

        class AccessGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
            name: str | None
            """Standard ACL Name."""
            vrf: str | None
            """VRF Name."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | None | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                    """
                    AccessGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Standard ACL Name.
                        vrf: VRF Name.

                    """

        class AccessGroups(AvdList[AccessGroupsItem]):
            """Subclass of AvdList with `AccessGroupsItem` items."""

        AccessGroups._item_type = AccessGroupsItem

        class Ipv6AccessGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
            name: str | None
            """Standard ACL Name."""
            vrf: str | None
            """VRF Name."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | None | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                    """
                    Ipv6AccessGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Standard ACL Name.
                        vrf: VRF Name.

                    """

        class Ipv6AccessGroups(AvdList[Ipv6AccessGroupsItem]):
            """Subclass of AvdList with `Ipv6AccessGroupsItem` items."""

        Ipv6AccessGroups._item_type = Ipv6AccessGroupsItem

        class Cipher(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Cipher._item_type = str

        class KeyExchange(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        KeyExchange._item_type = str

        class Mac(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Mac._item_type = str

        class Hostkey(AvdModel):
            """Subclass of AvdModel."""

            class Server(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Server._item_type = str

            _fields: ClassVar[dict] = {"server": {"type": Server}, "server_cert": {"type": str}, "client_strict_checking": {"type": bool}}
            server: Server
            """
            SSH host key settings.

            Subclass of AvdList with `str` items.
            """
            server_cert: str | None
            """Configure switch's hostkey cert file."""
            client_strict_checking: bool | None
            """Enforce strict host key checking."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    server: Server | UndefinedType = Undefined,
                    server_cert: str | None | UndefinedType = Undefined,
                    client_strict_checking: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Hostkey.


                    Subclass of AvdModel.

                    Args:
                        server:
                           SSH host key settings.

                           Subclass of AvdList with `str` items.
                        server_cert: Configure switch's hostkey cert file.
                        client_strict_checking: Enforce strict host key checking.

                    """

        class Connection(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"limit": {"type": int}, "per_host": {"type": int}}
            limit: int | None
            """Maximum total number of SSH sessions to device."""
            per_host: int | None
            """Maximum number of SSH sessions to device from a single host."""

            if TYPE_CHECKING:

                def __init__(self, *, limit: int | None | UndefinedType = Undefined, per_host: int | None | UndefinedType = Undefined) -> None:
                    """
                    Connection.


                    Subclass of AvdModel.

                    Args:
                        limit: Maximum total number of SSH sessions to device.
                        per_host: Maximum number of SSH sessions to device from a single host.

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "enable": {"type": bool},
                "ip_access_group_in": {"type": str},
                "ipv6_access_group_in": {"type": str},
            }
            name: str
            """VRF Name."""
            enable: bool | None
            """Enable SSH in VRF."""
            ip_access_group_in: str | None
            """
            Standard ACL Name.
            This should not be set for VRF 'default'. Use `management_ssh.ip_access_group_in`
            instead.
            """
            ipv6_access_group_in: str | None
            """
            Standard IPv6 ACL Name.
            This should not be set for VRF 'default'. Use
            `management_ssh.ipv6_access_group_in` instead.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    enable: bool | None | UndefinedType = Undefined,
                    ip_access_group_in: str | None | UndefinedType = Undefined,
                    ipv6_access_group_in: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF Name.
                        enable: Enable SSH in VRF.
                        ip_access_group_in:
                           Standard ACL Name.
                           This should not be set for VRF 'default'. Use `management_ssh.ip_access_group_in`
                           instead.
                        ipv6_access_group_in:
                           Standard IPv6 ACL Name.
                           This should not be set for VRF 'default'. Use
                           `management_ssh.ipv6_access_group_in` instead.

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class ClientAlive(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"count_max": {"type": int}, "interval": {"type": int}}
            count_max: int | None
            """
            Number of keep-alive packets that can be sent without a response before the connection is assumed
            dead.
            """
            interval: int | None
            """Time period (in seconds) to send SSH keep-alive packets."""

            if TYPE_CHECKING:

                def __init__(self, *, count_max: int | None | UndefinedType = Undefined, interval: int | None | UndefinedType = Undefined) -> None:
                    """
                    ClientAlive.


                    Subclass of AvdModel.

                    Args:
                        count_max:
                           Number of keep-alive packets that can be sent without a response before the connection is assumed
                           dead.
                        interval: Time period (in seconds) to send SSH keep-alive packets.

                    """

        _fields: ClassVar[dict] = {
            "authentication": {"type": Authentication},
            "access_groups": {"type": AccessGroups},
            "ipv6_access_groups": {"type": Ipv6AccessGroups},
            "ip_access_group_in": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "idle_timeout": {"type": int},
            "cipher": {"type": Cipher},
            "key_exchange": {"type": KeyExchange},
            "mac": {"type": Mac},
            "fips_restrictions": {"type": bool},
            "hostkey": {"type": Hostkey},
            "enable": {"type": bool},
            "connection": {"type": Connection},
            "vrfs": {"type": Vrfs},
            "log_level": {"type": str},
            "client_alive": {"type": ClientAlive},
        }
        authentication: Authentication
        """Subclass of AvdModel."""
        access_groups: AccessGroups
        """Subclass of AvdList with `AccessGroupsItem` items."""
        ipv6_access_groups: Ipv6AccessGroups
        """Subclass of AvdList with `Ipv6AccessGroupsItem` items."""
        ip_access_group_in: str | None
        """Standard ACL Name."""
        ipv6_access_group_in: str | None
        """Standard IPv6 ACL Name."""
        idle_timeout: int | None
        """Idle timeout in minutes."""
        cipher: Cipher
        """
        Cryptographic ciphers for SSH to use.

        Subclass of AvdList with `str` items.
        """
        key_exchange: KeyExchange
        """
        Cryptographic key exchange methods for SSH to use.

        Subclass of AvdList with `str` items.
        """
        mac: Mac
        """
        Cryptographic MAC algorithms for SSH to use.

        Subclass of AvdList with `str` items.
        """
        fips_restrictions: bool | None
        """Use FIPS compliant algorithms."""
        hostkey: Hostkey
        """Subclass of AvdModel."""
        enable: bool | None
        """Enable SSH for VRF default."""
        connection: Connection
        """Subclass of AvdModel."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        log_level: str | None
        """SSH daemon log level."""
        client_alive: ClientAlive
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                authentication: Authentication | UndefinedType = Undefined,
                access_groups: AccessGroups | UndefinedType = Undefined,
                ipv6_access_groups: Ipv6AccessGroups | UndefinedType = Undefined,
                ip_access_group_in: str | None | UndefinedType = Undefined,
                ipv6_access_group_in: str | None | UndefinedType = Undefined,
                idle_timeout: int | None | UndefinedType = Undefined,
                cipher: Cipher | UndefinedType = Undefined,
                key_exchange: KeyExchange | UndefinedType = Undefined,
                mac: Mac | UndefinedType = Undefined,
                fips_restrictions: bool | None | UndefinedType = Undefined,
                hostkey: Hostkey | UndefinedType = Undefined,
                enable: bool | None | UndefinedType = Undefined,
                connection: Connection | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                log_level: str | None | UndefinedType = Undefined,
                client_alive: ClientAlive | UndefinedType = Undefined,
            ) -> None:
                """
                ManagementSsh.


                Subclass of AvdModel.

                Args:
                    authentication: Subclass of AvdModel.
                    access_groups: Subclass of AvdList with `AccessGroupsItem` items.
                    ipv6_access_groups: Subclass of AvdList with `Ipv6AccessGroupsItem` items.
                    ip_access_group_in: Standard ACL Name.
                    ipv6_access_group_in: Standard IPv6 ACL Name.
                    idle_timeout: Idle timeout in minutes.
                    cipher:
                       Cryptographic ciphers for SSH to use.

                       Subclass of AvdList with `str` items.
                    key_exchange:
                       Cryptographic key exchange methods for SSH to use.

                       Subclass of AvdList with `str` items.
                    mac:
                       Cryptographic MAC algorithms for SSH to use.

                       Subclass of AvdList with `str` items.
                    fips_restrictions: Use FIPS compliant algorithms.
                    hostkey: Subclass of AvdModel.
                    enable: Enable SSH for VRF default.
                    connection: Subclass of AvdModel.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    log_level: SSH daemon log level.
                    client_alive: Subclass of AvdModel.

                """

    class ManagementTechSupport(AvdModel):
        """Subclass of AvdModel."""

        class PolicyShowTechSupport(AvdModel):
            """Subclass of AvdModel."""

            class ExcludeCommandsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"command": {"type": str}, "type": {"type": str, "default": "text"}}
                command: str | None
                """Command to exclude from tech-support."""
                type: Literal["text", "json"]
                """
                The supported values for type are platform dependent.

                Default value: `"text"`
                """

                if TYPE_CHECKING:

                    def __init__(self, *, command: str | None | UndefinedType = Undefined, type: Literal["text", "json"] | UndefinedType = Undefined) -> None:
                        """
                        ExcludeCommandsItem.


                        Subclass of AvdModel.

                        Args:
                            command: Command to exclude from tech-support.
                            type: The supported values for type are platform dependent.

                        """

            class ExcludeCommands(AvdList[ExcludeCommandsItem]):
                """Subclass of AvdList with `ExcludeCommandsItem` items."""

            ExcludeCommands._item_type = ExcludeCommandsItem

            class IncludeCommandsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"command": {"type": str}}
                command: str | None
                """Command to include in tech-support."""

                if TYPE_CHECKING:

                    def __init__(self, *, command: str | None | UndefinedType = Undefined) -> None:
                        """
                        IncludeCommandsItem.


                        Subclass of AvdModel.

                        Args:
                            command: Command to include in tech-support.

                        """

            class IncludeCommands(AvdList[IncludeCommandsItem]):
                """Subclass of AvdList with `IncludeCommandsItem` items."""

            IncludeCommands._item_type = IncludeCommandsItem

            _fields: ClassVar[dict] = {"exclude_commands": {"type": ExcludeCommands}, "include_commands": {"type": IncludeCommands}}
            exclude_commands: ExcludeCommands
            """Subclass of AvdList with `ExcludeCommandsItem` items."""
            include_commands: IncludeCommands
            """Subclass of AvdList with `IncludeCommandsItem` items."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, exclude_commands: ExcludeCommands | UndefinedType = Undefined, include_commands: IncludeCommands | UndefinedType = Undefined
                ) -> None:
                    """
                    PolicyShowTechSupport.


                    Subclass of AvdModel.

                    Args:
                        exclude_commands: Subclass of AvdList with `ExcludeCommandsItem` items.
                        include_commands: Subclass of AvdList with `IncludeCommandsItem` items.

                    """

        _fields: ClassVar[dict] = {"policy_show_tech_support": {"type": PolicyShowTechSupport}}
        policy_show_tech_support: PolicyShowTechSupport
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, policy_show_tech_support: PolicyShowTechSupport | UndefinedType = Undefined) -> None:
                """
                ManagementTechSupport.


                Subclass of AvdModel.

                Args:
                    policy_show_tech_support: Subclass of AvdModel.

                """

    class MatchListInput(AvdModel):
        """Subclass of AvdModel."""

        class PrefixIpv4Item(AvdModel):
            """Subclass of AvdModel."""

            class Prefixes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Prefixes._item_type = str

            _fields: ClassVar[dict] = {"name": {"type": str}, "prefixes": {"type": Prefixes}}
            name: str
            """Prefix-List Name."""
            prefixes: Prefixes
            """
            List of IPv4 prefixes (with the subnet mask e.g. 192.0.2.0/24).

            Subclass of AvdList with `str`
            items.
            """

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, prefixes: Prefixes | UndefinedType = Undefined) -> None:
                    """
                    PrefixIpv4Item.


                    Subclass of AvdModel.

                    Args:
                        name: Prefix-List Name.
                        prefixes:
                           List of IPv4 prefixes (with the subnet mask e.g. 192.0.2.0/24).

                           Subclass of AvdList with `str`
                           items.

                    """

        class PrefixIpv4(AvdIndexedList[str, PrefixIpv4Item]):
            """Subclass of AvdIndexedList with `PrefixIpv4Item` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        PrefixIpv4._item_type = PrefixIpv4Item

        class PrefixIpv6Item(AvdModel):
            """Subclass of AvdModel."""

            class Prefixes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Prefixes._item_type = str

            _fields: ClassVar[dict] = {"name": {"type": str}, "prefixes": {"type": Prefixes}}
            name: str
            """Prefix-List Name."""
            prefixes: Prefixes
            """
            List of IPv6 prefixes (with the subnet mask e.g. 2001:db8:abcd:0013::/64).

            Subclass of AvdList with
            `str` items.
            """

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, prefixes: Prefixes | UndefinedType = Undefined) -> None:
                    """
                    PrefixIpv6Item.


                    Subclass of AvdModel.

                    Args:
                        name: Prefix-List Name.
                        prefixes:
                           List of IPv6 prefixes (with the subnet mask e.g. 2001:db8:abcd:0013::/64).

                           Subclass of AvdList with
                           `str` items.

                    """

        class PrefixIpv6(AvdIndexedList[str, PrefixIpv6Item]):
            """Subclass of AvdIndexedList with `PrefixIpv6Item` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        PrefixIpv6._item_type = PrefixIpv6Item

        class StringItem(AvdModel):
            """Subclass of AvdModel."""

            class SequenceNumbersItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"sequence": {"type": int}, "match_regex": {"type": str}}
                sequence: int
                """Sequence ID."""
                match_regex: str
                """Regular Expression."""

                if TYPE_CHECKING:

                    def __init__(self, *, sequence: int | UndefinedType = Undefined, match_regex: str | UndefinedType = Undefined) -> None:
                        """
                        SequenceNumbersItem.


                        Subclass of AvdModel.

                        Args:
                            sequence: Sequence ID.
                            match_regex: Regular Expression.

                        """

            class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
                """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

                _primary_key: ClassVar[str] = "sequence"

            SequenceNumbers._item_type = SequenceNumbersItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
            name: str
            """Match-list Name."""
            sequence_numbers: SequenceNumbers
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, sequence_numbers: SequenceNumbers | UndefinedType = Undefined) -> None:
                    """
                    StringItem.


                    Subclass of AvdModel.

                    Args:
                        name: Match-list Name.
                        sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).

                    """

        class String(AvdIndexedList[str, StringItem]):
            """Subclass of AvdIndexedList with `StringItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        String._item_type = StringItem

        _fields: ClassVar[dict] = {"prefix_ipv4": {"type": PrefixIpv4}, "prefix_ipv6": {"type": PrefixIpv6}, "string": {"type": String}}
        prefix_ipv4: PrefixIpv4
        """Subclass of AvdIndexedList with `PrefixIpv4Item` items. Primary key is `name` (`str`)."""
        prefix_ipv6: PrefixIpv6
        """Subclass of AvdIndexedList with `PrefixIpv6Item` items. Primary key is `name` (`str`)."""
        string: String
        """Subclass of AvdIndexedList with `StringItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                prefix_ipv4: PrefixIpv4 | UndefinedType = Undefined,
                prefix_ipv6: PrefixIpv6 | UndefinedType = Undefined,
                string: String | UndefinedType = Undefined,
            ) -> None:
                """
                MatchListInput.


                Subclass of AvdModel.

                Args:
                    prefix_ipv4: Subclass of AvdIndexedList with `PrefixIpv4Item` items. Primary key is `name` (`str`).
                    prefix_ipv6: Subclass of AvdIndexedList with `PrefixIpv6Item` items. Primary key is `name` (`str`).
                    string: Subclass of AvdIndexedList with `StringItem` items. Primary key is `name` (`str`).

                """

    class McsClient(AvdModel):
        """Subclass of AvdModel."""

        class CvxSecondary(AvdModel):
            """Subclass of AvdModel."""

            class ServerHosts(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            ServerHosts._item_type = str

            _fields: ClassVar[dict] = {"name": {"type": str}, "shutdown": {"type": bool}, "server_hosts": {"type": ServerHosts}}
            name: str | None
            shutdown: bool | None
            server_hosts: ServerHosts
            """Subclass of AvdList with `str` items."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    server_hosts: ServerHosts | UndefinedType = Undefined,
                ) -> None:
                    """
                    CvxSecondary.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        shutdown: shutdown
                        server_hosts: Subclass of AvdList with `str` items.

                    """

        _fields: ClassVar[dict] = {"shutdown": {"type": bool}, "cvx_secondary": {"type": CvxSecondary}}
        shutdown: bool | None
        cvx_secondary: CvxSecondary
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, shutdown: bool | None | UndefinedType = Undefined, cvx_secondary: CvxSecondary | UndefinedType = Undefined) -> None:
                """
                McsClient.


                Subclass of AvdModel.

                Args:
                    shutdown: shutdown
                    cvx_secondary: Subclass of AvdModel.

                """

    class Metadata(AvdModel):
        """Subclass of AvdModel."""

        class CvTags(AvdModel):
            """Subclass of AvdModel."""

            class DeviceTagsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "value": {"type": str}}
                name: str
                value: str

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, value: str | UndefinedType = Undefined) -> None:
                        """
                        DeviceTagsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            value: value

                        """

            class DeviceTags(AvdList[DeviceTagsItem]):
                """Subclass of AvdList with `DeviceTagsItem` items."""

            DeviceTags._item_type = DeviceTagsItem

            class InterfaceTagsItem(AvdModel):
                """Subclass of AvdModel."""

                class TagsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "value": {"type": str}}
                    name: str
                    value: str

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | UndefinedType = Undefined, value: str | UndefinedType = Undefined) -> None:
                            """
                            TagsItem.


                            Subclass of AvdModel.

                            Args:
                                name: name
                                value: value

                            """

                class Tags(AvdList[TagsItem]):
                    """Subclass of AvdList with `TagsItem` items."""

                Tags._item_type = TagsItem

                _fields: ClassVar[dict] = {"interface": {"type": str}, "tags": {"type": Tags}}
                interface: str
                tags: Tags
                """Subclass of AvdList with `TagsItem` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, interface: str | UndefinedType = Undefined, tags: Tags | UndefinedType = Undefined) -> None:
                        """
                        InterfaceTagsItem.


                        Subclass of AvdModel.

                        Args:
                            interface: interface
                            tags: Subclass of AvdList with `TagsItem` items.

                        """

            class InterfaceTags(AvdList[InterfaceTagsItem]):
                """Subclass of AvdList with `InterfaceTagsItem` items."""

            InterfaceTags._item_type = InterfaceTagsItem

            _fields: ClassVar[dict] = {"device_tags": {"type": DeviceTags}, "interface_tags": {"type": InterfaceTags}}
            device_tags: DeviceTags
            """Subclass of AvdList with `DeviceTagsItem` items."""
            interface_tags: InterfaceTags
            """Subclass of AvdList with `InterfaceTagsItem` items."""

            if TYPE_CHECKING:

                def __init__(self, *, device_tags: DeviceTags | UndefinedType = Undefined, interface_tags: InterfaceTags | UndefinedType = Undefined) -> None:
                    """
                    CvTags.


                    Subclass of AvdModel.

                    Args:
                        device_tags: Subclass of AvdList with `DeviceTagsItem` items.
                        interface_tags: Subclass of AvdList with `InterfaceTagsItem` items.

                    """

        class CvPathfinder(AvdModel):
            """Subclass of AvdModel."""

            class PathfindersItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"vtep_ip": {"type": str}}
                vtep_ip: str

                if TYPE_CHECKING:

                    def __init__(self, *, vtep_ip: str | UndefinedType = Undefined) -> None:
                        """
                        PathfindersItem.


                        Subclass of AvdModel.

                        Args:
                            vtep_ip: vtep_ip

                        """

            class Pathfinders(AvdList[PathfindersItem]):
                """Subclass of AvdList with `PathfindersItem` items."""

            Pathfinders._item_type = PathfindersItem

            class InterfacesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "carrier": {"type": str},
                    "circuit_id": {"type": str},
                    "pathgroup": {"type": str},
                    "public_ip": {"type": str},
                }
                name: str | None
                carrier: str | None
                circuit_id: str | None
                pathgroup: str | None
                public_ip: str | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        carrier: str | None | UndefinedType = Undefined,
                        circuit_id: str | None | UndefinedType = Undefined,
                        pathgroup: str | None | UndefinedType = Undefined,
                        public_ip: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        InterfacesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            carrier: carrier
                            circuit_id: circuit_id
                            pathgroup: pathgroup
                            public_ip: public_ip

                        """

            class Interfaces(AvdList[InterfacesItem]):
                """Subclass of AvdList with `InterfacesItem` items."""

            Interfaces._item_type = InterfacesItem

            class PathgroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class CarriersItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}}
                    name: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | None | UndefinedType = Undefined) -> None:
                            """
                            CarriersItem.


                            Subclass of AvdModel.

                            Args:
                                name: name

                            """

                class Carriers(AvdList[CarriersItem]):
                    """Subclass of AvdList with `CarriersItem` items."""

                Carriers._item_type = CarriersItem

                class ImportedCarriersItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}}
                    name: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | None | UndefinedType = Undefined) -> None:
                            """
                            ImportedCarriersItem.


                            Subclass of AvdModel.

                            Args:
                                name: name

                            """

                class ImportedCarriers(AvdList[ImportedCarriersItem]):
                    """Subclass of AvdList with `ImportedCarriersItem` items."""

                ImportedCarriers._item_type = ImportedCarriersItem

                _fields: ClassVar[dict] = {"name": {"type": str}, "carriers": {"type": Carriers}, "imported_carriers": {"type": ImportedCarriers}}
                name: str
                carriers: Carriers
                """Subclass of AvdList with `CarriersItem` items."""
                imported_carriers: ImportedCarriers
                """Subclass of AvdList with `ImportedCarriersItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        carriers: Carriers | UndefinedType = Undefined,
                        imported_carriers: ImportedCarriers | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PathgroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            carriers: Subclass of AvdList with `CarriersItem` items.
                            imported_carriers: Subclass of AvdList with `ImportedCarriersItem` items.

                        """

            class Pathgroups(AvdList[PathgroupsItem]):
                """Subclass of AvdList with `PathgroupsItem` items."""

            Pathgroups._item_type = PathgroupsItem

            class RegionsItem(AvdModel):
                """Subclass of AvdModel."""

                class ZonesItem(AvdModel):
                    """Subclass of AvdModel."""

                    class SitesItem(AvdModel):
                        """Subclass of AvdModel."""

                        class Location(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"address": {"type": str}}
                            address: str | None

                            if TYPE_CHECKING:

                                def __init__(self, *, address: str | None | UndefinedType = Undefined) -> None:
                                    """
                                    Location.


                                    Subclass of AvdModel.

                                    Args:
                                        address: address

                                    """

                        _fields: ClassVar[dict] = {"id": {"type": int}, "name": {"type": str}, "location": {"type": Location}}
                        id: int | None
                        name: str | None
                        location: Location
                        """Subclass of AvdModel."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                id: int | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                                location: Location | UndefinedType = Undefined,
                            ) -> None:
                                """
                                SitesItem.


                                Subclass of AvdModel.

                                Args:
                                    id: id
                                    name: name
                                    location: Subclass of AvdModel.

                                """

                    class Sites(AvdList[SitesItem]):
                        """Subclass of AvdList with `SitesItem` items."""

                    Sites._item_type = SitesItem

                    _fields: ClassVar[dict] = {"id": {"type": int}, "name": {"type": str}, "sites": {"type": Sites}}
                    id: int | None
                    name: str | None
                    sites: Sites
                    """Subclass of AvdList with `SitesItem` items."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | None | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            sites: Sites | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ZonesItem.


                            Subclass of AvdModel.

                            Args:
                                id: id
                                name: name
                                sites: Subclass of AvdList with `SitesItem` items.

                            """

                class Zones(AvdList[ZonesItem]):
                    """Subclass of AvdList with `ZonesItem` items."""

                Zones._item_type = ZonesItem

                _fields: ClassVar[dict] = {"id": {"type": int}, "name": {"type": str}, "zones": {"type": Zones}}
                id: int | None
                name: str | None
                zones: Zones
                """Subclass of AvdList with `ZonesItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: int | None | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                        zones: Zones | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RegionsItem.


                        Subclass of AvdModel.

                        Args:
                            id: id
                            name: name
                            zones: Subclass of AvdList with `ZonesItem` items.

                        """

            class Regions(AvdList[RegionsItem]):
                """Subclass of AvdList with `RegionsItem` items."""

            Regions._item_type = RegionsItem

            class VrfsItem(AvdModel):
                """Subclass of AvdModel."""

                class AvtsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Constraints(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"jitter": {"type": int}, "latency": {"type": int}, "lossrate": {"type": str}, "hop_count": {"type": str}}
                        jitter: int | None
                        latency: int | None
                        lossrate: str | None
                        hop_count: str | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                jitter: int | None | UndefinedType = Undefined,
                                latency: int | None | UndefinedType = Undefined,
                                lossrate: str | None | UndefinedType = Undefined,
                                hop_count: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Constraints.


                                Subclass of AvdModel.

                                Args:
                                    jitter: jitter
                                    latency: latency
                                    lossrate: lossrate
                                    hop_count: hop_count

                                """

                    class PathgroupsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"name": {"type": str}, "preference": {"type": str}}
                        name: str | None
                        preference: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, name: str | None | UndefinedType = Undefined, preference: str | None | UndefinedType = Undefined) -> None:
                                """
                                PathgroupsItem.


                                Subclass of AvdModel.

                                Args:
                                    name: name
                                    preference: preference

                                """

                    class Pathgroups(AvdList[PathgroupsItem]):
                        """Subclass of AvdList with `PathgroupsItem` items."""

                    Pathgroups._item_type = PathgroupsItem

                    class ApplicationProfiles(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    ApplicationProfiles._item_type = str

                    _fields: ClassVar[dict] = {
                        "constraints": {"type": Constraints},
                        "description": {"type": str},
                        "id": {"type": int},
                        "name": {"type": str},
                        "pathgroups": {"type": Pathgroups},
                        "application_profiles": {"type": ApplicationProfiles},
                    }
                    constraints: Constraints
                    """Subclass of AvdModel."""
                    description: str | None
                    id: int | None
                    name: str | None
                    pathgroups: Pathgroups
                    """Subclass of AvdList with `PathgroupsItem` items."""
                    application_profiles: ApplicationProfiles
                    """Subclass of AvdList with `str` items."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            constraints: Constraints | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            id: int | None | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            pathgroups: Pathgroups | UndefinedType = Undefined,
                            application_profiles: ApplicationProfiles | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AvtsItem.


                            Subclass of AvdModel.

                            Args:
                                constraints: Subclass of AvdModel.
                                description: description
                                id: id
                                name: name
                                pathgroups: Subclass of AvdList with `PathgroupsItem` items.
                                application_profiles: Subclass of AvdList with `str` items.

                            """

                class Avts(AvdList[AvtsItem]):
                    """Subclass of AvdList with `AvtsItem` items."""

                Avts._item_type = AvtsItem

                _fields: ClassVar[dict] = {"name": {"type": str}, "vni": {"type": int}, "avts": {"type": Avts}}
                name: str | None
                vni: int | None
                avts: Avts
                """Subclass of AvdList with `AvtsItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        vni: int | None | UndefinedType = Undefined,
                        avts: Avts | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VrfsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            vni: vni
                            avts: Subclass of AvdList with `AvtsItem` items.

                        """

            class Vrfs(AvdList[VrfsItem]):
                """Subclass of AvdList with `VrfsItem` items."""

            Vrfs._item_type = VrfsItem

            class InternetExitPoliciesItem(AvdModel):
                """Subclass of AvdModel."""

                class VpnCredentialsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"fqdn": {"type": str}, "vpn_type": {"type": str}, "pre_shared_key": {"type": str}}
                    fqdn: str
                    vpn_type: str
                    pre_shared_key: str

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            fqdn: str | UndefinedType = Undefined,
                            vpn_type: str | UndefinedType = Undefined,
                            pre_shared_key: str | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VpnCredentialsItem.


                            Subclass of AvdModel.

                            Args:
                                fqdn: fqdn
                                vpn_type: vpn_type
                                pre_shared_key: pre_shared_key

                            """

                class VpnCredentials(AvdList[VpnCredentialsItem]):
                    """Subclass of AvdList with `VpnCredentialsItem` items."""

                VpnCredentials._item_type = VpnCredentialsItem

                class TunnelsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Endpoint(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "ip_address": {"type": str},
                            "datacenter": {"type": str},
                            "city": {"type": str},
                            "country": {"type": str},
                            "region": {"type": str},
                            "latitude": {"type": str},
                            "longitude": {"type": str},
                        }
                        ip_address: str
                        datacenter: str
                        city: str
                        country: str
                        region: str
                        latitude: str
                        longitude: str

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                ip_address: str | UndefinedType = Undefined,
                                datacenter: str | UndefinedType = Undefined,
                                city: str | UndefinedType = Undefined,
                                country: str | UndefinedType = Undefined,
                                region: str | UndefinedType = Undefined,
                                latitude: str | UndefinedType = Undefined,
                                longitude: str | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Endpoint.


                                Subclass of AvdModel.

                                Args:
                                    ip_address: ip_address
                                    datacenter: datacenter
                                    city: city
                                    country: country
                                    region: region
                                    latitude: latitude
                                    longitude: longitude

                                """

                    _fields: ClassVar[dict] = {"name": {"type": str}, "preference": {"type": str}, "endpoint": {"type": Endpoint}}
                    name: str
                    preference: str
                    endpoint: Endpoint
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            preference: str | UndefinedType = Undefined,
                            endpoint: Endpoint | UndefinedType = Undefined,
                        ) -> None:
                            """
                            TunnelsItem.


                            Subclass of AvdModel.

                            Args:
                                name: name
                                preference: preference
                                endpoint: Subclass of AvdModel.

                            """

                class Tunnels(AvdList[TunnelsItem]):
                    """Subclass of AvdList with `TunnelsItem` items."""

                Tunnels._item_type = TunnelsItem

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "type": {"type": str},
                    "city": {"type": str},
                    "country": {"type": str},
                    "upload_bandwidth": {"type": int},
                    "download_bandwidth": {"type": int},
                    "firewall": {"type": bool},
                    "ips_control": {"type": bool},
                    "acceptable_use_policy": {"type": bool},
                    "vpn_credentials": {"type": VpnCredentials},
                    "tunnels": {"type": Tunnels},
                }
                name: str
                type: str
                city: str
                country: str
                upload_bandwidth: int | None
                download_bandwidth: int | None
                firewall: bool
                ips_control: bool
                acceptable_use_policy: bool
                vpn_credentials: VpnCredentials
                """Subclass of AvdList with `VpnCredentialsItem` items."""
                tunnels: Tunnels
                """Subclass of AvdList with `TunnelsItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        type: str | UndefinedType = Undefined,
                        city: str | UndefinedType = Undefined,
                        country: str | UndefinedType = Undefined,
                        upload_bandwidth: int | None | UndefinedType = Undefined,
                        download_bandwidth: int | None | UndefinedType = Undefined,
                        firewall: bool | UndefinedType = Undefined,
                        ips_control: bool | UndefinedType = Undefined,
                        acceptable_use_policy: bool | UndefinedType = Undefined,
                        vpn_credentials: VpnCredentials | UndefinedType = Undefined,
                        tunnels: Tunnels | UndefinedType = Undefined,
                    ) -> None:
                        """
                        InternetExitPoliciesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            type: type
                            city: city
                            country: country
                            upload_bandwidth: upload_bandwidth
                            download_bandwidth: download_bandwidth
                            firewall: firewall
                            ips_control: ips_control
                            acceptable_use_policy: acceptable_use_policy
                            vpn_credentials: Subclass of AvdList with `VpnCredentialsItem` items.
                            tunnels: Subclass of AvdList with `TunnelsItem` items.

                        """

            class InternetExitPolicies(AvdList[InternetExitPoliciesItem]):
                """Subclass of AvdList with `InternetExitPoliciesItem` items."""

            InternetExitPolicies._item_type = InternetExitPoliciesItem

            class Applications(AvdModel):
                """Subclass of AvdModel."""

                class ProfilesItem(AvdModel):
                    """Subclass of AvdModel."""

                    class BuiltinApplicationsItem(AvdModel):
                        """Subclass of AvdModel."""

                        class Services(AvdList[str]):
                            """Subclass of AvdList with `str` items."""

                        Services._item_type = str

                        _fields: ClassVar[dict] = {"name": {"type": str}, "services": {"type": Services}}
                        name: str | None
                        services: Services
                        """Subclass of AvdList with `str` items."""

                        if TYPE_CHECKING:

                            def __init__(self, *, name: str | None | UndefinedType = Undefined, services: Services | UndefinedType = Undefined) -> None:
                                """
                                BuiltinApplicationsItem.


                                Subclass of AvdModel.

                                Args:
                                    name: name
                                    services: Subclass of AvdList with `str` items.

                                """

                    class BuiltinApplications(AvdList[BuiltinApplicationsItem]):
                        """Subclass of AvdList with `BuiltinApplicationsItem` items."""

                    BuiltinApplications._item_type = BuiltinApplicationsItem

                    class UserDefinedApplicationsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"name": {"type": str}}
                        name: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, name: str | None | UndefinedType = Undefined) -> None:
                                """
                                UserDefinedApplicationsItem.


                                Subclass of AvdModel.

                                Args:
                                    name: name

                                """

                    class UserDefinedApplications(AvdList[UserDefinedApplicationsItem]):
                        """Subclass of AvdList with `UserDefinedApplicationsItem` items."""

                    UserDefinedApplications._item_type = UserDefinedApplicationsItem

                    class CategoriesItem(AvdModel):
                        """Subclass of AvdModel."""

                        class Services(AvdList[str]):
                            """Subclass of AvdList with `str` items."""

                        Services._item_type = str

                        _fields: ClassVar[dict] = {"category": {"type": str}, "services": {"type": Services}}
                        category: str | None
                        services: Services
                        """Subclass of AvdList with `str` items."""

                        if TYPE_CHECKING:

                            def __init__(self, *, category: str | None | UndefinedType = Undefined, services: Services | UndefinedType = Undefined) -> None:
                                """
                                CategoriesItem.


                                Subclass of AvdModel.

                                Args:
                                    category: category
                                    services: Subclass of AvdList with `str` items.

                                """

                    class Categories(AvdList[CategoriesItem]):
                        """Subclass of AvdList with `CategoriesItem` items."""

                    Categories._item_type = CategoriesItem

                    class TransportProtocols(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    TransportProtocols._item_type = str

                    _fields: ClassVar[dict] = {
                        "name": {"type": str},
                        "builtin_applications": {"type": BuiltinApplications},
                        "user_defined_applications": {"type": UserDefinedApplications},
                        "categories": {"type": Categories},
                        "transport_protocols": {"type": TransportProtocols},
                    }
                    name: str | None
                    builtin_applications: BuiltinApplications
                    """Subclass of AvdList with `BuiltinApplicationsItem` items."""
                    user_defined_applications: UserDefinedApplications
                    """Subclass of AvdList with `UserDefinedApplicationsItem` items."""
                    categories: Categories
                    """Subclass of AvdList with `CategoriesItem` items."""
                    transport_protocols: TransportProtocols
                    """Subclass of AvdList with `str` items."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | None | UndefinedType = Undefined,
                            builtin_applications: BuiltinApplications | UndefinedType = Undefined,
                            user_defined_applications: UserDefinedApplications | UndefinedType = Undefined,
                            categories: Categories | UndefinedType = Undefined,
                            transport_protocols: TransportProtocols | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ProfilesItem.


                            Subclass of AvdModel.

                            Args:
                                name: name
                                builtin_applications: Subclass of AvdList with `BuiltinApplicationsItem` items.
                                user_defined_applications: Subclass of AvdList with `UserDefinedApplicationsItem` items.
                                categories: Subclass of AvdList with `CategoriesItem` items.
                                transport_protocols: Subclass of AvdList with `str` items.

                            """

                class Profiles(AvdList[ProfilesItem]):
                    """Subclass of AvdList with `ProfilesItem` items."""

                Profiles._item_type = ProfilesItem

                class Categories(AvdModel):
                    """Subclass of AvdModel."""

                    class BuiltinApplicationsItem(AvdModel):
                        """Subclass of AvdModel."""

                        class Services(AvdList[str]):
                            """Subclass of AvdList with `str` items."""

                        Services._item_type = str

                        _fields: ClassVar[dict] = {"name": {"type": str}, "category": {"type": str}, "services": {"type": Services}}
                        name: str | None
                        category: str | None
                        services: Services
                        """Subclass of AvdList with `str` items."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                name: str | None | UndefinedType = Undefined,
                                category: str | None | UndefinedType = Undefined,
                                services: Services | UndefinedType = Undefined,
                            ) -> None:
                                """
                                BuiltinApplicationsItem.


                                Subclass of AvdModel.

                                Args:
                                    name: name
                                    category: category
                                    services: Subclass of AvdList with `str` items.

                                """

                    class BuiltinApplications(AvdList[BuiltinApplicationsItem]):
                        """Subclass of AvdList with `BuiltinApplicationsItem` items."""

                    BuiltinApplications._item_type = BuiltinApplicationsItem

                    class UserDefinedApplicationsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"name": {"type": str}, "category": {"type": str}}
                        name: str | None
                        category: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, name: str | None | UndefinedType = Undefined, category: str | None | UndefinedType = Undefined) -> None:
                                """
                                UserDefinedApplicationsItem.


                                Subclass of AvdModel.

                                Args:
                                    name: name
                                    category: category

                                """

                    class UserDefinedApplications(AvdList[UserDefinedApplicationsItem]):
                        """Subclass of AvdList with `UserDefinedApplicationsItem` items."""

                    UserDefinedApplications._item_type = UserDefinedApplicationsItem

                    _fields: ClassVar[dict] = {
                        "builtin_applications": {"type": BuiltinApplications},
                        "user_defined_applications": {"type": UserDefinedApplications},
                    }
                    builtin_applications: BuiltinApplications
                    """Subclass of AvdList with `BuiltinApplicationsItem` items."""
                    user_defined_applications: UserDefinedApplications
                    """Subclass of AvdList with `UserDefinedApplicationsItem` items."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            builtin_applications: BuiltinApplications | UndefinedType = Undefined,
                            user_defined_applications: UserDefinedApplications | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Categories.


                            Subclass of AvdModel.

                            Args:
                                builtin_applications: Subclass of AvdList with `BuiltinApplicationsItem` items.
                                user_defined_applications: Subclass of AvdList with `UserDefinedApplicationsItem` items.

                            """

                _fields: ClassVar[dict] = {"profiles": {"type": Profiles}, "categories": {"type": Categories}}
                profiles: Profiles
                """Subclass of AvdList with `ProfilesItem` items."""
                categories: Categories
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, profiles: Profiles | UndefinedType = Undefined, categories: Categories | UndefinedType = Undefined) -> None:
                        """
                        Applications.


                        Subclass of AvdModel.

                        Args:
                            profiles: Subclass of AvdList with `ProfilesItem` items.
                            categories: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "role": {"type": str},
                "region": {"type": str},
                "zone": {"type": str},
                "site": {"type": str},
                "vtep_ip": {"type": str},
                "ssl_profile": {"type": str},
                "address": {"type": str},
                "pathfinders": {"type": Pathfinders},
                "interfaces": {"type": Interfaces},
                "pathgroups": {"type": Pathgroups},
                "regions": {"type": Regions},
                "vrfs": {"type": Vrfs},
                "internet_exit_policies": {"type": InternetExitPolicies},
                "applications": {"type": Applications},
            }
            role: str | None
            region: str | None
            zone: str | None
            site: str | None
            vtep_ip: str | None
            ssl_profile: str | None
            address: str | None
            pathfinders: Pathfinders
            """Subclass of AvdList with `PathfindersItem` items."""
            interfaces: Interfaces
            """Subclass of AvdList with `InterfacesItem` items."""
            pathgroups: Pathgroups
            """Subclass of AvdList with `PathgroupsItem` items."""
            regions: Regions
            """Subclass of AvdList with `RegionsItem` items."""
            vrfs: Vrfs
            """Subclass of AvdList with `VrfsItem` items."""
            internet_exit_policies: InternetExitPolicies
            """Subclass of AvdList with `InternetExitPoliciesItem` items."""
            applications: Applications
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    role: str | None | UndefinedType = Undefined,
                    region: str | None | UndefinedType = Undefined,
                    zone: str | None | UndefinedType = Undefined,
                    site: str | None | UndefinedType = Undefined,
                    vtep_ip: str | None | UndefinedType = Undefined,
                    ssl_profile: str | None | UndefinedType = Undefined,
                    address: str | None | UndefinedType = Undefined,
                    pathfinders: Pathfinders | UndefinedType = Undefined,
                    interfaces: Interfaces | UndefinedType = Undefined,
                    pathgroups: Pathgroups | UndefinedType = Undefined,
                    regions: Regions | UndefinedType = Undefined,
                    vrfs: Vrfs | UndefinedType = Undefined,
                    internet_exit_policies: InternetExitPolicies | UndefinedType = Undefined,
                    applications: Applications | UndefinedType = Undefined,
                ) -> None:
                    """
                    CvPathfinder.


                    Subclass of AvdModel.

                    Args:
                        role: role
                        region: region
                        zone: zone
                        site: site
                        vtep_ip: vtep_ip
                        ssl_profile: ssl_profile
                        address: address
                        pathfinders: Subclass of AvdList with `PathfindersItem` items.
                        interfaces: Subclass of AvdList with `InterfacesItem` items.
                        pathgroups: Subclass of AvdList with `PathgroupsItem` items.
                        regions: Subclass of AvdList with `RegionsItem` items.
                        vrfs: Subclass of AvdList with `VrfsItem` items.
                        internet_exit_policies: Subclass of AvdList with `InternetExitPoliciesItem` items.
                        applications: Subclass of AvdModel.

                    """

        class DigitalTwin(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "environment": {"type": str},
                "node_type": {"type": str},
                "ip_addr": {"type": str},
                "version": {"type": str},
                "username": {"type": str},
                "password": {"type": str},
                "internet_access": {"type": bool},
            }
            environment: Literal["act"] | None
            """Targeted Digital Twin environment."""
            node_type: str | None
            """
            Digital Twin's internal device type used for deploying a replica of the fabric device.
            Possible
            values depend on the target Digital Twin environment.
            """
            ip_addr: str | None
            """
            Management IPv4_address/Mask assigned to a replica of the fabric device within the Digital Twin
            environment.
            """
            version: str | None
            """OS version used for deploying a replica of the fabric device within the Digital Twin environment."""
            username: str | None
            """Local username assigned to a replica of the fabric device within the Digital Twin environment."""
            password: str | None
            """Local password assigned to a replica of the fabric device within the Digital Twin environment."""
            internet_access: bool | None
            """
            Specifies if the ACT Digital Twin device is deployed with direct access to the Internet.
            This option
            applies only to the `cloudeos` and `veos` node types and will be ignored for all other ACT node
            types.
            ACT does not provide direct Internet access to `cloudeos` or `veos` devices by default.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    environment: Literal["act"] | None | UndefinedType = Undefined,
                    node_type: str | None | UndefinedType = Undefined,
                    ip_addr: str | None | UndefinedType = Undefined,
                    version: str | None | UndefinedType = Undefined,
                    username: str | None | UndefinedType = Undefined,
                    password: str | None | UndefinedType = Undefined,
                    internet_access: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    DigitalTwin.


                    Subclass of AvdModel.

                    Args:
                        environment: Targeted Digital Twin environment.
                        node_type:
                           Digital Twin's internal device type used for deploying a replica of the fabric device.
                           Possible
                           values depend on the target Digital Twin environment.
                        ip_addr:
                           Management IPv4_address/Mask assigned to a replica of the fabric device within the Digital Twin
                           environment.
                        version: OS version used for deploying a replica of the fabric device within the Digital Twin environment.
                        username: Local username assigned to a replica of the fabric device within the Digital Twin environment.
                        password: Local password assigned to a replica of the fabric device within the Digital Twin environment.
                        internet_access:
                           Specifies if the ACT Digital Twin device is deployed with direct access to the Internet.
                           This option
                           applies only to the `cloudeos` and `veos` node types and will be ignored for all other ACT node
                           types.
                           ACT does not provide direct Internet access to `cloudeos` or `veos` devices by default.

                    """

        _fields: ClassVar[dict] = {
            "is_deployed": {"type": bool},
            "platform": {"type": str},
            "system_mac_address": {"type": str},
            "rack": {"type": str},
            "pod_name": {"type": str},
            "dc_name": {"type": str},
            "fabric_name": {"type": str},
            "cv_tags": {"type": CvTags},
            "cv_pathfinder": {"type": CvPathfinder},
            "digital_twin": {"type": DigitalTwin},
        }
        is_deployed: bool | None
        """Key only used for documentation or validation purposes."""
        platform: str | None
        system_mac_address: str | None
        rack: str | None
        pod_name: str | None
        dc_name: str | None
        fabric_name: str | None
        cv_tags: CvTags
        """Subclass of AvdModel."""
        cv_pathfinder: CvPathfinder
        """
        Metadata used for CV Pathfinder visualization on CloudVision.

        Subclass of AvdModel.
        """
        digital_twin: DigitalTwin
        """
        Metadata used to generate Digital Twin topology.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                is_deployed: bool | None | UndefinedType = Undefined,
                platform: str | None | UndefinedType = Undefined,
                system_mac_address: str | None | UndefinedType = Undefined,
                rack: str | None | UndefinedType = Undefined,
                pod_name: str | None | UndefinedType = Undefined,
                dc_name: str | None | UndefinedType = Undefined,
                fabric_name: str | None | UndefinedType = Undefined,
                cv_tags: CvTags | UndefinedType = Undefined,
                cv_pathfinder: CvPathfinder | UndefinedType = Undefined,
                digital_twin: DigitalTwin | UndefinedType = Undefined,
            ) -> None:
                """
                Metadata.


                Subclass of AvdModel.

                Args:
                    is_deployed: Key only used for documentation or validation purposes.
                    platform: platform
                    system_mac_address: system_mac_address
                    rack: rack
                    pod_name: pod_name
                    dc_name: dc_name
                    fabric_name: fabric_name
                    cv_tags: Subclass of AvdModel.
                    cv_pathfinder:
                       Metadata used for CV Pathfinder visualization on CloudVision.

                       Subclass of AvdModel.
                    digital_twin:
                       Metadata used to generate Digital Twin topology.

                       Subclass of AvdModel.

                """

    class MlagConfiguration(AvdModel):
        """Subclass of AvdModel."""

        class PeerAddressHeartbeat(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"peer_ip": {"type": str}, "vrf": {"type": str}}
            peer_ip: str | None
            """IPv4 or IPv6 Address."""
            vrf: str | None
            """VRF Name."""

            if TYPE_CHECKING:

                def __init__(self, *, peer_ip: str | None | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                    """
                    PeerAddressHeartbeat.


                    Subclass of AvdModel.

                    Args:
                        peer_ip: IPv4 or IPv6 Address.
                        vrf: VRF Name.

                    """

        _fields: ClassVar[dict] = {
            "domain_id": {"type": str},
            "heartbeat_interval": {"type": int},
            "local_interface": {"type": str},
            "peer_address": {"type": str},
            "peer_address_heartbeat": {"type": PeerAddressHeartbeat},
            "dual_primary_detection_delay": {"type": int},
            "dual_primary_recovery_delay_mlag": {"type": int},
            "dual_primary_recovery_delay_non_mlag": {"type": int},
            "peer_link": {"type": str},
            "reload_delay_mlag": {"type": str},
            "reload_delay_non_mlag": {"type": str},
        }
        domain_id: str | None
        heartbeat_interval: int | None
        """Heartbeat interval in milliseconds."""
        local_interface: str | None
        """Local Interface Name."""
        peer_address: str | None
        """IPv4 or IPv6 Address."""
        peer_address_heartbeat: PeerAddressHeartbeat
        """Subclass of AvdModel."""
        dual_primary_detection_delay: int | None
        """Delay in seconds."""
        dual_primary_recovery_delay_mlag: int | None
        """Delay in seconds."""
        dual_primary_recovery_delay_non_mlag: int | None
        """Delay in seconds."""
        peer_link: str | None
        """Port-Channel interface name."""
        reload_delay_mlag: str | None
        """Delay in seconds <0-86400> or 'infinity'."""
        reload_delay_non_mlag: str | None
        """Delay in seconds <0-86400> or 'infinity'."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                domain_id: str | None | UndefinedType = Undefined,
                heartbeat_interval: int | None | UndefinedType = Undefined,
                local_interface: str | None | UndefinedType = Undefined,
                peer_address: str | None | UndefinedType = Undefined,
                peer_address_heartbeat: PeerAddressHeartbeat | UndefinedType = Undefined,
                dual_primary_detection_delay: int | None | UndefinedType = Undefined,
                dual_primary_recovery_delay_mlag: int | None | UndefinedType = Undefined,
                dual_primary_recovery_delay_non_mlag: int | None | UndefinedType = Undefined,
                peer_link: str | None | UndefinedType = Undefined,
                reload_delay_mlag: str | None | UndefinedType = Undefined,
                reload_delay_non_mlag: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                MlagConfiguration.


                Subclass of AvdModel.

                Args:
                    domain_id: domain_id
                    heartbeat_interval: Heartbeat interval in milliseconds.
                    local_interface: Local Interface Name.
                    peer_address: IPv4 or IPv6 Address.
                    peer_address_heartbeat: Subclass of AvdModel.
                    dual_primary_detection_delay: Delay in seconds.
                    dual_primary_recovery_delay_mlag: Delay in seconds.
                    dual_primary_recovery_delay_non_mlag: Delay in seconds.
                    peer_link: Port-Channel interface name.
                    reload_delay_mlag: Delay in seconds <0-86400> or 'infinity'.
                    reload_delay_non_mlag: Delay in seconds <0-86400> or 'infinity'.

                """

    class MonitorConnectivity(AvdModel):
        """Subclass of AvdModel."""

        class InterfaceSetsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "interfaces": {"type": str}}
            name: str
            interfaces: str | None
            """
            Interface range(s) should be of same type, Ethernet, Loopback, Management etc.
            Multiple interface
            ranges can be specified separated by ",".
            """

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, interfaces: str | None | UndefinedType = Undefined) -> None:
                    """
                    InterfaceSetsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        interfaces:
                           Interface range(s) should be of same type, Ethernet, Loopback, Management etc.
                           Multiple interface
                           ranges can be specified separated by ",".

                    """

        class InterfaceSets(AvdIndexedList[str, InterfaceSetsItem]):
            """Subclass of AvdIndexedList with `InterfaceSetsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        InterfaceSets._item_type = InterfaceSetsItem

        class HostsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "description": {"type": str},
                "ip": {"type": str},
                "icmp_echo_size": {"type": int},
                "local_interfaces": {"type": str},
                "address_only": {"type": bool, "default": True},
                "url": {"type": str},
            }
            name: str
            """Host Name."""
            description: str | None
            ip: str | None
            icmp_echo_size: int | None
            """Size of ICMP probe in bytes."""
            local_interfaces: str | None
            address_only: bool
            """
            When address-only is configured, the source IP of the packet is set to the interface
            IP but the
            packet may exit the device via a different interface.
            When set to `false`, the probe uses the
            interface to exit the device.

            Default value: `True`
            """
            url: str | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    ip: str | None | UndefinedType = Undefined,
                    icmp_echo_size: int | None | UndefinedType = Undefined,
                    local_interfaces: str | None | UndefinedType = Undefined,
                    address_only: bool | UndefinedType = Undefined,
                    url: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Host Name.
                        description: description
                        ip: ip
                        icmp_echo_size: Size of ICMP probe in bytes.
                        local_interfaces: local_interfaces
                        address_only:
                           When address-only is configured, the source IP of the packet is set to the interface
                           IP but the
                           packet may exit the device via a different interface.
                           When set to `false`, the probe uses the
                           interface to exit the device.
                        url: url

                    """

        class Hosts(AvdIndexedList[str, HostsItem]):
            """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Hosts._item_type = HostsItem

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class InterfaceSetsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "interfaces": {"type": str}}
                name: str
                interfaces: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, interfaces: str | None | UndefinedType = Undefined) -> None:
                        """
                        InterfaceSetsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            interfaces: interfaces

                        """

            class InterfaceSets(AvdIndexedList[str, InterfaceSetsItem]):
                """Subclass of AvdIndexedList with `InterfaceSetsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            InterfaceSets._item_type = InterfaceSetsItem

            class HostsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "description": {"type": str},
                    "ip": {"type": str},
                    "icmp_echo_size": {"type": int},
                    "local_interfaces": {"type": str},
                    "address_only": {"type": bool, "default": True},
                    "url": {"type": str},
                }
                name: str
                """Host name."""
                description: str | None
                ip: str | None
                icmp_echo_size: int | None
                """Size of ICMP probe in bytes."""
                local_interfaces: str | None
                address_only: bool
                """
                When address-only is configured, the source IP of the packet is set to the interface
                IP but the
                packet may exit the device via a different interface.
                When set to `false`, the probe uses the
                interface to exit the device.

                Default value: `True`
                """
                url: str | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                        ip: str | None | UndefinedType = Undefined,
                        icmp_echo_size: int | None | UndefinedType = Undefined,
                        local_interfaces: str | None | UndefinedType = Undefined,
                        address_only: bool | UndefinedType = Undefined,
                        url: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        HostsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Host name.
                            description: description
                            ip: ip
                            icmp_echo_size: Size of ICMP probe in bytes.
                            local_interfaces: local_interfaces
                            address_only:
                               When address-only is configured, the source IP of the packet is set to the interface
                               IP but the
                               packet may exit the device via a different interface.
                               When set to `false`, the probe uses the
                               interface to exit the device.
                            url: url

                        """

            class Hosts(AvdIndexedList[str, HostsItem]):
                """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Hosts._item_type = HostsItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "description": {"type": str},
                "interface_sets": {"type": InterfaceSets},
                "local_interfaces": {"type": str},
                "address_only": {"type": bool, "default": True},
                "hosts": {"type": Hosts},
            }
            name: str
            """VRF Name."""
            description: str | None
            interface_sets: InterfaceSets
            """Subclass of AvdIndexedList with `InterfaceSetsItem` items. Primary key is `name` (`str`)."""
            local_interfaces: str | None
            address_only: bool
            """
            When address-only is configured, the source IP of the packet is set to the interface
            IP but the
            packet may exit the device via a different interface.
            When set to `false`, the probe uses the
            interface to exit the device.

            Default value: `True`
            """
            hosts: Hosts
            """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    interface_sets: InterfaceSets | UndefinedType = Undefined,
                    local_interfaces: str | None | UndefinedType = Undefined,
                    address_only: bool | UndefinedType = Undefined,
                    hosts: Hosts | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF Name.
                        description: description
                        interface_sets: Subclass of AvdIndexedList with `InterfaceSetsItem` items. Primary key is `name` (`str`).
                        local_interfaces: local_interfaces
                        address_only:
                           When address-only is configured, the source IP of the packet is set to the interface
                           IP but the
                           packet may exit the device via a different interface.
                           When set to `false`, the probe uses the
                           interface to exit the device.
                        hosts: Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`).

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "shutdown": {"type": bool},
            "interval": {"type": int},
            "interface_sets": {"type": InterfaceSets},
            "local_interfaces": {"type": str},
            "address_only": {"type": bool, "default": True},
            "hosts": {"type": Hosts},
            "name_server_group": {"type": str},
            "vrfs": {"type": Vrfs},
        }
        shutdown: bool | None
        interval: int | None
        interface_sets: InterfaceSets
        """Subclass of AvdIndexedList with `InterfaceSetsItem` items. Primary key is `name` (`str`)."""
        local_interfaces: str | None
        address_only: bool
        """
        When address-only is configured, the source IP of the packet is set to the interface
        IP but the
        packet may exit the device via a different interface.
        When set to `false`, the probe uses the
        interface to exit the device.

        Default value: `True`
        """
        hosts: Hosts
        """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`)."""
        name_server_group: str | None
        """Set name-server group."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                shutdown: bool | None | UndefinedType = Undefined,
                interval: int | None | UndefinedType = Undefined,
                interface_sets: InterfaceSets | UndefinedType = Undefined,
                local_interfaces: str | None | UndefinedType = Undefined,
                address_only: bool | UndefinedType = Undefined,
                hosts: Hosts | UndefinedType = Undefined,
                name_server_group: str | None | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorConnectivity.


                Subclass of AvdModel.

                Args:
                    shutdown: shutdown
                    interval: interval
                    interface_sets: Subclass of AvdIndexedList with `InterfaceSetsItem` items. Primary key is `name` (`str`).
                    local_interfaces: local_interfaces
                    address_only:
                       When address-only is configured, the source IP of the packet is set to the interface
                       IP but the
                       packet may exit the device via a different interface.
                       When set to `false`, the probe uses the
                       interface to exit the device.
                    hosts: Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`).
                    name_server_group: Set name-server group.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).

                """

    class MonitorLayer1(AvdModel):
        """Subclass of AvdModel."""

        class LoggingTransceiver(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"dom": {"type": bool}, "communication": {"type": bool}, "enabled": {"type": bool}}
            dom: bool | None
            """Enable transceiver Digital Optical Monitoring (DOM) logging."""
            communication: bool | None
            """Enable transceiver SMBus fail and reset logging."""
            enabled: bool | None
            """
            Some platforms support only the `logging transceiver` command. `enabled` key configures this
            command.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    dom: bool | None | UndefinedType = Undefined,
                    communication: bool | None | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LoggingTransceiver.


                    Subclass of AvdModel.

                    Args:
                        dom: Enable transceiver Digital Optical Monitoring (DOM) logging.
                        communication: Enable transceiver SMBus fail and reset logging.
                        enabled:
                           Some platforms support only the `logging transceiver` command. `enabled` key configures this
                           command.

                    """

        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "logging_mac_fault": {"type": bool}, "logging_transceiver": {"type": LoggingTransceiver}}
        enabled: bool
        """Enable monitor layer1."""
        logging_mac_fault: bool | None
        """Enable MAC fault logging."""
        logging_transceiver: LoggingTransceiver
        """
        Configure transceiver monitoring logging.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enabled: bool | UndefinedType = Undefined,
                logging_mac_fault: bool | None | UndefinedType = Undefined,
                logging_transceiver: LoggingTransceiver | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorLayer1.


                Subclass of AvdModel.

                Args:
                    enabled: Enable monitor layer1.
                    logging_mac_fault: Enable MAC fault logging.
                    logging_transceiver:
                       Configure transceiver monitoring logging.

                       Subclass of AvdModel.

                """

    class MonitorServerRadius(AvdModel):
        """Subclass of AvdModel."""

        class Probe(AvdModel):
            """Subclass of AvdModel."""

            class AccessRequest(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"username": {"type": str}, "password": {"type": str}, "password_type": {"type": str, "default": "7"}}
                username: str | None
                password: str | None
                """Encrypted password using the `password_type`."""
                password_type: Literal["0", "7", "8a"]
                """Default value: `"7"`"""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        username: str | None | UndefinedType = Undefined,
                        password: str | None | UndefinedType = Undefined,
                        password_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AccessRequest.


                        Subclass of AvdModel.

                        Args:
                            username: username
                            password: Encrypted password using the `password_type`.
                            password_type: password_type

                        """

            _fields: ClassVar[dict] = {
                "interval": {"type": int},
                "threshold_failure": {"type": int},
                "method": {"type": str},
                "access_request": {"type": AccessRequest},
            }
            interval: int | None
            """Server probe interval in seconds."""
            threshold_failure: int | None
            """Number of consecutive failed probes before a server is marked as dead."""
            method: Literal["status-server", "access-request"] | None
            """Method used to probe the server. `status-server` is the EOS default method."""
            access_request: AccessRequest
            """
            This can only be set when `method` is `access_request`.

            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    interval: int | None | UndefinedType = Undefined,
                    threshold_failure: int | None | UndefinedType = Undefined,
                    method: Literal["status-server", "access-request"] | None | UndefinedType = Undefined,
                    access_request: AccessRequest | UndefinedType = Undefined,
                ) -> None:
                    """
                    Probe.


                    Subclass of AvdModel.

                    Args:
                        interval: Server probe interval in seconds.
                        threshold_failure: Number of consecutive failed probes before a server is marked as dead.
                        method: Method used to probe the server. `status-server` is the EOS default method.
                        access_request:
                           This can only be set when `method` is `access_request`.

                           Subclass of AvdModel.

                    """

        _fields: ClassVar[dict] = {"service_dot1x": {"type": bool}, "probe": {"type": Probe}}
        service_dot1x: bool | None
        """Monitor servers used for 802.1X authentication."""
        probe: Probe
        """
        Settings for probe sent to the server.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(self, *, service_dot1x: bool | None | UndefinedType = Undefined, probe: Probe | UndefinedType = Undefined) -> None:
                """
                MonitorServerRadius.


                Subclass of AvdModel.

                Args:
                    service_dot1x: Monitor servers used for 802.1X authentication.
                    probe:
                       Settings for probe sent to the server.

                       Subclass of AvdModel.

                """

    class MonitorSessionDefaultEncapsulationGre(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"payload": {"type": str}}
        payload: Literal["full-packet", "inner-packet"] | None
        """Mirroring GRE payload type configuration commands."""

        if TYPE_CHECKING:

            def __init__(self, *, payload: Literal["full-packet", "inner-packet"] | None | UndefinedType = Undefined) -> None:
                """
                MonitorSessionDefaultEncapsulationGre.


                Subclass of AvdModel.

                Args:
                    payload: Mirroring GRE payload type configuration commands.

                """

    class MonitorSessionsItem(AvdModel):
        """Subclass of AvdModel."""

        class SourcesItem(AvdModel):
            """Subclass of AvdModel."""

            class AccessGroup(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"type": {"type": str}, "name": {"type": str}, "priority": {"type": int}}
                type: Literal["ip", "ipv6", "mac"] | None
                name: str | None
                """ACL Name."""
                priority: int | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        type: Literal["ip", "ipv6", "mac"] | None | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AccessGroup.


                        Subclass of AvdModel.

                        Args:
                            type: type
                            name: ACL Name.
                            priority: priority

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "direction": {"type": str}, "access_group": {"type": AccessGroup}}
            name: str
            """Interface name, range or comma separated list."""
            direction: Literal["rx", "tx", "both"] | None
            access_group: AccessGroup
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    direction: Literal["rx", "tx", "both"] | None | UndefinedType = Undefined,
                    access_group: AccessGroup | UndefinedType = Undefined,
                ) -> None:
                    """
                    SourcesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Interface name, range or comma separated list.
                        direction: direction
                        access_group: Subclass of AvdModel.

                    """

        class Sources(AvdIndexedList[str, SourcesItem]):
            """Subclass of AvdIndexedList with `SourcesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Sources._item_type = SourcesItem

        class Destinations(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Destinations._item_type = str

        class AccessGroup(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"type": {"type": str}, "name": {"type": str}}
            type: Literal["ip", "ipv6", "mac"] | None
            name: str | None
            """ACL Name."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, type: Literal["ip", "ipv6", "mac"] | None | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined
                ) -> None:
                    """
                    AccessGroup.


                    Subclass of AvdModel.

                    Args:
                        type: type
                        name: ACL Name.

                    """

        class Truncate(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "size": {"type": int}}
            enabled: bool | None
            size: int | None
            """Size in bytes."""

            if TYPE_CHECKING:

                def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, size: int | None | UndefinedType = Undefined) -> None:
                    """
                    Truncate.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        size: Size in bytes.

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "sources": {"type": Sources},
            "destinations": {"type": Destinations},
            "encapsulation_gre_metadata_tx": {"type": bool},
            "header_remove_size": {"type": int},
            "access_group": {"type": AccessGroup},
            "rate_limit_per_ingress_chip": {"type": str},
            "rate_limit_per_egress_chip": {"type": str},
            "sample": {"type": int},
            "truncate": {"type": Truncate},
        }
        name: str
        """Session Name."""
        sources: Sources
        """Subclass of AvdIndexedList with `SourcesItem` items. Primary key is `name` (`str`)."""
        destinations: Destinations
        """Subclass of AvdList with `str` items."""
        encapsulation_gre_metadata_tx: bool | None
        header_remove_size: int | None
        """Number of bytes to remove from header."""
        access_group: AccessGroup
        """Subclass of AvdModel."""
        rate_limit_per_ingress_chip: str | None
        """
        Ratelimit and unit as string.
        Examples:
          "100000 bps"
          "100 kbps"
          "10 mbps"
        """
        rate_limit_per_egress_chip: str | None
        """
        Ratelimit and unit as string.
        Examples:
          "100000 bps"
          "100 kbps"
          "10 mbps"
        """
        sample: int | None
        truncate: Truncate
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                sources: Sources | UndefinedType = Undefined,
                destinations: Destinations | UndefinedType = Undefined,
                encapsulation_gre_metadata_tx: bool | None | UndefinedType = Undefined,
                header_remove_size: int | None | UndefinedType = Undefined,
                access_group: AccessGroup | UndefinedType = Undefined,
                rate_limit_per_ingress_chip: str | None | UndefinedType = Undefined,
                rate_limit_per_egress_chip: str | None | UndefinedType = Undefined,
                sample: int | None | UndefinedType = Undefined,
                truncate: Truncate | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorSessionsItem.


                Subclass of AvdModel.

                Args:
                    name: Session Name.
                    sources: Subclass of AvdIndexedList with `SourcesItem` items. Primary key is `name` (`str`).
                    destinations: Subclass of AvdList with `str` items.
                    encapsulation_gre_metadata_tx: encapsulation_gre_metadata_tx
                    header_remove_size: Number of bytes to remove from header.
                    access_group: Subclass of AvdModel.
                    rate_limit_per_ingress_chip:
                       Ratelimit and unit as string.
                       Examples:  # fmt: skip
                         "100000 bps"
                         "100 kbps"
                         "10 mbps"
                    rate_limit_per_egress_chip:
                       Ratelimit and unit as string.
                       Examples:  # fmt: skip
                         "100000 bps"
                         "100 kbps"
                         "10 mbps"
                    sample: sample
                    truncate: Subclass of AvdModel.

                """

    class MonitorSessions(AvdIndexedList[str, MonitorSessionsItem]):
        """Subclass of AvdIndexedList with `MonitorSessionsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    MonitorSessions._item_type = MonitorSessionsItem

    class MonitorTelemetryInflux(AvdModel):
        """Subclass of AvdModel."""

        class DestinationsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "database": {"type": str},
                "data_retention_policy": {"type": str},
                "url": {"type": str},
                "username": {"type": str},
                "password": {"type": str},
                "password_type": {"type": str, "default": "7"},
            }
            name: str
            """InfluxDB connection name."""
            database: str | None
            """Set name of the database."""
            data_retention_policy: str | None
            url: str | None
            """It only accepts http(s), udp and unix domain destination URL."""
            username: str | None
            password: str | None
            password_type: Literal["0", "7", "8a"]
            """Default value: `"7"`"""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    database: str | None | UndefinedType = Undefined,
                    data_retention_policy: str | None | UndefinedType = Undefined,
                    url: str | None | UndefinedType = Undefined,
                    username: str | None | UndefinedType = Undefined,
                    password: str | None | UndefinedType = Undefined,
                    password_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                ) -> None:
                    """
                    DestinationsItem.


                    Subclass of AvdModel.

                    Args:
                        name: InfluxDB connection name.
                        database: Set name of the database.
                        data_retention_policy: data_retention_policy
                        url: It only accepts http(s), udp and unix domain destination URL.
                        username: username
                        password: password
                        password_type: password_type

                    """

        class Destinations(AvdIndexedList[str, DestinationsItem]):
            """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Destinations._item_type = DestinationsItem

        class SourceSocketsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "connection_limit": {"type": int}, "url": {"type": str}}
            name: str
            """Label of the socket connection."""
            connection_limit: int | None
            url: str | None
            """It only accepts http(s), udp and unix domain socket URL."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    connection_limit: int | None | UndefinedType = Undefined,
                    url: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SourceSocketsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Label of the socket connection.
                        connection_limit: connection_limit
                        url: It only accepts http(s), udp and unix domain socket URL.

                    """

        class SourceSockets(AvdIndexedList[str, SourceSocketsItem]):
            """Subclass of AvdIndexedList with `SourceSocketsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        SourceSockets._item_type = SourceSocketsItem

        class TagsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "value": {"type": str}}
            name: str
            """Key of the global tag pair."""
            value: str
            """Value of the global tag pair."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, value: str | UndefinedType = Undefined) -> None:
                    """
                    TagsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Key of the global tag pair.
                        value: Value of the global tag pair.

                    """

        class Tags(AvdIndexedList[str, TagsItem]):
            """Subclass of AvdIndexedList with `TagsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Tags._item_type = TagsItem

        _fields: ClassVar[dict] = {
            "vrf": {"type": str},
            "destinations": {"type": Destinations},
            "source_group_standard_disabled": {"type": bool},
            "source_sockets": {"type": SourceSockets},
            "tags": {"type": Tags},
        }
        vrf: str | None
        destinations: Destinations
        """
        Configure telemetry output destinations.

        Subclass of AvdIndexedList with `DestinationsItem` items.
        Primary key is `name` (`str`).
        """
        source_group_standard_disabled: bool | None
        """Disable standard set of telemetry."""
        source_sockets: SourceSockets
        """Subclass of AvdIndexedList with `SourceSocketsItem` items. Primary key is `name` (`str`)."""
        tags: Tags
        """
        Extra tags added to the telemetry output.

        Subclass of AvdIndexedList with `TagsItem` items. Primary
        key is `name` (`str`).
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                vrf: str | None | UndefinedType = Undefined,
                destinations: Destinations | UndefinedType = Undefined,
                source_group_standard_disabled: bool | None | UndefinedType = Undefined,
                source_sockets: SourceSockets | UndefinedType = Undefined,
                tags: Tags | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorTelemetryInflux.


                Subclass of AvdModel.

                Args:
                    vrf: vrf
                    destinations:
                       Configure telemetry output destinations.

                       Subclass of AvdIndexedList with `DestinationsItem` items.
                       Primary key is `name` (`str`).
                    source_group_standard_disabled: Disable standard set of telemetry.
                    source_sockets: Subclass of AvdIndexedList with `SourceSocketsItem` items. Primary key is `name` (`str`).
                    tags:
                       Extra tags added to the telemetry output.

                       Subclass of AvdIndexedList with `TagsItem` items. Primary
                       key is `name` (`str`).

                """

    class MonitorTelemetryPostcardPolicy(AvdModel):
        """Subclass of AvdModel."""

        class Ingress(AvdModel):
            """Subclass of AvdModel."""

            class Collection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"source": {"type": str}, "destination": {"type": str}, "version": {"type": int}}
                source: str | None
                """Source IP address of GRE tunnel."""
                destination: str | None
                """Destination IP address of GRE tunnel."""
                version: Literal[1, 2] | None
                """Postcard version."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source: str | None | UndefinedType = Undefined,
                        destination: str | None | UndefinedType = Undefined,
                        version: Literal[1, 2] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Collection.


                        Subclass of AvdModel.

                        Args:
                            source: Source IP address of GRE tunnel.
                            destination: Destination IP address of GRE tunnel.
                            version: Postcard version.

                        """

            class Sample(AvdModel):
                """Subclass of AvdModel."""

                class TcpUdpChecksum(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"value": {"type": int}, "mask": {"type": str}}
                    value: int | None
                    """TCP/UDP checksum or IP ID value."""
                    mask: str | None
                    """16 bit hexadecimal mask for TCP/UDP or IP ID with at most 2 unset bits."""

                    if TYPE_CHECKING:

                        def __init__(self, *, value: int | None | UndefinedType = Undefined, mask: str | None | UndefinedType = Undefined) -> None:
                            """
                            TcpUdpChecksum.


                            Subclass of AvdModel.

                            Args:
                                value: TCP/UDP checksum or IP ID value.
                                mask: 16 bit hexadecimal mask for TCP/UDP or IP ID with at most 2 unset bits.

                            """

                _fields: ClassVar[dict] = {"rate": {"type": int}, "tcp_udp_checksum": {"type": TcpUdpChecksum}}
                rate: Literal[16384, 32768, 65536] | None
                """Sampling rate. `rate` is preferred when both `rate` and `tcp_udp_checksum` are defined."""
                tcp_udp_checksum: TcpUdpChecksum
                """
                TCP/UDP parameters.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        rate: Literal[16384, 32768, 65536] | None | UndefinedType = Undefined,
                        tcp_udp_checksum: TcpUdpChecksum | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Sample.


                        Subclass of AvdModel.

                        Args:
                            rate: Sampling rate. `rate` is preferred when both `rate` and `tcp_udp_checksum` are defined.
                            tcp_udp_checksum:
                               TCP/UDP parameters.

                               Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"collection": {"type": Collection}, "sample": {"type": Sample}}
            collection: Collection
            """
            Collector configuration.

            Subclass of AvdModel.
            """
            sample: Sample
            """
            Sampling parameters.

            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(self, *, collection: Collection | UndefinedType = Undefined, sample: Sample | UndefinedType = Undefined) -> None:
                    """
                    Ingress.


                    Subclass of AvdModel.

                    Args:
                        collection:
                           Collector configuration.

                           Subclass of AvdModel.
                        sample:
                           Sampling parameters.

                           Subclass of AvdModel.

                    """

        class MarkerVxlan(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "header_word_zero_bit": {"type": int}}
            enabled: bool | None
            """Enable vxlan marking using default bit 0."""
            header_word_zero_bit: int | None

            if TYPE_CHECKING:

                def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, header_word_zero_bit: int | None | UndefinedType = Undefined) -> None:
                    """
                    MarkerVxlan.


                    Subclass of AvdModel.

                    Args:
                        enabled: Enable vxlan marking using default bit 0.
                        header_word_zero_bit: header_word_zero_bit

                    """

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "ingress_sample_policy": {"type": str}}
            name: str
            """Profile name."""
            ingress_sample_policy: str | None

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, ingress_sample_policy: str | None | UndefinedType = Undefined) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Profile name.
                        ingress_sample_policy: ingress_sample_policy

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        class SamplePoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class MatchRulesItem(AvdModel):
                """Subclass of AvdModel."""

                class ProtocolsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class SourcePorts(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    SourcePorts._item_type = str

                    class DestinationPorts(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    DestinationPorts._item_type = str

                    _fields: ClassVar[dict] = {
                        "protocol": {"type": str},
                        "source_ports": {"type": SourcePorts},
                        "destination_ports": {"type": DestinationPorts},
                    }
                    protocol: Literal["tcp", "udp"]
                    source_ports: SourcePorts
                    """
                    A list of port numbers or port range or port name. Combination of port numbers or range and port
                    name is not supported on EOS. The port numbers should be in range of 0-65535.
                    e.g.
                      ["12", "14-20"]
                    ["www"]

                    Subclass of AvdList with `str` items.
                    """
                    destination_ports: DestinationPorts
                    """
                    A list of port numbers or port range or port name. Combination of port numbers or range and port
                    name is not supported on EOS. The port numbers should be in range of 0-65535.
                    e.g.
                      ["12", "14-20",
                    "80"]
                      ["https"]

                    Subclass of AvdList with `str` items.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            protocol: Literal["tcp", "udp"] | UndefinedType = Undefined,
                            source_ports: SourcePorts | UndefinedType = Undefined,
                            destination_ports: DestinationPorts | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ProtocolsItem.


                            Subclass of AvdModel.

                            Args:
                                protocol: protocol
                                source_ports:
                                   A list of port numbers or port range or port name. Combination of port numbers or range and port
                                   name is not supported on EOS. The port numbers should be in range of 0-65535.
                                   e.g.
                                     ["12", "14-20"]
                                   ["www"]

                                   Subclass of AvdList with `str` items.
                                destination_ports:
                                   A list of port numbers or port range or port name. Combination of port numbers or range and port
                                   name is not supported on EOS. The port numbers should be in range of 0-65535.
                                   e.g.
                                     ["12", "14-20",
                                   "80"]
                                     ["https"]

                                   Subclass of AvdList with `str` items.

                            """

                class Protocols(AvdIndexedList[str, ProtocolsItem]):
                    """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                    _primary_key: ClassVar[str] = "protocol"

                Protocols._item_type = ProtocolsItem

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "type": {"type": str},
                    "destination_prefix": {"type": str},
                    "source_prefix": {"type": str},
                    "protocols": {"type": Protocols},
                }
                name: str
                type: Literal["ipv4", "ipv6"]
                """IP address version."""
                destination_prefix: str | None
                """
                IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                eg. 10.3.3.0/24
                """
                source_prefix: str | None
                """
                IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                eg. 10.3.3.0/24
                """
                protocols: Protocols
                """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        type: Literal["ipv4", "ipv6"] | UndefinedType = Undefined,
                        destination_prefix: str | None | UndefinedType = Undefined,
                        source_prefix: str | None | UndefinedType = Undefined,
                        protocols: Protocols | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchRulesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            type: IP address version.
                            destination_prefix:
                               IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                               eg. 10.3.3.0/24
                            source_prefix:
                               IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                               eg. 10.3.3.0/24
                            protocols: Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`).

                        """

            class MatchRules(AvdIndexedList[str, MatchRulesItem]):
                """Subclass of AvdIndexedList with `MatchRulesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            MatchRules._item_type = MatchRulesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "match_rules": {"type": MatchRules}}
            name: str
            match_rules: MatchRules
            """Subclass of AvdIndexedList with `MatchRulesItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, match_rules: MatchRules | UndefinedType = Undefined) -> None:
                    """
                    SamplePoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        match_rules: Subclass of AvdIndexedList with `MatchRulesItem` items. Primary key is `name` (`str`).

                    """

        class SamplePolicies(AvdIndexedList[str, SamplePoliciesItem]):
            """Subclass of AvdIndexedList with `SamplePoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        SamplePolicies._item_type = SamplePoliciesItem

        _fields: ClassVar[dict] = {
            "disabled": {"type": bool, "default": True},
            "ingress": {"type": Ingress},
            "marker_vxlan": {"type": MarkerVxlan},
            "profiles": {"type": Profiles},
            "sample_policies": {"type": SamplePolicies},
        }
        disabled: bool
        """
        Enable or disable the postcard telemetry feature.

        Default value: `True`
        """
        ingress: Ingress
        """Subclass of AvdModel."""
        marker_vxlan: MarkerVxlan
        """Subclass of AvdModel."""
        profiles: Profiles
        """
        Postcard telemetry profiles.

        Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is
        `name` (`str`).
        """
        sample_policies: SamplePolicies
        """Subclass of AvdIndexedList with `SamplePoliciesItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                disabled: bool | UndefinedType = Undefined,
                ingress: Ingress | UndefinedType = Undefined,
                marker_vxlan: MarkerVxlan | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
                sample_policies: SamplePolicies | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorTelemetryPostcardPolicy.


                Subclass of AvdModel.

                Args:
                    disabled: Enable or disable the postcard telemetry feature.
                    ingress: Subclass of AvdModel.
                    marker_vxlan: Subclass of AvdModel.
                    profiles:
                       Postcard telemetry profiles.

                       Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is
                       `name` (`str`).
                    sample_policies: Subclass of AvdIndexedList with `SamplePoliciesItem` items. Primary key is `name` (`str`).

                """

    class MonitorTwamp(AvdModel):
        """Subclass of AvdModel."""

        class TwampLight(AvdModel):
            """Subclass of AvdModel."""

            class ReflectorDefaults(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"listen_port": {"type": int}}
                listen_port: int | None

                if TYPE_CHECKING:

                    def __init__(self, *, listen_port: int | None | UndefinedType = Undefined) -> None:
                        """
                        ReflectorDefaults.


                        Subclass of AvdModel.

                        Args:
                            listen_port: listen_port

                        """

            class SenderDefaults(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"destination_port": {"type": int}, "source_port": {"type": int}}
                destination_port: int | None
                source_port: int | None

                if TYPE_CHECKING:

                    def __init__(
                        self, *, destination_port: int | None | UndefinedType = Undefined, source_port: int | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        SenderDefaults.


                        Subclass of AvdModel.

                        Args:
                            destination_port: destination_port
                            source_port: source_port

                        """

            class SenderProfilesItem(AvdModel):
                """Subclass of AvdModel."""

                class Significance(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"value": {"type": int}, "offset": {"type": int}}
                    value: int
                    """Significance value in microseconds."""
                    offset: int
                    """
                    Offset in microseconds, used to round up calculated TWAMP light delay statistics. Must be lower than
                    the significance value.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, value: int | UndefinedType = Undefined, offset: int | UndefinedType = Undefined) -> None:
                            """
                            Significance.


                            Subclass of AvdModel.

                            Args:
                                value: Significance value in microseconds.
                                offset:
                                   Offset in microseconds, used to round up calculated TWAMP light delay statistics. Must be lower than
                                   the significance value.

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "measurement_interval": {"type": int},
                    "measurement_samples": {"type": int},
                    "significance": {"type": Significance},
                }
                name: str
                measurement_interval: int | None
                """Measurement interval in seconds."""
                measurement_samples: int | None
                """Number of samples used to calculate TWAMP light metrics."""
                significance: Significance
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        measurement_interval: int | None | UndefinedType = Undefined,
                        measurement_samples: int | None | UndefinedType = Undefined,
                        significance: Significance | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SenderProfilesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            measurement_interval: Measurement interval in seconds.
                            measurement_samples: Number of samples used to calculate TWAMP light metrics.
                            significance: Subclass of AvdModel.

                        """

            class SenderProfiles(AvdIndexedList[str, SenderProfilesItem]):
                """Subclass of AvdIndexedList with `SenderProfilesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            SenderProfiles._item_type = SenderProfilesItem

            _fields: ClassVar[dict] = {
                "reflector_defaults": {"type": ReflectorDefaults},
                "sender_defaults": {"type": SenderDefaults},
                "sender_profiles": {"type": SenderProfiles},
            }
            reflector_defaults: ReflectorDefaults
            """Subclass of AvdModel."""
            sender_defaults: SenderDefaults
            """Subclass of AvdModel."""
            sender_profiles: SenderProfiles
            """Subclass of AvdIndexedList with `SenderProfilesItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    reflector_defaults: ReflectorDefaults | UndefinedType = Undefined,
                    sender_defaults: SenderDefaults | UndefinedType = Undefined,
                    sender_profiles: SenderProfiles | UndefinedType = Undefined,
                ) -> None:
                    """
                    TwampLight.


                    Subclass of AvdModel.

                    Args:
                        reflector_defaults: Subclass of AvdModel.
                        sender_defaults: Subclass of AvdModel.
                        sender_profiles: Subclass of AvdIndexedList with `SenderProfilesItem` items. Primary key is `name` (`str`).

                    """

        _fields: ClassVar[dict] = {"twamp_light": {"type": TwampLight}}
        twamp_light: TwampLight
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, twamp_light: TwampLight | UndefinedType = Undefined) -> None:
                """
                MonitorTwamp.


                Subclass of AvdModel.

                Args:
                    twamp_light: Subclass of AvdModel.

                """

    class Mpls(AvdModel):
        """Subclass of AvdModel."""

        class Ldp(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "interface_disabled_default": {"type": bool},
                "router_id": {"type": str},
                "shutdown": {"type": bool},
                "transport_address_interface": {"type": str},
            }
            interface_disabled_default: bool | None
            router_id: str | None
            shutdown: bool | None
            transport_address_interface: str | None
            """Interface Name."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    interface_disabled_default: bool | None | UndefinedType = Undefined,
                    router_id: str | None | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    transport_address_interface: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ldp.


                    Subclass of AvdModel.

                    Args:
                        interface_disabled_default: interface_disabled_default
                        router_id: router_id
                        shutdown: shutdown
                        transport_address_interface: Interface Name.

                    """

        class Icmp(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"fragmentation_needed_tunneling": {"type": bool}, "ttl_exceeded_tunneling": {"type": bool}}
            fragmentation_needed_tunneling: bool | None
            """Enables the MPLS tunneling of MTU exceeded ICMP replies (fragmentation needed, packet too big)."""
            ttl_exceeded_tunneling: bool | None
            """Enables the MPLS tunneling of TTL exceeded ICMP replies."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    fragmentation_needed_tunneling: bool | None | UndefinedType = Undefined,
                    ttl_exceeded_tunneling: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Icmp.


                    Subclass of AvdModel.

                    Args:
                        fragmentation_needed_tunneling: Enables the MPLS tunneling of MTU exceeded ICMP replies (fragmentation needed, packet too big).
                        ttl_exceeded_tunneling: Enables the MPLS tunneling of TTL exceeded ICMP replies.

                    """

        class Rsvp(AvdModel):
            """Subclass of AvdModel."""

            class Refresh(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "method": {"type": str}}
                interval: int | None
                """Time between refreshes."""
                method: Literal["bundled", "explicit"] | None
                """
                Neighbor refresh mechanism.
                bundled: Refresh states using message identifier lists.
                explicit: Send
                each message individually.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self, *, interval: int | None | UndefinedType = Undefined, method: Literal["bundled", "explicit"] | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        Refresh.


                        Subclass of AvdModel.

                        Args:
                            interval: Time between refreshes.
                            method:
                               Neighbor refresh mechanism.
                               bundled: Refresh states using message identifier lists.
                               explicit: Send
                               each message individually.

                        """

            class Authentication(AvdModel):
                """Subclass of AvdModel."""

                class PasswordIndexesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"index": {"type": int}, "password_type": {"type": str, "default": "7"}, "password": {"type": str}}
                    index: int
                    """Password index."""
                    password_type: Literal["0", "7", "8a"]
                    """
                    Authentication password type.

                    Default value: `"7"`
                    """
                    password: str | None
                    """Password string."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            index: int | UndefinedType = Undefined,
                            password_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            password: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            PasswordIndexesItem.


                            Subclass of AvdModel.

                            Args:
                                index: Password index.
                                password_type: Authentication password type.
                                password: Password string.

                            """

                class PasswordIndexes(AvdIndexedList[int, PasswordIndexesItem]):
                    """Subclass of AvdIndexedList with `PasswordIndexesItem` items. Primary key is `index` (`int`)."""

                    _primary_key: ClassVar[str] = "index"

                PasswordIndexes._item_type = PasswordIndexesItem

                _fields: ClassVar[dict] = {
                    "password_indexes": {"type": PasswordIndexes},
                    "active_index": {"type": int},
                    "sequence_number_window": {"type": int},
                    "type": {"type": str},
                }
                password_indexes: PasswordIndexes
                """Subclass of AvdIndexedList with `PasswordIndexesItem` items. Primary key is `index` (`int`)."""
                active_index: int | None
                """Use index as active password."""
                sequence_number_window: int | None
                """Size of reorder window for index in the sequence."""
                type: Literal["md5", "none"] | None
                """Authentication mechanism."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        password_indexes: PasswordIndexes | UndefinedType = Undefined,
                        active_index: int | None | UndefinedType = Undefined,
                        sequence_number_window: int | None | UndefinedType = Undefined,
                        type: Literal["md5", "none"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Authentication.


                        Subclass of AvdModel.

                        Args:
                            password_indexes: Subclass of AvdIndexedList with `PasswordIndexesItem` items. Primary key is `index` (`int`).
                            active_index: Use index as active password.
                            sequence_number_window: Size of reorder window for index in the sequence.
                            type: Authentication mechanism.

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class Authentication(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"index": {"type": int}, "type": {"type": str}}
                    index: int | None
                    """Password index."""
                    type: Literal["md5", "none"] | None
                    """Authentication mechanism."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, index: int | None | UndefinedType = Undefined, type: Literal["md5", "none"] | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            Authentication.


                            Subclass of AvdModel.

                            Args:
                                index: Password index.
                                type: Authentication mechanism.

                            """

                _fields: ClassVar[dict] = {"ip_address": {"type": str}, "ipv6_address": {"type": str}, "authentication": {"type": Authentication}}
                ip_address: str | None
                """Neighbor's interface IPv4 address."""
                ipv6_address: str | None
                """Neighbor's interface IPv6 address."""
                authentication: Authentication
                """
                Cryptographic authentication.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | None | UndefinedType = Undefined,
                        ipv6_address: str | None | UndefinedType = Undefined,
                        authentication: Authentication | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: Neighbor's interface IPv4 address.
                            ipv6_address: Neighbor's interface IPv6 address.
                            authentication:
                               Cryptographic authentication.

                               Subclass of AvdModel.

                        """

            class Neighbors(AvdList[NeighborsItem]):
                """Subclass of AvdList with `NeighborsItem` items."""

            Neighbors._item_type = NeighborsItem

            class FastReroute(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"mode": {"type": str}, "reversion": {"type": str}, "bypass_tunnel_optimization_interval": {"type": int}}
                mode: Literal["link-protection", "node-protection", "none"] | None
                """
                Fast reroute mode.
                link-protection: Protect against failure of the next link.
                node-protection:
                Protect against failure of the next node.
                none: Disable fast reroute.
                """
                reversion: Literal["global", "local"] | None
                """
                Reversion behavior.
                Global revertive repair.
                Local revertive repair.
                """
                bypass_tunnel_optimization_interval: int | None
                """
                Fast-reroute bypass configuration.
                Interval between each re-optimization attempt in seconds.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mode: Literal["link-protection", "node-protection", "none"] | None | UndefinedType = Undefined,
                        reversion: Literal["global", "local"] | None | UndefinedType = Undefined,
                        bypass_tunnel_optimization_interval: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        FastReroute.


                        Subclass of AvdModel.

                        Args:
                            mode:
                               Fast reroute mode.
                               link-protection: Protect against failure of the next link.
                               node-protection:
                               Protect against failure of the next node.
                               none: Disable fast reroute.
                            reversion:
                               Reversion behavior.
                               Global revertive repair.
                               Local revertive repair.
                            bypass_tunnel_optimization_interval:
                               Fast-reroute bypass configuration.
                               Interval between each re-optimization attempt in seconds.

                        """

            class Srlg(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "strict": {"type": bool}}
                enabled: bool | None
                """Select SRLG behavior."""
                strict: bool | None
                """Apply strict SRLG constraint."""

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, strict: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Srlg.


                        Subclass of AvdModel.

                        Args:
                            enabled: Select SRLG behavior.
                            strict: Apply strict SRLG constraint.

                        """

            class PreemptionMethod(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"preemption": {"type": str}, "timer": {"type": int}}
                preemption: Literal["hard", "soft"] | None
                timer: int | None
                """Timer value in units of seconds."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, preemption: Literal["hard", "soft"] | None | UndefinedType = Undefined, timer: int | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        PreemptionMethod.


                        Subclass of AvdModel.

                        Args:
                            preemption: preemption
                            timer: Timer value in units of seconds.

                        """

            class GracefulRestart(AvdModel):
                """Subclass of AvdModel."""

                class RoleHelper(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "timer_recovery": {"type": int}, "timer_restart": {"type": int}}
                    enabled: bool | None
                    timer_recovery: int | None
                    """Maximum recovery timer value in seconds."""
                    timer_restart: int | None
                    """Maximum restart timer value in seconds."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            timer_recovery: int | None | UndefinedType = Undefined,
                            timer_restart: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RoleHelper.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                timer_recovery: Maximum recovery timer value in seconds.
                                timer_restart: Maximum restart timer value in seconds.

                            """

                class RoleSpeaker(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "timer_recovery": {"type": int}, "timer_restart": {"type": int}}
                    enabled: bool | None
                    timer_recovery: int | None
                    """Maximum recovery timer value in seconds."""
                    timer_restart: int | None
                    """Maximum restart timer value in seconds."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            timer_recovery: int | None | UndefinedType = Undefined,
                            timer_restart: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RoleSpeaker.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                timer_recovery: Maximum recovery timer value in seconds.
                                timer_restart: Maximum restart timer value in seconds.

                            """

                _fields: ClassVar[dict] = {"role_helper": {"type": RoleHelper}, "role_speaker": {"type": RoleSpeaker}}
                role_helper: RoleHelper
                """Subclass of AvdModel."""
                role_speaker: RoleSpeaker
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, role_helper: RoleHelper | UndefinedType = Undefined, role_speaker: RoleSpeaker | UndefinedType = Undefined) -> None:
                        """
                        GracefulRestart.


                        Subclass of AvdModel.

                        Args:
                            role_helper: Subclass of AvdModel.
                            role_speaker: Subclass of AvdModel.

                        """

            class Hello(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "multiplier": {"type": int}}
                interval: int | None
                """Time between hello messages in seconds."""
                multiplier: int | None
                """Number of missed hellos after which the neighbor is expired."""

                if TYPE_CHECKING:

                    def __init__(self, *, interval: int | None | UndefinedType = Undefined, multiplier: int | None | UndefinedType = Undefined) -> None:
                        """
                        Hello.


                        Subclass of AvdModel.

                        Args:
                            interval: Time between hello messages in seconds.
                            multiplier: Number of missed hellos after which the neighbor is expired.

                        """

            class HitlessRestart(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "timer_recovery": {"type": int}}
                enabled: bool | None
                timer_recovery: int | None
                """
                Time stale states will be preserved after restart.
                Value in seconds.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, timer_recovery: int | None | UndefinedType = Undefined) -> None:
                        """
                        HitlessRestart.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            timer_recovery:
                               Time stale states will be preserved after restart.
                               Value in seconds.

                        """

            class P2mp(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}}
                enabled: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined) -> None:
                        """
                        P2mp.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled

                        """

            _fields: ClassVar[dict] = {
                "refresh": {"type": Refresh},
                "authentication": {"type": Authentication},
                "neighbors": {"type": Neighbors},
                "ip_access_group": {"type": str},
                "ipv6_access_group": {"type": str},
                "fast_reroute": {"type": FastReroute},
                "srlg": {"type": Srlg},
                "label_local_termination": {"type": str},
                "preemption_method": {"type": PreemptionMethod},
                "mtu_signaling": {"type": bool},
                "graceful_restart": {"type": GracefulRestart},
                "hello": {"type": Hello},
                "hitless_restart": {"type": HitlessRestart},
                "p2mp": {"type": P2mp},
                "shutdown": {"type": bool},
            }
            refresh: Refresh
            """Subclass of AvdModel."""
            authentication: Authentication
            """
            Cryptographic authentication.

            Subclass of AvdModel.
            """
            neighbors: Neighbors
            """Subclass of AvdList with `NeighborsItem` items."""
            ip_access_group: str | None
            """IPv4 Access list name."""
            ipv6_access_group: str | None
            """IPv6 access list name."""
            fast_reroute: FastReroute
            """Subclass of AvdModel."""
            srlg: Srlg
            """Subclass of AvdModel."""
            label_local_termination: Literal["implicit-null", "explicit-null"] | None
            """Local termination label to be advertised."""
            preemption_method: PreemptionMethod
            """Subclass of AvdModel."""
            mtu_signaling: bool | None
            """Enable MTU signaling."""
            graceful_restart: GracefulRestart
            """
            RSVP graceful restart.

            Subclass of AvdModel.
            """
            hello: Hello
            """Subclass of AvdModel."""
            hitless_restart: HitlessRestart
            """
            RSVP hitless restart.

            Subclass of AvdModel.
            """
            p2mp: P2mp
            """Subclass of AvdModel."""
            shutdown: bool | None
            """Make `shutdown` key false for `no shutdown` cli."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    refresh: Refresh | UndefinedType = Undefined,
                    authentication: Authentication | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    ip_access_group: str | None | UndefinedType = Undefined,
                    ipv6_access_group: str | None | UndefinedType = Undefined,
                    fast_reroute: FastReroute | UndefinedType = Undefined,
                    srlg: Srlg | UndefinedType = Undefined,
                    label_local_termination: Literal["implicit-null", "explicit-null"] | None | UndefinedType = Undefined,
                    preemption_method: PreemptionMethod | UndefinedType = Undefined,
                    mtu_signaling: bool | None | UndefinedType = Undefined,
                    graceful_restart: GracefulRestart | UndefinedType = Undefined,
                    hello: Hello | UndefinedType = Undefined,
                    hitless_restart: HitlessRestart | UndefinedType = Undefined,
                    p2mp: P2mp | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Rsvp.


                    Subclass of AvdModel.

                    Args:
                        refresh: Subclass of AvdModel.
                        authentication:
                           Cryptographic authentication.

                           Subclass of AvdModel.
                        neighbors: Subclass of AvdList with `NeighborsItem` items.
                        ip_access_group: IPv4 Access list name.
                        ipv6_access_group: IPv6 access list name.
                        fast_reroute: Subclass of AvdModel.
                        srlg: Subclass of AvdModel.
                        label_local_termination: Local termination label to be advertised.
                        preemption_method: Subclass of AvdModel.
                        mtu_signaling: Enable MTU signaling.
                        graceful_restart:
                           RSVP graceful restart.

                           Subclass of AvdModel.
                        hello: Subclass of AvdModel.
                        hitless_restart:
                           RSVP hitless restart.

                           Subclass of AvdModel.
                        p2mp: Subclass of AvdModel.
                        shutdown: Make `shutdown` key false for `no shutdown` cli.

                    """

        class Tunnel(AvdModel):
            """Subclass of AvdModel."""

            class Termination(AvdModel):
                """Subclass of AvdModel."""

                class Model(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ttl": {"type": str}, "dscp": {"type": str}}
                    ttl: Literal["pipe", "uniform"]
                    dscp: Literal["pipe", "uniform"]
                    """The DSCP model `uniform` is supported only on specific hardware platforms."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, ttl: Literal["pipe", "uniform"] | UndefinedType = Undefined, dscp: Literal["pipe", "uniform"] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Model.


                            Subclass of AvdModel.

                            Args:
                                ttl: ttl
                                dscp: The DSCP model `uniform` is supported only on specific hardware platforms.

                            """

                class PhpModel(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ttl": {"type": str}, "dscp": {"type": str}}
                    ttl: Literal["pipe", "uniform"]
                    dscp: Literal["pipe", "uniform"]
                    """The DSCP model `uniform` is supported only on specific hardware platforms."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, ttl: Literal["pipe", "uniform"] | UndefinedType = Undefined, dscp: Literal["pipe", "uniform"] | UndefinedType = Undefined
                        ) -> None:
                            """
                            PhpModel.


                            Subclass of AvdModel.

                            Args:
                                ttl: ttl
                                dscp: The DSCP model `uniform` is supported only on specific hardware platforms.

                            """

                _fields: ClassVar[dict] = {"model": {"type": Model}, "php_model": {"type": PhpModel}}
                model: Model
                """Subclass of AvdModel."""
                php_model: PhpModel
                """
                Used on PHP router in the absence of any VPN routes and explicit null VRF labels.

                Subclass of
                AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, model: Model | UndefinedType = Undefined, php_model: PhpModel | UndefinedType = Undefined) -> None:
                        """
                        Termination.


                        Subclass of AvdModel.

                        Args:
                            model: Subclass of AvdModel.
                            php_model:
                               Used on PHP router in the absence of any VPN routes and explicit null VRF labels.

                               Subclass of
                               AvdModel.

                        """

            _fields: ClassVar[dict] = {"termination": {"type": Termination}}
            termination: Termination
            """
            Controls selection of the TTL/DSCP values by LER when decapsulating MPLS packets.

            Subclass of
            AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(self, *, termination: Termination | UndefinedType = Undefined) -> None:
                    """
                    Tunnel.


                    Subclass of AvdModel.

                    Args:
                        termination:
                           Controls selection of the TTL/DSCP values by LER when decapsulating MPLS packets.

                           Subclass of
                           AvdModel.

                    """

        _fields: ClassVar[dict] = {"ip": {"type": bool}, "ldp": {"type": Ldp}, "icmp": {"type": Icmp}, "rsvp": {"type": Rsvp}, "tunnel": {"type": Tunnel}}
        ip: bool | None
        ldp: Ldp
        """Subclass of AvdModel."""
        icmp: Icmp
        """
        Enables the LSRs to generate ICMP reply messages and deliver them to the originating host.

        Subclass
        of AvdModel.
        """
        rsvp: Rsvp
        """Subclass of AvdModel."""
        tunnel: Tunnel
        """
        Configure MPLS tunnel.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                ip: bool | None | UndefinedType = Undefined,
                ldp: Ldp | UndefinedType = Undefined,
                icmp: Icmp | UndefinedType = Undefined,
                rsvp: Rsvp | UndefinedType = Undefined,
                tunnel: Tunnel | UndefinedType = Undefined,
            ) -> None:
                """
                Mpls.


                Subclass of AvdModel.

                Args:
                    ip: ip
                    ldp: Subclass of AvdModel.
                    icmp:
                       Enables the LSRs to generate ICMP reply messages and deliver them to the originating host.

                       Subclass
                       of AvdModel.
                    rsvp: Subclass of AvdModel.
                    tunnel:
                       Configure MPLS tunnel.

                       Subclass of AvdModel.

                """

    class Ntp(AvdModel):
        """Subclass of AvdModel."""

        class LocalInterface(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
            name: str | None
            """Source interface."""
            vrf: str | None
            """VRF name."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | None | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                    """
                    LocalInterface.


                    Subclass of AvdModel.

                    Args:
                        name: Source interface.
                        vrf: VRF name.

                    """

        class ServersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "burst": {"type": bool},
                "iburst": {"type": bool},
                "key": {"type": int},
                "local_interface": {"type": str},
                "maxpoll": {"type": int},
                "minpoll": {"type": int},
                "preferred": {"type": bool},
                "version": {"type": int},
                "vrf": {"type": str},
            }
            name: str
            """IP or hostname e.g., 2.2.2.55, 2001:db8::55, ie.pool.ntp.org."""
            burst: bool | None
            iburst: bool | None
            key: int | None
            local_interface: str | None
            """Source interface."""
            maxpoll: int | None
            """Value of maxpoll between 3 - 17 (Logarithmic)."""
            minpoll: int | None
            """Value of minpoll between 3 - 17 (Logarithmic)."""
            preferred: bool | None
            version: int | None
            vrf: str | None
            """VRF name."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    burst: bool | None | UndefinedType = Undefined,
                    iburst: bool | None | UndefinedType = Undefined,
                    key: int | None | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    maxpoll: int | None | UndefinedType = Undefined,
                    minpoll: int | None | UndefinedType = Undefined,
                    preferred: bool | None | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ServersItem.


                    Subclass of AvdModel.

                    Args:
                        name: IP or hostname e.g., 2.2.2.55, 2001:db8::55, ie.pool.ntp.org.
                        burst: burst
                        iburst: iburst
                        key: key
                        local_interface: Source interface.
                        maxpoll: Value of maxpoll between 3 - 17 (Logarithmic).
                        minpoll: Value of minpoll between 3 - 17 (Logarithmic).
                        preferred: preferred
                        version: version
                        vrf: VRF name.

                    """

        class Servers(AvdIndexedList[str, ServersItem]):
            """Subclass of AvdIndexedList with `ServersItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Servers._item_type = ServersItem

        class AuthenticationKeysItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": int}, "hash_algorithm": {"type": str}, "key": {"type": str}, "key_type": {"type": str}}
            id: int
            """Key identifier."""
            hash_algorithm: Literal["md5", "sha1"]
            key: str
            """Obfuscated key."""
            key_type: Literal["0", "7", "8a"] | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    hash_algorithm: Literal["md5", "sha1"] | UndefinedType = Undefined,
                    key: str | UndefinedType = Undefined,
                    key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AuthenticationKeysItem.


                    Subclass of AvdModel.

                    Args:
                        id: Key identifier.
                        hash_algorithm: hash_algorithm
                        key: Obfuscated key.
                        key_type: key_type

                    """

        class AuthenticationKeys(AvdIndexedList[int, AuthenticationKeysItem]):
            """Subclass of AvdIndexedList with `AuthenticationKeysItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        AuthenticationKeys._item_type = AuthenticationKeysItem

        class Serve(AvdModel):
            """Subclass of AvdModel."""

            class VrfsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "serve_all": {"type": bool},
                    "access_group": {"type": str},
                    "ipv6_access_group": {"type": str},
                }
                name: str
                serve_all: bool | None
                access_group: str | None
                ipv6_access_group: str | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        serve_all: bool | None | UndefinedType = Undefined,
                        access_group: str | None | UndefinedType = Undefined,
                        ipv6_access_group: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VrfsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            serve_all: serve_all
                            access_group: access_group
                            ipv6_access_group: ipv6_access_group

                        """

            class Vrfs(AvdIndexedList[str, VrfsItem]):
                """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Vrfs._item_type = VrfsItem

            _fields: ClassVar[dict] = {"serve_all": {"type": bool}, "access_group": {"type": str}, "ipv6_access_group": {"type": str}, "vrfs": {"type": Vrfs}}
            serve_all: bool | None
            access_group: str | None
            """Standard ACL to apply to NTP serve. All ACLs are applied in the 'in' direction."""
            ipv6_access_group: str | None
            """Standard IPv6 ACL to apply to NTP serve. All ACLs are applied in the 'in' direction."""
            vrfs: Vrfs
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    serve_all: bool | None | UndefinedType = Undefined,
                    access_group: str | None | UndefinedType = Undefined,
                    ipv6_access_group: str | None | UndefinedType = Undefined,
                    vrfs: Vrfs | UndefinedType = Undefined,
                ) -> None:
                    """
                    Serve.


                    Subclass of AvdModel.

                    Args:
                        serve_all: serve_all
                        access_group: Standard ACL to apply to NTP serve. All ACLs are applied in the 'in' direction.
                        ipv6_access_group: Standard IPv6 ACL to apply to NTP serve. All ACLs are applied in the 'in' direction.
                        vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).

                    """

        _fields: ClassVar[dict] = {
            "local_interface": {"type": LocalInterface},
            "servers": {"type": Servers},
            "authenticate": {"type": bool},
            "authenticate_servers_only": {"type": bool},
            "authentication_keys": {"type": AuthenticationKeys},
            "trusted_keys": {"type": str},
            "serve": {"type": Serve},
        }
        local_interface: LocalInterface
        """Subclass of AvdModel."""
        servers: Servers
        """Subclass of AvdIndexedList with `ServersItem` items. Primary key is `name` (`str`)."""
        authenticate: bool | None
        authenticate_servers_only: bool | None
        authentication_keys: AuthenticationKeys
        """Subclass of AvdIndexedList with `AuthenticationKeysItem` items. Primary key is `id` (`int`)."""
        trusted_keys: str | None
        """List of trusted-keys as string ex. 10-12,15."""
        serve: Serve
        """
        Enable Serving NTP to clients.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                local_interface: LocalInterface | UndefinedType = Undefined,
                servers: Servers | UndefinedType = Undefined,
                authenticate: bool | None | UndefinedType = Undefined,
                authenticate_servers_only: bool | None | UndefinedType = Undefined,
                authentication_keys: AuthenticationKeys | UndefinedType = Undefined,
                trusted_keys: str | None | UndefinedType = Undefined,
                serve: Serve | UndefinedType = Undefined,
            ) -> None:
                """
                Ntp.


                Subclass of AvdModel.

                Args:
                    local_interface: Subclass of AvdModel.
                    servers: Subclass of AvdIndexedList with `ServersItem` items. Primary key is `name` (`str`).
                    authenticate: authenticate
                    authenticate_servers_only: authenticate_servers_only
                    authentication_keys: Subclass of AvdIndexedList with `AuthenticationKeysItem` items. Primary key is `id` (`int`).
                    trusted_keys: List of trusted-keys as string ex. 10-12,15.
                    serve:
                       Enable Serving NTP to clients.

                       Subclass of AvdModel.

                """

    class PatchPanel(AvdModel):
        """Subclass of AvdModel."""

        class Connector(AvdModel):
            """Subclass of AvdModel."""

            class Interface(AvdModel):
                """Subclass of AvdModel."""

                class Patch(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"bgp_vpws_remote_failure_errdisable": {"type": bool}}
                    bgp_vpws_remote_failure_errdisable: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, bgp_vpws_remote_failure_errdisable: bool | None | UndefinedType = Undefined) -> None:
                            """
                            Patch.


                            Subclass of AvdModel.

                            Args:
                                bgp_vpws_remote_failure_errdisable: bgp_vpws_remote_failure_errdisable

                            """

                class Recovery(AvdModel):
                    """Subclass of AvdModel."""

                    class ReviewDelay(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"min": {"type": int}, "max": {"type": int}}
                        min: int
                        """Minimum delay."""
                        max: int
                        """Maximum delay."""

                        if TYPE_CHECKING:

                            def __init__(self, *, min: int | UndefinedType = Undefined, max: int | UndefinedType = Undefined) -> None:
                                """
                                ReviewDelay.


                                Subclass of AvdModel.

                                Args:
                                    min: Minimum delay.
                                    max: Maximum delay.

                                """

                    _fields: ClassVar[dict] = {"review_delay": {"type": ReviewDelay}}
                    review_delay: ReviewDelay
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, review_delay: ReviewDelay | UndefinedType = Undefined) -> None:
                            """
                            Recovery.


                            Subclass of AvdModel.

                            Args:
                                review_delay: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {"patch": {"type": Patch}, "recovery": {"type": Recovery}}
                patch: Patch
                """Subclass of AvdModel."""
                recovery: Recovery
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, patch: Patch | UndefinedType = Undefined, recovery: Recovery | UndefinedType = Undefined) -> None:
                        """
                        Interface.


                        Subclass of AvdModel.

                        Args:
                            patch: Subclass of AvdModel.
                            recovery: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"interface": {"type": Interface}}
            interface: Interface
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, interface: Interface | UndefinedType = Undefined) -> None:
                    """
                    Connector.


                    Subclass of AvdModel.

                    Args:
                        interface: Subclass of AvdModel.

                    """

        class PatchesItem(AvdModel):
            """Subclass of AvdModel."""

            class ConnectorsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"id": {"type": str}, "type": {"type": str}, "endpoint": {"type": str}}
                id: str
                type: Literal["interface", "pseudowire"]
                endpoint: str
                """
                String with relevant endpoint depending on type.
                Examples:
                - "Ethernet1"
                - "Ethernet1 dot1q vlan
                123"
                - "bgp vpws TENANT_A pseudowire VPWS_PW_1"
                - "ldp LDP_PW_1"
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: str | UndefinedType = Undefined,
                        type: Literal["interface", "pseudowire"] | UndefinedType = Undefined,
                        endpoint: str | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ConnectorsItem.


                        Subclass of AvdModel.

                        Args:
                            id: id
                            type: type
                            endpoint:
                               String with relevant endpoint depending on type.
                               Examples:  # fmt: skip
                               - "Ethernet1"
                               - "Ethernet1 dot1q vlan
                               123"
                               - "bgp vpws TENANT_A pseudowire VPWS_PW_1"
                               - "ldp LDP_PW_1"

                        """

            class Connectors(AvdIndexedList[str, ConnectorsItem]):
                """Subclass of AvdIndexedList with `ConnectorsItem` items. Primary key is `id` (`str`)."""

                _primary_key: ClassVar[str] = "id"

            Connectors._item_type = ConnectorsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "enabled": {"type": bool}, "connectors": {"type": Connectors}}
            name: str
            enabled: bool | None
            connectors: Connectors
            """
            Must have exactly two connectors to a patch of which at least one must be of type "interface".
            Subclass of AvdIndexedList with `ConnectorsItem` items. Primary key is `id` (`str`).
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    connectors: Connectors | UndefinedType = Undefined,
                ) -> None:
                    """
                    PatchesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        enabled: enabled
                        connectors:
                           Must have exactly two connectors to a patch of which at least one must be of type "interface".
                           Subclass of AvdIndexedList with `ConnectorsItem` items. Primary key is `id` (`str`).

                    """

        class Patches(AvdIndexedList[str, PatchesItem]):
            """Subclass of AvdIndexedList with `PatchesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Patches._item_type = PatchesItem

        _fields: ClassVar[dict] = {"connector": {"type": Connector}, "patches": {"type": Patches}}
        connector: Connector
        """Subclass of AvdModel."""
        patches: Patches
        """Subclass of AvdIndexedList with `PatchesItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(self, *, connector: Connector | UndefinedType = Undefined, patches: Patches | UndefinedType = Undefined) -> None:
                """
                PatchPanel.


                Subclass of AvdModel.

                Args:
                    connector: Subclass of AvdModel.
                    patches: Subclass of AvdIndexedList with `PatchesItem` items. Primary key is `name` (`str`).

                """

    class PeerFiltersItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "match": {"type": str}}
            sequence: int
            """Sequence ID."""
            match: str
            """
            Match as string.
            Example: "as-range 1-100 result accept"
            """

            if TYPE_CHECKING:

                def __init__(self, *, sequence: int | UndefinedType = Undefined, match: str | UndefinedType = Undefined) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        match:
                           Match as string.
                           Example: "as-range 1-100 result accept"

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
        name: str
        """Peer-filter Name."""
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, sequence_numbers: SequenceNumbers | UndefinedType = Undefined) -> None:
                """
                PeerFiltersItem.


                Subclass of AvdModel.

                Args:
                    name: Peer-filter Name.
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).

                """

    class PeerFilters(AvdIndexedList[str, PeerFiltersItem]):
        """Subclass of AvdIndexedList with `PeerFiltersItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    PeerFilters._item_type = PeerFiltersItem

    class Platform(AvdModel):
        """Subclass of AvdModel."""

        class Trident(AvdModel):
            """Subclass of AvdModel."""

            class L3(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"routing_mac_address_per_vlan": {"type": bool}}
                routing_mac_address_per_vlan: bool | None
                """Enable bridging of packets with destination MAC being a Router MAC in VLANs without routing."""

                if TYPE_CHECKING:

                    def __init__(self, *, routing_mac_address_per_vlan: bool | None | UndefinedType = Undefined) -> None:
                        """
                        L3.


                        Subclass of AvdModel.

                        Args:
                            routing_mac_address_per_vlan: Enable bridging of packets with destination MAC being a Router MAC in VLANs without routing.

                        """

            class Mmu(AvdModel):
                """Subclass of AvdModel."""

                class HeadroomPool(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"unit": {"type": str}, "limit": {"type": int}}
                    unit: Literal["bytes", "cells"] | None
                    """
                    Unit to be used for the `headroom_pool` value.
                    If not specified, default is bytes.
                    """
                    limit: int | None
                    """Max limit on headroom pool size."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, unit: Literal["bytes", "cells"] | None | UndefinedType = Undefined, limit: int | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            HeadroomPool.


                            Subclass of AvdModel.

                            Args:
                                unit:
                                   Unit to be used for the `headroom_pool` value.
                                   If not specified, default is bytes.
                                limit: Max limit on headroom pool size.

                            """

                class QueueProfilesItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Ingress(AvdModel):
                        """Subclass of AvdModel."""

                        class PriorityGroupsItem(AvdModel):
                            """Subclass of AvdModel."""

                            class Reserved(AvdModel):
                                """Subclass of AvdModel."""

                                _fields: ClassVar[dict] = {"unit": {"type": str}, "memory": {"type": int}}
                                unit: Literal["bytes", "cells"] | None
                                """
                                Unit to be used for the `priority_groups` `reserved` value.
                                If not specified, default is bytes.
                                """
                                memory: int | None
                                """Specify the amount of memory that should be reserved."""

                                if TYPE_CHECKING:

                                    def __init__(
                                        self,
                                        *,
                                        unit: Literal["bytes", "cells"] | None | UndefinedType = Undefined,
                                        memory: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Reserved.


                                        Subclass of AvdModel.

                                        Args:
                                            unit:
                                               Unit to be used for the `priority_groups` `reserved` value.
                                               If not specified, default is bytes.
                                            memory: Specify the amount of memory that should be reserved.

                                        """

                            _fields: ClassVar[dict] = {"id": {"type": int}, "threshold": {"type": str}, "reserved": {"type": Reserved}}
                            id: int
                            """Priority-group group number."""
                            threshold: Literal["1", "1/128", "1/16", "1/2", "1/32", "1/4", "1/64", "1/8", "2", "4", "8"] | None
                            reserved: Reserved
                            """Subclass of AvdModel."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    id: int | UndefinedType = Undefined,
                                    threshold: Literal["1", "1/128", "1/16", "1/2", "1/32", "1/4", "1/64", "1/8", "2", "4", "8"]
                                    | None
                                    | UndefinedType = Undefined,
                                    reserved: Reserved | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    PriorityGroupsItem.


                                    Subclass of AvdModel.

                                    Args:
                                        id: Priority-group group number.
                                        threshold: threshold
                                        reserved: Subclass of AvdModel.

                                    """

                        class PriorityGroups(AvdIndexedList[int, PriorityGroupsItem]):
                            """Subclass of AvdIndexedList with `PriorityGroupsItem` items. Primary key is `id` (`int`)."""

                            _primary_key: ClassVar[str] = "id"

                        PriorityGroups._item_type = PriorityGroupsItem

                        class Reserved(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"unit": {"type": str}, "memory": {"type": int}}
                            unit: Literal["bytes", "cells"] | None
                            """
                            Unit to be used for the `reserved` value.
                            If not specified, default is bytes.
                            """
                            memory: int | None
                            """Specify the amount of memory that should be reserved."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self, *, unit: Literal["bytes", "cells"] | None | UndefinedType = Undefined, memory: int | None | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    Reserved.


                                    Subclass of AvdModel.

                                    Args:
                                        unit:
                                           Unit to be used for the `reserved` value.
                                           If not specified, default is bytes.
                                        memory: Specify the amount of memory that should be reserved.

                                    """

                        class Headroom(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"unit": {"type": str}, "memory": {"type": int}}
                            unit: Literal["bytes", "cells"] | None
                            """
                            Unit to be used for the headroom value.
                            If not specified, default is bytes.
                            """
                            memory: int | None
                            """Specify the amount of memory that should be reserved."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self, *, unit: Literal["bytes", "cells"] | None | UndefinedType = Undefined, memory: int | None | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    Headroom.


                                    Subclass of AvdModel.

                                    Args:
                                        unit:
                                           Unit to be used for the headroom value.
                                           If not specified, default is bytes.
                                        memory: Specify the amount of memory that should be reserved.

                                    """

                        _fields: ClassVar[dict] = {
                            "priority_groups": {"type": PriorityGroups},
                            "threshold": {"type": str},
                            "reserved": {"type": Reserved},
                            "headroom": {"type": Headroom},
                            "resume": {"type": int},
                        }
                        priority_groups: PriorityGroups
                        """Subclass of AvdIndexedList with `PriorityGroupsItem` items. Primary key is `id` (`int`)."""
                        threshold: Literal["1", "1/128", "1/16", "1/2", "1/32", "1/4", "1/64", "1/8", "2", "4", "8"] | None
                        """Specify the dynamic shared memory threshold."""
                        reserved: Reserved
                        """Subclass of AvdModel."""
                        headroom: Headroom
                        """Subclass of AvdModel."""
                        resume: int | None
                        """Amount of memory that should be reserved (in bytes)"""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                priority_groups: PriorityGroups | UndefinedType = Undefined,
                                threshold: Literal["1", "1/128", "1/16", "1/2", "1/32", "1/4", "1/64", "1/8", "2", "4", "8"] | None | UndefinedType = Undefined,
                                reserved: Reserved | UndefinedType = Undefined,
                                headroom: Headroom | UndefinedType = Undefined,
                                resume: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ingress.


                                Subclass of AvdModel.

                                Args:
                                    priority_groups: Subclass of AvdIndexedList with `PriorityGroupsItem` items. Primary key is `id` (`int`).
                                    threshold: Specify the dynamic shared memory threshold.
                                    reserved: Subclass of AvdModel.
                                    headroom: Subclass of AvdModel.
                                    resume: Amount of memory that should be reserved (in bytes)

                                """

                    class MulticastQueuesItem(AvdModel):
                        """Subclass of AvdModel."""

                        class Drop(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"precedence": {"type": int}, "threshold": {"type": str}}
                            precedence: Literal[1, 2]
                            threshold: str
                            """
                            Drop Threshold. This value may also be fractions.
                            Example: 7/8 or 3/4 or 1/2
                            """

                            if TYPE_CHECKING:

                                def __init__(
                                    self, *, precedence: Literal[1, 2] | UndefinedType = Undefined, threshold: str | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    Drop.


                                    Subclass of AvdModel.

                                    Args:
                                        precedence: precedence
                                        threshold:
                                           Drop Threshold. This value may also be fractions.
                                           Example: 7/8 or 3/4 or 1/2

                                    """

                        _fields: ClassVar[dict] = {
                            "id": {"type": int},
                            "unit": {"type": str},
                            "reserved": {"type": int},
                            "threshold": {"type": str},
                            "drop": {"type": Drop},
                        }
                        id: int
                        unit: Literal["bytes", "cells"] | None
                        """Unit to be used for the reservation value. If not specified, default is bytes."""
                        reserved: int | None
                        """
                        Amount of memory that should be reserved for this
                        queue.
                        """
                        threshold: Literal["1", "1/128", "1/16", "1/2", "1/32", "1/4", "1/64", "1/8", "2", "4", "8"] | None
                        """Dynamic Shared Memory threshold."""
                        drop: Drop
                        """Subclass of AvdModel."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                id: int | UndefinedType = Undefined,
                                unit: Literal["bytes", "cells"] | None | UndefinedType = Undefined,
                                reserved: int | None | UndefinedType = Undefined,
                                threshold: Literal["1", "1/128", "1/16", "1/2", "1/32", "1/4", "1/64", "1/8", "2", "4", "8"] | None | UndefinedType = Undefined,
                                drop: Drop | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MulticastQueuesItem.


                                Subclass of AvdModel.

                                Args:
                                    id: id
                                    unit: Unit to be used for the reservation value. If not specified, default is bytes.
                                    reserved:
                                       Amount of memory that should be reserved for this
                                       queue.
                                    threshold: Dynamic Shared Memory threshold.
                                    drop: Subclass of AvdModel.

                                """

                    class MulticastQueues(AvdIndexedList[int, MulticastQueuesItem]):
                        """Subclass of AvdIndexedList with `MulticastQueuesItem` items. Primary key is `id` (`int`)."""

                        _primary_key: ClassVar[str] = "id"

                    MulticastQueues._item_type = MulticastQueuesItem

                    class UnicastQueuesItem(AvdModel):
                        """Subclass of AvdModel."""

                        class Drop(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"precedence": {"type": int}, "threshold": {"type": str}}
                            precedence: Literal[1, 2]
                            threshold: str
                            """
                            Drop Threshold. This value may also be fractions.
                            Example: 7/8 or 3/4 or 1/2
                            """

                            if TYPE_CHECKING:

                                def __init__(
                                    self, *, precedence: Literal[1, 2] | UndefinedType = Undefined, threshold: str | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    Drop.


                                    Subclass of AvdModel.

                                    Args:
                                        precedence: precedence
                                        threshold:
                                           Drop Threshold. This value may also be fractions.
                                           Example: 7/8 or 3/4 or 1/2

                                    """

                        _fields: ClassVar[dict] = {
                            "id": {"type": int},
                            "unit": {"type": str},
                            "reserved": {"type": int},
                            "threshold": {"type": str},
                            "drop": {"type": Drop},
                        }
                        id: int
                        unit: Literal["bytes", "cells"] | None
                        """Unit to be used for the reservation value. If not specified, default is bytes."""
                        reserved: int | None
                        """
                        Amount of memory that should be reserved for this
                        queue.
                        """
                        threshold: Literal["1", "1/128", "1/16", "1/2", "1/32", "1/4", "1/64", "1/8", "2", "4", "8"] | None
                        """Dynamic Shared Memory threshold."""
                        drop: Drop
                        """Subclass of AvdModel."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                id: int | UndefinedType = Undefined,
                                unit: Literal["bytes", "cells"] | None | UndefinedType = Undefined,
                                reserved: int | None | UndefinedType = Undefined,
                                threshold: Literal["1", "1/128", "1/16", "1/2", "1/32", "1/4", "1/64", "1/8", "2", "4", "8"] | None | UndefinedType = Undefined,
                                drop: Drop | UndefinedType = Undefined,
                            ) -> None:
                                """
                                UnicastQueuesItem.


                                Subclass of AvdModel.

                                Args:
                                    id: id
                                    unit: Unit to be used for the reservation value. If not specified, default is bytes.
                                    reserved:
                                       Amount of memory that should be reserved for this
                                       queue.
                                    threshold: Dynamic Shared Memory threshold.
                                    drop: Subclass of AvdModel.

                                """

                    class UnicastQueues(AvdIndexedList[int, UnicastQueuesItem]):
                        """Subclass of AvdIndexedList with `UnicastQueuesItem` items. Primary key is `id` (`int`)."""

                        _primary_key: ClassVar[str] = "id"

                    UnicastQueues._item_type = UnicastQueuesItem

                    _fields: ClassVar[dict] = {
                        "name": {"type": str},
                        "ingress": {"type": Ingress},
                        "multicast_queues": {"type": MulticastQueues},
                        "unicast_queues": {"type": UnicastQueues},
                    }
                    name: str
                    ingress: Ingress
                    """Subclass of AvdModel."""
                    multicast_queues: MulticastQueues
                    """
                    Egress multicast queues.

                    Subclass of AvdIndexedList with `MulticastQueuesItem` items. Primary key
                    is `id` (`int`).
                    """
                    unicast_queues: UnicastQueues
                    """
                    Egress unicast queues.

                    Subclass of AvdIndexedList with `UnicastQueuesItem` items. Primary key is
                    `id` (`int`).
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            ingress: Ingress | UndefinedType = Undefined,
                            multicast_queues: MulticastQueues | UndefinedType = Undefined,
                            unicast_queues: UnicastQueues | UndefinedType = Undefined,
                        ) -> None:
                            """
                            QueueProfilesItem.


                            Subclass of AvdModel.

                            Args:
                                name: name
                                ingress: Subclass of AvdModel.
                                multicast_queues:
                                   Egress multicast queues.

                                   Subclass of AvdIndexedList with `MulticastQueuesItem` items. Primary key
                                   is `id` (`int`).
                                unicast_queues:
                                   Egress unicast queues.

                                   Subclass of AvdIndexedList with `UnicastQueuesItem` items. Primary key is
                                   `id` (`int`).

                            """

                class QueueProfiles(AvdIndexedList[str, QueueProfilesItem]):
                    """Subclass of AvdIndexedList with `QueueProfilesItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                QueueProfiles._item_type = QueueProfilesItem

                _fields: ClassVar[dict] = {"active_profile": {"type": str}, "headroom_pool": {"type": HeadroomPool}, "queue_profiles": {"type": QueueProfiles}}
                active_profile: str | None
                """The queue profile to be applied to the platform."""
                headroom_pool: HeadroomPool
                """Subclass of AvdModel."""
                queue_profiles: QueueProfiles
                """Subclass of AvdIndexedList with `QueueProfilesItem` items. Primary key is `name` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        active_profile: str | None | UndefinedType = Undefined,
                        headroom_pool: HeadroomPool | UndefinedType = Undefined,
                        queue_profiles: QueueProfiles | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Mmu.


                        Subclass of AvdModel.

                        Args:
                            active_profile: The queue profile to be applied to the platform.
                            headroom_pool: Subclass of AvdModel.
                            queue_profiles: Subclass of AvdIndexedList with `QueueProfilesItem` items. Primary key is `name` (`str`).

                        """

            _fields: ClassVar[dict] = {"forwarding_table_partition": {"type": str}, "l3": {"type": L3}, "mmu": {"type": Mmu}}
            forwarding_table_partition: str | None
            l3: L3
            """Subclass of AvdModel."""
            mmu: Mmu
            """
            Memory Management Unit settings.


            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    forwarding_table_partition: str | None | UndefinedType = Undefined,
                    l3: L3 | UndefinedType = Undefined,
                    mmu: Mmu | UndefinedType = Undefined,
                ) -> None:
                    """
                    Trident.


                    Subclass of AvdModel.

                    Args:
                        forwarding_table_partition: forwarding_table_partition
                        l3: Subclass of AvdModel.
                        mmu:
                           Memory Management Unit settings.


                           Subclass of AvdModel.

                    """

        class Sand(AvdModel):
            """Subclass of AvdModel."""

            class QosMapsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"traffic_class": {"type": int}, "to_network_qos": {"type": int}}
                traffic_class: int | None
                to_network_qos: int | None

                if TYPE_CHECKING:

                    def __init__(
                        self, *, traffic_class: int | None | UndefinedType = Undefined, to_network_qos: int | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        QosMapsItem.


                        Subclass of AvdModel.

                        Args:
                            traffic_class: traffic_class
                            to_network_qos: to_network_qos

                        """

            class QosMaps(AvdList[QosMapsItem]):
                """Subclass of AvdList with `QosMapsItem` items."""

            QosMaps._item_type = QosMapsItem

            class Lag(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"hardware_only": {"type": bool}, "mode": {"type": str}}
                hardware_only: bool | None
                mode: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, hardware_only: bool | None | UndefinedType = Undefined, mode: str | None | UndefinedType = Undefined) -> None:
                        """
                        Lag.


                        Subclass of AvdModel.

                        Args:
                            hardware_only: hardware_only
                            mode: mode

                        """

            class MulticastReplication(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"default": {"type": str}}
                default: Literal["ingress", "egress"] | None

                if TYPE_CHECKING:

                    def __init__(self, *, default: Literal["ingress", "egress"] | None | UndefinedType = Undefined) -> None:
                        """
                        MulticastReplication.


                        Subclass of AvdModel.

                        Args:
                            default: default

                        """

            _fields: ClassVar[dict] = {
                "qos_maps": {"type": QosMaps},
                "lag": {"type": Lag},
                "forwarding_mode": {"type": str},
                "multicast_replication": {"type": MulticastReplication},
                "mdb_profile": {"type": str},
            }
            qos_maps: QosMaps
            """Subclass of AvdList with `QosMapsItem` items."""
            lag: Lag
            """Subclass of AvdModel."""
            forwarding_mode: str | None
            multicast_replication: MulticastReplication
            """Subclass of AvdModel."""
            mdb_profile: Literal["balanced", "balanced-xl", "l3", "l3-xl", "l3-xxl", "l3-xxxl"] | None
            """Sand platforms MDB Profile configuration. Note: l3-xxxl does not support MLAG."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    qos_maps: QosMaps | UndefinedType = Undefined,
                    lag: Lag | UndefinedType = Undefined,
                    forwarding_mode: str | None | UndefinedType = Undefined,
                    multicast_replication: MulticastReplication | UndefinedType = Undefined,
                    mdb_profile: Literal["balanced", "balanced-xl", "l3", "l3-xl", "l3-xxl", "l3-xxxl"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Sand.


                    Subclass of AvdModel.

                    Args:
                        qos_maps: Subclass of AvdList with `QosMapsItem` items.
                        lag: Subclass of AvdModel.
                        forwarding_mode: forwarding_mode
                        multicast_replication: Subclass of AvdModel.
                        mdb_profile: Sand platforms MDB Profile configuration. Note: l3-xxxl does not support MLAG.

                    """

        class Sfe(AvdModel):
            """Subclass of AvdModel."""

            class Interface(AvdModel):
                """Subclass of AvdModel."""

                class ProfilesItem(AvdModel):
                    """Subclass of AvdModel."""

                    class InterfacesItem(AvdModel):
                        """Subclass of AvdModel."""

                        class RxQueue(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"count": {"type": int}, "worker": {"type": str}, "mode": {"type": str}}
                            count: int | None
                            """
                            Number of receive queues.
                            The maximum value is platform dependent.
                            """
                            worker: str | None
                            """
                            Worker ids specified as combination of range and/or comma separated values
                            such as 0-4,7.
                            """
                            mode: Literal["shared", "exclusive"] | None
                            """Mode applicable to the workers. Default mode is 'shared'."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    count: int | None | UndefinedType = Undefined,
                                    worker: str | None | UndefinedType = Undefined,
                                    mode: Literal["shared", "exclusive"] | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    RxQueue.


                                    Subclass of AvdModel.

                                    Args:
                                        count:
                                           Number of receive queues.
                                           The maximum value is platform dependent.
                                        worker:
                                           Worker ids specified as combination of range and/or comma separated values
                                           such as 0-4,7.
                                        mode: Mode applicable to the workers. Default mode is 'shared'.

                                    """

                        _fields: ClassVar[dict] = {"name": {"type": str}, "rx_queue": {"type": RxQueue}}
                        name: str
                        """Interface name such as 'Ethernet2'."""
                        rx_queue: RxQueue
                        """
                        Receive queue parameters for the selected interface.

                        Subclass of AvdModel.
                        """

                        if TYPE_CHECKING:

                            def __init__(self, *, name: str | UndefinedType = Undefined, rx_queue: RxQueue | UndefinedType = Undefined) -> None:
                                """
                                InterfacesItem.


                                Subclass of AvdModel.

                                Args:
                                    name: Interface name such as 'Ethernet2'.
                                    rx_queue:
                                       Receive queue parameters for the selected interface.

                                       Subclass of AvdModel.

                                """

                    class Interfaces(AvdIndexedList[str, InterfacesItem]):
                        """Subclass of AvdIndexedList with `InterfacesItem` items. Primary key is `name` (`str`)."""

                        _primary_key: ClassVar[str] = "name"

                    Interfaces._item_type = InterfacesItem

                    _fields: ClassVar[dict] = {"name": {"type": str}, "interfaces": {"type": Interfaces}}
                    name: str
                    """RSS interface profile name."""
                    interfaces: Interfaces
                    """
                    Interfaces within RSS profile.

                    Subclass of AvdIndexedList with `InterfacesItem` items. Primary key
                    is `name` (`str`).
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | UndefinedType = Undefined, interfaces: Interfaces | UndefinedType = Undefined) -> None:
                            """
                            ProfilesItem.


                            Subclass of AvdModel.

                            Args:
                                name: RSS interface profile name.
                                interfaces:
                                   Interfaces within RSS profile.

                                   Subclass of AvdIndexedList with `InterfacesItem` items. Primary key
                                   is `name` (`str`).

                            """

                class Profiles(AvdIndexedList[str, ProfilesItem]):
                    """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                Profiles._item_type = ProfilesItem

                _fields: ClassVar[dict] = {"profiles": {"type": Profiles}, "interface_profile": {"type": str}}
                profiles: Profiles
                """
                Configure one or more Receive Side Scaling (RSS) interface profiles.
                This is supported on specific
                platforms.

                Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`).
                """
                interface_profile: str | None
                """
                RSS interface profile name to apply for the platform.
                Needs system reload or Sfe agent restart for
                change to take effect.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, profiles: Profiles | UndefinedType = Undefined, interface_profile: str | None | UndefinedType = Undefined) -> None:
                        """
                        Interface.


                        Subclass of AvdModel.

                        Args:
                            profiles:
                               Configure one or more Receive Side Scaling (RSS) interface profiles.
                               This is supported on specific
                               platforms.

                               Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`).
                            interface_profile:
                               RSS interface profile name to apply for the platform.
                               Needs system reload or Sfe agent restart for
                               change to take effect.

                        """

            _fields: ClassVar[dict] = {"data_plane_cpu_allocation_max": {"type": int}, "interface": {"type": Interface}}
            data_plane_cpu_allocation_max: int | None
            """Maximum number of CPUs used for data plane traffic forwarding."""
            interface: Interface
            """
            Configure interface related settings for Sfe platform.

            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self, *, data_plane_cpu_allocation_max: int | None | UndefinedType = Undefined, interface: Interface | UndefinedType = Undefined
                ) -> None:
                    """
                    Sfe.


                    Subclass of AvdModel.

                    Args:
                        data_plane_cpu_allocation_max: Maximum number of CPUs used for data plane traffic forwarding.
                        interface:
                           Configure interface related settings for Sfe platform.

                           Subclass of AvdModel.

                    """

        class Fap(AvdModel):
            """Subclass of AvdModel."""

            class BufferingEgress(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"profile": {"type": str}}
                profile: Literal["unicast", "balanced"] | None
                """Preferred traffic profile for egress fap buffering."""

                if TYPE_CHECKING:

                    def __init__(self, *, profile: Literal["unicast", "balanced"] | None | UndefinedType = Undefined) -> None:
                        """
                        BufferingEgress.


                        Subclass of AvdModel.

                        Args:
                            profile: Preferred traffic profile for egress fap buffering.

                        """

            class Voq(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"credit_rates_unified": {"type": bool}}
                credit_rates_unified: bool | None
                """Set Unified credit rates for all port speeds."""

                if TYPE_CHECKING:

                    def __init__(self, *, credit_rates_unified: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Voq.


                        Subclass of AvdModel.

                        Args:
                            credit_rates_unified: Set Unified credit rates for all port speeds.

                        """

            _fields: ClassVar[dict] = {"buffering_egress": {"type": BufferingEgress}, "voq": {"type": Voq}}
            buffering_egress: BufferingEgress
            """Subclass of AvdModel."""
            voq: Voq
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, buffering_egress: BufferingEgress | UndefinedType = Undefined, voq: Voq | UndefinedType = Undefined) -> None:
                    """
                    Fap.


                    Subclass of AvdModel.

                    Args:
                        buffering_egress: Subclass of AvdModel.
                        voq: Subclass of AvdModel.

                    """

        _fields: ClassVar[dict] = {"trident": {"type": Trident}, "sand": {"type": Sand}, "sfe": {"type": Sfe}, "fap": {"type": Fap}}
        trident: Trident
        """Subclass of AvdModel."""
        sand: Sand
        """
        Most of the platform sand options are hardware dependent and optional.

        Subclass of AvdModel.
        """
        sfe: Sfe
        """
        Sfe (Software Forwarding Engine) settings.

        Subclass of AvdModel.
        """
        fap: Fap
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                trident: Trident | UndefinedType = Undefined,
                sand: Sand | UndefinedType = Undefined,
                sfe: Sfe | UndefinedType = Undefined,
                fap: Fap | UndefinedType = Undefined,
            ) -> None:
                """
                Platform.


                Subclass of AvdModel.

                Args:
                    trident: Subclass of AvdModel.
                    sand:
                       Most of the platform sand options are hardware dependent and optional.

                       Subclass of AvdModel.
                    sfe:
                       Sfe (Software Forwarding Engine) settings.

                       Subclass of AvdModel.
                    fap: Subclass of AvdModel.

                """

    class Poe(AvdModel):
        """Subclass of AvdModel."""

        class Reboot(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"action": {"type": str}}
            action: Literal["power-off", "maintain"] | None
            """PoE action for interface. By default in EOS, reboot action is set to power-off."""

            if TYPE_CHECKING:

                def __init__(self, *, action: Literal["power-off", "maintain"] | None | UndefinedType = Undefined) -> None:
                    """
                    Reboot.


                    Subclass of AvdModel.

                    Args:
                        action: PoE action for interface. By default in EOS, reboot action is set to power-off.

                    """

        class InterfaceShutdown(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"action": {"type": str}}
            action: Literal["power-off", "maintain"] | None
            """PoE action for interface. By default in EOS, interface shutdown action is set to maintain."""

            if TYPE_CHECKING:

                def __init__(self, *, action: Literal["power-off", "maintain"] | None | UndefinedType = Undefined) -> None:
                    """
                    InterfaceShutdown.


                    Subclass of AvdModel.

                    Args:
                        action: PoE action for interface. By default in EOS, interface shutdown action is set to maintain.

                    """

        _fields: ClassVar[dict] = {"reboot": {"type": Reboot}, "interface_shutdown": {"type": InterfaceShutdown}}
        reboot: Reboot
        """
        Set the global PoE power behavior for PoE ports when the system is rebooted.

        Subclass of AvdModel.
        """
        interface_shutdown: InterfaceShutdown
        """
        Set the global PoE power behavior for PoE ports when ports are admin down.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(self, *, reboot: Reboot | UndefinedType = Undefined, interface_shutdown: InterfaceShutdown | UndefinedType = Undefined) -> None:
                """
                Poe.


                Subclass of AvdModel.

                Args:
                    reboot:
                       Set the global PoE power behavior for PoE ports when the system is rebooted.

                       Subclass of AvdModel.
                    interface_shutdown:
                       Set the global PoE power behavior for PoE ports when ports are admin down.

                       Subclass of AvdModel.

                """

    class PolicyMaps(AvdModel):
        """Subclass of AvdModel."""

        class PbrItem(AvdModel):
            """Subclass of AvdModel."""

            class ClassesItem(AvdModel):
                """Subclass of AvdModel."""

                class Set(AvdModel):
                    """Subclass of AvdModel."""

                    class Nexthop(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"ip_address": {"type": str}, "recursive": {"type": bool}}
                        ip_address: str | None
                        """IPv4 or IPv6 Address."""
                        recursive: bool | None

                        if TYPE_CHECKING:

                            def __init__(
                                self, *, ip_address: str | None | UndefinedType = Undefined, recursive: bool | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                Nexthop.


                                Subclass of AvdModel.

                                Args:
                                    ip_address: IPv4 or IPv6 Address.
                                    recursive: recursive

                                """

                    _fields: ClassVar[dict] = {"nexthop": {"type": Nexthop}}
                    nexthop: Nexthop
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, nexthop: Nexthop | UndefinedType = Undefined) -> None:
                            """
                            Set.


                            Subclass of AvdModel.

                            Args:
                                nexthop: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "index": {"type": int}, "drop": {"type": bool}, "set": {"type": Set}}
                name: str
                """Class Name."""
                index: int | None
                drop: bool | None
                """'drop' and 'set' are mutually exclusive."""
                set: Set
                """
                Set Nexthop
                'drop' and 'set' are mutually exclusive.


                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        index: int | None | UndefinedType = Undefined,
                        drop: bool | None | UndefinedType = Undefined,
                        set: Set | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ClassesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Class Name.
                            index: index
                            drop: 'drop' and 'set' are mutually exclusive.
                            set:
                               Set Nexthop
                               'drop' and 'set' are mutually exclusive.


                               Subclass of AvdModel.

                        """

            class Classes(AvdIndexedList[str, ClassesItem]):
                """Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Classes._item_type = ClassesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "classes": {"type": Classes}}
            name: str
            """Policy-Map Name."""
            classes: Classes
            """Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, classes: Classes | UndefinedType = Undefined) -> None:
                    """
                    PbrItem.


                    Subclass of AvdModel.

                    Args:
                        name: Policy-Map Name.
                        classes: Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`).

                    """

        class Pbr(AvdIndexedList[str, PbrItem]):
            """Subclass of AvdIndexedList with `PbrItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Pbr._item_type = PbrItem

        class QosItem(AvdModel):
            """Subclass of AvdModel."""

            class ClassesItem(AvdModel):
                """Subclass of AvdModel."""

                class Set(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"cos": {"type": int}, "dscp": {"type": str}, "traffic_class": {"type": int}, "drop_precedence": {"type": int}}
                    cos: int | None
                    dscp: str | None
                    traffic_class: int | None
                    drop_precedence: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            cos: int | None | UndefinedType = Undefined,
                            dscp: str | None | UndefinedType = Undefined,
                            traffic_class: int | None | UndefinedType = Undefined,
                            drop_precedence: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Set.


                            Subclass of AvdModel.

                            Args:
                                cos: cos
                                dscp: dscp
                                traffic_class: traffic_class
                                drop_precedence: drop_precedence

                            """

                class Police(AvdModel):
                    """Subclass of AvdModel."""

                    class Action(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"type": {"type": str}, "dscp_value": {"type": str}}
                        type: Literal["dscp", "drop-precedence"] | None
                        """Set action for policed traffic."""
                        dscp_value: str | None
                        """Set when action.type is set to "dscp"."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                type: Literal["dscp", "drop-precedence"] | None | UndefinedType = Undefined,
                                dscp_value: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Action.


                                Subclass of AvdModel.

                                Args:
                                    type: Set action for policed traffic.
                                    dscp_value: Set when action.type is set to "dscp".

                                """

                    _fields: ClassVar[dict] = {
                        "rate": {"type": int},
                        "rate_unit": {"type": str, "default": "bps"},
                        "rate_burst_size": {"type": int},
                        "rate_burst_size_unit": {"type": str, "default": "bytes"},
                        "action": {"type": Action},
                        "higher_rate": {"type": int},
                        "higher_rate_unit": {"type": str, "default": "bps"},
                        "higher_rate_burst_size": {"type": int},
                        "higher_rate_burst_size_unit": {"type": str, "default": "bytes"},
                    }
                    rate: int | None
                    """
                    Specify rate.
                    Range in kbps <8-200000000>.
                    """
                    rate_unit: Literal["bps", "kbps", "mbps", "pps"]
                    """Default value: `"bps"`"""
                    rate_burst_size: int | None
                    """Range in bytes <256-128000000>."""
                    rate_burst_size_unit: Literal["bytes", "kbytes", "mbytes", "packets"]
                    """Default value: `"bytes"`"""
                    action: Action
                    """Subclass of AvdModel."""
                    higher_rate: int | None
                    """
                    Specify higher rate.
                    Range in kbps <lower_rate in kbps + 8 - lower_rate in kbps + 200000000>.
                    """
                    higher_rate_unit: Literal["bps", "kbps", "mbps", "pps"]
                    """Default value: `"bps"`"""
                    higher_rate_burst_size: int | None
                    """Range in bytes <256-128000000>."""
                    higher_rate_burst_size_unit: Literal["bytes", "kbytes", "mbytes", "packets"]
                    """Default value: `"bytes"`"""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            rate: int | None | UndefinedType = Undefined,
                            rate_unit: Literal["bps", "kbps", "mbps", "pps"] | UndefinedType = Undefined,
                            rate_burst_size: int | None | UndefinedType = Undefined,
                            rate_burst_size_unit: Literal["bytes", "kbytes", "mbytes", "packets"] | UndefinedType = Undefined,
                            action: Action | UndefinedType = Undefined,
                            higher_rate: int | None | UndefinedType = Undefined,
                            higher_rate_unit: Literal["bps", "kbps", "mbps", "pps"] | UndefinedType = Undefined,
                            higher_rate_burst_size: int | None | UndefinedType = Undefined,
                            higher_rate_burst_size_unit: Literal["bytes", "kbytes", "mbytes", "packets"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Police.


                            Subclass of AvdModel.

                            Args:
                                rate:
                                   Specify rate.
                                   Range in kbps <8-200000000>.
                                rate_unit: rate_unit
                                rate_burst_size: Range in bytes <256-128000000>.
                                rate_burst_size_unit: rate_burst_size_unit
                                action: Subclass of AvdModel.
                                higher_rate:
                                   Specify higher rate.
                                   Range in kbps <lower_rate in kbps + 8 - lower_rate in kbps + 200000000>.
                                higher_rate_unit: higher_rate_unit
                                higher_rate_burst_size: Range in bytes <256-128000000>.
                                higher_rate_burst_size_unit: higher_rate_burst_size_unit

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "set": {"type": Set}, "police": {"type": Police}}
                name: str
                """Class Name."""
                set: Set
                """Subclass of AvdModel."""
                police: Police
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, name: str | UndefinedType = Undefined, set: Set | UndefinedType = Undefined, police: Police | UndefinedType = Undefined
                    ) -> None:
                        """
                        ClassesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Class Name.
                            set: Subclass of AvdModel.
                            police: Subclass of AvdModel.

                        """

            class Classes(AvdIndexedList[str, ClassesItem]):
                """Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Classes._item_type = ClassesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "classes": {"type": Classes}}
            name: str
            """Policy-Map Name."""
            classes: Classes
            """Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, classes: Classes | UndefinedType = Undefined) -> None:
                    """
                    QosItem.


                    Subclass of AvdModel.

                    Args:
                        name: Policy-Map Name.
                        classes: Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`).

                    """

        class Qos(AvdIndexedList[str, QosItem]):
            """Subclass of AvdIndexedList with `QosItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Qos._item_type = QosItem

        class CoppSystemPolicy(AvdModel):
            """Subclass of AvdModel."""

            class ClassesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "shape": {"type": int}, "bandwidth": {"type": int}, "rate_unit": {"type": str}}
                name: str
                shape: int | None
                """Maximum rate limit."""
                bandwidth: int | None
                """Minimum bandwidth."""
                rate_unit: Literal["pps", "kbps"] | None
                """The `rate_unit` must be defined for `shape` and `bandwidth`."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        shape: int | None | UndefinedType = Undefined,
                        bandwidth: int | None | UndefinedType = Undefined,
                        rate_unit: Literal["pps", "kbps"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ClassesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            shape: Maximum rate limit.
                            bandwidth: Minimum bandwidth.
                            rate_unit: The `rate_unit` must be defined for `shape` and `bandwidth`.

                        """

            class Classes(AvdIndexedList[str, ClassesItem]):
                """Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Classes._item_type = ClassesItem

            _fields: ClassVar[dict] = {"classes": {"type": Classes}}
            classes: Classes
            """Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(self, *, classes: Classes | UndefinedType = Undefined) -> None:
                    """
                    CoppSystemPolicy.


                    Subclass of AvdModel.

                    Args:
                        classes: Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`).

                    """

        _fields: ClassVar[dict] = {"pbr": {"type": Pbr}, "qos": {"type": Qos}, "copp_system_policy": {"type": CoppSystemPolicy}}
        pbr: Pbr
        """
        PBR Policy-Maps.

        Subclass of AvdIndexedList with `PbrItem` items. Primary key is `name` (`str`).
        """
        qos: Qos
        """
        QOS Policy-Maps.

        Subclass of AvdIndexedList with `QosItem` items. Primary key is `name` (`str`).
        """
        copp_system_policy: CoppSystemPolicy
        """
        Control-plane policy configuration.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                pbr: Pbr | UndefinedType = Undefined,
                qos: Qos | UndefinedType = Undefined,
                copp_system_policy: CoppSystemPolicy | UndefinedType = Undefined,
            ) -> None:
                """
                PolicyMaps.


                Subclass of AvdModel.

                Args:
                    pbr:
                       PBR Policy-Maps.

                       Subclass of AvdIndexedList with `PbrItem` items. Primary key is `name` (`str`).
                    qos:
                       QOS Policy-Maps.

                       Subclass of AvdIndexedList with `QosItem` items. Primary key is `name` (`str`).
                    copp_system_policy:
                       Control-plane policy configuration.

                       Subclass of AvdModel.

                """

    class PortChannel(AvdModel):
        """Subclass of AvdModel."""

        class LoadBalanceTridentUdfItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "eth_type": {"type": str},
                "ip_protocol": {"type": str},
                "header": {"type": str},
                "offset": {"type": int},
                "mask": {"type": str},
            }
            eth_type: Literal["ipv4", "ipv6"]
            """Ethernet type in the port channel hash."""
            ip_protocol: str | None
            """
            IP protocol name like - gre, icmp, tcp, udp, mpls-over-gre, sctp.
            IP protocol number within the
            range <0-255>.
            """
            header: Literal["inner_l3", "inner_l4", "outer_l2", "outer_l3", "outer_l4"]
            offset: int
            """Offset starting from selected header in the packet."""
            mask: str | None
            """Mask of the offset. A hex value within the range 0x01-0xFF."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    eth_type: Literal["ipv4", "ipv6"] | UndefinedType = Undefined,
                    ip_protocol: str | None | UndefinedType = Undefined,
                    header: Literal["inner_l3", "inner_l4", "outer_l2", "outer_l3", "outer_l4"] | UndefinedType = Undefined,
                    offset: int | UndefinedType = Undefined,
                    mask: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LoadBalanceTridentUdfItem.


                    Subclass of AvdModel.

                    Args:
                        eth_type: Ethernet type in the port channel hash.
                        ip_protocol:
                           IP protocol name like - gre, icmp, tcp, udp, mpls-over-gre, sctp.
                           IP protocol number within the
                           range <0-255>.
                        header: header
                        offset: Offset starting from selected header in the packet.
                        mask: Mask of the offset. A hex value within the range 0x01-0xFF.

                    """

        class LoadBalanceTridentUdf(AvdList[LoadBalanceTridentUdfItem]):
            """Subclass of AvdList with `LoadBalanceTridentUdfItem` items."""

        LoadBalanceTridentUdf._item_type = LoadBalanceTridentUdfItem

        _fields: ClassVar[dict] = {"load_balance_trident_udf": {"type": LoadBalanceTridentUdf}, "load_balance_sand_profile": {"type": str}}
        load_balance_trident_udf: LoadBalanceTridentUdf
        """
        Trident chip UDF fields load balancing.

        Subclass of AvdList with `LoadBalanceTridentUdfItem` items.
        """
        load_balance_sand_profile: str | None
        """Name of the load-balance profile for sand platform."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                load_balance_trident_udf: LoadBalanceTridentUdf | UndefinedType = Undefined,
                load_balance_sand_profile: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                PortChannel.


                Subclass of AvdModel.

                Args:
                    load_balance_trident_udf:
                       Trident chip UDF fields load balancing.

                       Subclass of AvdList with `LoadBalanceTridentUdfItem` items.
                    load_balance_sand_profile: Name of the load-balance profile for sand platform.

                """

    class PortChannelInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class Logging(AvdModel):
            """Subclass of AvdModel."""

            class Event(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"link_status": {"type": bool}, "storm_control_discards": {"type": bool}}
                link_status: bool | None
                storm_control_discards: bool | None
                """Discards due to storm-control."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, link_status: bool | None | UndefinedType = Undefined, storm_control_discards: bool | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        Event.


                        Subclass of AvdModel.

                        Args:
                            link_status: link_status
                            storm_control_discards: Discards due to storm-control.

                        """

            _fields: ClassVar[dict] = {"event": {"type": Event}}
            event: Event
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, event: Event | UndefinedType = Undefined) -> None:
                    """
                    Logging.


                    Subclass of AvdModel.

                    Args:
                        event: Subclass of AvdModel.

                    """

        class EncapsulationDot1q(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"vlan": {"type": int}, "inner_vlan": {"type": int}}
            vlan: int
            """VLAD ID."""
            inner_vlan: int | None
            """Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS."""

            if TYPE_CHECKING:

                def __init__(self, *, vlan: int | UndefinedType = Undefined, inner_vlan: int | None | UndefinedType = Undefined) -> None:
                    """
                    EncapsulationDot1q.


                    Subclass of AvdModel.

                    Args:
                        vlan: VLAD ID.
                        inner_vlan: Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS.

                    """

        class EncapsulationVlan(AvdModel):
            """Subclass of AvdModel."""

            class Client(AvdModel):
                """Subclass of AvdModel."""

                class Dot1q(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"vlan": {"type": int}, "outer": {"type": int}, "inner": {"type": int}}
                    vlan: int | None
                    """Client VLAN ID."""
                    outer: int | None
                    """Client Outer VLAN ID."""
                    inner: int | None
                    """Client Inner VLAN ID."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            vlan: int | None | UndefinedType = Undefined,
                            outer: int | None | UndefinedType = Undefined,
                            inner: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dot1q.


                            Subclass of AvdModel.

                            Args:
                                vlan: Client VLAN ID.
                                outer: Client Outer VLAN ID.
                                inner: Client Inner VLAN ID.

                            """

                _fields: ClassVar[dict] = {
                    "dot1q": {"type": Dot1q},
                    "unmatched": {"type": bool},
                    "encapsulation": {"type": str},
                    "vlan": {"type": int},
                    "outer_vlan": {"type": int},
                    "inner_vlan": {"type": int},
                    "inner_encapsulation": {"type": str},
                }
                dot1q: Dot1q
                """Subclass of AvdModel."""
                unmatched: bool | None
                encapsulation: Literal["dot1q", "dot1ad", "unmatched", "untagged"] | None
                vlan: int | None
                """Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                outer_vlan: int | None
                """Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_vlan: int | None
                """Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_encapsulation: Literal["dot1q", "dot1ad"] | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dot1q: Dot1q | UndefinedType = Undefined,
                        unmatched: bool | None | UndefinedType = Undefined,
                        encapsulation: Literal["dot1q", "dot1ad", "unmatched", "untagged"] | None | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                        outer_vlan: int | None | UndefinedType = Undefined,
                        inner_vlan: int | None | UndefinedType = Undefined,
                        inner_encapsulation: Literal["dot1q", "dot1ad"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Client.


                        Subclass of AvdModel.

                        Args:
                            dot1q: Subclass of AvdModel.
                            unmatched: unmatched
                            encapsulation: encapsulation
                            vlan: Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                            outer_vlan: Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                            inner_vlan: Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                            inner_encapsulation: inner_encapsulation

                        """

            class Network(AvdModel):
                """Subclass of AvdModel."""

                class Dot1q(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"vlan": {"type": int}, "outer": {"type": int}, "inner": {"type": int}}
                    vlan: int | None
                    """Network VLAN ID."""
                    outer: int | None
                    """Network Outer VLAN ID."""
                    inner: int | None
                    """Network Inner VLAN ID."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            vlan: int | None | UndefinedType = Undefined,
                            outer: int | None | UndefinedType = Undefined,
                            inner: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dot1q.


                            Subclass of AvdModel.

                            Args:
                                vlan: Network VLAN ID.
                                outer: Network Outer VLAN ID.
                                inner: Network Inner VLAN ID.

                            """

                _fields: ClassVar[dict] = {
                    "dot1q": {"type": Dot1q},
                    "client": {"type": bool},
                    "encapsulation": {"type": str},
                    "vlan": {"type": int},
                    "outer_vlan": {"type": int},
                    "inner_vlan": {"type": int},
                    "inner_encapsulation": {"type": str},
                }
                dot1q: Dot1q
                """Subclass of AvdModel."""
                client: bool | None
                encapsulation: Literal["dot1q", "dot1ad", "client", "client inner", "untagged"] | None
                """
                `untagged` (no encapsulation) is applicable for `untagged` client only.
                `client` and `client inner`
                (retain client encapsulation) is not applicable for `untagged` client.
                """
                vlan: int | None
                """Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                outer_vlan: int | None
                """Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_vlan: int | None
                """Network inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_encapsulation: Literal["dot1q", "dot1ad"] | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dot1q: Dot1q | UndefinedType = Undefined,
                        client: bool | None | UndefinedType = Undefined,
                        encapsulation: Literal["dot1q", "dot1ad", "client", "client inner", "untagged"] | None | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                        outer_vlan: int | None | UndefinedType = Undefined,
                        inner_vlan: int | None | UndefinedType = Undefined,
                        inner_encapsulation: Literal["dot1q", "dot1ad"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Network.


                        Subclass of AvdModel.

                        Args:
                            dot1q: Subclass of AvdModel.
                            client: client
                            encapsulation:
                               `untagged` (no encapsulation) is applicable for `untagged` client only.
                               `client` and `client inner`
                               (retain client encapsulation) is not applicable for `untagged` client.
                            vlan: Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                            outer_vlan: Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                            inner_vlan: Network inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                            inner_encapsulation: inner_encapsulation

                        """

            _fields: ClassVar[dict] = {"client": {"type": Client}, "network": {"type": Network}}
            client: Client
            """Subclass of AvdModel."""
            network: Network
            """
            Network encapsulation are all optional, and skipped if using client unmatched.

            Subclass of
            AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(self, *, client: Client | UndefinedType = Undefined, network: Network | UndefinedType = Undefined) -> None:
                    """
                    EncapsulationVlan.


                    Subclass of AvdModel.

                    Args:
                        client: Subclass of AvdModel.
                        network:
                           Network encapsulation are all optional, and skipped if using client unmatched.

                           Subclass of
                           AvdModel.

                    """

        class LinkTrackingGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "direction": {"type": str}}
            name: str
            """Group name."""
            direction: Literal["upstream", "downstream"] | None

            if TYPE_CHECKING:

                def __init__(
                    self, *, name: str | UndefinedType = Undefined, direction: Literal["upstream", "downstream"] | None | UndefinedType = Undefined
                ) -> None:
                    """
                    LinkTrackingGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Group name.
                        direction: direction

                    """

        class LinkTrackingGroups(AvdIndexedList[str, LinkTrackingGroupsItem]):
            """Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        LinkTrackingGroups._item_type = LinkTrackingGroupsItem

        class LinkTracking(AvdModel):
            """Subclass of AvdModel."""

            class Groups(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Groups._item_type = str

            _fields: ClassVar[dict] = {"direction": {"type": str}, "groups": {"type": Groups}}
            direction: Literal["upstream", "downstream"] | None
            groups: Groups
            """
            Link state group(s) an interface belongs to.

            Subclass of AvdList with `str` items.
            """

            if TYPE_CHECKING:

                def __init__(
                    self, *, direction: Literal["upstream", "downstream"] | None | UndefinedType = Undefined, groups: Groups | UndefinedType = Undefined
                ) -> None:
                    """
                    LinkTracking.


                    Subclass of AvdModel.

                    Args:
                        direction: direction
                        groups:
                           Link state group(s) an interface belongs to.

                           Subclass of AvdList with `str` items.

                    """

        class Phone(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"trunk": {"type": str}, "vlan": {"type": int}}
            trunk: Literal["tagged", "untagged"] | None
            vlan: int | None

            if TYPE_CHECKING:

                def __init__(
                    self, *, trunk: Literal["tagged", "untagged"] | None | UndefinedType = Undefined, vlan: int | None | UndefinedType = Undefined
                ) -> None:
                    """
                    Phone.


                    Subclass of AvdModel.

                    Args:
                        trunk: trunk
                        vlan: vlan

                    """

        class L2Protocol(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"encapsulation_dot1q_vlan": {"type": int}, "forwarding_profile": {"type": str}}
            encapsulation_dot1q_vlan: int | None
            """Vlan tag to configure on sub-interface."""
            forwarding_profile: str | None
            """L2 protocol forwarding profile."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined, forwarding_profile: str | None | UndefinedType = Undefined
                ) -> None:
                    """
                    L2Protocol.


                    Subclass of AvdModel.

                    Args:
                        encapsulation_dot1q_vlan: Vlan tag to configure on sub-interface.
                        forwarding_profile: L2 protocol forwarding profile.

                    """

        class TrunkGroups(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        TrunkGroups._item_type = str

        class Qos(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"trust": {"type": str}, "dscp": {"type": int}, "cos": {"type": int}}
            trust: Literal["dscp", "cos", "disabled"] | None
            dscp: int | None
            """DSCP value."""
            cos: int | None
            """COS value."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    trust: Literal["dscp", "cos", "disabled"] | None | UndefinedType = Undefined,
                    dscp: int | None | UndefinedType = Undefined,
                    cos: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Qos.


                    Subclass of AvdModel.

                    Args:
                        trust: trust
                        dscp: DSCP value.
                        cos: COS value.

                    """

        class Bfd(AvdModel):
            """Subclass of AvdModel."""

            class PerLink(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rfc_7130": {"type": bool}}
                enabled: bool | None
                rfc_7130: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, rfc_7130: bool | None | UndefinedType = Undefined) -> None:
                        """
                        PerLink.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            rfc_7130: rfc_7130

                        """

            _fields: ClassVar[dict] = {
                "echo": {"type": bool},
                "interval": {"type": int},
                "min_rx": {"type": int},
                "multiplier": {"type": int},
                "neighbor": {"type": str},
                "per_link": {"type": PerLink},
            }
            echo: bool | None
            interval: int | None
            """Interval in milliseconds."""
            min_rx: int | None
            """Rate in milliseconds."""
            multiplier: int | None
            neighbor: str | None
            """
            IPv4 or IPv6 address. When the Port-channel is a L2 interface, a local L3 BFD address
            (router_bfd.local_address) has to be defined globally on the switch.
            """
            per_link: PerLink
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    echo: bool | None | UndefinedType = Undefined,
                    interval: int | None | UndefinedType = Undefined,
                    min_rx: int | None | UndefinedType = Undefined,
                    multiplier: int | None | UndefinedType = Undefined,
                    neighbor: str | None | UndefinedType = Undefined,
                    per_link: PerLink | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bfd.


                    Subclass of AvdModel.

                    Args:
                        echo: echo
                        interval: Interval in milliseconds.
                        min_rx: Rate in milliseconds.
                        multiplier: multiplier
                        neighbor:
                           IPv4 or IPv6 address. When the Port-channel is a L2 interface, a local L3 BFD address
                           (router_bfd.local_address) has to be defined globally on the switch.
                        per_link: Subclass of AvdModel.

                    """

        class ServicePolicy(AvdModel):
            """Subclass of AvdModel."""

            class Pbr(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"input": {"type": str}}
                input: str | None
                """Policy Based Routing Policy-map name."""

                if TYPE_CHECKING:

                    def __init__(self, *, input: str | None | UndefinedType = Undefined) -> None:
                        """
                        Pbr.


                        Subclass of AvdModel.

                        Args:
                            input: Policy Based Routing Policy-map name.

                        """

            class Qos(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"input": {"type": str}}
                input: str
                """Quality of Service Policy-map name."""

                if TYPE_CHECKING:

                    def __init__(self, *, input: str | UndefinedType = Undefined) -> None:
                        """
                        Qos.


                        Subclass of AvdModel.

                        Args:
                            input: Quality of Service Policy-map name.

                        """

            _fields: ClassVar[dict] = {"pbr": {"type": Pbr}, "qos": {"type": Qos}}
            pbr: Pbr
            """Subclass of AvdModel."""
            qos: Qos
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, pbr: Pbr | UndefinedType = Undefined, qos: Qos | UndefinedType = Undefined) -> None:
                    """
                    ServicePolicy.


                    Subclass of AvdModel.

                    Args:
                        pbr: Subclass of AvdModel.
                        qos: Subclass of AvdModel.

                    """

        class Mpls(AvdModel):
            """Subclass of AvdModel."""

            class Ldp(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interface": {"type": bool}, "igp_sync": {"type": bool}}
                interface: bool | None
                igp_sync: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, interface: bool | None | UndefinedType = Undefined, igp_sync: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Ldp.


                        Subclass of AvdModel.

                        Args:
                            interface: interface
                            igp_sync: igp_sync

                        """

            _fields: ClassVar[dict] = {"ip": {"type": bool}, "ldp": {"type": Ldp}}
            ip: bool | None
            ldp: Ldp
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, ip: bool | None | UndefinedType = Undefined, ldp: Ldp | UndefinedType = Undefined) -> None:
                    """
                    Mpls.


                    Subclass of AvdModel.

                    Args:
                        ip: ip
                        ldp: Subclass of AvdModel.

                    """

        class VlanTranslationsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"field_from": {"type": str}, "to": {"type": int}, "direction": {"type": str, "default": "both"}}
            _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
            _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
            field_from: str | None
            """List of vlans as string (only one vlan if direction is "both")."""
            to: int | None
            """VLAN ID."""
            direction: Literal["in", "out", "both"]
            """Default value: `"both"`"""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    field_from: str | None | UndefinedType = Undefined,
                    to: int | None | UndefinedType = Undefined,
                    direction: Literal["in", "out", "both"] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VlanTranslationsItem.


                    Subclass of AvdModel.

                    Args:
                        field_from: List of vlans as string (only one vlan if direction is "both").
                        to: VLAN ID.
                        direction: direction

                    """

        class VlanTranslations(AvdList[VlanTranslationsItem]):
            """Subclass of AvdList with `VlanTranslationsItem` items."""

        VlanTranslations._item_type = VlanTranslationsItem

        class Shape(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"rate": {"type": str}}
            rate: str | None
            """
            Rate in kbps, pps or percent.
            Supported options are platform dependent.
            Examples:
            - "5000 kbps"
            -
            "1000 pps"
            - "20 percent"
            """

            if TYPE_CHECKING:

                def __init__(self, *, rate: str | None | UndefinedType = Undefined) -> None:
                    """
                    Shape.


                    Subclass of AvdModel.

                    Args:
                        rate:
                           Rate in kbps, pps or percent.
                           Supported options are platform dependent.
                           Examples:  # fmt: skip
                           - "5000 kbps"
                           -
                           "1000 pps"
                           - "20 percent"

                    """

        class StormControl(AvdModel):
            """Subclass of AvdModel."""

            class All(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """

                if TYPE_CHECKING:

                    def __init__(self, *, level: str | None | UndefinedType = Undefined, unit: Literal["percent", "pps"] | UndefinedType = Undefined) -> None:
                        """
                        All.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.

                        """

            class Broadcast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """

                if TYPE_CHECKING:

                    def __init__(self, *, level: str | None | UndefinedType = Undefined, unit: Literal["percent", "pps"] | UndefinedType = Undefined) -> None:
                        """
                        Broadcast.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.

                        """

            class Multicast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """

                if TYPE_CHECKING:

                    def __init__(self, *, level: str | None | UndefinedType = Undefined, unit: Literal["percent", "pps"] | UndefinedType = Undefined) -> None:
                        """
                        Multicast.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.

                        """

            class UnknownUnicast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """

                if TYPE_CHECKING:

                    def __init__(self, *, level: str | None | UndefinedType = Undefined, unit: Literal["percent", "pps"] | UndefinedType = Undefined) -> None:
                        """
                        UnknownUnicast.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.

                        """

            _fields: ClassVar[dict] = {
                "all": {"type": All},
                "broadcast": {"type": Broadcast},
                "multicast": {"type": Multicast},
                "unknown_unicast": {"type": UnknownUnicast},
            }
            all: All
            """Subclass of AvdModel."""
            broadcast: Broadcast
            """Subclass of AvdModel."""
            multicast: Multicast
            """Subclass of AvdModel."""
            unknown_unicast: UnknownUnicast
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    all: All | UndefinedType = Undefined,
                    broadcast: Broadcast | UndefinedType = Undefined,
                    multicast: Multicast | UndefinedType = Undefined,
                    unknown_unicast: UnknownUnicast | UndefinedType = Undefined,
                ) -> None:
                    """
                    StormControl.


                    Subclass of AvdModel.

                    Args:
                        all: Subclass of AvdModel.
                        broadcast: Subclass of AvdModel.
                        multicast: Subclass of AvdModel.
                        unknown_unicast: Subclass of AvdModel.

                    """

        class IsisAuthentication(AvdModel):
            """Subclass of AvdModel."""

            class Both(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}}
                    key_id: int

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Both.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.

                        """

            class Level1(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}}
                    key_id: int

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level1.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.

                        """

            class Level2(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}}
                    key_id: int

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level2.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.

                        """

            _fields: ClassVar[dict] = {"both": {"type": Both}, "level_1": {"type": Level1}, "level_2": {"type": Level2}}
            both: Both
            """
            Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
            'level_2' settings.

            Subclass of AvdModel.
            """
            level_1: Level1
            """
            Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """
            level_2: Level2
            """
            Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self, *, both: Both | UndefinedType = Undefined, level_1: Level1 | UndefinedType = Undefined, level_2: Level2 | UndefinedType = Undefined
                ) -> None:
                    """
                    IsisAuthentication.


                    Subclass of AvdModel.

                    Args:
                        both:
                           Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
                           'level_2' settings.

                           Subclass of AvdModel.
                        level_1:
                           Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.
                        level_2:
                           Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.

                    """

        class TrafficPolicy(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"input": {"type": str}, "output": {"type": str}}
            input: str | None
            """Ingress traffic policy."""
            output: str | None
            """Egress traffic policy."""

            if TYPE_CHECKING:

                def __init__(self, *, input: str | None | UndefinedType = Undefined, output: str | None | UndefinedType = Undefined) -> None:
                    """
                    TrafficPolicy.


                    Subclass of AvdModel.

                    Args:
                        input: Ingress traffic policy.
                        output: Egress traffic policy.

                    """

        class EvpnEthernetSegment(AvdModel):
            """Subclass of AvdModel."""

            class DesignatedForwarderElection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "algorithm": {"type": str},
                    "preference_value": {"type": int},
                    "dont_preempt": {"type": bool, "default": False},
                    "hold_time": {"type": int},
                    "subsequent_hold_time": {"type": int},
                    "candidate_reachability_required": {"type": bool},
                }
                algorithm: Literal["modulus", "preference"] | None
                preference_value: int | None
                """Preference_value is only used when "algorithm" is "preference"."""
                dont_preempt: bool
                """
                Dont_preempt is only used when "algorithm" is "preference".

                Default value: `False`
                """
                hold_time: int | None
                subsequent_hold_time: int | None
                candidate_reachability_required: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        algorithm: Literal["modulus", "preference"] | None | UndefinedType = Undefined,
                        preference_value: int | None | UndefinedType = Undefined,
                        dont_preempt: bool | UndefinedType = Undefined,
                        hold_time: int | None | UndefinedType = Undefined,
                        subsequent_hold_time: int | None | UndefinedType = Undefined,
                        candidate_reachability_required: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DesignatedForwarderElection.


                        Subclass of AvdModel.

                        Args:
                            algorithm: algorithm
                            preference_value: Preference_value is only used when "algorithm" is "preference".
                            dont_preempt: Dont_preempt is only used when "algorithm" is "preference".
                            hold_time: hold_time
                            subsequent_hold_time: subsequent_hold_time
                            candidate_reachability_required: candidate_reachability_required

                        """

            class Mpls(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"shared_index": {"type": int}, "tunnel_flood_filter_time": {"type": int}}
                shared_index: int | None
                tunnel_flood_filter_time: int | None

                if TYPE_CHECKING:

                    def __init__(
                        self, *, shared_index: int | None | UndefinedType = Undefined, tunnel_flood_filter_time: int | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        Mpls.


                        Subclass of AvdModel.

                        Args:
                            shared_index: shared_index
                            tunnel_flood_filter_time: tunnel_flood_filter_time

                        """

            _fields: ClassVar[dict] = {
                "identifier": {"type": str},
                "redundancy": {"type": str},
                "designated_forwarder_election": {"type": DesignatedForwarderElection},
                "mpls": {"type": Mpls},
                "route_target": {"type": str},
            }
            identifier: str | None
            """EVPN Ethernet Segment Identifier (Type 1 format)."""
            redundancy: Literal["all-active", "single-active"] | None
            designated_forwarder_election: DesignatedForwarderElection
            """Subclass of AvdModel."""
            mpls: Mpls
            """Subclass of AvdModel."""
            route_target: str | None
            """EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    identifier: str | None | UndefinedType = Undefined,
                    redundancy: Literal["all-active", "single-active"] | None | UndefinedType = Undefined,
                    designated_forwarder_election: DesignatedForwarderElection | UndefinedType = Undefined,
                    mpls: Mpls | UndefinedType = Undefined,
                    route_target: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    EvpnEthernetSegment.


                    Subclass of AvdModel.

                    Args:
                        identifier: EVPN Ethernet Segment Identifier (Type 1 format).
                        redundancy: redundancy
                        designated_forwarder_election: Subclass of AvdModel.
                        mpls: Subclass of AvdModel.
                        route_target: EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx.

                    """

        class Ptp(AvdModel):
            """Subclass of AvdModel."""

            class Announce(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "timeout": {"type": int}}
                interval: int | None
                timeout: int | None

                if TYPE_CHECKING:

                    def __init__(self, *, interval: int | None | UndefinedType = Undefined, timeout: int | None | UndefinedType = Undefined) -> None:
                        """
                        Announce.


                        Subclass of AvdModel.

                        Args:
                            interval: interval
                            timeout: timeout

                        """

            class Profile(AvdModel):
                """Subclass of AvdModel."""

                class G82751(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"destination_mac_address": {"type": str}}
                    destination_mac_address: Literal["forwardable", "non-forwardable"] | None

                    if TYPE_CHECKING:

                        def __init__(self, *, destination_mac_address: Literal["forwardable", "non-forwardable"] | None | UndefinedType = Undefined) -> None:
                            """
                            G82751.


                            Subclass of AvdModel.

                            Args:
                                destination_mac_address: destination_mac_address

                            """

                _fields: ClassVar[dict] = {"g8275_1": {"type": G82751}}
                g8275_1: G82751
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, g8275_1: G82751 | UndefinedType = Undefined) -> None:
                        """
                        Profile.


                        Subclass of AvdModel.

                        Args:
                            g8275_1: Subclass of AvdModel.

                        """

            class SyncMessage(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}}
                interval: int | None

                if TYPE_CHECKING:

                    def __init__(self, *, interval: int | None | UndefinedType = Undefined) -> None:
                        """
                        SyncMessage.


                        Subclass of AvdModel.

                        Args:
                            interval: interval

                        """

            _fields: ClassVar[dict] = {
                "enable": {"type": bool},
                "announce": {"type": Announce},
                "delay_req": {"type": int},
                "delay_mechanism": {"type": str},
                "profile": {"type": Profile},
                "sync_message": {"type": SyncMessage},
                "role": {"type": str},
                "vlan": {"type": str},
                "transport": {"type": str},
                "mpass": {"type": bool},
            }
            enable: bool | None
            announce: Announce
            """Subclass of AvdModel."""
            delay_req: int | None
            delay_mechanism: Literal["e2e", "p2p"] | None
            profile: Profile
            """Subclass of AvdModel."""
            sync_message: SyncMessage
            """Subclass of AvdModel."""
            role: Literal["master", "dynamic"] | None
            vlan: str | None
            """VLAN can be 'all' or list of vlans as string."""
            transport: Literal["ipv4", "ipv6", "layer2"] | None
            mpass: bool | None
            """
            When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
            logical device.
            Arista PTP enabled devices always place PTP messages on the same physical link
            within the port-channel.
            Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
            devices.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enable: bool | None | UndefinedType = Undefined,
                    announce: Announce | UndefinedType = Undefined,
                    delay_req: int | None | UndefinedType = Undefined,
                    delay_mechanism: Literal["e2e", "p2p"] | None | UndefinedType = Undefined,
                    profile: Profile | UndefinedType = Undefined,
                    sync_message: SyncMessage | UndefinedType = Undefined,
                    role: Literal["master", "dynamic"] | None | UndefinedType = Undefined,
                    vlan: str | None | UndefinedType = Undefined,
                    transport: Literal["ipv4", "ipv6", "layer2"] | None | UndefinedType = Undefined,
                    mpass: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ptp.


                    Subclass of AvdModel.

                    Args:
                        enable: enable
                        announce: Subclass of AvdModel.
                        delay_req: delay_req
                        delay_mechanism: delay_mechanism
                        profile: Subclass of AvdModel.
                        sync_message: Subclass of AvdModel.
                        role: role
                        vlan: VLAN can be 'all' or list of vlans as string.
                        transport: transport
                        mpass:
                           When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
                           logical device.
                           Arista PTP enabled devices always place PTP messages on the same physical link
                           within the port-channel.
                           Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
                           devices.

                    """

        class IpNat(AvdModel):
            """Subclass of AvdModel."""

            class Destination(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"access_list": {"type": str}, "comment": {"type": str}, "pool_name": {"type": str}, "priority": {"type": int}}
                    access_list: str
                    comment: str | None
                    pool_name: str
                    priority: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            pool_name: str | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                pool_name: pool_name
                                priority: priority

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, dynamic: Dynamic | UndefinedType = Undefined, static: Static | UndefinedType = Undefined) -> None:
                        """
                        Destination.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.

                        """

            class Source(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "nat_type": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                    }
                    access_list: str
                    comment: str | None
                    nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"]
                    pool_name: str | None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"] | UndefinedType = Undefined,
                            pool_name: str | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                nat_type: nat_type
                                pool_name:
                                   required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                                   ignored if 'nat_type' is
                                   overload.
                                priority: priority

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, dynamic: Dynamic | UndefinedType = Undefined, static: Static | UndefinedType = Undefined) -> None:
                        """
                        Source.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.

                        """

            _fields: ClassVar[dict] = {"service_profile": {"type": str}, "destination": {"type": Destination}, "source": {"type": Source}}
            service_profile: str | None
            """NAT interface profile."""
            destination: Destination
            """Subclass of AvdModel."""
            source: Source
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    service_profile: str | None | UndefinedType = Undefined,
                    destination: Destination | UndefinedType = Undefined,
                    source: Source | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpNat.


                    Subclass of AvdModel.

                    Args:
                        service_profile: NAT interface profile.
                        destination: Subclass of AvdModel.
                        source: Subclass of AvdModel.

                    """

        class Ipv6NdPrefixesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "ipv6_prefix": {"type": str},
                "valid_lifetime": {"type": str},
                "preferred_lifetime": {"type": str},
                "no_autoconfig_flag": {"type": bool},
            }
            ipv6_prefix: str
            valid_lifetime: str | None
            """Infinite or lifetime in seconds."""
            preferred_lifetime: str | None
            """Infinite or lifetime in seconds."""
            no_autoconfig_flag: bool | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv6_prefix: str | UndefinedType = Undefined,
                    valid_lifetime: str | None | UndefinedType = Undefined,
                    preferred_lifetime: str | None | UndefinedType = Undefined,
                    no_autoconfig_flag: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6NdPrefixesItem.


                    Subclass of AvdModel.

                    Args:
                        ipv6_prefix: ipv6_prefix
                        valid_lifetime: Infinite or lifetime in seconds.
                        preferred_lifetime: Infinite or lifetime in seconds.
                        no_autoconfig_flag: no_autoconfig_flag

                    """

        class Ipv6NdPrefixes(AvdIndexedList[str, Ipv6NdPrefixesItem]):
            """Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`)."""

            _primary_key: ClassVar[str] = "ipv6_prefix"

        Ipv6NdPrefixes._item_type = Ipv6NdPrefixesItem

        class Pim(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class Hello(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"count": {"type": str}, "interval": {"type": int}}
                    count: str | None
                    """Number of missed hellos after which the neighbor expires. Range <1.5-65535>."""
                    interval: int | None
                    """PIM hello interval in seconds."""

                    if TYPE_CHECKING:

                        def __init__(self, *, count: str | None | UndefinedType = Undefined, interval: int | None | UndefinedType = Undefined) -> None:
                            """
                            Hello.


                            Subclass of AvdModel.

                            Args:
                                count: Number of missed hellos after which the neighbor expires. Range <1.5-65535>.
                                interval: PIM hello interval in seconds.

                            """

                _fields: ClassVar[dict] = {
                    "border_router": {"type": bool},
                    "dr_priority": {"type": int},
                    "sparse_mode": {"type": bool},
                    "bfd": {"type": bool},
                    "bidirectional": {"type": bool},
                    "neighbor_filter": {"type": str},
                    "hello": {"type": Hello},
                }
                border_router: bool | None
                """Configure PIM border router. EOS default is false."""
                dr_priority: int | None
                sparse_mode: bool | None
                bfd: bool | None
                """Set the default for whether Bidirectional Forwarding Detection is enabled for PIM."""
                bidirectional: bool | None
                neighbor_filter: str | None
                """Standard access list name."""
                hello: Hello
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        border_router: bool | None | UndefinedType = Undefined,
                        dr_priority: int | None | UndefinedType = Undefined,
                        sparse_mode: bool | None | UndefinedType = Undefined,
                        bfd: bool | None | UndefinedType = Undefined,
                        bidirectional: bool | None | UndefinedType = Undefined,
                        neighbor_filter: str | None | UndefinedType = Undefined,
                        hello: Hello | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            border_router: Configure PIM border router. EOS default is false.
                            dr_priority: dr_priority
                            sparse_mode: sparse_mode
                            bfd: Set the default for whether Bidirectional Forwarding Detection is enabled for PIM.
                            bidirectional: bidirectional
                            neighbor_filter: Standard access list name.
                            hello: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}}
            ipv4: Ipv4
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, ipv4: Ipv4 | UndefinedType = Undefined) -> None:
                    """
                    Pim.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Subclass of AvdModel.

                    """

        class OspfMessageDigestKeysItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": int}, "hash_algorithm": {"type": str}, "key": {"type": str}}
            id: int
            hash_algorithm: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None
            key: str | None
            """Encrypted password."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    hash_algorithm: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    OspfMessageDigestKeysItem.


                    Subclass of AvdModel.

                    Args:
                        id: id
                        hash_algorithm: hash_algorithm
                        key: Encrypted password.

                    """

        class OspfMessageDigestKeys(AvdIndexedList[int, OspfMessageDigestKeysItem]):
            """Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        OspfMessageDigestKeys._item_type = OspfMessageDigestKeysItem

        class FlowTracker(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sampled": {"type": str}, "hardware": {"type": str}}
            sampled: str | None
            """Sampled flow tracker name."""
            hardware: str | None
            """Hardware flow tracker name."""

            if TYPE_CHECKING:

                def __init__(self, *, sampled: str | None | UndefinedType = Undefined, hardware: str | None | UndefinedType = Undefined) -> None:
                    """
                    FlowTracker.


                    Subclass of AvdModel.

                    Args:
                        sampled: Sampled flow tracker name.
                        hardware: Hardware flow tracker name.

                    """

        class Bgp(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"session_tracker": {"type": str}}
            session_tracker: str | None
            """Name of session tracker."""

            if TYPE_CHECKING:

                def __init__(self, *, session_tracker: str | None | UndefinedType = Undefined) -> None:
                    """
                    Bgp.


                    Subclass of AvdModel.

                    Args:
                        session_tracker: Name of session tracker.

                    """

        class IpIgmpHostProxy(AvdModel):
            """Subclass of AvdModel."""

            class GroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class ExcludeItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}}
                    source: str

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | UndefinedType = Undefined) -> None:
                            """
                            ExcludeItem.


                            Subclass of AvdModel.

                            Args:
                                source: source

                            """

                class Exclude(AvdIndexedList[str, ExcludeItem]):
                    """Subclass of AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`)."""

                    _primary_key: ClassVar[str] = "source"

                Exclude._item_type = ExcludeItem

                class IncludeItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}}
                    source: str

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | UndefinedType = Undefined) -> None:
                            """
                            IncludeItem.


                            Subclass of AvdModel.

                            Args:
                                source: source

                            """

                class Include(AvdIndexedList[str, IncludeItem]):
                    """Subclass of AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`)."""

                    _primary_key: ClassVar[str] = "source"

                Include._item_type = IncludeItem

                _fields: ClassVar[dict] = {"group": {"type": str}, "exclude": {"type": Exclude}, "include": {"type": Include}}
                group: str
                """Multicast Address."""
                exclude: Exclude
                """
                The same source must not be present both in `exclude` and `include` list.

                Subclass of
                AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`).
                """
                include: Include
                """
                The same source must not be present both in `exclude` and `include` list.

                Subclass of
                AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`).
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        group: str | UndefinedType = Undefined,
                        exclude: Exclude | UndefinedType = Undefined,
                        include: Include | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GroupsItem.


                        Subclass of AvdModel.

                        Args:
                            group: Multicast Address.
                            exclude:
                               The same source must not be present both in `exclude` and `include` list.

                               Subclass of
                               AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`).
                            include:
                               The same source must not be present both in `exclude` and `include` list.

                               Subclass of
                               AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`).

                        """

            class Groups(AvdIndexedList[str, GroupsItem]):
                """Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`)."""

                _primary_key: ClassVar[str] = "group"

            Groups._item_type = GroupsItem

            class AccessListsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}}
                name: str

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined) -> None:
                        """
                        AccessListsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name

                        """

            class AccessLists(AvdIndexedList[str, AccessListsItem]):
                """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            AccessLists._item_type = AccessListsItem

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "groups": {"type": Groups},
                "report_interval": {"type": int},
                "access_lists": {"type": AccessLists},
                "version": {"type": int},
            }
            enabled: bool | None
            groups: Groups
            """Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`)."""
            report_interval: int | None
            """Time interval between unsolicited reports."""
            access_lists: AccessLists
            """
            Non-standard Access List name.

            Subclass of AvdIndexedList with `AccessListsItem` items. Primary key
            is `name` (`str`).
            """
            version: int | None
            """IGMP version on IGMP host-proxy interface."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    groups: Groups | UndefinedType = Undefined,
                    report_interval: int | None | UndefinedType = Undefined,
                    access_lists: AccessLists | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpIgmpHostProxy.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        groups: Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`).
                        report_interval: Time interval between unsolicited reports.
                        access_lists:
                           Non-standard Access List name.

                           Subclass of AvdIndexedList with `AccessListsItem` items. Primary key
                           is `name` (`str`).
                        version: IGMP version on IGMP host-proxy interface.

                    """

        class Sflow(AvdModel):
            """Subclass of AvdModel."""

            class Egress(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enable": {"type": bool}, "unmodified_enable": {"type": bool}}
                enable: bool | None
                unmodified_enable: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, enable: bool | None | UndefinedType = Undefined, unmodified_enable: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Egress.


                        Subclass of AvdModel.

                        Args:
                            enable: enable
                            unmodified_enable: unmodified_enable

                        """

            _fields: ClassVar[dict] = {"enable": {"type": bool}, "egress": {"type": Egress}}
            enable: bool | None
            egress: Egress
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, enable: bool | None | UndefinedType = Undefined, egress: Egress | UndefinedType = Undefined) -> None:
                    """
                    Sflow.


                    Subclass of AvdModel.

                    Args:
                        enable: enable
                        egress: Subclass of AvdModel.

                    """

        class VrrpIdsItem(AvdModel):
            """Subclass of AvdModel."""

            class Advertisement(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}}
                interval: int | None
                """Interval in seconds."""

                if TYPE_CHECKING:

                    def __init__(self, *, interval: int | None | UndefinedType = Undefined) -> None:
                        """
                        Advertisement.


                        Subclass of AvdModel.

                        Args:
                            interval: Interval in seconds.

                        """

            class Preempt(AvdModel):
                """Subclass of AvdModel."""

                class Delay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"minimum": {"type": int}, "reload": {"type": int}}
                    minimum: int | None
                    """Minimum preempt delay in seconds."""
                    reload: int | None
                    """Reload preempt delay in seconds."""

                    if TYPE_CHECKING:

                        def __init__(self, *, minimum: int | None | UndefinedType = Undefined, reload: int | None | UndefinedType = Undefined) -> None:
                            """
                            Delay.


                            Subclass of AvdModel.

                            Args:
                                minimum: Minimum preempt delay in seconds.
                                reload: Reload preempt delay in seconds.

                            """

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "delay": {"type": Delay}}
                enabled: bool
                delay: Delay
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | UndefinedType = Undefined, delay: Delay | UndefinedType = Undefined) -> None:
                        """
                        Preempt.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            delay: Subclass of AvdModel.

                        """

            class Timers(AvdModel):
                """Subclass of AvdModel."""

                class Delay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"reload": {"type": int}}
                    reload: int | None
                    """Delay after reload in seconds."""

                    if TYPE_CHECKING:

                        def __init__(self, *, reload: int | None | UndefinedType = Undefined) -> None:
                            """
                            Delay.


                            Subclass of AvdModel.

                            Args:
                                reload: Delay after reload in seconds.

                            """

                _fields: ClassVar[dict] = {"delay": {"type": Delay}}
                delay: Delay
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, delay: Delay | UndefinedType = Undefined) -> None:
                        """
                        Timers.


                        Subclass of AvdModel.

                        Args:
                            delay: Subclass of AvdModel.

                        """

            class TrackedObjectItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "decrement": {"type": int}, "shutdown": {"type": bool}}
                name: str
                """Tracked object name."""
                decrement: int | None
                """Decrement VRRP priority by 1-254."""
                shutdown: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        decrement: int | None | UndefinedType = Undefined,
                        shutdown: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrackedObjectItem.


                        Subclass of AvdModel.

                        Args:
                            name: Tracked object name.
                            decrement: Decrement VRRP priority by 1-254.
                            shutdown: shutdown

                        """

            class TrackedObject(AvdIndexedList[str, TrackedObjectItem]):
                """Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            TrackedObject._item_type = TrackedObjectItem

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class SecondaryAddresses(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                SecondaryAddresses._item_type = str

                _fields: ClassVar[dict] = {"address": {"type": str}, "secondary_addresses": {"type": SecondaryAddresses}, "version": {"type": int}}
                address: str
                """Virtual IPv4 address."""
                secondary_addresses: SecondaryAddresses
                """
                Additional VRRP IPv4 addresses.

                Subclass of AvdList with `str` items.
                """
                version: Literal[2, 3] | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        address: str | UndefinedType = Undefined,
                        secondary_addresses: SecondaryAddresses | UndefinedType = Undefined,
                        version: Literal[2, 3] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            address: Virtual IPv4 address.
                            secondary_addresses:
                               Additional VRRP IPv4 addresses.

                               Subclass of AvdList with `str` items.
                            version: version

                        """

            class Ipv6(AvdModel):
                """Subclass of AvdModel."""

                class Addresses(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Addresses._item_type = str

                _fields: ClassVar[dict] = {"address": {"type": str}, "addresses": {"type": Addresses}}
                address: str | None
                """Virtual IPv6 address."""
                addresses: Addresses
                """
                Virtual IPv6 addresses.

                Subclass of AvdList with `str` items.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, address: str | None | UndefinedType = Undefined, addresses: Addresses | UndefinedType = Undefined) -> None:
                        """
                        Ipv6.


                        Subclass of AvdModel.

                        Args:
                            address: Virtual IPv6 address.
                            addresses:
                               Virtual IPv6 addresses.

                               Subclass of AvdList with `str` items.

                        """

            class PeerAuthentication(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"mode": {"type": str}, "key": {"type": str}, "key_type": {"type": str}}
                mode: Literal["text", "ietf-md5"]
                """Authentication mode."""
                key: str
                """Authentication key."""
                key_type: Literal["0", "7", "8a"] | None
                """Authentication key type."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mode: Literal["text", "ietf-md5"] | UndefinedType = Undefined,
                        key: str | UndefinedType = Undefined,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerAuthentication.


                        Subclass of AvdModel.

                        Args:
                            mode: Authentication mode.
                            key: Authentication key.
                            key_type: Authentication key type.

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "priority_level": {"type": int},
                "advertisement": {"type": Advertisement},
                "preempt": {"type": Preempt},
                "timers": {"type": Timers},
                "tracked_object": {"type": TrackedObject},
                "ipv4": {"type": Ipv4},
                "ipv6": {"type": Ipv6},
                "peer_authentication": {"type": PeerAuthentication},
            }
            id: int
            """VRID."""
            priority_level: int | None
            """Instance priority."""
            advertisement: Advertisement
            """Subclass of AvdModel."""
            preempt: Preempt
            """Subclass of AvdModel."""
            timers: Timers
            """Subclass of AvdModel."""
            tracked_object: TrackedObject
            """Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`)."""
            ipv4: Ipv4
            """Subclass of AvdModel."""
            ipv6: Ipv6
            """Subclass of AvdModel."""
            peer_authentication: PeerAuthentication
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    priority_level: int | None | UndefinedType = Undefined,
                    advertisement: Advertisement | UndefinedType = Undefined,
                    preempt: Preempt | UndefinedType = Undefined,
                    timers: Timers | UndefinedType = Undefined,
                    tracked_object: TrackedObject | UndefinedType = Undefined,
                    ipv4: Ipv4 | UndefinedType = Undefined,
                    ipv6: Ipv6 | UndefinedType = Undefined,
                    peer_authentication: PeerAuthentication | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrrpIdsItem.


                    Subclass of AvdModel.

                    Args:
                        id: VRID.
                        priority_level: Instance priority.
                        advertisement: Subclass of AvdModel.
                        preempt: Subclass of AvdModel.
                        timers: Subclass of AvdModel.
                        tracked_object: Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`).
                        ipv4: Subclass of AvdModel.
                        ipv6: Subclass of AvdModel.
                        peer_authentication: Subclass of AvdModel.

                    """

        class VrrpIds(AvdIndexedList[int, VrrpIdsItem]):
            """Subclass of AvdIndexedList with `VrrpIdsItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        VrrpIds._item_type = VrrpIdsItem

        class Switchport(AvdModel):
            """Subclass of AvdModel."""

            class Trunk(AvdModel):
                """Subclass of AvdModel."""

                class Groups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Groups._item_type = str

                _fields: ClassVar[dict] = {
                    "allowed_vlan": {"type": str},
                    "native_vlan": {"type": int},
                    "native_vlan_tag": {"type": bool},
                    "private_vlan_secondary": {"type": bool},
                    "groups": {"type": Groups},
                }
                allowed_vlan: str | None
                """
                VLAN ID or range(s) of VLAN IDs (1-4094).
                Warning: This should not be combined with
                `port_channel_interfaces[].mode = trunk` and `port_channel_interfaces[].vlans`.
                """
                native_vlan: int | None
                """
                Set native VLAN when interface is in trunking mode.
                Warning: This should not be combined with
                `port_channel_interfaces[].native_vlan`.
                """
                native_vlan_tag: bool | None
                """
                If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                Warning: This
                should not be combined with `port_channel_interfaces[].native_vlan_tag`.
                """
                private_vlan_secondary: bool | None
                """
                Enable secondary VLAN mapping for a private vlan.
                Warning: This should not be combined with
                `port_channel_interfaces[].trunk_private_vlan_secondary`.
                """
                groups: Groups
                """
                Warning: This should not be combined with `port_channel_interfaces[].trunk_groups`.


                Subclass of
                AvdList with `str` items.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        allowed_vlan: str | None | UndefinedType = Undefined,
                        native_vlan: int | None | UndefinedType = Undefined,
                        native_vlan_tag: bool | None | UndefinedType = Undefined,
                        private_vlan_secondary: bool | None | UndefinedType = Undefined,
                        groups: Groups | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Trunk.


                        Subclass of AvdModel.

                        Args:
                            allowed_vlan:
                               VLAN ID or range(s) of VLAN IDs (1-4094).
                               Warning: This should not be combined with
                               `port_channel_interfaces[].mode = trunk` and `port_channel_interfaces[].vlans`.
                            native_vlan:
                               Set native VLAN when interface is in trunking mode.
                               Warning: This should not be combined with
                               `port_channel_interfaces[].native_vlan`.
                            native_vlan_tag:
                               If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                               Warning: This
                               should not be combined with `port_channel_interfaces[].native_vlan_tag`.
                            private_vlan_secondary:
                               Enable secondary VLAN mapping for a private vlan.
                               Warning: This should not be combined with
                               `port_channel_interfaces[].trunk_private_vlan_secondary`.
                            groups:
                               Warning: This should not be combined with `port_channel_interfaces[].trunk_groups`.


                               Subclass of
                               AvdList with `str` items.

                        """

            class Phone(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"vlan": {"type": int}, "trunk": {"type": str}}
                vlan: int | None
                """Warning: This should not be combined with `port_channel_interfaces[].phone.vlan`."""
                trunk: Literal["tagged", "tagged phone", "untagged", "untagged phone"] | None
                """Warning: This should not be combined with `port_channel_interfaces[].phone.trunk`"""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        vlan: int | None | UndefinedType = Undefined,
                        trunk: Literal["tagged", "tagged phone", "untagged", "untagged phone"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Phone.


                        Subclass of AvdModel.

                        Args:
                            vlan: Warning: This should not be combined with `port_channel_interfaces[].phone.vlan`.
                            trunk: Warning: This should not be combined with `port_channel_interfaces[].phone.trunk`

                        """

            class Dot1q(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ethertype": {"type": int}, "vlan_tag": {"type": str}}
                ethertype: int | None
                """Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames."""
                vlan_tag: Literal["disallowed", "required"] | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ethertype: int | None | UndefinedType = Undefined,
                        vlan_tag: Literal["disallowed", "required"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dot1q.


                        Subclass of AvdModel.

                        Args:
                            ethertype: Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames.
                            vlan_tag: vlan_tag

                        """

            class VlanTranslations(AvdModel):
                """Subclass of AvdModel."""

                class DirectionInItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "field_from": {"type": str},
                        "to": {"type": int},
                        "dot1q_tunnel": {"type": bool},
                        "inner_vlan_from": {"type": int},
                    }
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str | None
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int | None
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None
                    inner_vlan_from: int | None
                    """Inner VLAN ID to map from."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | None | UndefinedType = Undefined,
                            to: int | None | UndefinedType = Undefined,
                            dot1q_tunnel: bool | None | UndefinedType = Undefined,
                            inner_vlan_from: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionInItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                                to: VLAN ID to map to.
                                dot1q_tunnel: dot1q_tunnel
                                inner_vlan_from: Inner VLAN ID to map from.

                            """

                class DirectionIn(AvdList[DirectionInItem]):
                    """Subclass of AvdList with `DirectionInItem` items."""

                DirectionIn._item_type = DirectionInItem

                class DirectionOutItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "field_from": {"type": str},
                        "to": {"type": int},
                        "dot1q_tunnel_to": {"type": str},
                        "inner_vlan_to": {"type": int},
                    }
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int | None
                    """VLAN ID to map to."""
                    dot1q_tunnel_to: str | None
                    """
                    VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                    This takes precedence over `to` and
                    `inner_vlan_to`.
                    """
                    inner_vlan_to: int | None
                    """Inner VLAN ID to map to."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | UndefinedType = Undefined,
                            to: int | None | UndefinedType = Undefined,
                            dot1q_tunnel_to: str | None | UndefinedType = Undefined,
                            inner_vlan_to: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionOutItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                                to: VLAN ID to map to.
                                dot1q_tunnel_to:
                                   VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                                   This takes precedence over `to` and
                                   `inner_vlan_to`.
                                inner_vlan_to: Inner VLAN ID to map to.

                            """

                class DirectionOut(AvdList[DirectionOutItem]):
                    """Subclass of AvdList with `DirectionOutItem` items."""

                DirectionOut._item_type = DirectionOutItem

                class DirectionBothItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "field_from": {"type": str},
                        "to": {"type": int},
                        "dot1q_tunnel": {"type": bool},
                        "inner_vlan_from": {"type": int},
                        "network": {"type": bool},
                    }
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None
                    inner_vlan_from: int | None
                    """Inner VLAN ID to map from."""
                    network: bool | None
                    """
                    Enable use of network-side VLAN ID.
                    This setting can only be enabled when `inner_vlan_from` is
                    defined.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | UndefinedType = Undefined,
                            to: int | UndefinedType = Undefined,
                            dot1q_tunnel: bool | None | UndefinedType = Undefined,
                            inner_vlan_from: int | None | UndefinedType = Undefined,
                            network: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionBothItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                                to: VLAN ID to map to.
                                dot1q_tunnel: dot1q_tunnel
                                inner_vlan_from: Inner VLAN ID to map from.
                                network:
                                   Enable use of network-side VLAN ID.
                                   This setting can only be enabled when `inner_vlan_from` is
                                   defined.

                            """

                class DirectionBoth(AvdList[DirectionBothItem]):
                    """Subclass of AvdList with `DirectionBothItem` items."""

                DirectionBoth._item_type = DirectionBothItem

                _fields: ClassVar[dict] = {
                    "in_required": {"type": bool},
                    "out_required": {"type": bool},
                    "direction_in": {"type": DirectionIn},
                    "direction_out": {"type": DirectionOut},
                    "direction_both": {"type": DirectionBoth},
                }
                in_required: bool | None
                """Drop the ingress traffic that do not match any VLAN mapping."""
                out_required: bool | None
                """Drop the egress traffic that do not match any VLAN mapping."""
                direction_in: DirectionIn
                """
                Map ingress traffic only.

                Subclass of AvdList with `DirectionInItem` items.
                """
                direction_out: DirectionOut
                """
                Map egress traffic only.

                Subclass of AvdList with `DirectionOutItem` items.
                """
                direction_both: DirectionBoth
                """
                Map both egress and ingress traffic.

                Subclass of AvdList with `DirectionBothItem` items.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        in_required: bool | None | UndefinedType = Undefined,
                        out_required: bool | None | UndefinedType = Undefined,
                        direction_in: DirectionIn | UndefinedType = Undefined,
                        direction_out: DirectionOut | UndefinedType = Undefined,
                        direction_both: DirectionBoth | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VlanTranslations.


                        Subclass of AvdModel.

                        Args:
                            in_required: Drop the ingress traffic that do not match any VLAN mapping.
                            out_required: Drop the egress traffic that do not match any VLAN mapping.
                            direction_in:
                               Map ingress traffic only.

                               Subclass of AvdList with `DirectionInItem` items.
                            direction_out:
                               Map egress traffic only.

                               Subclass of AvdList with `DirectionOutItem` items.
                            direction_both:
                               Map both egress and ingress traffic.

                               Subclass of AvdList with `DirectionBothItem` items.

                        """

            class BackupLink(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interface": {"type": str}, "prefer_vlan": {"type": str}}
                interface: str
                """Backup interface. Example - Ethernet4, Vlan10 etc."""
                prefer_vlan: str | None
                """VLANs to carry on the backup interface (1-4094)."""

                if TYPE_CHECKING:

                    def __init__(self, *, interface: str | UndefinedType = Undefined, prefer_vlan: str | None | UndefinedType = Undefined) -> None:
                        """
                        BackupLink.


                        Subclass of AvdModel.

                        Args:
                            interface: Backup interface. Example - Ethernet4, Vlan10 etc.
                            prefer_vlan: VLANs to carry on the backup interface (1-4094).

                        """

            class Backup(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "dest_macaddr": {"type": str},
                    "initial_mac_move_delay": {"type": int},
                    "mac_move_burst": {"type": int},
                    "mac_move_burst_interval": {"type": int},
                    "preemption_delay": {"type": int},
                }
                dest_macaddr: str | None
                """
                Destination MAC address for MAC move updates.
                The mac address should be multicast or broadcast.
                Example: 01:00:00:00:00:00
                """
                initial_mac_move_delay: int | None
                """Initial MAC move delay in milliseconds."""
                mac_move_burst: int | None
                """Size of MAC move bursts."""
                mac_move_burst_interval: int | None
                """MAC move burst interval in milliseconds."""
                preemption_delay: int | None
                """Preemption delay in milliseconds."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dest_macaddr: str | None | UndefinedType = Undefined,
                        initial_mac_move_delay: int | None | UndefinedType = Undefined,
                        mac_move_burst: int | None | UndefinedType = Undefined,
                        mac_move_burst_interval: int | None | UndefinedType = Undefined,
                        preemption_delay: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Backup.


                        Subclass of AvdModel.

                        Args:
                            dest_macaddr:
                               Destination MAC address for MAC move updates.
                               The mac address should be multicast or broadcast.
                               Example: 01:00:00:00:00:00
                            initial_mac_move_delay: Initial MAC move delay in milliseconds.
                            mac_move_burst: Size of MAC move bursts.
                            mac_move_burst_interval: MAC move burst interval in milliseconds.
                            preemption_delay: Preemption delay in milliseconds.

                        """

            class PortSecurity(AvdModel):
                """Subclass of AvdModel."""

                class MacAddressMaximum(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"disabled": {"type": bool}, "limit": {"type": int}}
                    disabled: bool | None
                    """Disable port level check for port security (only in violation 'shutdown' mode)."""
                    limit: int | None
                    """MAC address limit."""

                    if TYPE_CHECKING:

                        def __init__(self, *, disabled: bool | None | UndefinedType = Undefined, limit: int | None | UndefinedType = Undefined) -> None:
                            """
                            MacAddressMaximum.


                            Subclass of AvdModel.

                            Args:
                                disabled: Disable port level check for port security (only in violation 'shutdown' mode).
                                limit: MAC address limit.

                            """

                class Violation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"mode": {"type": str}, "protect_log": {"type": bool}}
                    mode: Literal["shutdown", "protect"] | None
                    """Configure port security mode."""
                    protect_log: bool | None
                    """Log new addresses seen after limit is reached in protect mode."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            mode: Literal["shutdown", "protect"] | None | UndefinedType = Undefined,
                            protect_log: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Violation.


                            Subclass of AvdModel.

                            Args:
                                mode: Configure port security mode.
                                protect_log: Log new addresses seen after limit is reached in protect mode.

                            """

                class VlansItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"range": {"type": str}, "mac_address_maximum": {"type": int}}
                    range: str
                    """
                    VLAN ID or range(s) of VLAN IDs, <1-4094>.
                    Example:
                      - 3
                      - 1,3
                      - 1-10
                    """
                    mac_address_maximum: int | None

                    if TYPE_CHECKING:

                        def __init__(self, *, range: str | UndefinedType = Undefined, mac_address_maximum: int | None | UndefinedType = Undefined) -> None:
                            """
                            VlansItem.


                            Subclass of AvdModel.

                            Args:
                                range:
                                   VLAN ID or range(s) of VLAN IDs, <1-4094>.
                                   Example:  # fmt: skip
                                     - 3
                                     - 1,3
                                     - 1-10
                                mac_address_maximum: mac_address_maximum

                            """

                class Vlans(AvdIndexedList[str, VlansItem]):
                    """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `range` (`str`)."""

                    _primary_key: ClassVar[str] = "range"

                Vlans._item_type = VlansItem

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "mac_address_maximum": {"type": MacAddressMaximum},
                    "violation": {"type": Violation},
                    "vlan_default_mac_address_maximum": {"type": int},
                    "vlans": {"type": Vlans},
                }
                enabled: bool | None
                mac_address_maximum: MacAddressMaximum
                """
                Maximum number of MAC addresses allowed on the interface.

                Subclass of AvdModel.
                """
                violation: Violation
                """
                Configure violation mode (shutdown or protect), EOS default is 'shutdown'.

                Subclass of AvdModel.
                """
                vlan_default_mac_address_maximum: int | None
                """Default maximum MAC addresses for all VLANs on this interface."""
                vlans: Vlans
                """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `range` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        mac_address_maximum: MacAddressMaximum | UndefinedType = Undefined,
                        violation: Violation | UndefinedType = Undefined,
                        vlan_default_mac_address_maximum: int | None | UndefinedType = Undefined,
                        vlans: Vlans | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PortSecurity.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            mac_address_maximum:
                               Maximum number of MAC addresses allowed on the interface.

                               Subclass of AvdModel.
                            violation:
                               Configure violation mode (shutdown or protect), EOS default is 'shutdown'.

                               Subclass of AvdModel.
                            vlan_default_mac_address_maximum: Default maximum MAC addresses for all VLANs on this interface.
                            vlans: Subclass of AvdIndexedList with `VlansItem` items. Primary key is `range` (`str`).

                        """

            class Tap(AvdModel):
                """Subclass of AvdModel."""

                class Default(AvdModel):
                    """Subclass of AvdModel."""

                    class Groups(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Groups._item_type = str

                    class Interfaces(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Interfaces._item_type = str

                    class NexthopGroups(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    NexthopGroups._item_type = str

                    _fields: ClassVar[dict] = {"groups": {"type": Groups}, "interfaces": {"type": Interfaces}, "nexthop_groups": {"type": NexthopGroups}}
                    groups: Groups
                    """
                    Tap group names for the interface.

                    Subclass of AvdList with `str` items.
                    """
                    interfaces: Interfaces
                    """
                    Interfaces like -  Ethernet1, InternalRecirc1, Port-Channel1, Recirc-Channel1.

                    Subclass of AvdList
                    with `str` items.
                    """
                    nexthop_groups: NexthopGroups
                    """
                    Default nexthop-group names.

                    Subclass of AvdList with `str` items.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            groups: Groups | UndefinedType = Undefined,
                            interfaces: Interfaces | UndefinedType = Undefined,
                            nexthop_groups: NexthopGroups | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Default.


                            Subclass of AvdModel.

                            Args:
                                groups:
                                   Tap group names for the interface.

                                   Subclass of AvdList with `str` items.
                                interfaces:
                                   Interfaces like -  Ethernet1, InternalRecirc1, Port-Channel1, Recirc-Channel1.

                                   Subclass of AvdList
                                   with `str` items.
                                nexthop_groups:
                                   Default nexthop-group names.

                                   Subclass of AvdList with `str` items.

                            """

                class Identity(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"id": {"type": int}, "inner_vlan": {"type": int}}
                    id: int | None
                    """Tap port VLAN ID (1-4094) or DzGRE extended ID (1-65535)."""
                    inner_vlan: int | None
                    """Tap port inner VLAN ID. Only applicable if `id` is a VLAN ID (1-4094)."""

                    if TYPE_CHECKING:

                        def __init__(self, *, id: int | None | UndefinedType = Undefined, inner_vlan: int | None | UndefinedType = Undefined) -> None:
                            """
                            Identity.


                            Subclass of AvdModel.

                            Args:
                                id: Tap port VLAN ID (1-4094) or DzGRE extended ID (1-65535).
                                inner_vlan: Tap port inner VLAN ID. Only applicable if `id` is a VLAN ID (1-4094).

                            """

                class Truncation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "size": {"type": int}}
                    enabled: bool | None
                    size: int | None
                    """Ingress packet truncation size in bytes."""

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, size: int | None | UndefinedType = Undefined) -> None:
                            """
                            Truncation.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                size: Ingress packet truncation size in bytes.

                            """

                class MacAddress(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}, "destination": {"type": str}}
                    source: str | None
                    """MAC address for the source."""
                    destination: str | None
                    """MAC address for the destination."""

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | None | UndefinedType = Undefined, destination: str | None | UndefinedType = Undefined) -> None:
                            """
                            MacAddress.


                            Subclass of AvdModel.

                            Args:
                                source: MAC address for the source.
                                destination: MAC address for the destination.

                            """

                class Encapsulation(AvdModel):
                    """Subclass of AvdModel."""

                    class Gre(AvdModel):
                        """Subclass of AvdModel."""

                        class ProtocolsItem(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "protocol": {"type": str},
                                "strip": {"type": bool},
                                "feature_header_length": {"type": int},
                                "re_encapsulation_ethernet_header": {"type": bool},
                            }
                            protocol: str
                            """
                            Protocol type in GRE header.
                            Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                            "0x0".
                            """
                            strip: bool | None
                            """This is a required key to strip GRE encapsulation header with protocols."""
                            feature_header_length: int | None
                            """
                            Feature header length in bytes.
                            Note: This setting does not appear in the EOS running-config for
                            protocol 0x0.
                            """
                            re_encapsulation_ethernet_header: bool | None
                            """
                            Extra ethernet header to prepend to the terminated packet.
                            Note: This setting does not appear in the
                            EOS running-config for protocol 0x0.
                            """

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    protocol: str | UndefinedType = Undefined,
                                    strip: bool | None | UndefinedType = Undefined,
                                    feature_header_length: int | None | UndefinedType = Undefined,
                                    re_encapsulation_ethernet_header: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    ProtocolsItem.


                                    Subclass of AvdModel.

                                    Args:
                                        protocol:
                                           Protocol type in GRE header.
                                           Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                                           "0x0".
                                        strip: This is a required key to strip GRE encapsulation header with protocols.
                                        feature_header_length:
                                           Feature header length in bytes.
                                           Note: This setting does not appear in the EOS running-config for
                                           protocol 0x0.
                                        re_encapsulation_ethernet_header:
                                           Extra ethernet header to prepend to the terminated packet.
                                           Note: This setting does not appear in the
                                           EOS running-config for protocol 0x0.

                                    """

                        class Protocols(AvdIndexedList[str, ProtocolsItem]):
                            """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                            _primary_key: ClassVar[str] = "protocol"

                        Protocols._item_type = ProtocolsItem

                        class DestinationsItem(AvdModel):
                            """Subclass of AvdModel."""

                            class ProtocolsItem(AvdModel):
                                """Subclass of AvdModel."""

                                _fields: ClassVar[dict] = {
                                    "protocol": {"type": str},
                                    "strip": {"type": bool},
                                    "feature_header_length": {"type": int},
                                    "re_encapsulation_ethernet_header": {"type": bool},
                                }
                                protocol: str
                                """
                                Protocol type in GRE header.
                                Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                                "0x0".
                                """
                                strip: bool | None
                                """This is a required key to strip GRE encapsulation header for specific destination with protocols."""
                                feature_header_length: int | None
                                """
                                Feature header length in bytes.
                                Note: This setting does not appear in the EOS running-config for
                                protocol 0x0.
                                """
                                re_encapsulation_ethernet_header: bool | None
                                """
                                Extra ethernet header to prepend to the terminated packet.
                                Note: This setting does not appear in the
                                EOS running-config for protocol 0x0.
                                """

                                if TYPE_CHECKING:

                                    def __init__(
                                        self,
                                        *,
                                        protocol: str | UndefinedType = Undefined,
                                        strip: bool | None | UndefinedType = Undefined,
                                        feature_header_length: int | None | UndefinedType = Undefined,
                                        re_encapsulation_ethernet_header: bool | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        ProtocolsItem.


                                        Subclass of AvdModel.

                                        Args:
                                            protocol:
                                               Protocol type in GRE header.
                                               Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                                               "0x0".
                                            strip: This is a required key to strip GRE encapsulation header for specific destination with protocols.
                                            feature_header_length:
                                               Feature header length in bytes.
                                               Note: This setting does not appear in the EOS running-config for
                                               protocol 0x0.
                                            re_encapsulation_ethernet_header:
                                               Extra ethernet header to prepend to the terminated packet.
                                               Note: This setting does not appear in the
                                               EOS running-config for protocol 0x0.

                                        """

                            class Protocols(AvdIndexedList[str, ProtocolsItem]):
                                """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                                _primary_key: ClassVar[str] = "protocol"

                            Protocols._item_type = ProtocolsItem

                            _fields: ClassVar[dict] = {
                                "destination": {"type": str},
                                "source": {"type": str},
                                "strip": {"type": bool},
                                "protocols": {"type": Protocols},
                            }
                            destination: str
                            """Destination IP address of tunnel packets."""
                            source: str | None
                            """
                            Source IP address of tunnel packets. Applied only when destination is defined. When not defined; any
                            GRE packet that matches the `destination` is terminated.
                            """
                            strip: bool | None
                            """Strip GRE encapsulation header for specific destination."""
                            protocols: Protocols
                            """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    destination: str | UndefinedType = Undefined,
                                    source: str | None | UndefinedType = Undefined,
                                    strip: bool | None | UndefinedType = Undefined,
                                    protocols: Protocols | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    DestinationsItem.


                                    Subclass of AvdModel.

                                    Args:
                                        destination: Destination IP address of tunnel packets.
                                        source:
                                           Source IP address of tunnel packets. Applied only when destination is defined. When not defined; any
                                           GRE packet that matches the `destination` is terminated.
                                        strip: Strip GRE encapsulation header for specific destination.
                                        protocols: Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`).

                                    """

                        class Destinations(AvdIndexedList[str, DestinationsItem]):
                            """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`)."""

                            _primary_key: ClassVar[str] = "destination"

                        Destinations._item_type = DestinationsItem

                        _fields: ClassVar[dict] = {"strip": {"type": bool}, "protocols": {"type": Protocols}, "destinations": {"type": Destinations}}
                        strip: bool | None
                        """Strip GRE encapsulation header for all GRE tunnels."""
                        protocols: Protocols
                        """
                        Protocols for all destinations; destination-specific protocols should be set under the
                        `destinations[].protocols` key.

                        Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key
                        is `protocol` (`str`).
                        """
                        destinations: Destinations
                        """
                        In EOS, `gre.strip` and `destinations.destination/source.strip` (without defining protocols) are
                        mutually exclusive.

                        Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is
                        `destination` (`str`).
                        """

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                strip: bool | None | UndefinedType = Undefined,
                                protocols: Protocols | UndefinedType = Undefined,
                                destinations: Destinations | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Gre.


                                Subclass of AvdModel.

                                Args:
                                    strip: Strip GRE encapsulation header for all GRE tunnels.
                                    protocols:
                                       Protocols for all destinations; destination-specific protocols should be set under the
                                       `destinations[].protocols` key.

                                       Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key
                                       is `protocol` (`str`).
                                    destinations:
                                       In EOS, `gre.strip` and `destinations.destination/source.strip` (without defining protocols) are
                                       mutually exclusive.

                                       Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is
                                       `destination` (`str`).

                                """

                    _fields: ClassVar[dict] = {"vxlan_strip": {"type": bool}, "gre": {"type": Gre}}
                    vxlan_strip: bool | None
                    """
                    Strip VXLAN encapsulation header.
                    `encapsulation.vxlan_strip` and `mpls_pop_all` are mutually
                    exclusive.
                    `mpls_pop_all` takes precedence.
                    """
                    gre: Gre
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, vxlan_strip: bool | None | UndefinedType = Undefined, gre: Gre | UndefinedType = Undefined) -> None:
                            """
                            Encapsulation.


                            Subclass of AvdModel.

                            Args:
                                vxlan_strip:
                                   Strip VXLAN encapsulation header.
                                   `encapsulation.vxlan_strip` and `mpls_pop_all` are mutually
                                   exclusive.
                                   `mpls_pop_all` takes precedence.
                                gre: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {
                    "allowed_vlan": {"type": str},
                    "default": {"type": Default},
                    "identity": {"type": Identity},
                    "mpls_pop_all": {"type": bool},
                    "native_vlan": {"type": int},
                    "truncation": {"type": Truncation},
                    "mac_address": {"type": MacAddress},
                    "encapsulation": {"type": Encapsulation},
                }
                allowed_vlan: str | None
                """VLAN ID or range(s) of VLAN IDs within range 1-4094."""
                default: Default
                """
                Default tap destination config.

                Subclass of AvdModel.
                """
                identity: Identity
                """Subclass of AvdModel."""
                mpls_pop_all: bool | None
                """Pop all MPLS labels."""
                native_vlan: int | None
                """Native VLAN ID when interface is in tap mode."""
                truncation: Truncation
                """Subclass of AvdModel."""
                mac_address: MacAddress
                """Subclass of AvdModel."""
                encapsulation: Encapsulation
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        allowed_vlan: str | None | UndefinedType = Undefined,
                        default: Default | UndefinedType = Undefined,
                        identity: Identity | UndefinedType = Undefined,
                        mpls_pop_all: bool | None | UndefinedType = Undefined,
                        native_vlan: int | None | UndefinedType = Undefined,
                        truncation: Truncation | UndefinedType = Undefined,
                        mac_address: MacAddress | UndefinedType = Undefined,
                        encapsulation: Encapsulation | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Tap.


                        Subclass of AvdModel.

                        Args:
                            allowed_vlan: VLAN ID or range(s) of VLAN IDs within range 1-4094.
                            default:
                               Default tap destination config.

                               Subclass of AvdModel.
                            identity: Subclass of AvdModel.
                            mpls_pop_all: Pop all MPLS labels.
                            native_vlan: Native VLAN ID when interface is in tap mode.
                            truncation: Subclass of AvdModel.
                            mac_address: Subclass of AvdModel.
                            encapsulation: Subclass of AvdModel.

                        """

            class Tool(AvdModel):
                """Subclass of AvdModel."""

                class Encapsulation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"dot1br_strip": {"type": bool}, "vn_tag_strip": {"type": bool}}
                    dot1br_strip: bool | None
                    """Remove a 802.1 BR tag in packet header. 'mpls_pop_all' takes precedence over 'dot1br_strip' in EOS."""
                    vn_tag_strip: bool | None
                    """Remove a VN-tag in packet header. 'mpls_pop_all' takes precedence over 'vn_tag_strip' in EOS."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, dot1br_strip: bool | None | UndefinedType = Undefined, vn_tag_strip: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            Encapsulation.


                            Subclass of AvdModel.

                            Args:
                                dot1br_strip: Remove a 802.1 BR tag in packet header. 'mpls_pop_all' takes precedence over 'dot1br_strip' in EOS.
                                vn_tag_strip: Remove a VN-tag in packet header. 'mpls_pop_all' takes precedence over 'vn_tag_strip' in EOS.

                            """

                class Identity(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"tag": {"type": str}, "dot1q_dzgre_source": {"type": str}, "qinq_dzgre_source": {"type": str}}
                    tag: Literal["dot1q", "qinq"] | None
                    dot1q_dzgre_source: Literal["policy", "port"] | None
                    qinq_dzgre_source: Literal["policy inner port", "port inner policy"] | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            tag: Literal["dot1q", "qinq"] | None | UndefinedType = Undefined,
                            dot1q_dzgre_source: Literal["policy", "port"] | None | UndefinedType = Undefined,
                            qinq_dzgre_source: Literal["policy inner port", "port inner policy"] | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Identity.


                            Subclass of AvdModel.

                            Args:
                                tag: tag
                                dot1q_dzgre_source: dot1q_dzgre_source
                                qinq_dzgre_source: qinq_dzgre_source

                            """

                class Groups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Groups._item_type = str

                _fields: ClassVar[dict] = {
                    "mpls_pop_all": {"type": bool},
                    "encapsulation": {"type": Encapsulation},
                    "allowed_vlan": {"type": str},
                    "identity": {"type": Identity},
                    "groups": {"type": Groups},
                    "dot1q_remove_outer_vlan_tag": {"type": str},
                }
                mpls_pop_all: bool | None
                """Pop all MPLS labels."""
                encapsulation: Encapsulation
                """Subclass of AvdModel."""
                allowed_vlan: str | None
                """VLAN ID or range of VLAN IDs within range 1-4094."""
                identity: Identity
                """Subclass of AvdModel."""
                groups: Groups
                """
                Tool groups for the interface.

                Subclass of AvdList with `str` items.
                """
                dot1q_remove_outer_vlan_tag: str | None
                """
                Indices of vlan tags to be removed.
                Range: 1-2
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mpls_pop_all: bool | None | UndefinedType = Undefined,
                        encapsulation: Encapsulation | UndefinedType = Undefined,
                        allowed_vlan: str | None | UndefinedType = Undefined,
                        identity: Identity | UndefinedType = Undefined,
                        groups: Groups | UndefinedType = Undefined,
                        dot1q_remove_outer_vlan_tag: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Tool.


                        Subclass of AvdModel.

                        Args:
                            mpls_pop_all: Pop all MPLS labels.
                            encapsulation: Subclass of AvdModel.
                            allowed_vlan: VLAN ID or range of VLAN IDs within range 1-4094.
                            identity: Subclass of AvdModel.
                            groups:
                               Tool groups for the interface.

                               Subclass of AvdList with `str` items.
                            dot1q_remove_outer_vlan_tag:
                               Indices of vlan tags to be removed.
                               Range: 1-2

                        """

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "mode": {"type": str},
                "access_vlan": {"type": int},
                "trunk": {"type": Trunk},
                "phone": {"type": Phone},
                "pvlan_mapping": {"type": str},
                "dot1q": {"type": Dot1q},
                "source_interface": {"type": str},
                "vlan_translations": {"type": VlanTranslations},
                "vlan_forwarding_accept_all": {"type": bool},
                "backup_link": {"type": BackupLink},
                "backup": {"type": Backup},
                "port_security": {"type": PortSecurity},
                "tap": {"type": Tap},
                "tool": {"type": Tool},
            }
            enabled: bool | None
            """Warning: This should not be combined with `port_channel_interfaces[].type = routed`."""
            mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None
            """Warning: This should not be combined with `port_channel_interfaces[].mode`"""
            access_vlan: int | None
            """
            Set VLAN when interface is in access mode.
            Warning: This should not be combined with
            `port_channel_interfaces[].mode = access/dot1q-tunnel` and `port_channel_interface.vlans`.
            """
            trunk: Trunk
            """Subclass of AvdModel."""
            phone: Phone
            """Subclass of AvdModel."""
            pvlan_mapping: str | None
            """
            Secondary VLAN IDs of the private VLAN mapping.
            Warning: This should not be combined with
            `port_channel_interfaces[].pvlan_mapping`.
            """
            dot1q: Dot1q
            """Subclass of AvdModel."""
            source_interface: Literal["tx", "tx multicast"] | None
            """
            tx: Allow bridged traffic to go out of the source interface.
            tx multicast: Allow multicast traffic
            only to go out of the source interface.
            """
            vlan_translations: VlanTranslations
            """
            VLAN Translation mappings.
            Warning: This should not be combined with
            `port_channel_interfaces[].vlan_translations`.

            Subclass of AvdModel.
            """
            vlan_forwarding_accept_all: bool | None
            backup_link: BackupLink
            """Subclass of AvdModel."""
            backup: Backup
            """
            The `backup_link` is required for this setting.

            Subclass of AvdModel.
            """
            port_security: PortSecurity
            """Subclass of AvdModel."""
            tap: Tap
            """
            In tap mode, the interface operates as a tap port.
            Tap ports receive traffic for replication on one
            or more tool ports.
            This setting applies only to parent interfaces.

            Subclass of AvdModel.
            """
            tool: Tool
            """
            In tool mode, the interface operates as a tool port.
            Tool ports replicate traffic received by tap
            ports.
            This setting applies only to parent interfaces.

            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None | UndefinedType = Undefined,
                    access_vlan: int | None | UndefinedType = Undefined,
                    trunk: Trunk | UndefinedType = Undefined,
                    phone: Phone | UndefinedType = Undefined,
                    pvlan_mapping: str | None | UndefinedType = Undefined,
                    dot1q: Dot1q | UndefinedType = Undefined,
                    source_interface: Literal["tx", "tx multicast"] | None | UndefinedType = Undefined,
                    vlan_translations: VlanTranslations | UndefinedType = Undefined,
                    vlan_forwarding_accept_all: bool | None | UndefinedType = Undefined,
                    backup_link: BackupLink | UndefinedType = Undefined,
                    backup: Backup | UndefinedType = Undefined,
                    port_security: PortSecurity | UndefinedType = Undefined,
                    tap: Tap | UndefinedType = Undefined,
                    tool: Tool | UndefinedType = Undefined,
                ) -> None:
                    """
                    Switchport.


                    Subclass of AvdModel.

                    Args:
                        enabled: Warning: This should not be combined with `port_channel_interfaces[].type = routed`.
                        mode: Warning: This should not be combined with `port_channel_interfaces[].mode`
                        access_vlan:
                           Set VLAN when interface is in access mode.
                           Warning: This should not be combined with
                           `port_channel_interfaces[].mode = access/dot1q-tunnel` and `port_channel_interface.vlans`.
                        trunk: Subclass of AvdModel.
                        phone: Subclass of AvdModel.
                        pvlan_mapping:
                           Secondary VLAN IDs of the private VLAN mapping.
                           Warning: This should not be combined with
                           `port_channel_interfaces[].pvlan_mapping`.
                        dot1q: Subclass of AvdModel.
                        source_interface:
                           tx: Allow bridged traffic to go out of the source interface.
                           tx multicast: Allow multicast traffic
                           only to go out of the source interface.
                        vlan_translations:
                           VLAN Translation mappings.
                           Warning: This should not be combined with
                           `port_channel_interfaces[].vlan_translations`.

                           Subclass of AvdModel.
                        vlan_forwarding_accept_all: vlan_forwarding_accept_all
                        backup_link: Subclass of AvdModel.
                        backup:
                           The `backup_link` is required for this setting.

                           Subclass of AvdModel.
                        port_security: Subclass of AvdModel.
                        tap:
                           In tap mode, the interface operates as a tap port.
                           Tap ports receive traffic for replication on one
                           or more tool ports.
                           This setting applies only to parent interfaces.

                           Subclass of AvdModel.
                        tool:
                           In tool mode, the interface operates as a tool port.
                           Tool ports replicate traffic received by tap
                           ports.
                           This setting applies only to parent interfaces.

                           Subclass of AvdModel.

                    """

        class TrafficEngineering(AvdModel):
            """Subclass of AvdModel."""

            class AdministrativeGroups(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            AdministrativeGroups._item_type = str

            class Srlgs(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Srlgs._item_type = str

            class Bandwidth(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"number": {"type": int}, "unit": {"type": str}}
                number: int
                unit: Literal["gbps", "mbps", "percent"]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, number: int | UndefinedType = Undefined, unit: Literal["gbps", "mbps", "percent"] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bandwidth.


                        Subclass of AvdModel.

                        Args:
                            number: number
                            unit: unit

                        """

            class MinDelayStatic(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"number": {"type": int}, "unit": {"type": str}}
                number: int
                """
                Valid values are 1-16777215 microseconds.
                This is regardless of whether the specified unit is
                milliseconds or microseconds.
                """
                unit: Literal["microseconds", "milliseconds"]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, number: int | UndefinedType = Undefined, unit: Literal["microseconds", "milliseconds"] | UndefinedType = Undefined
                    ) -> None:
                        """
                        MinDelayStatic.


                        Subclass of AvdModel.

                        Args:
                            number:
                               Valid values are 1-16777215 microseconds.
                               This is regardless of whether the specified unit is
                               milliseconds or microseconds.
                            unit: unit

                        """

            class MinDelayDynamic(AvdModel):
                """Subclass of AvdModel."""

                class TwampLightFallback(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"number": {"type": int}, "unit": {"type": str}}
                    number: int
                    """
                    Valid values are 1-16777215 microseconds.
                    This is regardless of whether the specified unit is
                    milliseconds or microseconds.
                    """
                    unit: Literal["microseconds", "milliseconds"]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, number: int | UndefinedType = Undefined, unit: Literal["microseconds", "milliseconds"] | UndefinedType = Undefined
                        ) -> None:
                            """
                            TwampLightFallback.


                            Subclass of AvdModel.

                            Args:
                                number:
                                   Valid values are 1-16777215 microseconds.
                                   This is regardless of whether the specified unit is
                                   milliseconds or microseconds.
                                unit: unit

                            """

                _fields: ClassVar[dict] = {"twamp_light_fallback": {"type": TwampLightFallback}}
                twamp_light_fallback: TwampLightFallback
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, twamp_light_fallback: TwampLightFallback | UndefinedType = Undefined) -> None:
                        """
                        MinDelayDynamic.


                        Subclass of AvdModel.

                        Args:
                            twamp_light_fallback: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "administrative_groups": {"type": AdministrativeGroups},
                "srlgs": {"type": Srlgs},
                "srlg": {"type": str},
                "metric": {"type": int},
                "bandwidth": {"type": Bandwidth},
                "min_delay_static": {"type": MinDelayStatic},
                "min_delay_dynamic": {"type": MinDelayDynamic},
            }
            enabled: bool | None
            """Whether to enable traffic-engineering on this interface."""
            administrative_groups: AdministrativeGroups
            """
            List of traffic-engineering administrative groups, valid values are names, ranges 0-127, or single
            integers 0-127.

            Subclass of AvdList with `str` items.
            """
            srlgs: Srlgs
            """
            List of SRLGs.

            Subclass of AvdList with `str` items.
            """
            srlg: str | None
            """SRLG name or number."""
            metric: int | None
            bandwidth: Bandwidth
            """
            Interface maximum reservable bandwidth.

            Subclass of AvdModel.
            """
            min_delay_static: MinDelayStatic
            """
            Mutually exclusive with min_delay_dynamic, if both are defined min_delay_static takes precedence.
            Subclass of AvdModel.
            """
            min_delay_dynamic: MinDelayDynamic
            """
            Mutually exclusive with min_delay_static, if both are defined min_delay_static takes precedence.
            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    administrative_groups: AdministrativeGroups | UndefinedType = Undefined,
                    srlgs: Srlgs | UndefinedType = Undefined,
                    srlg: str | None | UndefinedType = Undefined,
                    metric: int | None | UndefinedType = Undefined,
                    bandwidth: Bandwidth | UndefinedType = Undefined,
                    min_delay_static: MinDelayStatic | UndefinedType = Undefined,
                    min_delay_dynamic: MinDelayDynamic | UndefinedType = Undefined,
                ) -> None:
                    """
                    TrafficEngineering.


                    Subclass of AvdModel.

                    Args:
                        enabled: Whether to enable traffic-engineering on this interface.
                        administrative_groups:
                           List of traffic-engineering administrative groups, valid values are names, ranges 0-127, or single
                           integers 0-127.

                           Subclass of AvdList with `str` items.
                        srlgs:
                           List of SRLGs.

                           Subclass of AvdList with `str` items.
                        srlg: SRLG name or number.
                        metric: metric
                        bandwidth:
                           Interface maximum reservable bandwidth.

                           Subclass of AvdModel.
                        min_delay_static:
                           Mutually exclusive with min_delay_dynamic, if both are defined min_delay_static takes precedence.
                           Subclass of AvdModel.
                        min_delay_dynamic:
                           Mutually exclusive with min_delay_static, if both are defined min_delay_static takes precedence.
                           Subclass of AvdModel.

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "comment": {"type": str},
            "description": {"type": str},
            "profile": {"type": str},
            "logging": {"type": Logging},
            "shutdown": {"type": bool},
            "l2_mtu": {"type": int},
            "l2_mru": {"type": int},
            "vlans": {"type": str},
            "arp_gratuitous_accept": {"type": bool},
            "snmp_trap_link_change": {"type": bool},
            "type": {"type": str},
            "encapsulation_dot1q_vlan": {"type": int},
            "encapsulation_dot1q": {"type": EncapsulationDot1q},
            "vrf": {"type": str},
            "encapsulation_vlan": {"type": EncapsulationVlan},
            "vlan_id": {"type": int},
            "mode": {"type": str},
            "native_vlan": {"type": int},
            "native_vlan_tag": {"type": bool},
            "link_tracking_groups": {"type": LinkTrackingGroups},
            "link_tracking": {"type": LinkTracking},
            "phone": {"type": Phone},
            "l2_protocol": {"type": L2Protocol},
            "mtu": {"type": int},
            "mlag": {"type": int},
            "trunk_groups": {"type": TrunkGroups},
            "lacp_fallback_timeout": {"type": int},
            "min_links": {"type": int},
            "lacp_fallback_mode": {"type": str},
            "qos": {"type": Qos},
            "bfd": {"type": Bfd},
            "service_policy": {"type": ServicePolicy},
            "mpls": {"type": Mpls},
            "ntp_serve": {"type": bool},
            "trunk_private_vlan_secondary": {"type": bool},
            "pvlan_mapping": {"type": str},
            "vlan_translations": {"type": VlanTranslations},
            "shape": {"type": Shape},
            "storm_control": {"type": StormControl},
            "ip_proxy_arp": {"type": bool},
            "isis_enable": {"type": str},
            "isis_bfd": {"type": bool},
            "isis_passive": {"type": bool},
            "isis_metric": {"type": int},
            "isis_network_point_to_point": {"type": bool},
            "isis_circuit_type": {"type": str},
            "isis_hello_padding": {"type": bool},
            "isis_authentication_mode": {"type": str},
            "isis_authentication_key": {"type": str},
            "isis_authentication": {"type": IsisAuthentication},
            "traffic_policy": {"type": TrafficPolicy},
            "evpn_ethernet_segment": {"type": EvpnEthernetSegment},
            "lacp_id": {"type": str},
            "spanning_tree_bpdufilter": {"type": str},
            "spanning_tree_bpduguard": {"type": str},
            "spanning_tree_guard": {"type": str},
            "spanning_tree_portfast": {"type": str},
            "vmtracer": {"type": bool},
            "ptp": {"type": Ptp},
            "ip_address": {"type": str},
            "dhcp_client_accept_default_route": {"type": bool},
            "dhcp_server_ipv4": {"type": bool},
            "dhcp_server_ipv6": {"type": bool},
            "ip_verify_unicast_source_reachable_via": {"type": str},
            "ip_nat": {"type": IpNat},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "ipv6_address_link_local": {"type": str},
            "ipv6_nd_ra_disabled": {"type": bool},
            "ipv6_nd_managed_config_flag": {"type": bool},
            "ipv6_nd_prefixes": {"type": Ipv6NdPrefixes},
            "access_group_in": {"type": str},
            "access_group_out": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "ipv6_access_group_out": {"type": str},
            "mac_access_group_in": {"type": str},
            "mac_access_group_out": {"type": str},
            "pim": {"type": Pim},
            "service_profile": {"type": str},
            "ospf_network_point_to_point": {"type": bool},
            "ospf_area": {"type": str},
            "ospf_cost": {"type": int},
            "ospf_authentication": {"type": str},
            "ospf_authentication_key": {"type": str},
            "ospf_message_digest_keys": {"type": OspfMessageDigestKeys},
            "flow_tracker": {"type": FlowTracker},
            "bgp": {"type": Bgp},
            "ip_igmp_host_proxy": {"type": IpIgmpHostProxy},
            "peer": {"type": str},
            "peer_interface": {"type": str},
            "peer_type": {"type": str},
            "sflow": {"type": Sflow},
            "vrrp_ids": {"type": VrrpIds},
            "switchport": {"type": Switchport},
            "traffic_engineering": {"type": TrafficEngineering},
            "validate_state": {"type": bool},
            "validate_lldp": {"type": bool},
            "eos_cli": {"type": str},
        }
        name: str
        comment: str | None
        """Text comment added under port-channel interface."""
        description: str | None
        profile: str | None
        """Interface profile."""
        logging: Logging
        """Subclass of AvdModel."""
        shutdown: bool | None
        l2_mtu: int | None
        """"l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI."""
        l2_mru: int | None
        """"l2_mru" should only be defined for platforms supporting the "l2 mru" CLI."""
        vlans: str | None
        """
        List of switchport vlans as string.
        For a trunk port this would be a range like "1-200,300".
        For an
        access port this would be a single vlan "123".
        """
        arp_gratuitous_accept: bool | None
        """Accept gratuitous ARP."""
        snmp_trap_link_change: bool | None
        type: Literal["routed", "switched", "l3dot1q", "l2dot1q"] | None
        """
        l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
        Interface will not be listed in device documentation, unless "type" is set.
        """
        encapsulation_dot1q_vlan: int | None
        """VLAN tag to configure on sub-interface."""
        encapsulation_dot1q: EncapsulationDot1q
        """
        Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
        `ethernet_interfaces[].type: l2dot1q`.

        Subclass of AvdModel.
        """
        vrf: str | None
        """VRF name."""
        encapsulation_vlan: EncapsulationVlan
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `encapsulation_vlan` should not
        be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
        Subclass of AvdModel.
        """
        vlan_id: int | None
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `vlan_id` should not be combined
        with `ethernet_interfaces[].type == l2dot1q`.
        """
        mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None
        native_vlan: int | None
        """If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence."""
        native_vlan_tag: bool | None
        """If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence."""
        link_tracking_groups: LinkTrackingGroups
        """Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`)."""
        link_tracking: LinkTracking
        """Subclass of AvdModel."""
        phone: Phone
        """Subclass of AvdModel."""
        l2_protocol: L2Protocol
        """Subclass of AvdModel."""
        mtu: int | None
        mlag: int | None
        """MLAG ID."""
        trunk_groups: TrunkGroups
        """Subclass of AvdList with `str` items."""
        lacp_fallback_timeout: int | None
        """Timeout in seconds. EOS default is 90 seconds."""
        min_links: int | None
        """
        Minimum number of ports required up before bringing up a port-channel.
        Maximum in `min_links` is
        hardware dependent.
        """
        lacp_fallback_mode: Literal["individual", "static"] | None
        qos: Qos
        """Subclass of AvdModel."""
        bfd: Bfd
        """Subclass of AvdModel."""
        service_policy: ServicePolicy
        """Subclass of AvdModel."""
        mpls: Mpls
        """Subclass of AvdModel."""
        ntp_serve: bool | None
        """Enable/disable serving NTP to clients."""
        trunk_private_vlan_secondary: bool | None
        pvlan_mapping: str | None
        """List of vlans as string."""
        vlan_translations: VlanTranslations
        """Subclass of AvdList with `VlanTranslationsItem` items."""
        shape: Shape
        """Subclass of AvdModel."""
        storm_control: StormControl
        """Subclass of AvdModel."""
        ip_proxy_arp: bool | None
        isis_enable: str | None
        """ISIS instance."""
        isis_bfd: bool | None
        """Enable BFD for ISIS."""
        isis_passive: bool | None
        isis_metric: int | None
        isis_network_point_to_point: bool | None
        isis_circuit_type: Literal["level-1-2", "level-1", "level-2"] | None
        isis_hello_padding: bool | None
        isis_authentication_mode: Literal["text", "md5"] | None
        isis_authentication_key: str | None
        """Type-7 encrypted password."""
        isis_authentication: IsisAuthentication
        """
        This key should not be mixed with port_channel_interfaces[].isis_authentication_mode or
        ethernet_interfaces[].isis_authentication_key.

        Subclass of AvdModel.
        """
        traffic_policy: TrafficPolicy
        """Subclass of AvdModel."""
        evpn_ethernet_segment: EvpnEthernetSegment
        """Subclass of AvdModel."""
        lacp_id: str | None
        """LACP ID with format xxxx.xxxx.xxxx."""
        spanning_tree_bpdufilter: Literal["enabled", "disabled", "True", "False", "true", "false"] | None
        spanning_tree_bpduguard: Literal["enabled", "disabled", "True", "False", "true", "false"] | None
        spanning_tree_guard: Literal["loop", "root", "disabled"] | None
        spanning_tree_portfast: Literal["edge", "network"] | None
        vmtracer: bool | None
        ptp: Ptp
        """Subclass of AvdModel."""
        ip_address: str | None
        """IPv4 address/mask or "dhcp"."""
        dhcp_client_accept_default_route: bool | None
        """Install default-route obtained via DHCP."""
        dhcp_server_ipv4: bool | None
        """Enable IPv4 DHCP server."""
        dhcp_server_ipv6: bool | None
        """Enable IPv6 DHCP server."""
        ip_verify_unicast_source_reachable_via: Literal["any", "rx"] | None
        ip_nat: IpNat
        """Subclass of AvdModel."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6 address/mask."""
        ipv6_address_link_local: str | None
        """Link local IPv6 address/mask."""
        ipv6_nd_ra_disabled: bool | None
        ipv6_nd_managed_config_flag: bool | None
        ipv6_nd_prefixes: Ipv6NdPrefixes
        """Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`)."""
        access_group_in: str | None
        """Access list name."""
        access_group_out: str | None
        """Access list name."""
        ipv6_access_group_in: str | None
        """IPv6 access list name."""
        ipv6_access_group_out: str | None
        """IPv6 access list name."""
        mac_access_group_in: str | None
        """MAC access list name."""
        mac_access_group_out: str | None
        """MAC access list name."""
        pim: Pim
        """Subclass of AvdModel."""
        service_profile: str | None
        """QOS profile."""
        ospf_network_point_to_point: bool | None
        ospf_area: str | None
        ospf_cost: int | None
        ospf_authentication: Literal["none", "simple", "message-digest"] | None
        ospf_authentication_key: str | None
        """Encrypted password."""
        ospf_message_digest_keys: OspfMessageDigestKeys
        """Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`)."""
        flow_tracker: FlowTracker
        """Subclass of AvdModel."""
        bgp: Bgp
        """Subclass of AvdModel."""
        ip_igmp_host_proxy: IpIgmpHostProxy
        """Subclass of AvdModel."""
        peer: str | None
        """Key only used for documentation or validation purposes."""
        peer_interface: str | None
        """Key only used for documentation or validation purposes."""
        peer_type: str | None
        """Key only used for documentation or validation purposes."""
        sflow: Sflow
        """Subclass of AvdModel."""
        vrrp_ids: VrrpIds
        """
        VRRP model.

        Subclass of AvdIndexedList with `VrrpIdsItem` items. Primary key is `id` (`int`).
        """
        switchport: Switchport
        """Subclass of AvdModel."""
        traffic_engineering: TrafficEngineering
        """Subclass of AvdModel."""
        validate_state: bool | None
        """
        Set to false to disable interface state and LLDP topology validation performed by the
        `eos_validate_state` role.
        """
        validate_lldp: bool | None
        """Set to false to disable the LLDP topology validation performed by the `eos_validate_state` role."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the port-channel interface in the final EOS configuration."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                comment: str | None | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                profile: str | None | UndefinedType = Undefined,
                logging: Logging | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                l2_mtu: int | None | UndefinedType = Undefined,
                l2_mru: int | None | UndefinedType = Undefined,
                vlans: str | None | UndefinedType = Undefined,
                arp_gratuitous_accept: bool | None | UndefinedType = Undefined,
                snmp_trap_link_change: bool | None | UndefinedType = Undefined,
                type: Literal["routed", "switched", "l3dot1q", "l2dot1q"] | None | UndefinedType = Undefined,
                encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                encapsulation_dot1q: EncapsulationDot1q | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                encapsulation_vlan: EncapsulationVlan | UndefinedType = Undefined,
                vlan_id: int | None | UndefinedType = Undefined,
                mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None | UndefinedType = Undefined,
                native_vlan: int | None | UndefinedType = Undefined,
                native_vlan_tag: bool | None | UndefinedType = Undefined,
                link_tracking_groups: LinkTrackingGroups | UndefinedType = Undefined,
                link_tracking: LinkTracking | UndefinedType = Undefined,
                phone: Phone | UndefinedType = Undefined,
                l2_protocol: L2Protocol | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                mlag: int | None | UndefinedType = Undefined,
                trunk_groups: TrunkGroups | UndefinedType = Undefined,
                lacp_fallback_timeout: int | None | UndefinedType = Undefined,
                min_links: int | None | UndefinedType = Undefined,
                lacp_fallback_mode: Literal["individual", "static"] | None | UndefinedType = Undefined,
                qos: Qos | UndefinedType = Undefined,
                bfd: Bfd | UndefinedType = Undefined,
                service_policy: ServicePolicy | UndefinedType = Undefined,
                mpls: Mpls | UndefinedType = Undefined,
                ntp_serve: bool | None | UndefinedType = Undefined,
                trunk_private_vlan_secondary: bool | None | UndefinedType = Undefined,
                pvlan_mapping: str | None | UndefinedType = Undefined,
                vlan_translations: VlanTranslations | UndefinedType = Undefined,
                shape: Shape | UndefinedType = Undefined,
                storm_control: StormControl | UndefinedType = Undefined,
                ip_proxy_arp: bool | None | UndefinedType = Undefined,
                isis_enable: str | None | UndefinedType = Undefined,
                isis_bfd: bool | None | UndefinedType = Undefined,
                isis_passive: bool | None | UndefinedType = Undefined,
                isis_metric: int | None | UndefinedType = Undefined,
                isis_network_point_to_point: bool | None | UndefinedType = Undefined,
                isis_circuit_type: Literal["level-1-2", "level-1", "level-2"] | None | UndefinedType = Undefined,
                isis_hello_padding: bool | None | UndefinedType = Undefined,
                isis_authentication_mode: Literal["text", "md5"] | None | UndefinedType = Undefined,
                isis_authentication_key: str | None | UndefinedType = Undefined,
                isis_authentication: IsisAuthentication | UndefinedType = Undefined,
                traffic_policy: TrafficPolicy | UndefinedType = Undefined,
                evpn_ethernet_segment: EvpnEthernetSegment | UndefinedType = Undefined,
                lacp_id: str | None | UndefinedType = Undefined,
                spanning_tree_bpdufilter: Literal["enabled", "disabled", "True", "False", "true", "false"] | None | UndefinedType = Undefined,
                spanning_tree_bpduguard: Literal["enabled", "disabled", "True", "False", "true", "false"] | None | UndefinedType = Undefined,
                spanning_tree_guard: Literal["loop", "root", "disabled"] | None | UndefinedType = Undefined,
                spanning_tree_portfast: Literal["edge", "network"] | None | UndefinedType = Undefined,
                vmtracer: bool | None | UndefinedType = Undefined,
                ptp: Ptp | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                dhcp_client_accept_default_route: bool | None | UndefinedType = Undefined,
                dhcp_server_ipv4: bool | None | UndefinedType = Undefined,
                dhcp_server_ipv6: bool | None | UndefinedType = Undefined,
                ip_verify_unicast_source_reachable_via: Literal["any", "rx"] | None | UndefinedType = Undefined,
                ip_nat: IpNat | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                ipv6_address_link_local: str | None | UndefinedType = Undefined,
                ipv6_nd_ra_disabled: bool | None | UndefinedType = Undefined,
                ipv6_nd_managed_config_flag: bool | None | UndefinedType = Undefined,
                ipv6_nd_prefixes: Ipv6NdPrefixes | UndefinedType = Undefined,
                access_group_in: str | None | UndefinedType = Undefined,
                access_group_out: str | None | UndefinedType = Undefined,
                ipv6_access_group_in: str | None | UndefinedType = Undefined,
                ipv6_access_group_out: str | None | UndefinedType = Undefined,
                mac_access_group_in: str | None | UndefinedType = Undefined,
                mac_access_group_out: str | None | UndefinedType = Undefined,
                pim: Pim | UndefinedType = Undefined,
                service_profile: str | None | UndefinedType = Undefined,
                ospf_network_point_to_point: bool | None | UndefinedType = Undefined,
                ospf_area: str | None | UndefinedType = Undefined,
                ospf_cost: int | None | UndefinedType = Undefined,
                ospf_authentication: Literal["none", "simple", "message-digest"] | None | UndefinedType = Undefined,
                ospf_authentication_key: str | None | UndefinedType = Undefined,
                ospf_message_digest_keys: OspfMessageDigestKeys | UndefinedType = Undefined,
                flow_tracker: FlowTracker | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                ip_igmp_host_proxy: IpIgmpHostProxy | UndefinedType = Undefined,
                peer: str | None | UndefinedType = Undefined,
                peer_interface: str | None | UndefinedType = Undefined,
                peer_type: str | None | UndefinedType = Undefined,
                sflow: Sflow | UndefinedType = Undefined,
                vrrp_ids: VrrpIds | UndefinedType = Undefined,
                switchport: Switchport | UndefinedType = Undefined,
                traffic_engineering: TrafficEngineering | UndefinedType = Undefined,
                validate_state: bool | None | UndefinedType = Undefined,
                validate_lldp: bool | None | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                PortChannelInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: name
                    comment: Text comment added under port-channel interface.
                    description: description
                    profile: Interface profile.
                    logging: Subclass of AvdModel.
                    shutdown: shutdown
                    l2_mtu: "l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI.
                    l2_mru: "l2_mru" should only be defined for platforms supporting the "l2 mru" CLI.
                    vlans:
                       List of switchport vlans as string.
                       For a trunk port this would be a range like "1-200,300".
                       For an
                       access port this would be a single vlan "123".
                    arp_gratuitous_accept: Accept gratuitous ARP.
                    snmp_trap_link_change: snmp_trap_link_change
                    type:
                       l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
                       Interface will not be listed in device documentation, unless "type" is set.
                    encapsulation_dot1q_vlan: VLAN tag to configure on sub-interface.
                    encapsulation_dot1q:
                       Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
                       `ethernet_interfaces[].type: l2dot1q`.

                       Subclass of AvdModel.
                    vrf: VRF name.
                    encapsulation_vlan:
                       This setting can only be applied to sub-interfaces on EOS.
                       Warning: `encapsulation_vlan` should not
                       be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
                       Subclass of AvdModel.
                    vlan_id:
                       This setting can only be applied to sub-interfaces on EOS.
                       Warning: `vlan_id` should not be combined
                       with `ethernet_interfaces[].type == l2dot1q`.
                    mode: mode
                    native_vlan: If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                    native_vlan_tag: If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                    link_tracking_groups: Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`).
                    link_tracking: Subclass of AvdModel.
                    phone: Subclass of AvdModel.
                    l2_protocol: Subclass of AvdModel.
                    mtu: mtu
                    mlag: MLAG ID.
                    trunk_groups: Subclass of AvdList with `str` items.
                    lacp_fallback_timeout: Timeout in seconds. EOS default is 90 seconds.
                    min_links:
                       Minimum number of ports required up before bringing up a port-channel.
                       Maximum in `min_links` is
                       hardware dependent.
                    lacp_fallback_mode: lacp_fallback_mode
                    qos: Subclass of AvdModel.
                    bfd: Subclass of AvdModel.
                    service_policy: Subclass of AvdModel.
                    mpls: Subclass of AvdModel.
                    ntp_serve: Enable/disable serving NTP to clients.
                    trunk_private_vlan_secondary: trunk_private_vlan_secondary
                    pvlan_mapping: List of vlans as string.
                    vlan_translations: Subclass of AvdList with `VlanTranslationsItem` items.
                    shape: Subclass of AvdModel.
                    storm_control: Subclass of AvdModel.
                    ip_proxy_arp: ip_proxy_arp
                    isis_enable: ISIS instance.
                    isis_bfd: Enable BFD for ISIS.
                    isis_passive: isis_passive
                    isis_metric: isis_metric
                    isis_network_point_to_point: isis_network_point_to_point
                    isis_circuit_type: isis_circuit_type
                    isis_hello_padding: isis_hello_padding
                    isis_authentication_mode: isis_authentication_mode
                    isis_authentication_key: Type-7 encrypted password.
                    isis_authentication:
                       This key should not be mixed with port_channel_interfaces[].isis_authentication_mode or
                       ethernet_interfaces[].isis_authentication_key.

                       Subclass of AvdModel.
                    traffic_policy: Subclass of AvdModel.
                    evpn_ethernet_segment: Subclass of AvdModel.
                    lacp_id: LACP ID with format xxxx.xxxx.xxxx.
                    spanning_tree_bpdufilter: spanning_tree_bpdufilter
                    spanning_tree_bpduguard: spanning_tree_bpduguard
                    spanning_tree_guard: spanning_tree_guard
                    spanning_tree_portfast: spanning_tree_portfast
                    vmtracer: vmtracer
                    ptp: Subclass of AvdModel.
                    ip_address: IPv4 address/mask or "dhcp".
                    dhcp_client_accept_default_route: Install default-route obtained via DHCP.
                    dhcp_server_ipv4: Enable IPv4 DHCP server.
                    dhcp_server_ipv6: Enable IPv6 DHCP server.
                    ip_verify_unicast_source_reachable_via: ip_verify_unicast_source_reachable_via
                    ip_nat: Subclass of AvdModel.
                    ipv6_enable: ipv6_enable
                    ipv6_address: IPv6 address/mask.
                    ipv6_address_link_local: Link local IPv6 address/mask.
                    ipv6_nd_ra_disabled: ipv6_nd_ra_disabled
                    ipv6_nd_managed_config_flag: ipv6_nd_managed_config_flag
                    ipv6_nd_prefixes: Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`).
                    access_group_in: Access list name.
                    access_group_out: Access list name.
                    ipv6_access_group_in: IPv6 access list name.
                    ipv6_access_group_out: IPv6 access list name.
                    mac_access_group_in: MAC access list name.
                    mac_access_group_out: MAC access list name.
                    pim: Subclass of AvdModel.
                    service_profile: QOS profile.
                    ospf_network_point_to_point: ospf_network_point_to_point
                    ospf_area: ospf_area
                    ospf_cost: ospf_cost
                    ospf_authentication: ospf_authentication
                    ospf_authentication_key: Encrypted password.
                    ospf_message_digest_keys: Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`).
                    flow_tracker: Subclass of AvdModel.
                    bgp: Subclass of AvdModel.
                    ip_igmp_host_proxy: Subclass of AvdModel.
                    peer: Key only used for documentation or validation purposes.
                    peer_interface: Key only used for documentation or validation purposes.
                    peer_type: Key only used for documentation or validation purposes.
                    sflow: Subclass of AvdModel.
                    vrrp_ids:
                       VRRP model.

                       Subclass of AvdIndexedList with `VrrpIdsItem` items. Primary key is `id` (`int`).
                    switchport: Subclass of AvdModel.
                    traffic_engineering: Subclass of AvdModel.
                    validate_state:
                       Set to false to disable interface state and LLDP topology validation performed by the
                       `eos_validate_state` role.
                    validate_lldp: Set to false to disable the LLDP topology validation performed by the `eos_validate_state` role.
                    eos_cli: Multiline EOS CLI rendered directly on the port-channel interface in the final EOS configuration.

                """

    class PortChannelInterfaces(AvdIndexedList[str, PortChannelInterfacesItem]):
        """Subclass of AvdIndexedList with `PortChannelInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    PortChannelInterfaces._item_type = PortChannelInterfacesItem

    class PrefixListsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}}
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "permit 10.255.0.0/27 eq 32"
            """

            if TYPE_CHECKING:

                def __init__(self, *, sequence: int | UndefinedType = Undefined, action: str | UndefinedType = Undefined) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        action:
                           Action as string.
                           Example: "permit 10.255.0.0/27 eq 32"

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
        name: str
        """Prefix-list Name."""
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, sequence_numbers: SequenceNumbers | UndefinedType = Undefined) -> None:
                """
                PrefixListsItem.


                Subclass of AvdModel.

                Args:
                    name: Prefix-list Name.
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).

                """

    class PrefixLists(AvdIndexedList[str, PrefixListsItem]):
        """Subclass of AvdIndexedList with `PrefixListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    PrefixLists._item_type = PrefixListsItem

    class PriorityFlowControl(AvdModel):
        """Subclass of AvdModel."""

        class Watchdog(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "action": {"type": str},
                "timeout": {"type": str},
                "polling_interval": {"type": str},
                "recovery_time": {"type": str},
                "override_action_drop": {"type": bool},
            }
            action: Literal["drop", "no-drop"] | None
            """Action on stuck queue."""
            timeout: str | None
            """
            Timeout in seconds after which port should be errdisabled or
            should start dropping on congested
            priorities.
            This should be decimal with up to 2 decimal point.
            Example: 0.01 or 60
            """
            polling_interval: str | None
            """
            Time interval in seconds at which the watchdog should poll the queues.
            This should be decimal with
            up to 3 decimal point.
            Example: 0.005 or 60
            """
            recovery_time: str | None
            """
            Recovery-time in seconds after which stuck queue should
            recover and start forwarding again.
            This
            should be decimal with up to 2 decimal point.
            Example: 0.01 or 60
            """
            override_action_drop: bool | None
            """Override configured action on stuck queue to drop."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    action: Literal["drop", "no-drop"] | None | UndefinedType = Undefined,
                    timeout: str | None | UndefinedType = Undefined,
                    polling_interval: str | None | UndefinedType = Undefined,
                    recovery_time: str | None | UndefinedType = Undefined,
                    override_action_drop: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Watchdog.


                    Subclass of AvdModel.

                    Args:
                        action: Action on stuck queue.
                        timeout:
                           Timeout in seconds after which port should be errdisabled or
                           should start dropping on congested
                           priorities.
                           This should be decimal with up to 2 decimal point.
                           Example: 0.01 or 60
                        polling_interval:
                           Time interval in seconds at which the watchdog should poll the queues.
                           This should be decimal with
                           up to 3 decimal point.
                           Example: 0.005 or 60
                        recovery_time:
                           Recovery-time in seconds after which stuck queue should
                           recover and start forwarding again.
                           This
                           should be decimal with up to 2 decimal point.
                           Example: 0.01 or 60
                        override_action_drop: Override configured action on stuck queue to drop.

                    """

        _fields: ClassVar[dict] = {"all_off": {"type": bool}, "watchdog": {"type": Watchdog}}
        all_off: bool | None
        """Disable PFC on all interfaces."""
        watchdog: Watchdog
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, all_off: bool | None | UndefinedType = Undefined, watchdog: Watchdog | UndefinedType = Undefined) -> None:
                """
                PriorityFlowControl.


                Subclass of AvdModel.

                Args:
                    all_off: Disable PFC on all interfaces.
                    watchdog: Subclass of AvdModel.

                """

    class Ptp(AvdModel):
        """Subclass of AvdModel."""

        class Source(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ip": {"type": str}}
            ip: str | None
            """Source IP."""

            if TYPE_CHECKING:

                def __init__(self, *, ip: str | None | UndefinedType = Undefined) -> None:
                    """
                    Source.


                    Subclass of AvdModel.

                    Args:
                        ip: Source IP.

                    """

        class MessageType(AvdModel):
            """Subclass of AvdModel."""

            class General(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"dscp": {"type": int}}
                dscp: int | None

                if TYPE_CHECKING:

                    def __init__(self, *, dscp: int | None | UndefinedType = Undefined) -> None:
                        """
                        General.


                        Subclass of AvdModel.

                        Args:
                            dscp: dscp

                        """

            class Event(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"dscp": {"type": int}}
                dscp: int | None

                if TYPE_CHECKING:

                    def __init__(self, *, dscp: int | None | UndefinedType = Undefined) -> None:
                        """
                        Event.


                        Subclass of AvdModel.

                        Args:
                            dscp: dscp

                        """

            _fields: ClassVar[dict] = {"general": {"type": General}, "event": {"type": Event}}
            general: General
            """Subclass of AvdModel."""
            event: Event
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, general: General | UndefinedType = Undefined, event: Event | UndefinedType = Undefined) -> None:
                    """
                    MessageType.


                    Subclass of AvdModel.

                    Args:
                        general: Subclass of AvdModel.
                        event: Subclass of AvdModel.

                    """

        class Monitor(AvdModel):
            """Subclass of AvdModel."""

            class Threshold(AvdModel):
                """Subclass of AvdModel."""

                class Drop(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"offset_from_master": {"type": int}, "mean_path_delay": {"type": int}}
                    offset_from_master: int | None
                    mean_path_delay: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, offset_from_master: int | None | UndefinedType = Undefined, mean_path_delay: int | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            Drop.


                            Subclass of AvdModel.

                            Args:
                                offset_from_master: offset_from_master
                                mean_path_delay: mean_path_delay

                            """

                _fields: ClassVar[dict] = {"offset_from_master": {"type": int}, "mean_path_delay": {"type": int}, "drop": {"type": Drop}}
                offset_from_master: int | None
                mean_path_delay: int | None
                drop: Drop
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        offset_from_master: int | None | UndefinedType = Undefined,
                        mean_path_delay: int | None | UndefinedType = Undefined,
                        drop: Drop | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Threshold.


                        Subclass of AvdModel.

                        Args:
                            offset_from_master: offset_from_master
                            mean_path_delay: mean_path_delay
                            drop: Subclass of AvdModel.

                        """

            class MissingMessage(AvdModel):
                """Subclass of AvdModel."""

                class Intervals(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"announce": {"type": int}, "follow_up": {"type": int}, "sync": {"type": int}}
                    announce: int | None
                    follow_up: int | None
                    sync: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            announce: int | None | UndefinedType = Undefined,
                            follow_up: int | None | UndefinedType = Undefined,
                            sync: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Intervals.


                            Subclass of AvdModel.

                            Args:
                                announce: announce
                                follow_up: follow_up
                                sync: sync

                            """

                class SequenceIds(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "announce": {"type": int},
                        "delay_resp": {"type": int},
                        "follow_up": {"type": int},
                        "sync": {"type": int},
                    }
                    enabled: bool | None
                    announce: int | None
                    delay_resp: int | None
                    follow_up: int | None
                    sync: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            announce: int | None | UndefinedType = Undefined,
                            delay_resp: int | None | UndefinedType = Undefined,
                            follow_up: int | None | UndefinedType = Undefined,
                            sync: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SequenceIds.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                announce: announce
                                delay_resp: delay_resp
                                follow_up: follow_up
                                sync: sync

                            """

                _fields: ClassVar[dict] = {"intervals": {"type": Intervals}, "sequence_ids": {"type": SequenceIds}}
                intervals: Intervals
                """Subclass of AvdModel."""
                sequence_ids: SequenceIds
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, intervals: Intervals | UndefinedType = Undefined, sequence_ids: SequenceIds | UndefinedType = Undefined) -> None:
                        """
                        MissingMessage.


                        Subclass of AvdModel.

                        Args:
                            intervals: Subclass of AvdModel.
                            sequence_ids: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool, "default": True},
                "threshold": {"type": Threshold},
                "missing_message": {"type": MissingMessage},
            }
            enabled: bool
            """Default value: `True`"""
            threshold: Threshold
            """Subclass of AvdModel."""
            missing_message: MissingMessage
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    threshold: Threshold | UndefinedType = Undefined,
                    missing_message: MissingMessage | UndefinedType = Undefined,
                ) -> None:
                    """
                    Monitor.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        threshold: Subclass of AvdModel.
                        missing_message: Subclass of AvdModel.

                    """

        class FreeRunning(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "source_clock_hardware": {"type": bool}}
            enabled: bool
            """
            Enables PTP configuration in free-running mode.
            When set to true, the boundary clock can start
            serving PTP downstream even before it locks to an upstream master.
            When set to false, the clock will
            not start serving PTP downstream before it has successfully locked to an upstream master.
            """
            source_clock_hardware: bool | None
            """When enabled, the hardware clock is used as the source for PTP time during free-running mode."""

            if TYPE_CHECKING:

                def __init__(self, *, enabled: bool | UndefinedType = Undefined, source_clock_hardware: bool | None | UndefinedType = Undefined) -> None:
                    """
                    FreeRunning.


                    Subclass of AvdModel.

                    Args:
                        enabled:
                           Enables PTP configuration in free-running mode.
                           When set to true, the boundary clock can start
                           serving PTP downstream even before it locks to an upstream master.
                           When set to false, the clock will
                           not start serving PTP downstream before it has successfully locked to an upstream master.
                        source_clock_hardware: When enabled, the hardware clock is used as the source for PTP time during free-running mode.

                    """

        _fields: ClassVar[dict] = {
            "mode": {"type": str},
            "profile": {"type": str},
            "mode_one_step": {"type": bool},
            "forward_unicast": {"type": bool},
            "clock_identity": {"type": str},
            "source": {"type": Source},
            "priority1": {"type": int},
            "priority2": {"type": int},
            "ttl": {"type": int},
            "domain": {"type": int},
            "hold_ptp_time": {"type": int},
            "message_type": {"type": MessageType},
            "monitor": {"type": Monitor},
            "free_running": {"type": FreeRunning},
            "forward_v1": {"type": bool},
        }
        mode: Literal["boundary", "disabled", "e2etransparent", "gptp", "ordinarymaster", "p2ptransparent"] | None
        profile: Literal["g8275.1", "g8275.2"] | None
        mode_one_step: bool | None
        forward_unicast: bool | None
        clock_identity: str | None
        """The clock-id in xx:xx:xx:xx:xx:xx format."""
        source: Source
        """Subclass of AvdModel."""
        priority1: int | None
        priority2: int | None
        ttl: int | None
        domain: int | None
        hold_ptp_time: int | None
        """
        The length of time that PTP will remain in hold-down on the internal oscillator if the connection to
        the GM is lost.
        If a new GM is not elected before the expiry of the hold-down time, the clock will
        revert to free-running.
        Some platforms support larger maximum values, however 172000 seconds was the
        max for 7150 series, and was widely used.
        """
        message_type: MessageType
        """Subclass of AvdModel."""
        monitor: Monitor
        """Subclass of AvdModel."""
        free_running: FreeRunning
        """Subclass of AvdModel."""
        forward_v1: bool | None
        """Forward dataplane PTP V1 packets."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                mode: Literal["boundary", "disabled", "e2etransparent", "gptp", "ordinarymaster", "p2ptransparent"] | None | UndefinedType = Undefined,
                profile: Literal["g8275.1", "g8275.2"] | None | UndefinedType = Undefined,
                mode_one_step: bool | None | UndefinedType = Undefined,
                forward_unicast: bool | None | UndefinedType = Undefined,
                clock_identity: str | None | UndefinedType = Undefined,
                source: Source | UndefinedType = Undefined,
                priority1: int | None | UndefinedType = Undefined,
                priority2: int | None | UndefinedType = Undefined,
                ttl: int | None | UndefinedType = Undefined,
                domain: int | None | UndefinedType = Undefined,
                hold_ptp_time: int | None | UndefinedType = Undefined,
                message_type: MessageType | UndefinedType = Undefined,
                monitor: Monitor | UndefinedType = Undefined,
                free_running: FreeRunning | UndefinedType = Undefined,
                forward_v1: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ptp.


                Subclass of AvdModel.

                Args:
                    mode: mode
                    profile: profile
                    mode_one_step: mode_one_step
                    forward_unicast: forward_unicast
                    clock_identity: The clock-id in xx:xx:xx:xx:xx:xx format.
                    source: Subclass of AvdModel.
                    priority1: priority1
                    priority2: priority2
                    ttl: ttl
                    domain: domain
                    hold_ptp_time:
                       The length of time that PTP will remain in hold-down on the internal oscillator if the connection to
                       the GM is lost.
                       If a new GM is not elected before the expiry of the hold-down time, the clock will
                       revert to free-running.
                       Some platforms support larger maximum values, however 172000 seconds was the
                       max for 7150 series, and was widely used.
                    message_type: Subclass of AvdModel.
                    monitor: Subclass of AvdModel.
                    free_running: Subclass of AvdModel.
                    forward_v1: Forward dataplane PTP V1 packets.

                """

    class Qos(AvdModel):
        """Subclass of AvdModel."""

        class Map(AvdModel):
            """Subclass of AvdModel."""

            class Cos(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Cos._item_type = str

            class Dscp(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Dscp._item_type = str

            class Exp(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Exp._item_type = str

            class TrafficClass(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            TrafficClass._item_type = str

            _fields: ClassVar[dict] = {"cos": {"type": Cos}, "dscp": {"type": Dscp}, "exp": {"type": Exp}, "traffic_class": {"type": TrafficClass}}
            cos: Cos
            """Subclass of AvdList with `str` items."""
            dscp: Dscp
            """Subclass of AvdList with `str` items."""
            exp: Exp
            """Subclass of AvdList with `str` items."""
            traffic_class: TrafficClass
            """Subclass of AvdList with `str` items."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    cos: Cos | UndefinedType = Undefined,
                    dscp: Dscp | UndefinedType = Undefined,
                    exp: Exp | UndefinedType = Undefined,
                    traffic_class: TrafficClass | UndefinedType = Undefined,
                ) -> None:
                    """
                    Map.


                    Subclass of AvdModel.

                    Args:
                        cos: Subclass of AvdList with `str` items.
                        dscp: Subclass of AvdList with `str` items.
                        exp: Subclass of AvdList with `str` items.
                        traffic_class: Subclass of AvdList with `str` items.

                    """

        class RandomDetect(AvdModel):
            """Subclass of AvdModel."""

            class Ecn(AvdModel):
                """Subclass of AvdModel."""

                class AllowNonEct(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "chip_based": {"type": bool}}
                    enabled: bool | None
                    """
                    Allow non-ect and set drop-precedence 1 in a policy map simultaneously.
                    Check which command is
                    required for your platform.
                    """
                    chip_based: bool | None
                    """Allow non-ect chip-based."""

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, chip_based: bool | None | UndefinedType = Undefined) -> None:
                            """
                            AllowNonEct.


                            Subclass of AvdModel.

                            Args:
                                enabled:
                                   Allow non-ect and set drop-precedence 1 in a policy map simultaneously.
                                   Check which command is
                                   required for your platform.
                                chip_based: Allow non-ect chip-based.

                            """

                _fields: ClassVar[dict] = {"allow_non_ect": {"type": AllowNonEct}}
                allow_non_ect: AllowNonEct
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, allow_non_ect: AllowNonEct | UndefinedType = Undefined) -> None:
                        """
                        Ecn.


                        Subclass of AvdModel.

                        Args:
                            allow_non_ect: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"ecn": {"type": Ecn}}
            ecn: Ecn
            """
            Global ECN Configuration.

            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(self, *, ecn: Ecn | UndefinedType = Undefined) -> None:
                    """
                    RandomDetect.


                    Subclass of AvdModel.

                    Args:
                        ecn:
                           Global ECN Configuration.

                           Subclass of AvdModel.

                    """

        class TxQueue(AvdModel):
            """Subclass of AvdModel."""

            class QueuesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"id": {"type": int}, "scheduler_profile_responsive": {"type": bool}}
                id: int
                """Queue ID."""
                scheduler_profile_responsive: bool | None
                """Set scheduler profile to optimize latency at the expense of burstiness."""

                if TYPE_CHECKING:

                    def __init__(self, *, id: int | UndefinedType = Undefined, scheduler_profile_responsive: bool | None | UndefinedType = Undefined) -> None:
                        """
                        QueuesItem.


                        Subclass of AvdModel.

                        Args:
                            id: Queue ID.
                            scheduler_profile_responsive: Set scheduler profile to optimize latency at the expense of burstiness.

                        """

            class Queues(AvdIndexedList[int, QueuesItem]):
                """Subclass of AvdIndexedList with `QueuesItem` items. Primary key is `id` (`int`)."""

                _primary_key: ClassVar[str] = "id"

            Queues._item_type = QueuesItem

            _fields: ClassVar[dict] = {"shape_rate_percent_adaptive": {"type": bool}, "queues": {"type": Queues}}
            shape_rate_percent_adaptive: bool | None
            """Use the parent available bandwidth for transmit queue percentage-based allocation."""
            queues: Queues
            """Subclass of AvdIndexedList with `QueuesItem` items. Primary key is `id` (`int`)."""

            if TYPE_CHECKING:

                def __init__(self, *, shape_rate_percent_adaptive: bool | None | UndefinedType = Undefined, queues: Queues | UndefinedType = Undefined) -> None:
                    """
                    TxQueue.


                    Subclass of AvdModel.

                    Args:
                        shape_rate_percent_adaptive: Use the parent available bandwidth for transmit queue percentage-based allocation.
                        queues: Subclass of AvdIndexedList with `QueuesItem` items. Primary key is `id` (`int`).

                    """

        _fields: ClassVar[dict] = {"map": {"type": Map}, "rewrite_dscp": {"type": bool}, "random_detect": {"type": RandomDetect}, "tx_queue": {"type": TxQueue}}
        map: Map
        """Subclass of AvdModel."""
        rewrite_dscp: bool | None
        random_detect: RandomDetect
        """
        Global random-detect settings.

        Subclass of AvdModel.
        """
        tx_queue: TxQueue
        """
        Global transmit queue settings.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                map: Map | UndefinedType = Undefined,
                rewrite_dscp: bool | None | UndefinedType = Undefined,
                random_detect: RandomDetect | UndefinedType = Undefined,
                tx_queue: TxQueue | UndefinedType = Undefined,
            ) -> None:
                """
                Qos.


                Subclass of AvdModel.

                Args:
                    map: Subclass of AvdModel.
                    rewrite_dscp: rewrite_dscp
                    random_detect:
                       Global random-detect settings.

                       Subclass of AvdModel.
                    tx_queue:
                       Global transmit queue settings.

                       Subclass of AvdModel.

                """

    class QosProfilesItem(AvdModel):
        """Subclass of AvdModel."""

        class Shape(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"rate": {"type": str}}
            rate: str | None
            """
            Supported options are platform dependent.
            Example: "< rate > kbps", "1-100 percent", "< rate > pps"
            """

            if TYPE_CHECKING:

                def __init__(self, *, rate: str | None | UndefinedType = Undefined) -> None:
                    """
                    Shape.


                    Subclass of AvdModel.

                    Args:
                        rate:
                           Supported options are platform dependent.
                           Example: "< rate > kbps", "1-100 percent", "< rate > pps"

                    """

        class ServicePolicy(AvdModel):
            """Subclass of AvdModel."""

            class Type(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"qos_input": {"type": str}}
                qos_input: str | None
                """Policy-map name."""

                if TYPE_CHECKING:

                    def __init__(self, *, qos_input: str | None | UndefinedType = Undefined) -> None:
                        """
                        Type.


                        Subclass of AvdModel.

                        Args:
                            qos_input: Policy-map name.

                        """

            _fields: ClassVar[dict] = {"type": {"type": Type}}
            type: Type
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, type: Type | UndefinedType = Undefined) -> None:
                    """
                    ServicePolicy.


                    Subclass of AvdModel.

                    Args:
                        type: Subclass of AvdModel.

                    """

        class TxQueuesItem(AvdModel):
            """Subclass of AvdModel."""

            class Shape(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"rate": {"type": str}}
                rate: str | None
                """
                Supported options are platform dependent.
                Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                """

                if TYPE_CHECKING:

                    def __init__(self, *, rate: str | None | UndefinedType = Undefined) -> None:
                        """
                        Shape.


                        Subclass of AvdModel.

                        Args:
                            rate:
                               Supported options are platform dependent.
                               Example: "< rate > kbps", "1-100 percent", "< rate > pps"

                        """

            class RandomDetect(AvdModel):
                """Subclass of AvdModel."""

                class Ecn(AvdModel):
                    """Subclass of AvdModel."""

                    class Threshold(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "units": {"type": str},
                            "min": {"type": int},
                            "max": {"type": int},
                            "max_probability": {"type": int},
                            "weight": {"type": int},
                        }
                        units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds", "microseconds"]
                        """Units to be used for the threshold values."""
                        min: int
                        """Random-detect ECN minimum-threshold."""
                        max: int
                        """Random-detect ECN maximum-threshold."""
                        max_probability: int | None
                        """Random-detect ECN maximum mark probability."""
                        weight: int | None
                        """Random-detect ECN weight."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds", "microseconds"] | UndefinedType = Undefined,
                                min: int | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                max_probability: int | None | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Threshold.


                                Subclass of AvdModel.

                                Args:
                                    units: Units to be used for the threshold values.
                                    min: Random-detect ECN minimum-threshold.
                                    max: Random-detect ECN maximum-threshold.
                                    max_probability: Random-detect ECN maximum mark probability.
                                    weight: Random-detect ECN weight.

                                """

                    _fields: ClassVar[dict] = {"count": {"type": bool}, "threshold": {"type": Threshold}}
                    count: bool | None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, count: bool | None | UndefinedType = Undefined, threshold: Threshold | UndefinedType = Undefined) -> None:
                            """
                            Ecn.


                            Subclass of AvdModel.

                            Args:
                                count: Enable counter for random-detect ECNs.
                                threshold: Subclass of AvdModel.

                            """

                class Drop(AvdModel):
                    """Subclass of AvdModel."""

                    class Threshold(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "units": {"type": str},
                            "drop_precedence": {"type": int},
                            "min": {"type": int},
                            "max": {"type": int},
                            "drop_probability": {"type": int},
                            "weight": {"type": int},
                        }
                        units: Literal["segments", "bytes", "kbytes", "mbytes", "microseconds", "milliseconds"]
                        """Units to be used for the threshold values."""
                        drop_precedence: int | None
                        """Specify Drop Precedence value."""
                        min: int
                        """WRED minimum-threshold."""
                        max: int
                        """WRED maximum-threshold."""
                        drop_probability: int
                        """WRED drop probability."""
                        weight: int | None
                        """WRED weight."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                units: Literal["segments", "bytes", "kbytes", "mbytes", "microseconds", "milliseconds"] | UndefinedType = Undefined,
                                drop_precedence: int | None | UndefinedType = Undefined,
                                min: int | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                drop_probability: int | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Threshold.


                                Subclass of AvdModel.

                                Args:
                                    units: Units to be used for the threshold values.
                                    drop_precedence: Specify Drop Precedence value.
                                    min: WRED minimum-threshold.
                                    max: WRED maximum-threshold.
                                    drop_probability: WRED drop probability.
                                    weight: WRED weight.

                                """

                    _fields: ClassVar[dict] = {"threshold": {"type": Threshold}}
                    threshold: Threshold
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, threshold: Threshold | UndefinedType = Undefined) -> None:
                            """
                            Drop.


                            Subclass of AvdModel.

                            Args:
                                threshold: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {"ecn": {"type": Ecn}, "drop": {"type": Drop}}
                ecn: Ecn
                """
                Explicit Congestion Notification.

                Subclass of AvdModel.
                """
                drop: Drop
                """
                Set WRED parameters.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, ecn: Ecn | UndefinedType = Undefined, drop: Drop | UndefinedType = Undefined) -> None:
                        """
                        RandomDetect.


                        Subclass of AvdModel.

                        Args:
                            ecn:
                               Explicit Congestion Notification.

                               Subclass of AvdModel.
                            drop:
                               Set WRED parameters.

                               Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "bandwidth_percent": {"type": int},
                "bandwidth_guaranteed_percent": {"type": int},
                "priority": {"type": str},
                "shape": {"type": Shape},
                "comment": {"type": str},
                "random_detect": {"type": RandomDetect},
            }
            id: int
            """TX-Queue ID."""
            bandwidth_percent: int | None
            bandwidth_guaranteed_percent: int | None
            priority: Literal["priority strict", "no priority"] | None
            shape: Shape
            """Subclass of AvdModel."""
            comment: str | None
            """Text comment added to queue."""
            random_detect: RandomDetect
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    bandwidth_percent: int | None | UndefinedType = Undefined,
                    bandwidth_guaranteed_percent: int | None | UndefinedType = Undefined,
                    priority: Literal["priority strict", "no priority"] | None | UndefinedType = Undefined,
                    shape: Shape | UndefinedType = Undefined,
                    comment: str | None | UndefinedType = Undefined,
                    random_detect: RandomDetect | UndefinedType = Undefined,
                ) -> None:
                    """
                    TxQueuesItem.


                    Subclass of AvdModel.

                    Args:
                        id: TX-Queue ID.
                        bandwidth_percent: bandwidth_percent
                        bandwidth_guaranteed_percent: bandwidth_guaranteed_percent
                        priority: priority
                        shape: Subclass of AvdModel.
                        comment: Text comment added to queue.
                        random_detect: Subclass of AvdModel.

                    """

        class TxQueues(AvdIndexedList[int, TxQueuesItem]):
            """Subclass of AvdIndexedList with `TxQueuesItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        TxQueues._item_type = TxQueuesItem

        class UcTxQueuesItem(AvdModel):
            """Subclass of AvdModel."""

            class Shape(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"rate": {"type": str}}
                rate: str | None
                """
                Supported options are platform dependent.
                Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                """

                if TYPE_CHECKING:

                    def __init__(self, *, rate: str | None | UndefinedType = Undefined) -> None:
                        """
                        Shape.


                        Subclass of AvdModel.

                        Args:
                            rate:
                               Supported options are platform dependent.
                               Example: "< rate > kbps", "1-100 percent", "< rate > pps"

                        """

            class RandomDetect(AvdModel):
                """Subclass of AvdModel."""

                class Ecn(AvdModel):
                    """Subclass of AvdModel."""

                    class Threshold(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "units": {"type": str},
                            "min": {"type": int},
                            "max": {"type": int},
                            "max_probability": {"type": int},
                            "weight": {"type": int},
                        }
                        units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"]
                        """Unit to be used for the threshold values."""
                        min: int
                        """Random-detect ECN minimum-threshold."""
                        max: int
                        """Random-detect ECN maximum-threshold."""
                        max_probability: int | None
                        """Random-detect ECN maximum mark probability."""
                        weight: int | None
                        """Random-detect ECN weight."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"] | UndefinedType = Undefined,
                                min: int | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                max_probability: int | None | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Threshold.


                                Subclass of AvdModel.

                                Args:
                                    units: Unit to be used for the threshold values.
                                    min: Random-detect ECN minimum-threshold.
                                    max: Random-detect ECN maximum-threshold.
                                    max_probability: Random-detect ECN maximum mark probability.
                                    weight: Random-detect ECN weight.

                                """

                    _fields: ClassVar[dict] = {"count": {"type": bool}, "threshold": {"type": Threshold}}
                    count: bool | None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, count: bool | None | UndefinedType = Undefined, threshold: Threshold | UndefinedType = Undefined) -> None:
                            """
                            Ecn.


                            Subclass of AvdModel.

                            Args:
                                count: Enable counter for random-detect ECNs.
                                threshold: Subclass of AvdModel.

                            """

                class Drop(AvdModel):
                    """Subclass of AvdModel."""

                    class Threshold(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "units": {"type": str},
                            "drop_precedence": {"type": int},
                            "min": {"type": int},
                            "max": {"type": int},
                            "drop_probability": {"type": int},
                            "weight": {"type": int},
                        }
                        units: Literal["segments", "bytes", "kbytes", "mbytes", "microseconds", "milliseconds"]
                        """Units to be used for the threshold values."""
                        drop_precedence: int | None
                        """Specify Drop Precedence value."""
                        min: int
                        """WRED minimum-threshold."""
                        max: int
                        """WRED maximum-threshold."""
                        drop_probability: int
                        """WRED drop probability."""
                        weight: int | None
                        """WRED weight."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                units: Literal["segments", "bytes", "kbytes", "mbytes", "microseconds", "milliseconds"] | UndefinedType = Undefined,
                                drop_precedence: int | None | UndefinedType = Undefined,
                                min: int | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                drop_probability: int | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Threshold.


                                Subclass of AvdModel.

                                Args:
                                    units: Units to be used for the threshold values.
                                    drop_precedence: Specify Drop Precedence value.
                                    min: WRED minimum-threshold.
                                    max: WRED maximum-threshold.
                                    drop_probability: WRED drop probability.
                                    weight: WRED weight.

                                """

                    _fields: ClassVar[dict] = {"threshold": {"type": Threshold}}
                    threshold: Threshold
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, threshold: Threshold | UndefinedType = Undefined) -> None:
                            """
                            Drop.


                            Subclass of AvdModel.

                            Args:
                                threshold: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {"ecn": {"type": Ecn}, "drop": {"type": Drop}}
                ecn: Ecn
                """
                Explicit Congestion Notification.

                Subclass of AvdModel.
                """
                drop: Drop
                """
                Set WRED parameters.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, ecn: Ecn | UndefinedType = Undefined, drop: Drop | UndefinedType = Undefined) -> None:
                        """
                        RandomDetect.


                        Subclass of AvdModel.

                        Args:
                            ecn:
                               Explicit Congestion Notification.

                               Subclass of AvdModel.
                            drop:
                               Set WRED parameters.

                               Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "bandwidth_percent": {"type": int},
                "bandwidth_guaranteed_percent": {"type": int},
                "priority": {"type": str},
                "shape": {"type": Shape},
                "comment": {"type": str},
                "random_detect": {"type": RandomDetect},
            }
            id: int
            """UC TX queue ID."""
            bandwidth_percent: int | None
            bandwidth_guaranteed_percent: int | None
            priority: Literal["priority strict", "no priority"] | None
            shape: Shape
            """Subclass of AvdModel."""
            comment: str | None
            """Text comment added to queue."""
            random_detect: RandomDetect
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    bandwidth_percent: int | None | UndefinedType = Undefined,
                    bandwidth_guaranteed_percent: int | None | UndefinedType = Undefined,
                    priority: Literal["priority strict", "no priority"] | None | UndefinedType = Undefined,
                    shape: Shape | UndefinedType = Undefined,
                    comment: str | None | UndefinedType = Undefined,
                    random_detect: RandomDetect | UndefinedType = Undefined,
                ) -> None:
                    """
                    UcTxQueuesItem.


                    Subclass of AvdModel.

                    Args:
                        id: UC TX queue ID.
                        bandwidth_percent: bandwidth_percent
                        bandwidth_guaranteed_percent: bandwidth_guaranteed_percent
                        priority: priority
                        shape: Subclass of AvdModel.
                        comment: Text comment added to queue.
                        random_detect: Subclass of AvdModel.

                    """

        class UcTxQueues(AvdIndexedList[int, UcTxQueuesItem]):
            """Subclass of AvdIndexedList with `UcTxQueuesItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        UcTxQueues._item_type = UcTxQueuesItem

        class McTxQueuesItem(AvdModel):
            """Subclass of AvdModel."""

            class Shape(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"rate": {"type": str}}
                rate: str | None
                """
                Supported options are platform dependent.
                Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                """

                if TYPE_CHECKING:

                    def __init__(self, *, rate: str | None | UndefinedType = Undefined) -> None:
                        """
                        Shape.


                        Subclass of AvdModel.

                        Args:
                            rate:
                               Supported options are platform dependent.
                               Example: "< rate > kbps", "1-100 percent", "< rate > pps"

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "bandwidth_percent": {"type": int},
                "bandwidth_guaranteed_percent": {"type": int},
                "priority": {"type": str},
                "shape": {"type": Shape},
                "comment": {"type": str},
            }
            id: int
            """MC TX queue ID."""
            bandwidth_percent: int | None
            bandwidth_guaranteed_percent: int | None
            priority: Literal["priority strict", "no priority"] | None
            shape: Shape
            """Subclass of AvdModel."""
            comment: str | None
            """Text comment added to queue."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    bandwidth_percent: int | None | UndefinedType = Undefined,
                    bandwidth_guaranteed_percent: int | None | UndefinedType = Undefined,
                    priority: Literal["priority strict", "no priority"] | None | UndefinedType = Undefined,
                    shape: Shape | UndefinedType = Undefined,
                    comment: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    McTxQueuesItem.


                    Subclass of AvdModel.

                    Args:
                        id: MC TX queue ID.
                        bandwidth_percent: bandwidth_percent
                        bandwidth_guaranteed_percent: bandwidth_guaranteed_percent
                        priority: priority
                        shape: Subclass of AvdModel.
                        comment: Text comment added to queue.

                    """

        class McTxQueues(AvdIndexedList[int, McTxQueuesItem]):
            """Subclass of AvdIndexedList with `McTxQueuesItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        McTxQueues._item_type = McTxQueuesItem

        class PriorityFlowControl(AvdModel):
            """Subclass of AvdModel."""

            class Watchdog(AvdModel):
                """Subclass of AvdModel."""

                class Timer(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "timeout": {"type": str},
                        "polling_interval": {"type": str},
                        "recovery_time": {"type": str},
                        "forced": {"type": bool},
                    }
                    timeout: str
                    """
                    Timeout in seconds after which port should be errdisabled or
                    should start dropping on congested
                    priorities.
                    This should be decimal with up to 2 decimal point.
                    Example: 0.01 or 60
                    """
                    polling_interval: str
                    """
                    Time interval in seconds at which the watchdog should poll the queues.
                    This should be decimal with
                    up to 3 decimal point or set
                    to 'auto' based on recovery_time and timeout values.
                    Example: 0.005 or
                    60
                    """
                    recovery_time: str
                    """
                    Recovery-time in seconds after which stuck queue should
                    recover and start forwarding again.
                    This
                    should be decimal with up to 2 decimal point.
                    Example: 0.01 or 60
                    """
                    forced: bool | None
                    """
                    Force recover any stuck queue(s) after the duration,
                    irrespective of whether PFC frames are being
                    received or not.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            timeout: str | UndefinedType = Undefined,
                            polling_interval: str | UndefinedType = Undefined,
                            recovery_time: str | UndefinedType = Undefined,
                            forced: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Timer.


                            Subclass of AvdModel.

                            Args:
                                timeout:
                                   Timeout in seconds after which port should be errdisabled or
                                   should start dropping on congested
                                   priorities.
                                   This should be decimal with up to 2 decimal point.
                                   Example: 0.01 or 60
                                polling_interval:
                                   Time interval in seconds at which the watchdog should poll the queues.
                                   This should be decimal with
                                   up to 3 decimal point or set
                                   to 'auto' based on recovery_time and timeout values.
                                   Example: 0.005 or
                                   60
                                recovery_time:
                                   Recovery-time in seconds after which stuck queue should
                                   recover and start forwarding again.
                                   This
                                   should be decimal with up to 2 decimal point.
                                   Example: 0.01 or 60
                                forced:
                                   Force recover any stuck queue(s) after the duration,
                                   irrespective of whether PFC frames are being
                                   received or not.

                            """

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "action": {"type": str}, "timer": {"type": Timer}}
                enabled: bool
                """Enable the watchdog on stuck transmit queues."""
                action: Literal["drop", "notify-only"] | None
                """
                Override the default error-disable action to either drop
                traffic on the stuck queue or notify-only
                without making any actions on the stuck queue.
                """
                timer: Timer
                """
                Timer thresholds whilst monitoring queues.


                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        action: Literal["drop", "notify-only"] | None | UndefinedType = Undefined,
                        timer: Timer | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Watchdog.


                        Subclass of AvdModel.

                        Args:
                            enabled: Enable the watchdog on stuck transmit queues.
                            action:
                               Override the default error-disable action to either drop
                               traffic on the stuck queue or notify-only
                               without making any actions on the stuck queue.
                            timer:
                               Timer thresholds whilst monitoring queues.


                               Subclass of AvdModel.

                        """

            class PrioritiesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"priority": {"type": int}, "no_drop": {"type": bool}}
                priority: int
                """Priority queue number (COS value)."""
                no_drop: bool
                """Enable Priority Flow Control frames on this queue."""

                if TYPE_CHECKING:

                    def __init__(self, *, priority: int | UndefinedType = Undefined, no_drop: bool | UndefinedType = Undefined) -> None:
                        """
                        PrioritiesItem.


                        Subclass of AvdModel.

                        Args:
                            priority: Priority queue number (COS value).
                            no_drop: Enable Priority Flow Control frames on this queue.

                        """

            class Priorities(AvdIndexedList[int, PrioritiesItem]):
                """Subclass of AvdIndexedList with `PrioritiesItem` items. Primary key is `priority` (`int`)."""

                _primary_key: ClassVar[str] = "priority"

            Priorities._item_type = PrioritiesItem

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "watchdog": {"type": Watchdog}, "priorities": {"type": Priorities}}
            enabled: bool | None
            """Enable Priority Flow control."""
            watchdog: Watchdog
            """
            Watchdog can detect stuck transmit queues.


            Subclass of AvdModel.
            """
            priorities: Priorities
            """
            Set the drop/no_drop on each queue.


            Subclass of AvdIndexedList with `PrioritiesItem` items.
            Primary key is `priority` (`int`).
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    watchdog: Watchdog | UndefinedType = Undefined,
                    priorities: Priorities | UndefinedType = Undefined,
                ) -> None:
                    """
                    PriorityFlowControl.


                    Subclass of AvdModel.

                    Args:
                        enabled: Enable Priority Flow control.
                        watchdog:
                           Watchdog can detect stuck transmit queues.


                           Subclass of AvdModel.
                        priorities:
                           Set the drop/no_drop on each queue.


                           Subclass of AvdIndexedList with `PrioritiesItem` items.
                           Primary key is `priority` (`int`).

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "trust": {"type": str},
            "cos": {"type": int},
            "dscp": {"type": int},
            "shape": {"type": Shape},
            "service_policy": {"type": ServicePolicy},
            "tx_queues": {"type": TxQueues},
            "uc_tx_queues": {"type": UcTxQueues},
            "mc_tx_queues": {"type": McTxQueues},
            "priority_flow_control": {"type": PriorityFlowControl},
        }
        name: str
        """Profile-Name."""
        trust: Literal["cos", "dscp", "disabled"] | None
        cos: int | None
        dscp: int | None
        shape: Shape
        """Subclass of AvdModel."""
        service_policy: ServicePolicy
        """Subclass of AvdModel."""
        tx_queues: TxQueues
        """Subclass of AvdIndexedList with `TxQueuesItem` items. Primary key is `id` (`int`)."""
        uc_tx_queues: UcTxQueues
        """Subclass of AvdIndexedList with `UcTxQueuesItem` items. Primary key is `id` (`int`)."""
        mc_tx_queues: McTxQueues
        """Subclass of AvdIndexedList with `McTxQueuesItem` items. Primary key is `id` (`int`)."""
        priority_flow_control: PriorityFlowControl
        """
        Priority Flow Control settings.


        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                trust: Literal["cos", "dscp", "disabled"] | None | UndefinedType = Undefined,
                cos: int | None | UndefinedType = Undefined,
                dscp: int | None | UndefinedType = Undefined,
                shape: Shape | UndefinedType = Undefined,
                service_policy: ServicePolicy | UndefinedType = Undefined,
                tx_queues: TxQueues | UndefinedType = Undefined,
                uc_tx_queues: UcTxQueues | UndefinedType = Undefined,
                mc_tx_queues: McTxQueues | UndefinedType = Undefined,
                priority_flow_control: PriorityFlowControl | UndefinedType = Undefined,
            ) -> None:
                """
                QosProfilesItem.


                Subclass of AvdModel.

                Args:
                    name: Profile-Name.
                    trust: trust
                    cos: cos
                    dscp: dscp
                    shape: Subclass of AvdModel.
                    service_policy: Subclass of AvdModel.
                    tx_queues: Subclass of AvdIndexedList with `TxQueuesItem` items. Primary key is `id` (`int`).
                    uc_tx_queues: Subclass of AvdIndexedList with `UcTxQueuesItem` items. Primary key is `id` (`int`).
                    mc_tx_queues: Subclass of AvdIndexedList with `McTxQueuesItem` items. Primary key is `id` (`int`).
                    priority_flow_control:
                       Priority Flow Control settings.


                       Subclass of AvdModel.

                """

    class QosProfiles(AvdIndexedList[str, QosProfilesItem]):
        """Subclass of AvdIndexedList with `QosProfilesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    QosProfiles._item_type = QosProfilesItem

    class QueueMonitorLength(AvdModel):
        """Subclass of AvdModel."""

        class DefaultThresholds(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"high": {"type": int}, "low": {"type": int}}
            high: int
            """Default high threshold for Ethernet Interfaces."""
            low: int | None
            """
            Default low threshold for Ethernet Interfaces.
            Low threshold support is platform dependent.
            """

            if TYPE_CHECKING:

                def __init__(self, *, high: int | UndefinedType = Undefined, low: int | None | UndefinedType = Undefined) -> None:
                    """
                    DefaultThresholds.


                    Subclass of AvdModel.

                    Args:
                        high: Default high threshold for Ethernet Interfaces.
                        low:
                           Default low threshold for Ethernet Interfaces.
                           Low threshold support is platform dependent.

                    """

        class Cpu(AvdModel):
            """Subclass of AvdModel."""

            class Thresholds(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"high": {"type": int}, "low": {"type": int}}
                high: int
                low: int | None

                if TYPE_CHECKING:

                    def __init__(self, *, high: int | UndefinedType = Undefined, low: int | None | UndefinedType = Undefined) -> None:
                        """
                        Thresholds.


                        Subclass of AvdModel.

                        Args:
                            high: high
                            low: low

                        """

            _fields: ClassVar[dict] = {"thresholds": {"type": Thresholds}}
            thresholds: Thresholds
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, thresholds: Thresholds | UndefinedType = Undefined) -> None:
                    """
                    Cpu.


                    Subclass of AvdModel.

                    Args:
                        thresholds: Subclass of AvdModel.

                    """

        class Mirror(AvdModel):
            """Subclass of AvdModel."""

            class Destination(AvdModel):
                """Subclass of AvdModel."""

                class EthernetInterfaces(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                EthernetInterfaces._item_type = str

                class TunnelModeGre(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "source": {"type": str},
                        "destination": {"type": str},
                        "dscp": {"type": int},
                        "ttl": {"type": int},
                        "protocol": {"type": str},
                        "vrf": {"type": str},
                    }
                    source: str
                    """Source IP address of GRE tunnel."""
                    destination: str
                    """Destination IP address of GRE tunnel."""
                    dscp: int | None
                    """DSCP of the GRE tunnel. EOS default is 0."""
                    ttl: int | None
                    """TTL range. EOS default is 128."""
                    protocol: str | None
                    """
                    Protocol type in GRE header. Protocol range - 0x0000-0xFFFF.
                    EOS default is 0x88BE.
                    """
                    vrf: str | None
                    """VRF name of the GRE tunnel. EOS default is "default"."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            source: str | UndefinedType = Undefined,
                            destination: str | UndefinedType = Undefined,
                            dscp: int | None | UndefinedType = Undefined,
                            ttl: int | None | UndefinedType = Undefined,
                            protocol: str | None | UndefinedType = Undefined,
                            vrf: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            TunnelModeGre.


                            Subclass of AvdModel.

                            Args:
                                source: Source IP address of GRE tunnel.
                                destination: Destination IP address of GRE tunnel.
                                dscp: DSCP of the GRE tunnel. EOS default is 0.
                                ttl: TTL range. EOS default is 128.
                                protocol:
                                   Protocol type in GRE header. Protocol range - 0x0000-0xFFFF.
                                   EOS default is 0x88BE.
                                vrf: VRF name of the GRE tunnel. EOS default is "default".

                            """

                _fields: ClassVar[dict] = {
                    "cpu": {"type": bool},
                    "ethernet_interfaces": {"type": EthernetInterfaces},
                    "tunnel_mode_gre": {"type": TunnelModeGre},
                }
                cpu: bool | None
                """CPU ports."""
                ethernet_interfaces: EthernetInterfaces
                """Subclass of AvdList with `str` items."""
                tunnel_mode_gre: TunnelModeGre
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        cpu: bool | None | UndefinedType = Undefined,
                        ethernet_interfaces: EthernetInterfaces | UndefinedType = Undefined,
                        tunnel_mode_gre: TunnelModeGre | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Destination.


                        Subclass of AvdModel.

                        Args:
                            cpu: CPU ports.
                            ethernet_interfaces: Subclass of AvdList with `str` items.
                            tunnel_mode_gre: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "destination": {"type": Destination}}
            enabled: bool | None
            destination: Destination
            """
            Mirror destination.

            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, destination: Destination | UndefinedType = Undefined) -> None:
                    """
                    Mirror.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        destination:
                           Mirror destination.

                           Subclass of AvdModel.

                    """

        _fields: ClassVar[dict] = {
            "enabled": {"type": bool},
            "default_thresholds": {"type": DefaultThresholds},
            "log": {"type": int},
            "notifying": {"type": bool},
            "cpu": {"type": Cpu},
            "tx_latency": {"type": bool},
            "mirror": {"type": Mirror},
        }
        enabled: bool
        default_thresholds: DefaultThresholds
        """Subclass of AvdModel."""
        log: int | None
        """Logging interval in seconds."""
        notifying: bool | None
        """Should only be used for platforms supporting the "queue-monitor length notifying" CLI."""
        cpu: Cpu
        """Subclass of AvdModel."""
        tx_latency: bool | None
        """Enable tx-latency mode."""
        mirror: Mirror
        """
        Enable frame mirroring during congestion.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enabled: bool | UndefinedType = Undefined,
                default_thresholds: DefaultThresholds | UndefinedType = Undefined,
                log: int | None | UndefinedType = Undefined,
                notifying: bool | None | UndefinedType = Undefined,
                cpu: Cpu | UndefinedType = Undefined,
                tx_latency: bool | None | UndefinedType = Undefined,
                mirror: Mirror | UndefinedType = Undefined,
            ) -> None:
                """
                QueueMonitorLength.


                Subclass of AvdModel.

                Args:
                    enabled: enabled
                    default_thresholds: Subclass of AvdModel.
                    log: Logging interval in seconds.
                    notifying: Should only be used for platforms supporting the "queue-monitor length notifying" CLI.
                    cpu: Subclass of AvdModel.
                    tx_latency: Enable tx-latency mode.
                    mirror:
                       Enable frame mirroring during congestion.

                       Subclass of AvdModel.

                """

    class QueueMonitorStreaming(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "enable": {"type": bool},
            "ip_access_group": {"type": str},
            "ipv6_access_group": {"type": str},
            "max_connections": {"type": int},
            "vrf": {"type": str},
        }
        enable: bool | None
        ip_access_group: str | None
        """Name of IP ACL."""
        ipv6_access_group: str | None
        """Name of IPv6 ACL."""
        max_connections: int | None
        vrf: str | None

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enable: bool | None | UndefinedType = Undefined,
                ip_access_group: str | None | UndefinedType = Undefined,
                ipv6_access_group: str | None | UndefinedType = Undefined,
                max_connections: int | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                QueueMonitorStreaming.


                Subclass of AvdModel.

                Args:
                    enable: enable
                    ip_access_group: Name of IP ACL.
                    ipv6_access_group: Name of IPv6 ACL.
                    max_connections: max_connections
                    vrf: vrf

                """

    class RadiusProxy(AvdModel):
        """Subclass of AvdModel."""

        class ClientGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            class ServerGroups(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            ServerGroups._item_type = str

            class VrfsItem(AvdModel):
                """Subclass of AvdModel."""

                class Ipv4ClientsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"address": {"type": str}, "key": {"type": str}}
                    address: str
                    """IPv4 address "A.B.C.D" or prefix "A.B.C.D/E"."""
                    key: str | None
                    """
                    Key for this client. Overrides`radius_proxy.client_key`.
                    Only type 7 supported.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, address: str | UndefinedType = Undefined, key: str | None | UndefinedType = Undefined) -> None:
                            """
                            Ipv4ClientsItem.


                            Subclass of AvdModel.

                            Args:
                                address: IPv4 address "A.B.C.D" or prefix "A.B.C.D/E".
                                key:
                                   Key for this client. Overrides`radius_proxy.client_key`.
                                   Only type 7 supported.

                            """

                class Ipv4Clients(AvdIndexedList[str, Ipv4ClientsItem]):
                    """Subclass of AvdIndexedList with `Ipv4ClientsItem` items. Primary key is `address` (`str`)."""

                    _primary_key: ClassVar[str] = "address"

                Ipv4Clients._item_type = Ipv4ClientsItem

                class Ipv6ClientsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"address": {"type": str}, "key": {"type": str}}
                    address: str
                    """IPv6 address "A:B:C:D:E:F:G:H" prefix "A:B:C:D:E:F:G:H/I"."""
                    key: str | None
                    """
                    Key for this client. Overrides`radius_proxy.client_key`.
                    Only type 7 supported.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, address: str | UndefinedType = Undefined, key: str | None | UndefinedType = Undefined) -> None:
                            """
                            Ipv6ClientsItem.


                            Subclass of AvdModel.

                            Args:
                                address: IPv6 address "A:B:C:D:E:F:G:H" prefix "A:B:C:D:E:F:G:H/I".
                                key:
                                   Key for this client. Overrides`radius_proxy.client_key`.
                                   Only type 7 supported.

                            """

                class Ipv6Clients(AvdIndexedList[str, Ipv6ClientsItem]):
                    """Subclass of AvdIndexedList with `Ipv6ClientsItem` items. Primary key is `address` (`str`)."""

                    _primary_key: ClassVar[str] = "address"

                Ipv6Clients._item_type = Ipv6ClientsItem

                class HostClientsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "key": {"type": str}}
                    name: str
                    """Hostname."""
                    key: str | None
                    """
                    Key for this client. Overrides`radius_proxy.client_key`.
                    Only type 7 supported.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | UndefinedType = Undefined, key: str | None | UndefinedType = Undefined) -> None:
                            """
                            HostClientsItem.


                            Subclass of AvdModel.

                            Args:
                                name: Hostname.
                                key:
                                   Key for this client. Overrides`radius_proxy.client_key`.
                                   Only type 7 supported.

                            """

                class HostClients(AvdIndexedList[str, HostClientsItem]):
                    """Subclass of AvdIndexedList with `HostClientsItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                HostClients._item_type = HostClientsItem

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "ipv4_clients": {"type": Ipv4Clients},
                    "ipv6_clients": {"type": Ipv6Clients},
                    "host_clients": {"type": HostClients},
                }
                name: str
                ipv4_clients: Ipv4Clients
                """Subclass of AvdIndexedList with `Ipv4ClientsItem` items. Primary key is `address` (`str`)."""
                ipv6_clients: Ipv6Clients
                """Subclass of AvdIndexedList with `Ipv6ClientsItem` items. Primary key is `address` (`str`)."""
                host_clients: HostClients
                """Subclass of AvdIndexedList with `HostClientsItem` items. Primary key is `name` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        ipv4_clients: Ipv4Clients | UndefinedType = Undefined,
                        ipv6_clients: Ipv6Clients | UndefinedType = Undefined,
                        host_clients: HostClients | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VrfsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            ipv4_clients: Subclass of AvdIndexedList with `Ipv4ClientsItem` items. Primary key is `address` (`str`).
                            ipv6_clients: Subclass of AvdIndexedList with `Ipv6ClientsItem` items. Primary key is `address` (`str`).
                            host_clients: Subclass of AvdIndexedList with `HostClientsItem` items. Primary key is `name` (`str`).

                        """

            class Vrfs(AvdIndexedList[str, VrfsItem]):
                """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Vrfs._item_type = VrfsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "server_groups": {"type": ServerGroups}, "vrfs": {"type": Vrfs}}
            name: str
            server_groups: ServerGroups
            """Subclass of AvdList with `str` items."""
            vrfs: Vrfs
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    server_groups: ServerGroups | UndefinedType = Undefined,
                    vrfs: Vrfs | UndefinedType = Undefined,
                ) -> None:
                    """
                    ClientGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        server_groups: Subclass of AvdList with `str` items.
                        vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).

                    """

        class ClientGroups(AvdIndexedList[str, ClientGroupsItem]):
            """Subclass of AvdIndexedList with `ClientGroupsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        ClientGroups._item_type = ClientGroupsItem

        _fields: ClassVar[dict] = {
            "client_key": {"type": str},
            "client_session_idle_timeout": {"type": int},
            "dynamic_authorization": {"type": bool},
            "client_groups": {"type": ClientGroups},
        }
        client_key: str | None
        """
        Set client secret key, allowed max size is 128.
        Only type 7 supported.
        """
        client_session_idle_timeout: int | None
        """Idle timeout in seconds."""
        dynamic_authorization: bool | None
        """Enable/Disable dynamic authorization."""
        client_groups: ClientGroups
        """Subclass of AvdIndexedList with `ClientGroupsItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                client_key: str | None | UndefinedType = Undefined,
                client_session_idle_timeout: int | None | UndefinedType = Undefined,
                dynamic_authorization: bool | None | UndefinedType = Undefined,
                client_groups: ClientGroups | UndefinedType = Undefined,
            ) -> None:
                """
                RadiusProxy.


                Subclass of AvdModel.

                Args:
                    client_key:
                       Set client secret key, allowed max size is 128.
                       Only type 7 supported.
                    client_session_idle_timeout: Idle timeout in seconds.
                    dynamic_authorization: Enable/Disable dynamic authorization.
                    client_groups: Subclass of AvdIndexedList with `ClientGroupsItem` items. Primary key is `name` (`str`).

                """

    class RadiusServer(AvdModel):
        """Subclass of AvdModel."""

        class Attribute32IncludeInAccessReq(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"hostname": {"type": bool}, "format": {"type": str}}
            hostname: bool | None
            format: str | None
            """Specify the format of the NAS-Identifier. If 'hostname' is set, this is ignored."""

            if TYPE_CHECKING:

                def __init__(self, *, hostname: bool | None | UndefinedType = Undefined, format: str | None | UndefinedType = Undefined) -> None:
                    """
                    Attribute32IncludeInAccessReq.


                    Subclass of AvdModel.

                    Args:
                        hostname: hostname
                        format: Specify the format of the NAS-Identifier. If 'hostname' is set, this is ignored.

                    """

        class DynamicAuthorization(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"port": {"type": int}, "tls_ssl_profile": {"type": str}}
            port: int | None
            """TCP Port."""
            tls_ssl_profile: str | None
            """Name of TLS profile."""

            if TYPE_CHECKING:

                def __init__(self, *, port: int | None | UndefinedType = Undefined, tls_ssl_profile: str | None | UndefinedType = Undefined) -> None:
                    """
                    DynamicAuthorization.


                    Subclass of AvdModel.

                    Args:
                        port: TCP Port.
                        tls_ssl_profile: Name of TLS profile.

                    """

        class HostsItem(AvdModel):
            """Subclass of AvdModel."""

            class Tls(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "ssl_profile": {"type": str}, "port": {"type": int}}
                enabled: bool | None
                """Enable TLS for radius-server."""
                ssl_profile: str | None
                """Name of TLS profile."""
                port: int | None
                """TCP Port used for TLS. EOS default is 2083."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        ssl_profile: str | None | UndefinedType = Undefined,
                        port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Tls.


                        Subclass of AvdModel.

                        Args:
                            enabled: Enable TLS for radius-server.
                            ssl_profile: Name of TLS profile.
                            port: TCP Port used for TLS. EOS default is 2083.

                        """

            _fields: ClassVar[dict] = {
                "host": {"type": str},
                "vrf": {"type": str},
                "tls": {"type": Tls},
                "timeout": {"type": int},
                "retransmit": {"type": int},
                "key": {"type": str},
            }
            host: str
            """Host IP address or name."""
            vrf: str | None
            tls: Tls
            """
            When TLS is configured, `key` is ignored..

            Subclass of AvdModel.
            """
            timeout: int | None
            retransmit: int | None
            key: str | None
            """
            Encrypted key - only type 7 supported.
            When TLS is configured, `key` is ignored.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    host: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    tls: Tls | UndefinedType = Undefined,
                    timeout: int | None | UndefinedType = Undefined,
                    retransmit: int | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostsItem.


                    Subclass of AvdModel.

                    Args:
                        host: Host IP address or name.
                        vrf: vrf
                        tls:
                           When TLS is configured, `key` is ignored..

                           Subclass of AvdModel.
                        timeout: timeout
                        retransmit: retransmit
                        key:
                           Encrypted key - only type 7 supported.
                           When TLS is configured, `key` is ignored.

                    """

        class Hosts(AvdIndexedList[str, HostsItem]):
            """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `host` (`str`)."""

            _primary_key: ClassVar[str] = "host"

        Hosts._item_type = HostsItem

        _fields: ClassVar[dict] = {
            "attribute_32_include_in_access_req": {"type": Attribute32IncludeInAccessReq},
            "deadtime": {"type": int},
            "dynamic_authorization": {"type": DynamicAuthorization},
            "hosts": {"type": Hosts},
            "tls_ssl_profile": {"type": str},
        }
        attribute_32_include_in_access_req: Attribute32IncludeInAccessReq
        """Subclass of AvdModel."""
        deadtime: int | None
        """Time to skip a non-responsive server in minutes."""
        dynamic_authorization: DynamicAuthorization
        """Subclass of AvdModel."""
        hosts: Hosts
        """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `host` (`str`)."""
        tls_ssl_profile: str | None
        """Name of global TLS profile."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                attribute_32_include_in_access_req: Attribute32IncludeInAccessReq | UndefinedType = Undefined,
                deadtime: int | None | UndefinedType = Undefined,
                dynamic_authorization: DynamicAuthorization | UndefinedType = Undefined,
                hosts: Hosts | UndefinedType = Undefined,
                tls_ssl_profile: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                RadiusServer.


                Subclass of AvdModel.

                Args:
                    attribute_32_include_in_access_req: Subclass of AvdModel.
                    deadtime: Time to skip a non-responsive server in minutes.
                    dynamic_authorization: Subclass of AvdModel.
                    hosts: Subclass of AvdIndexedList with `HostsItem` items. Primary key is `host` (`str`).
                    tls_ssl_profile: Name of global TLS profile.

                """

    class Redundancy(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"protocol": {"type": str}}
        protocol: str | None
        """Redundancy Protocol."""

        if TYPE_CHECKING:

            def __init__(self, *, protocol: str | None | UndefinedType = Undefined) -> None:
                """
                Redundancy.


                Subclass of AvdModel.

                Args:
                    protocol: Redundancy Protocol.

                """

    class RolesItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}, "mode": {"type": str}, "command": {"type": str}}
            sequence: int | None
            """Sequence number."""
            action: Literal["permit", "deny"] | None
            mode: str | None
            """"config", "config-all", "exec" or mode key as string."""
            command: str | None
            """Command as string."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | None | UndefinedType = Undefined,
                    action: Literal["permit", "deny"] | None | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    command: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence number.
                        action: action
                        mode: "config", "config-all", "exec" or mode key as string.
                        command: Command as string.

                    """

        class SequenceNumbers(AvdList[SequenceNumbersItem]):
            """Subclass of AvdList with `SequenceNumbersItem` items."""

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
        name: str
        """Role name."""
        sequence_numbers: SequenceNumbers
        """Subclass of AvdList with `SequenceNumbersItem` items."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, sequence_numbers: SequenceNumbers | UndefinedType = Undefined) -> None:
                """
                RolesItem.


                Subclass of AvdModel.

                Args:
                    name: Role name.
                    sequence_numbers: Subclass of AvdList with `SequenceNumbersItem` items.

                """

    class Roles(AvdIndexedList[str, RolesItem]):
        """Subclass of AvdIndexedList with `RolesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Roles._item_type = RolesItem

    class RouteMapsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            class Match(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Match._item_type = str

            class Set(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Set._item_type = str

            class Continue(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "sequence_number": {"type": int}}
                enabled: bool | None
                sequence_number: int | None

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, sequence_number: int | None | UndefinedType = Undefined) -> None:
                        """
                        Continue.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            sequence_number: sequence_number

                        """

            _fields: ClassVar[dict] = {
                "sequence": {"type": int},
                "type": {"type": str},
                "description": {"type": str},
                "match": {"type": Match},
                "set": {"type": Set},
                "sub_route_map": {"type": str},
                "field_continue": {"type": Continue},
            }
            _field_to_key_map: ClassVar[dict] = {"field_continue": "continue"}
            _key_to_field_map: ClassVar[dict] = {"continue": "field_continue"}
            sequence: int
            """Sequence ID."""
            type: Literal["permit", "deny"]
            description: str | None
            match: Match
            """
            List of "match" statements.

            Subclass of AvdList with `str` items.
            """
            set: Set
            """
            List of "set" statements.

            Subclass of AvdList with `str` items.
            """
            sub_route_map: str | None
            """Name of Sub-Route-map."""
            field_continue: Continue
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | UndefinedType = Undefined,
                    type: Literal["permit", "deny"] | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    match: Match | UndefinedType = Undefined,
                    set: Set | UndefinedType = Undefined,
                    sub_route_map: str | None | UndefinedType = Undefined,
                    field_continue: Continue | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        type: type
                        description: description
                        match:
                           List of "match" statements.

                           Subclass of AvdList with `str` items.
                        set:
                           List of "set" statements.

                           Subclass of AvdList with `str` items.
                        sub_route_map: Name of Sub-Route-map.
                        field_continue: Subclass of AvdModel.

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
        name: str
        """Route-map Name."""
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

        if TYPE_CHECKING:

            def __init__(self, *, name: str | UndefinedType = Undefined, sequence_numbers: SequenceNumbers | UndefinedType = Undefined) -> None:
                """
                RouteMapsItem.


                Subclass of AvdModel.

                Args:
                    name: Route-map Name.
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).

                """

    class RouteMaps(AvdIndexedList[str, RouteMapsItem]):
        """Subclass of AvdIndexedList with `RouteMapsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    RouteMaps._item_type = RouteMapsItem

    class RouterAdaptiveVirtualTopology(AvdModel):
        """Subclass of AvdModel."""

        class Region(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "id": {"type": int}}
            name: str
            id: int

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, id: int | UndefinedType = Undefined) -> None:
                    """
                    Region.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        id: id

                    """

        class Zone(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "id": {"type": int}}
            name: str
            id: int

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, id: int | UndefinedType = Undefined) -> None:
                    """
                    Zone.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        id: id

                    """

        class Site(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "id": {"type": int}}
            name: str
            id: int

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, id: int | UndefinedType = Undefined) -> None:
                    """
                    Site.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        id: id

                    """

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class MetricOrder(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"preferred_metric": {"type": str}}
                preferred_metric: Literal["jitter", "latency", "load", "loss-rate"]

                if TYPE_CHECKING:

                    def __init__(self, *, preferred_metric: Literal["jitter", "latency", "load", "loss-rate"] | UndefinedType = Undefined) -> None:
                        """
                        MetricOrder.


                        Subclass of AvdModel.

                        Args:
                            preferred_metric: preferred_metric

                        """

            class OutlierElimination(AvdModel):
                """Subclass of AvdModel."""

                class Threshold(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"jitter": {"type": int}, "latency": {"type": int}, "load": {"type": str}, "loss_rate": {"type": str}}
                    jitter: int | None
                    """Jitter threshold in millisecond."""
                    latency: int | None
                    """Latency threshold in millisecond."""
                    load: str | None
                    """Load threshold percentage. Valid range <0.00-100.00>."""
                    loss_rate: str | None
                    """Loss-rate threshold percentage. Valid range <0.00-100.00>."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            jitter: int | None | UndefinedType = Undefined,
                            latency: int | None | UndefinedType = Undefined,
                            load: str | None | UndefinedType = Undefined,
                            loss_rate: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Threshold.


                            Subclass of AvdModel.

                            Args:
                                jitter: Jitter threshold in millisecond.
                                latency: Latency threshold in millisecond.
                                load: Load threshold percentage. Valid range <0.00-100.00>.
                                loss_rate: Loss-rate threshold percentage. Valid range <0.00-100.00>.

                            """

                _fields: ClassVar[dict] = {"disabled": {"type": bool}, "threshold": {"type": Threshold}}
                disabled: bool | None
                """Set true to disable the AVT path outlier elimination."""
                threshold: Threshold
                """
                Change the threshold values for path comparison.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, disabled: bool | None | UndefinedType = Undefined, threshold: Threshold | UndefinedType = Undefined) -> None:
                        """
                        OutlierElimination.


                        Subclass of AvdModel.

                        Args:
                            disabled: Set true to disable the AVT path outlier elimination.
                            threshold:
                               Change the threshold values for path comparison.

                               Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "load_balance_policy": {"type": str},
                "internet_exit_policy": {"type": str},
                "metric_order": {"type": MetricOrder},
                "outlier_elimination": {"type": OutlierElimination},
            }
            name: str
            """AVT Name."""
            load_balance_policy: str | None
            """Name of the load-balance policy."""
            internet_exit_policy: str | None
            """Name of the internet exit policy."""
            metric_order: MetricOrder
            """
            Metric order to be used for path comparison.

            Subclass of AvdModel.
            """
            outlier_elimination: OutlierElimination
            """
            AVT path outlier elimination.

            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    load_balance_policy: str | None | UndefinedType = Undefined,
                    internet_exit_policy: str | None | UndefinedType = Undefined,
                    metric_order: MetricOrder | UndefinedType = Undefined,
                    outlier_elimination: OutlierElimination | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: AVT Name.
                        load_balance_policy: Name of the load-balance policy.
                        internet_exit_policy: Name of the internet exit policy.
                        metric_order:
                           Metric order to be used for path comparison.

                           Subclass of AvdModel.
                        outlier_elimination:
                           AVT path outlier elimination.

                           Subclass of AvdModel.

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        class PoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class MatchesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "application_profile": {"type": str},
                    "avt_profile": {"type": str},
                    "dscp": {"type": int},
                    "traffic_class": {"type": int},
                }
                application_profile: str | None
                """Application profile name."""
                avt_profile: str | None
                """AVT Profile name."""
                dscp: int | None
                """Set DSCP for matched traffic."""
                traffic_class: int | None
                """Set traffic-class for matched traffic."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        application_profile: str | None | UndefinedType = Undefined,
                        avt_profile: str | None | UndefinedType = Undefined,
                        dscp: int | None | UndefinedType = Undefined,
                        traffic_class: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchesItem.


                        Subclass of AvdModel.

                        Args:
                            application_profile: Application profile name.
                            avt_profile: AVT Profile name.
                            dscp: Set DSCP for matched traffic.
                            traffic_class: Set traffic-class for matched traffic.

                        """

            class Matches(AvdList[MatchesItem]):
                """Subclass of AvdList with `MatchesItem` items."""

            Matches._item_type = MatchesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "matches": {"type": Matches}}
            name: str
            """Policy name."""
            matches: Matches
            """Subclass of AvdList with `MatchesItem` items."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, matches: Matches | UndefinedType = Undefined) -> None:
                    """
                    PoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Policy name.
                        matches: Subclass of AvdList with `MatchesItem` items.

                    """

        class Policies(AvdIndexedList[str, PoliciesItem]):
            """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class ProfilesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "id": {"type": int}}
                name: str | None
                """AVT profile name."""
                id: int
                """Unique ID for this AVT (per VRF)."""

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | None | UndefinedType = Undefined, id: int | UndefinedType = Undefined) -> None:
                        """
                        ProfilesItem.


                        Subclass of AvdModel.

                        Args:
                            name: AVT profile name.
                            id: Unique ID for this AVT (per VRF).

                        """

            class Profiles(AvdIndexedList[int, ProfilesItem]):
                """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `id` (`int`)."""

                _primary_key: ClassVar[str] = "id"

            Profiles._item_type = ProfilesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "policy": {"type": str}, "profiles": {"type": Profiles}}
            name: str
            """VRF name."""
            policy: str | None
            """AVT Policy name."""
            profiles: Profiles
            """
            AVT profiles in this VRF.

            Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `id`
            (`int`).
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    policy: str | None | UndefinedType = Undefined,
                    profiles: Profiles | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        policy: AVT Policy name.
                        profiles:
                           AVT profiles in this VRF.

                           Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `id`
                           (`int`).

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "topology_role": {"type": str},
            "gateway_vxlan": {"type": bool},
            "region": {"type": Region},
            "zone": {"type": Zone},
            "site": {"type": Site},
            "profiles": {"type": Profiles},
            "policies": {"type": Policies},
            "vrfs": {"type": Vrfs},
        }
        topology_role: Literal["edge", "pathfinder", "transit region", "transit zone"] | None
        """Role name."""
        gateway_vxlan: bool | None
        """
        Enables VXLAN gateway router profile.
        Only applicable for `topology_role: edge`, `topology_role:
        transit region` or `topology_role: transit zone`.
        """
        region: Region
        """
        Region name and ID.

        Subclass of AvdModel.
        """
        zone: Zone
        """
        Zone name and ID.

        Subclass of AvdModel.
        """
        site: Site
        """
        Site name and ID.

        Subclass of AvdModel.
        """
        profiles: Profiles
        """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""
        policies: Policies
        """
        A sequence of application profiles mapped to some virtual topologies.

        Subclass of AvdIndexedList
        with `PoliciesItem` items. Primary key is `name` (`str`).
        """
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                topology_role: Literal["edge", "pathfinder", "transit region", "transit zone"] | None | UndefinedType = Undefined,
                gateway_vxlan: bool | None | UndefinedType = Undefined,
                region: Region | UndefinedType = Undefined,
                zone: Zone | UndefinedType = Undefined,
                site: Site | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
                policies: Policies | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
            ) -> None:
                """
                RouterAdaptiveVirtualTopology.


                Subclass of AvdModel.

                Args:
                    topology_role: Role name.
                    gateway_vxlan:
                       Enables VXLAN gateway router profile.
                       Only applicable for `topology_role: edge`, `topology_role:
                       transit region` or `topology_role: transit zone`.
                    region:
                       Region name and ID.

                       Subclass of AvdModel.
                    zone:
                       Zone name and ID.

                       Subclass of AvdModel.
                    site:
                       Site name and ID.

                       Subclass of AvdModel.
                    profiles: Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`).
                    policies:
                       A sequence of application profiles mapped to some virtual topologies.

                       Subclass of AvdIndexedList
                       with `PoliciesItem` items. Primary key is `name` (`str`).
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).

                """

    class RouterBfd(AvdModel):
        """Subclass of AvdModel."""

        class Multihop(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}}
            interval: int | None
            """Rate in milliseconds."""
            min_rx: int | None
            """Rate in milliseconds."""
            multiplier: int | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    interval: int | None | UndefinedType = Undefined,
                    min_rx: int | None | UndefinedType = Undefined,
                    multiplier: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Multihop.


                    Subclass of AvdModel.

                    Args:
                        interval: Rate in milliseconds.
                        min_rx: Rate in milliseconds.
                        multiplier: multiplier

                    """

        class Sbfd(AvdModel):
            """Subclass of AvdModel."""

            class LocalInterface(AvdModel):
                """Subclass of AvdModel."""

                class Protocols(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ipv4": {"type": bool}, "ipv6": {"type": bool}}
                    ipv4: bool | None
                    ipv6: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, ipv4: bool | None | UndefinedType = Undefined, ipv6: bool | None | UndefinedType = Undefined) -> None:
                            """
                            Protocols.


                            Subclass of AvdModel.

                            Args:
                                ipv4: ipv4
                                ipv6: ipv6

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "protocols": {"type": Protocols}}
                name: str | None
                """Interface Name."""
                protocols: Protocols
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | None | UndefinedType = Undefined, protocols: Protocols | UndefinedType = Undefined) -> None:
                        """
                        LocalInterface.


                        Subclass of AvdModel.

                        Args:
                            name: Interface Name.
                            protocols: Subclass of AvdModel.

                        """

            class Reflector(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"min_rx": {"type": int}, "local_discriminator": {"type": str}}
                min_rx: int | None
                """Rate in milliseconds."""
                local_discriminator: str | None
                """IPv4 address or 32 bit integer."""

                if TYPE_CHECKING:

                    def __init__(self, *, min_rx: int | None | UndefinedType = Undefined, local_discriminator: str | None | UndefinedType = Undefined) -> None:
                        """
                        Reflector.


                        Subclass of AvdModel.

                        Args:
                            min_rx: Rate in milliseconds.
                            local_discriminator: IPv4 address or 32 bit integer.

                        """

            _fields: ClassVar[dict] = {
                "local_interface": {"type": LocalInterface},
                "initiator_interval": {"type": int},
                "initiator_multiplier": {"type": int},
                "initiator_measurement_round_trip": {"type": bool},
                "reflector": {"type": Reflector},
            }
            local_interface: LocalInterface
            """Subclass of AvdModel."""
            initiator_interval: int | None
            """Rate in milliseconds."""
            initiator_multiplier: int | None
            initiator_measurement_round_trip: bool | None
            """Enable round-trip delay measurement."""
            reflector: Reflector
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    local_interface: LocalInterface | UndefinedType = Undefined,
                    initiator_interval: int | None | UndefinedType = Undefined,
                    initiator_multiplier: int | None | UndefinedType = Undefined,
                    initiator_measurement_round_trip: bool | None | UndefinedType = Undefined,
                    reflector: Reflector | UndefinedType = Undefined,
                ) -> None:
                    """
                    Sbfd.


                    Subclass of AvdModel.

                    Args:
                        local_interface: Subclass of AvdModel.
                        initiator_interval: Rate in milliseconds.
                        initiator_multiplier: initiator_multiplier
                        initiator_measurement_round_trip: Enable round-trip delay measurement.
                        reflector: Subclass of AvdModel.

                    """

        _fields: ClassVar[dict] = {
            "interval": {"type": int},
            "local_address": {"type": str},
            "min_rx": {"type": int},
            "multiplier": {"type": int},
            "multihop": {"type": Multihop},
            "session_snapshot_interval": {"type": int},
            "session_snapshot_interval_dangerous": {"type": bool},
            "sbfd": {"type": Sbfd},
            "slow_timer": {"type": int},
        }
        interval: int | None
        """Rate in milliseconds."""
        local_address: str | None
        """Configure BFD local IP/IPv6 address."""
        min_rx: int | None
        """Rate in milliseconds."""
        multiplier: int | None
        multihop: Multihop
        """Subclass of AvdModel."""
        session_snapshot_interval: int | None
        """
        Interval in seconds.
        Intervals below 10 are considered "dangerous" on EOS and must have
        `session_snapshot_interval_dangerous` set to `true`.
        """
        session_snapshot_interval_dangerous: bool | None
        sbfd: Sbfd
        """Subclass of AvdModel."""
        slow_timer: int | None
        """Rate in milliseconds."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                interval: int | None | UndefinedType = Undefined,
                local_address: str | None | UndefinedType = Undefined,
                min_rx: int | None | UndefinedType = Undefined,
                multiplier: int | None | UndefinedType = Undefined,
                multihop: Multihop | UndefinedType = Undefined,
                session_snapshot_interval: int | None | UndefinedType = Undefined,
                session_snapshot_interval_dangerous: bool | None | UndefinedType = Undefined,
                sbfd: Sbfd | UndefinedType = Undefined,
                slow_timer: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                RouterBfd.


                Subclass of AvdModel.

                Args:
                    interval: Rate in milliseconds.
                    local_address: Configure BFD local IP/IPv6 address.
                    min_rx: Rate in milliseconds.
                    multiplier: multiplier
                    multihop: Subclass of AvdModel.
                    session_snapshot_interval:
                       Interval in seconds.
                       Intervals below 10 are considered "dangerous" on EOS and must have
                       `session_snapshot_interval_dangerous` set to `true`.
                    session_snapshot_interval_dangerous: session_snapshot_interval_dangerous
                    sbfd: Subclass of AvdModel.
                    slow_timer: Rate in milliseconds.

                """

    class RouterBgp(AvdModel):
        """Subclass of AvdModel."""

        class Timers(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "keepalive_time": {"type": int},
                "hold_time": {"type": int},
                "min_hold_time": {"type": int},
                "send_failure_hold_time": {"type": int},
            }
            keepalive_time: int | None
            """
            Time between BGP keepalive messages in seconds.
            `keepalive_time` should be lesser than `hold_time`.
            """
            hold_time: int | None
            """
            Hold time in seconds. Must be defined along with `keepalive_time`.
            The valid values are 3-7200 or 0
            if both values are 0.
            """
            min_hold_time: int | None
            """
            Neighbor's minimum hold time constraint in seconds.
            `min_hold_time` should be less than `hold_time`.
            """
            send_failure_hold_time: int | None
            """Send failure hold time in seconds."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    keepalive_time: int | None | UndefinedType = Undefined,
                    hold_time: int | None | UndefinedType = Undefined,
                    min_hold_time: int | None | UndefinedType = Undefined,
                    send_failure_hold_time: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Timers.


                    Subclass of AvdModel.

                    Args:
                        keepalive_time:
                           Time between BGP keepalive messages in seconds.
                           `keepalive_time` should be lesser than `hold_time`.
                        hold_time:
                           Hold time in seconds. Must be defined along with `keepalive_time`.
                           The valid values are 3-7200 or 0
                           if both values are 0.
                        min_hold_time:
                           Neighbor's minimum hold time constraint in seconds.
                           `min_hold_time` should be less than `hold_time`.
                        send_failure_hold_time: Send failure hold time in seconds.

                    """

        class Distance(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"external_routes": {"type": int}, "internal_routes": {"type": int}, "local_routes": {"type": int}}
            external_routes: int
            internal_routes: int
            local_routes: int

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    external_routes: int | UndefinedType = Undefined,
                    internal_routes: int | UndefinedType = Undefined,
                    local_routes: int | UndefinedType = Undefined,
                ) -> None:
                    """
                    Distance.


                    Subclass of AvdModel.

                    Args:
                        external_routes: external_routes
                        internal_routes: internal_routes
                        local_routes: local_routes

                    """

        class GracefulRestart(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "restart_time": {"type": int}, "stalepath_time": {"type": int}}
            enabled: bool | None
            restart_time: int | None
            """Number of seconds."""
            stalepath_time: int | None
            """Number of seconds."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    restart_time: int | None | UndefinedType = Undefined,
                    stalepath_time: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    GracefulRestart.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        restart_time: Number of seconds.
                        stalepath_time: Number of seconds.

                    """

        class GracefulRestartHelper(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "restart_time": {"type": int}, "long_lived": {"type": bool}}
            enabled: bool | None
            restart_time: int | None
            """
            Number of seconds
            graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
            restart-time will take precedence if both are configured.
            """
            long_lived: bool | None
            """
            graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
            restart-time will
            take precedence if both are configured.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    restart_time: int | None | UndefinedType = Undefined,
                    long_lived: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    GracefulRestartHelper.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        restart_time:
                           Number of seconds
                           graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
                           restart-time will take precedence if both are configured.
                        long_lived:
                           graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
                           restart-time will
                           take precedence if both are configured.

                    """

        class MaximumPaths(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"paths": {"type": int}, "ecmp": {"type": int}}
            paths: int
            ecmp: int | None

            if TYPE_CHECKING:

                def __init__(self, *, paths: int | UndefinedType = Undefined, ecmp: int | None | UndefinedType = Undefined) -> None:
                    """
                    MaximumPaths.


                    Subclass of AvdModel.

                    Args:
                        paths: paths
                        ecmp: ecmp

                    """

        class Updates(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"wait_for_convergence": {"type": bool}, "wait_install": {"type": bool}}
            wait_for_convergence: bool | None
            """
            Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
            convergence state is reached.
            """
            wait_install: bool | None
            """
            Do not advertise reachability to a prefix until that prefix has been installed in hardware.
            This
            will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
            that may not yet be installed into the forwarding plane.
            """

            if TYPE_CHECKING:

                def __init__(
                    self, *, wait_for_convergence: bool | None | UndefinedType = Undefined, wait_install: bool | None | UndefinedType = Undefined
                ) -> None:
                    """
                    Updates.


                    Subclass of AvdModel.

                    Args:
                        wait_for_convergence:
                           Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                           convergence state is reached.
                        wait_install:
                           Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                           This
                           will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                           that may not yet be installed into the forwarding plane.

                    """

        class BgpDefaults(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        BgpDefaults._item_type = str

        class Bgp(AvdModel):
            """Subclass of AvdModel."""

            class Default(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4_unicast": {"type": bool}, "ipv4_unicast_transport_ipv6": {"type": bool}}
                ipv4_unicast: bool | None
                """Default activation of IPv4 unicast address-family on all IPv4 neighbors (EOS default = True)."""
                ipv4_unicast_transport_ipv6: bool | None
                """Default activation of IPv4 unicast address-family on all IPv6 neighbors (EOS default == False)."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, ipv4_unicast: bool | None | UndefinedType = Undefined, ipv4_unicast_transport_ipv6: bool | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        Default.


                        Subclass of AvdModel.

                        Args:
                            ipv4_unicast: Default activation of IPv4 unicast address-family on all IPv4 neighbors (EOS default = True).
                            ipv4_unicast_transport_ipv6: Default activation of IPv4 unicast address-family on all IPv6 neighbors (EOS default == False).

                        """

            class RouteReflectorPreserveAttributes(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "always": {"type": bool}}
                enabled: bool | None
                always: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, always: bool | None | UndefinedType = Undefined) -> None:
                        """
                        RouteReflectorPreserveAttributes.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            always: always

                        """

            class Bestpath(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"d_path": {"type": bool}}
                d_path: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, d_path: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Bestpath.


                        Subclass of AvdModel.

                        Args:
                            d_path: d_path

                        """

            class AdditionalPaths(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                receive: bool | None
                """Enable or disable reception of additional-paths."""
                send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                """
                Select an option to send multiple paths for same prefix through bgp updates.
                any: Send any eligible
                path.
                backup: Best path and installed backup path.
                ecmp: All paths in best path ECMP group.
                limit:
                Limit to n eligible paths.
                disabled: Disable sending any paths.
                """
                send_limit: int | None
                """
                Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                `ecmp`.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        receive: bool | None | UndefinedType = Undefined,
                        send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.


                        Subclass of AvdModel.

                        Args:
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """

            _fields: ClassVar[dict] = {
                "default": {"type": Default},
                "route_reflector_preserve_attributes": {"type": RouteReflectorPreserveAttributes},
                "bestpath": {"type": Bestpath},
                "additional_paths": {"type": AdditionalPaths},
                "redistribute_internal": {"type": bool},
            }
            default: Default
            """Subclass of AvdModel."""
            route_reflector_preserve_attributes: RouteReflectorPreserveAttributes
            """Subclass of AvdModel."""
            bestpath: Bestpath
            """Subclass of AvdModel."""
            additional_paths: AdditionalPaths
            """Subclass of AvdModel."""
            redistribute_internal: bool | None
            """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    default: Default | UndefinedType = Undefined,
                    route_reflector_preserve_attributes: RouteReflectorPreserveAttributes | UndefinedType = Undefined,
                    bestpath: Bestpath | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    redistribute_internal: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bgp.


                    Subclass of AvdModel.

                    Args:
                        default: Subclass of AvdModel.
                        route_reflector_preserve_attributes: Subclass of AvdModel.
                        bestpath: Subclass of AvdModel.
                        additional_paths: Subclass of AvdModel.
                        redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.

                    """

        class ListenRangesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "prefix": {"type": str},
                "peer_id_include_router_id": {"type": bool},
                "peer_group": {"type": str},
                "peer_filter": {"type": str},
                "remote_as": {"type": str},
            }
            prefix: str | None
            """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
            peer_id_include_router_id: bool | None
            """Include router ID as part of peer filter."""
            peer_group: str | None
            """Peer group name."""
            peer_filter: str | None
            """
            Peer-filter name.
            note: `peer_filter` or `remote_as` is required but mutually exclusive.
            If both are
            defined, `peer_filter` takes precedence
            """
            remote_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    prefix: str | None | UndefinedType = Undefined,
                    peer_id_include_router_id: bool | None | UndefinedType = Undefined,
                    peer_group: str | None | UndefinedType = Undefined,
                    peer_filter: str | None | UndefinedType = Undefined,
                    remote_as: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ListenRangesItem.


                    Subclass of AvdModel.

                    Args:
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        peer_id_include_router_id: Include router ID as part of peer filter.
                        peer_group: Peer group name.
                        peer_filter:
                           Peer-filter name.
                           note: `peer_filter` or `remote_as` is required but mutually exclusive.
                           If both are
                           defined, `peer_filter` takes precedence
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.

                    """

        class ListenRanges(AvdList[ListenRangesItem]):
            """Subclass of AvdList with `ListenRangesItem` items."""

        ListenRanges._item_type = ListenRangesItem

        class NeighborDefault(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"send_community": {"type": str}}
            send_community: (
                Literal["all", "large", "extended", "standard", "extended large", "standard large", "standard extended", "standard extended large"] | None
            )

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    send_community: Literal[
                        "all", "large", "extended", "standard", "extended large", "standard large", "standard extended", "standard extended large"
                    ]
                    | None
                    | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborDefault.


                    Subclass of AvdModel.

                    Args:
                        send_community: send_community

                    """

        class PeerGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            class AsPath(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"remote_as_replace_out": {"type": bool}, "prepend_own_disabled": {"type": bool}}
                remote_as_replace_out: bool | None
                """Replace AS number with local AS number."""
                prepend_own_disabled: bool | None
                """Disable prepending own AS number to AS path."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, remote_as_replace_out: bool | None | UndefinedType = Undefined, prepend_own_disabled: bool | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        AsPath.


                        Subclass of AvdModel.

                        Args:
                            remote_as_replace_out: Replace AS number with local AS number.
                            prepend_own_disabled: Disable prepending own AS number to AS path.

                        """

            class RemovePrivateAs(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "all": {"type": bool}, "replace_as": {"type": bool}}
                enabled: bool | None
                all: bool | None
                replace_as: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        all: bool | None | UndefinedType = Undefined,
                        replace_as: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RemovePrivateAs.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            all: all
                            replace_as: replace_as

                        """

            class RemovePrivateAsIngress(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "replace_as": {"type": bool}}
                enabled: bool | None
                replace_as: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, replace_as: bool | None | UndefinedType = Undefined) -> None:
                        """
                        RemovePrivateAsIngress.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            replace_as: replace_as

                        """

            class BfdTimers(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}}
                interval: int
                """Interval in milliseconds."""
                min_rx: int
                """Rate in milliseconds."""
                multiplier: int

                if TYPE_CHECKING:

                    def __init__(
                        self, *, interval: int | UndefinedType = Undefined, min_rx: int | UndefinedType = Undefined, multiplier: int | UndefinedType = Undefined
                    ) -> None:
                        """
                        BfdTimers.


                        Subclass of AvdModel.

                        Args:
                            interval: Interval in milliseconds.
                            min_rx: Rate in milliseconds.
                            multiplier: multiplier

                        """

            class DefaultOriginate(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "always": {"type": bool}, "route_map": {"type": str}}
                enabled: bool | None
                always: bool | None
                route_map: str | None
                """Route-map name."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        always: bool | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultOriginate.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            always: always
                            route_map: Route-map name.

                        """

            class MissingPolicy(AvdModel):
                """Subclass of AvdModel."""

                class DirectionIn(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "action": {"type": str},
                        "include_community_list": {"type": bool},
                        "include_prefix_list": {"type": bool},
                        "include_sub_route_map": {"type": bool},
                    }
                    action: Literal["deny", "permit", "deny-in-out"]
                    """Missing policy action."""
                    include_community_list: bool | None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None
                    """Include sub-route-map references in missing policy decision."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionIn.


                            Subclass of AvdModel.

                            Args:
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """

                class DirectionOut(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "action": {"type": str},
                        "include_community_list": {"type": bool},
                        "include_prefix_list": {"type": bool},
                        "include_sub_route_map": {"type": bool},
                    }
                    action: Literal["deny", "permit", "deny-in-out"]
                    """Missing policy action."""
                    include_community_list: bool | None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None
                    """Include sub-route-map references in missing policy decision."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionOut.


                            Subclass of AvdModel.

                            Args:
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """

                _fields: ClassVar[dict] = {"direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}}
                direction_in: DirectionIn
                """
                Missing policy inbound direction.

                Subclass of AvdModel.
                """
                direction_out: DirectionOut
                """
                Missing policy outbound direction.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self, *, direction_in: DirectionIn | UndefinedType = Undefined, direction_out: DirectionOut | UndefinedType = Undefined
                    ) -> None:
                        """
                        MissingPolicy.


                        Subclass of AvdModel.

                        Args:
                            direction_in:
                               Missing policy inbound direction.

                               Subclass of AvdModel.
                            direction_out:
                               Missing policy outbound direction.

                               Subclass of AvdModel.

                        """

            class LinkBandwidth(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "default": {"type": str}}
                enabled: bool | None
                default: str | None
                """nn.nn(K|M|G) link speed in bits/second."""

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, default: str | None | UndefinedType = Undefined) -> None:
                        """
                        LinkBandwidth.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            default: nn.nn(K|M|G) link speed in bits/second.

                        """

            class AllowasIn(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "times": {"type": int}}
                enabled: bool | None
                times: int | None
                """Number of local ASNs allowed in a BGP update."""

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, times: int | None | UndefinedType = Undefined) -> None:
                        """
                        AllowasIn.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            times: Number of local ASNs allowed in a BGP update.

                        """

            class RibInPrePolicyRetain(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "all": {"type": bool}}
                enabled: bool | None
                all: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, all: bool | None | UndefinedType = Undefined) -> None:
                        """
                        RibInPrePolicyRetain.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            all: all

                        """

            class SharedSecret(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"profile": {"type": str}, "hash_algorithm": {"type": str}}
                profile: str
                """Name of profile defined under `management_security`."""
                hash_algorithm: Literal["aes-128-cmac-96", "hmac-sha-256", "hmac-sha1-96"]
                """Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        profile: str | UndefinedType = Undefined,
                        hash_algorithm: Literal["aes-128-cmac-96", "hmac-sha-256", "hmac-sha1-96"] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SharedSecret.


                        Subclass of AvdModel.

                        Args:
                            profile: Name of profile defined under `management_security`.
                            hash_algorithm: Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above.

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "type": {"type": str},
                "remote_as": {"type": str},
                "local_as": {"type": str},
                "description": {"type": str},
                "shutdown": {"type": bool},
                "as_path": {"type": AsPath},
                "remove_private_as": {"type": RemovePrivateAs},
                "remove_private_as_ingress": {"type": RemovePrivateAsIngress},
                "next_hop_unchanged": {"type": bool},
                "update_source": {"type": str},
                "route_reflector_client": {"type": bool},
                "bfd": {"type": bool},
                "bfd_timers": {"type": BfdTimers},
                "ebgp_multihop": {"type": int},
                "next_hop_peer": {"type": bool},
                "next_hop_self": {"type": bool},
                "password": {"type": str},
                "passive": {"type": bool},
                "default_originate": {"type": DefaultOriginate},
                "send_community": {"type": str},
                "maximum_routes": {"type": int},
                "maximum_routes_warning_limit": {"type": str},
                "maximum_routes_warning_only": {"type": bool},
                "missing_policy": {"type": MissingPolicy},
                "link_bandwidth": {"type": LinkBandwidth},
                "allowas_in": {"type": AllowasIn},
                "weight": {"type": int},
                "timers": {"type": str},
                "rib_in_pre_policy_retain": {"type": RibInPrePolicyRetain},
                "route_map_in": {"type": str},
                "route_map_out": {"type": str},
                "peer_tag_in": {"type": str},
                "peer_tag_out_discard": {"type": str},
                "session_tracker": {"type": str},
                "shared_secret": {"type": SharedSecret},
                "ttl_maximum_hops": {"type": int},
            }
            name: str
            """Peer-group name."""
            type: str | None
            """Key only used for documentation or validation purposes."""
            remote_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            local_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            description: str | None
            shutdown: bool | None
            as_path: AsPath
            """
            BGP AS-PATH options.

            Subclass of AvdModel.
            """
            remove_private_as: RemovePrivateAs
            """
            Remove private AS numbers in outbound AS path.

            Subclass of AvdModel.
            """
            remove_private_as_ingress: RemovePrivateAsIngress
            """Subclass of AvdModel."""
            next_hop_unchanged: bool | None
            update_source: str | None
            """IP address or interface name."""
            route_reflector_client: bool | None
            bfd: bool | None
            """Enable BFD."""
            bfd_timers: BfdTimers
            """
            Override default BFD timers. BFD must be enabled with `bfd: true`.

            Subclass of AvdModel.
            """
            ebgp_multihop: int | None
            """Time-to-live in range of hops."""
            next_hop_peer: bool | None
            next_hop_self: bool | None
            password: str | None
            passive: bool | None
            default_originate: DefaultOriginate
            """Subclass of AvdModel."""
            send_community: str | None
            """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
            maximum_routes: int | None
            """Maximum number of routes (0 means unlimited)."""
            maximum_routes_warning_limit: str | None
            """
            Maximum number of routes after which a warning is issued (0 means never warn) or
            Percentage of
            maximum number of routes at which to warn ("<1-100> percent").
            """
            maximum_routes_warning_only: bool | None
            missing_policy: MissingPolicy
            """
            Missing policy configuration for all address-families.

            Subclass of AvdModel.
            """
            link_bandwidth: LinkBandwidth
            """Subclass of AvdModel."""
            allowas_in: AllowasIn
            """Subclass of AvdModel."""
            weight: int | None
            timers: str | None
            """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
            rib_in_pre_policy_retain: RibInPrePolicyRetain
            """Subclass of AvdModel."""
            route_map_in: str | None
            """Inbound route-map name."""
            route_map_out: str | None
            """Outbound route-map name."""
            peer_tag_in: str | None
            """Inbound peer tag name."""
            peer_tag_out_discard: str | None
            """Outbound discard peer tag name."""
            session_tracker: str | None
            shared_secret: SharedSecret
            """Subclass of AvdModel."""
            ttl_maximum_hops: int | None
            """Maximum number of hops."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    type: str | None | UndefinedType = Undefined,
                    remote_as: str | None | UndefinedType = Undefined,
                    local_as: str | None | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    as_path: AsPath | UndefinedType = Undefined,
                    remove_private_as: RemovePrivateAs | UndefinedType = Undefined,
                    remove_private_as_ingress: RemovePrivateAsIngress | UndefinedType = Undefined,
                    next_hop_unchanged: bool | None | UndefinedType = Undefined,
                    update_source: str | None | UndefinedType = Undefined,
                    route_reflector_client: bool | None | UndefinedType = Undefined,
                    bfd: bool | None | UndefinedType = Undefined,
                    bfd_timers: BfdTimers | UndefinedType = Undefined,
                    ebgp_multihop: int | None | UndefinedType = Undefined,
                    next_hop_peer: bool | None | UndefinedType = Undefined,
                    next_hop_self: bool | None | UndefinedType = Undefined,
                    password: str | None | UndefinedType = Undefined,
                    passive: bool | None | UndefinedType = Undefined,
                    default_originate: DefaultOriginate | UndefinedType = Undefined,
                    send_community: str | None | UndefinedType = Undefined,
                    maximum_routes: int | None | UndefinedType = Undefined,
                    maximum_routes_warning_limit: str | None | UndefinedType = Undefined,
                    maximum_routes_warning_only: bool | None | UndefinedType = Undefined,
                    missing_policy: MissingPolicy | UndefinedType = Undefined,
                    link_bandwidth: LinkBandwidth | UndefinedType = Undefined,
                    allowas_in: AllowasIn | UndefinedType = Undefined,
                    weight: int | None | UndefinedType = Undefined,
                    timers: str | None | UndefinedType = Undefined,
                    rib_in_pre_policy_retain: RibInPrePolicyRetain | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    peer_tag_in: str | None | UndefinedType = Undefined,
                    peer_tag_out_discard: str | None | UndefinedType = Undefined,
                    session_tracker: str | None | UndefinedType = Undefined,
                    shared_secret: SharedSecret | UndefinedType = Undefined,
                    ttl_maximum_hops: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Peer-group name.
                        type: Key only used for documentation or validation purposes.
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        local_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        description: description
                        shutdown: shutdown
                        as_path:
                           BGP AS-PATH options.

                           Subclass of AvdModel.
                        remove_private_as:
                           Remove private AS numbers in outbound AS path.

                           Subclass of AvdModel.
                        remove_private_as_ingress: Subclass of AvdModel.
                        next_hop_unchanged: next_hop_unchanged
                        update_source: IP address or interface name.
                        route_reflector_client: route_reflector_client
                        bfd: Enable BFD.
                        bfd_timers:
                           Override default BFD timers. BFD must be enabled with `bfd: true`.

                           Subclass of AvdModel.
                        ebgp_multihop: Time-to-live in range of hops.
                        next_hop_peer: next_hop_peer
                        next_hop_self: next_hop_self
                        password: password
                        passive: passive
                        default_originate: Subclass of AvdModel.
                        send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                        maximum_routes: Maximum number of routes (0 means unlimited).
                        maximum_routes_warning_limit:
                           Maximum number of routes after which a warning is issued (0 means never warn) or
                           Percentage of
                           maximum number of routes at which to warn ("<1-100> percent").
                        maximum_routes_warning_only: maximum_routes_warning_only
                        missing_policy:
                           Missing policy configuration for all address-families.

                           Subclass of AvdModel.
                        link_bandwidth: Subclass of AvdModel.
                        allowas_in: Subclass of AvdModel.
                        weight: weight
                        timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                        rib_in_pre_policy_retain: Subclass of AvdModel.
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        peer_tag_in: Inbound peer tag name.
                        peer_tag_out_discard: Outbound discard peer tag name.
                        session_tracker: session_tracker
                        shared_secret: Subclass of AvdModel.
                        ttl_maximum_hops: Maximum number of hops.

                    """

        class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        PeerGroups._item_type = PeerGroupsItem

        class NeighborsItem(AvdModel):
            """Subclass of AvdModel."""

            class AsPath(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"remote_as_replace_out": {"type": bool}, "prepend_own_disabled": {"type": bool}}
                remote_as_replace_out: bool | None
                """Replace AS number with local AS number."""
                prepend_own_disabled: bool | None
                """Disable prepending own AS number to AS path."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, remote_as_replace_out: bool | None | UndefinedType = Undefined, prepend_own_disabled: bool | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        AsPath.


                        Subclass of AvdModel.

                        Args:
                            remote_as_replace_out: Replace AS number with local AS number.
                            prepend_own_disabled: Disable prepending own AS number to AS path.

                        """

            class BfdTimers(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}}
                interval: int
                """Interval in milliseconds."""
                min_rx: int
                """Rate in milliseconds."""
                multiplier: int

                if TYPE_CHECKING:

                    def __init__(
                        self, *, interval: int | UndefinedType = Undefined, min_rx: int | UndefinedType = Undefined, multiplier: int | UndefinedType = Undefined
                    ) -> None:
                        """
                        BfdTimers.


                        Subclass of AvdModel.

                        Args:
                            interval: Interval in milliseconds.
                            min_rx: Rate in milliseconds.
                            multiplier: multiplier

                        """

            class DefaultOriginate(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "always": {"type": bool}, "route_map": {"type": str}}
                enabled: bool | None
                always: bool | None
                route_map: str | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        always: bool | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultOriginate.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            always: always
                            route_map: route_map

                        """

            class MissingPolicy(AvdModel):
                """Subclass of AvdModel."""

                class DirectionIn(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "action": {"type": str},
                        "include_community_list": {"type": bool},
                        "include_prefix_list": {"type": bool},
                        "include_sub_route_map": {"type": bool},
                    }
                    action: Literal["deny", "permit", "deny-in-out"]
                    """Missing policy action."""
                    include_community_list: bool | None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None
                    """Include sub-route-map references in missing policy decision."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionIn.


                            Subclass of AvdModel.

                            Args:
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """

                class DirectionOut(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "action": {"type": str},
                        "include_community_list": {"type": bool},
                        "include_prefix_list": {"type": bool},
                        "include_sub_route_map": {"type": bool},
                    }
                    action: Literal["deny", "permit", "deny-in-out"]
                    """Missing policy action."""
                    include_community_list: bool | None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None
                    """Include sub-route-map references in missing policy decision."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionOut.


                            Subclass of AvdModel.

                            Args:
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """

                _fields: ClassVar[dict] = {"direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}}
                direction_in: DirectionIn
                """
                Missing policy inbound direction.

                Subclass of AvdModel.
                """
                direction_out: DirectionOut
                """
                Missing policy outbound direction.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self, *, direction_in: DirectionIn | UndefinedType = Undefined, direction_out: DirectionOut | UndefinedType = Undefined
                    ) -> None:
                        """
                        MissingPolicy.


                        Subclass of AvdModel.

                        Args:
                            direction_in:
                               Missing policy inbound direction.

                               Subclass of AvdModel.
                            direction_out:
                               Missing policy outbound direction.

                               Subclass of AvdModel.

                        """

            class AllowasIn(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "times": {"type": int}}
                enabled: bool | None
                times: int | None
                """Number of local ASNs allowed in a BGP update."""

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, times: int | None | UndefinedType = Undefined) -> None:
                        """
                        AllowasIn.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            times: Number of local ASNs allowed in a BGP update.

                        """

            class LinkBandwidth(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "default": {"type": str}}
                enabled: bool | None
                default: str | None
                """nn.nn(K|M|G) link speed in bits/second."""

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, default: str | None | UndefinedType = Undefined) -> None:
                        """
                        LinkBandwidth.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            default: nn.nn(K|M|G) link speed in bits/second.

                        """

            class RibInPrePolicyRetain(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "all": {"type": bool}}
                enabled: bool | None
                all: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, all: bool | None | UndefinedType = Undefined) -> None:
                        """
                        RibInPrePolicyRetain.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            all: all

                        """

            class RemovePrivateAs(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "all": {"type": bool}, "replace_as": {"type": bool}}
                enabled: bool | None
                all: bool | None
                replace_as: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        all: bool | None | UndefinedType = Undefined,
                        replace_as: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RemovePrivateAs.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            all: all
                            replace_as: replace_as

                        """

            class RemovePrivateAsIngress(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "replace_as": {"type": bool}}
                enabled: bool | None
                replace_as: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, replace_as: bool | None | UndefinedType = Undefined) -> None:
                        """
                        RemovePrivateAsIngress.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            replace_as: replace_as

                        """

            class SharedSecret(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"profile": {"type": str}, "hash_algorithm": {"type": str}}
                profile: str
                """Name of profile defined under `management_security`."""
                hash_algorithm: Literal["aes-128-cmac-96", "hmac-sha-256", "hmac-sha1-96"]
                """Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        profile: str | UndefinedType = Undefined,
                        hash_algorithm: Literal["aes-128-cmac-96", "hmac-sha-256", "hmac-sha1-96"] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SharedSecret.


                        Subclass of AvdModel.

                        Args:
                            profile: Name of profile defined under `management_security`.
                            hash_algorithm: Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above.

                        """

            _fields: ClassVar[dict] = {
                "ip_address": {"type": str},
                "peer_group": {"type": str},
                "remote_as": {"type": str},
                "local_as": {"type": str},
                "as_path": {"type": AsPath},
                "peer": {"type": str},
                "description": {"type": str},
                "route_reflector_client": {"type": bool},
                "password": {"type": str},
                "passive": {"type": bool},
                "shutdown": {"type": bool},
                "update_source": {"type": str},
                "bfd": {"type": bool},
                "bfd_timers": {"type": BfdTimers},
                "weight": {"type": int},
                "timers": {"type": str},
                "route_map_in": {"type": str},
                "route_map_out": {"type": str},
                "peer_tag_in": {"type": str},
                "peer_tag_out_discard": {"type": str},
                "default_originate": {"type": DefaultOriginate},
                "send_community": {"type": str},
                "maximum_routes": {"type": int},
                "maximum_routes_warning_limit": {"type": str},
                "maximum_routes_warning_only": {"type": bool},
                "missing_policy": {"type": MissingPolicy},
                "allowas_in": {"type": AllowasIn},
                "ebgp_multihop": {"type": int},
                "next_hop_peer": {"type": bool},
                "next_hop_self": {"type": bool},
                "link_bandwidth": {"type": LinkBandwidth},
                "rib_in_pre_policy_retain": {"type": RibInPrePolicyRetain},
                "remove_private_as": {"type": RemovePrivateAs},
                "remove_private_as_ingress": {"type": RemovePrivateAsIngress},
                "session_tracker": {"type": str},
                "shared_secret": {"type": SharedSecret},
                "ttl_maximum_hops": {"type": int},
            }
            ip_address: str
            peer_group: str | None
            remote_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            local_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            as_path: AsPath
            """
            BGP AS-PATH options.

            Subclass of AvdModel.
            """
            peer: str | None
            """Key only used for documentation or validation purposes."""
            description: str | None
            route_reflector_client: bool | None
            password: str | None
            passive: bool | None
            shutdown: bool | None
            update_source: str | None
            """Source Interface."""
            bfd: bool | None
            """Enable BFD."""
            bfd_timers: BfdTimers
            """
            Override default BFD timers. BFD must be enabled with `bfd: true`.

            Subclass of AvdModel.
            """
            weight: int | None
            timers: str | None
            """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
            route_map_in: str | None
            """Inbound route-map name."""
            route_map_out: str | None
            """Outbound route-map name."""
            peer_tag_in: str | None
            """Inbound peer tag name."""
            peer_tag_out_discard: str | None
            """Outbound discard peer tag name."""
            default_originate: DefaultOriginate
            """Subclass of AvdModel."""
            send_community: str | None
            """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
            maximum_routes: int | None
            """Maximum number of routes (0 means unlimited)."""
            maximum_routes_warning_limit: str | None
            """
            Maximum number of routes after which a warning is issued (0 means never warn) or
            Percentage of
            maximum number of routes at which to warn ("<1-100> percent").
            """
            maximum_routes_warning_only: bool | None
            missing_policy: MissingPolicy
            """
            Missing policy configuration for all address-families.

            Subclass of AvdModel.
            """
            allowas_in: AllowasIn
            """Subclass of AvdModel."""
            ebgp_multihop: int | None
            """Time-to-live in range of hops."""
            next_hop_peer: bool | None
            next_hop_self: bool | None
            link_bandwidth: LinkBandwidth
            """Subclass of AvdModel."""
            rib_in_pre_policy_retain: RibInPrePolicyRetain
            """Subclass of AvdModel."""
            remove_private_as: RemovePrivateAs
            """
            Remove private AS numbers in outbound AS path.

            Subclass of AvdModel.
            """
            remove_private_as_ingress: RemovePrivateAsIngress
            """Subclass of AvdModel."""
            session_tracker: str | None
            shared_secret: SharedSecret
            """Subclass of AvdModel."""
            ttl_maximum_hops: int | None
            """Maximum number of hops."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ip_address: str | UndefinedType = Undefined,
                    peer_group: str | None | UndefinedType = Undefined,
                    remote_as: str | None | UndefinedType = Undefined,
                    local_as: str | None | UndefinedType = Undefined,
                    as_path: AsPath | UndefinedType = Undefined,
                    peer: str | None | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    route_reflector_client: bool | None | UndefinedType = Undefined,
                    password: str | None | UndefinedType = Undefined,
                    passive: bool | None | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    update_source: str | None | UndefinedType = Undefined,
                    bfd: bool | None | UndefinedType = Undefined,
                    bfd_timers: BfdTimers | UndefinedType = Undefined,
                    weight: int | None | UndefinedType = Undefined,
                    timers: str | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    peer_tag_in: str | None | UndefinedType = Undefined,
                    peer_tag_out_discard: str | None | UndefinedType = Undefined,
                    default_originate: DefaultOriginate | UndefinedType = Undefined,
                    send_community: str | None | UndefinedType = Undefined,
                    maximum_routes: int | None | UndefinedType = Undefined,
                    maximum_routes_warning_limit: str | None | UndefinedType = Undefined,
                    maximum_routes_warning_only: bool | None | UndefinedType = Undefined,
                    missing_policy: MissingPolicy | UndefinedType = Undefined,
                    allowas_in: AllowasIn | UndefinedType = Undefined,
                    ebgp_multihop: int | None | UndefinedType = Undefined,
                    next_hop_peer: bool | None | UndefinedType = Undefined,
                    next_hop_self: bool | None | UndefinedType = Undefined,
                    link_bandwidth: LinkBandwidth | UndefinedType = Undefined,
                    rib_in_pre_policy_retain: RibInPrePolicyRetain | UndefinedType = Undefined,
                    remove_private_as: RemovePrivateAs | UndefinedType = Undefined,
                    remove_private_as_ingress: RemovePrivateAsIngress | UndefinedType = Undefined,
                    session_tracker: str | None | UndefinedType = Undefined,
                    shared_secret: SharedSecret | UndefinedType = Undefined,
                    ttl_maximum_hops: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.


                    Subclass of AvdModel.

                    Args:
                        ip_address: ip_address
                        peer_group: peer_group
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        local_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        as_path:
                           BGP AS-PATH options.

                           Subclass of AvdModel.
                        peer: Key only used for documentation or validation purposes.
                        description: description
                        route_reflector_client: route_reflector_client
                        password: password
                        passive: passive
                        shutdown: shutdown
                        update_source: Source Interface.
                        bfd: Enable BFD.
                        bfd_timers:
                           Override default BFD timers. BFD must be enabled with `bfd: true`.

                           Subclass of AvdModel.
                        weight: weight
                        timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        peer_tag_in: Inbound peer tag name.
                        peer_tag_out_discard: Outbound discard peer tag name.
                        default_originate: Subclass of AvdModel.
                        send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                        maximum_routes: Maximum number of routes (0 means unlimited).
                        maximum_routes_warning_limit:
                           Maximum number of routes after which a warning is issued (0 means never warn) or
                           Percentage of
                           maximum number of routes at which to warn ("<1-100> percent").
                        maximum_routes_warning_only: maximum_routes_warning_only
                        missing_policy:
                           Missing policy configuration for all address-families.

                           Subclass of AvdModel.
                        allowas_in: Subclass of AvdModel.
                        ebgp_multihop: Time-to-live in range of hops.
                        next_hop_peer: next_hop_peer
                        next_hop_self: next_hop_self
                        link_bandwidth: Subclass of AvdModel.
                        rib_in_pre_policy_retain: Subclass of AvdModel.
                        remove_private_as:
                           Remove private AS numbers in outbound AS path.

                           Subclass of AvdModel.
                        remove_private_as_ingress: Subclass of AvdModel.
                        session_tracker: session_tracker
                        shared_secret: Subclass of AvdModel.
                        ttl_maximum_hops: Maximum number of hops.

                    """

        class Neighbors(AvdIndexedList[str, NeighborsItem]):
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

            _primary_key: ClassVar[str] = "ip_address"

        Neighbors._item_type = NeighborsItem

        class NeighborInterfacesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "remote_as": {"type": str},
                "peer": {"type": str},
                "peer_group": {"type": str, "default": "Peer-group name"},
                "description": {"type": str},
                "peer_filter": {"type": str},
            }
            name: str
            """Interface name."""
            remote_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            peer: str | None
            """Key only used for documentation or validation purposes."""
            peer_group: str
            """Default value: `"Peer-group name"`"""
            description: str | None
            peer_filter: str | None
            """Peer-filter name."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    remote_as: str | None | UndefinedType = Undefined,
                    peer: str | None | UndefinedType = Undefined,
                    peer_group: str | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    peer_filter: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborInterfacesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Interface name.
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        peer: Key only used for documentation or validation purposes.
                        peer_group: peer_group
                        description: description
                        peer_filter: Peer-filter name.

                    """

        class NeighborInterfaces(AvdIndexedList[str, NeighborInterfacesItem]):
            """Subclass of AvdIndexedList with `NeighborInterfacesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        NeighborInterfaces._item_type = NeighborInterfacesItem

        class AggregateAddressesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "prefix": {"type": str},
                "advertise_only": {"type": bool},
                "as_set": {"type": bool},
                "summary_only": {"type": bool},
                "attribute_map": {"type": str},
                "match_map": {"type": str},
            }
            prefix: str
            """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
            advertise_only: bool | None
            as_set: bool | None
            summary_only: bool | None
            attribute_map: str | None
            """Route-map name."""
            match_map: str | None
            """Route-map name."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    prefix: str | UndefinedType = Undefined,
                    advertise_only: bool | None | UndefinedType = Undefined,
                    as_set: bool | None | UndefinedType = Undefined,
                    summary_only: bool | None | UndefinedType = Undefined,
                    attribute_map: str | None | UndefinedType = Undefined,
                    match_map: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AggregateAddressesItem.


                    Subclass of AvdModel.

                    Args:
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        advertise_only: advertise_only
                        as_set: as_set
                        summary_only: summary_only
                        attribute_map: Route-map name.
                        match_map: Route-map name.

                    """

        class AggregateAddresses(AvdIndexedList[str, AggregateAddressesItem]):
            """Subclass of AvdIndexedList with `AggregateAddressesItem` items. Primary key is `prefix` (`str`)."""

            _primary_key: ClassVar[str] = "prefix"

        AggregateAddresses._item_type = AggregateAddressesItem

        class Redistribute(AvdModel):
            """Subclass of AvdModel."""

            class AttachedHost(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                enabled: bool
                route_map: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                        """
                        AttachedHost.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            route_map: route_map

                        """

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                enabled: bool
                route_map: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            route_map: route_map

                        """

            class Connected(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "include_leaked": {"type": bool}}
                enabled: bool
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """
                include_leaked: bool | None
                """Include following routes while redistributing."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Connected.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """

            class Dynamic(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                enabled: bool
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dynamic.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.

                        """

            class Isis(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "isis_level": {"type": str},
                    "route_map": {"type": str},
                    "rcf": {"type": str},
                    "include_leaked": {"type": bool},
                }
                enabled: bool
                isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                """Redistribute IS-IS route level."""
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """
                include_leaked: bool | None
                """Include following routes while redistributing."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Isis.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            isis_level: Redistribute IS-IS route level.
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """

            class Ospf(AvdModel):
                """Subclass of AvdModel."""

                class MatchExternal(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """

                class MatchInternal(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """

                class MatchNssaExternal(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "nssa_type": {"type": int},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool
                    nssa_type: Literal[1, 2] | None
                    """NSSA External Type Number."""
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "match_external": {"type": MatchExternal},
                    "match_internal": {"type": MatchInternal},
                    "match_nssa_external": {"type": MatchNssaExternal},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                }
                enabled: bool | None
                """Redistribute OSPF routes."""
                match_external: MatchExternal
                """
                Redistribute OSPF routes learned from external sources.

                Subclass of AvdModel.
                """
                match_internal: MatchInternal
                """
                Redistribute OSPF routes learned from internal sources.

                Subclass of AvdModel.
                """
                match_nssa_external: MatchNssaExternal
                """
                Redistribute OSPF routes learned from external NSSA sources.

                Subclass of AvdModel.
                """
                route_map: str | None
                include_leaked: bool | None
                """Include following routes while redistributing."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospf.


                        Subclass of AvdModel.

                        Args:
                            enabled: Redistribute OSPF routes.
                            match_external:
                               Redistribute OSPF routes learned from external sources.

                               Subclass of AvdModel.
                            match_internal:
                               Redistribute OSPF routes learned from internal sources.

                               Subclass of AvdModel.
                            match_nssa_external:
                               Redistribute OSPF routes learned from external NSSA sources.

                               Subclass of AvdModel.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """

            class Ospfv3(AvdModel):
                """Subclass of AvdModel."""

                class MatchExternal(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """

                class MatchInternal(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """

                class MatchNssaExternal(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "nssa_type": {"type": int},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool
                    nssa_type: Literal[1, 2] | None
                    """NSSA External Type Number."""
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "match_external": {"type": MatchExternal},
                    "match_internal": {"type": MatchInternal},
                    "match_nssa_external": {"type": MatchNssaExternal},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                }
                enabled: bool | None
                """Redistribute OSPFv3 routes."""
                match_external: MatchExternal
                """
                Redistribute OSPFv3 routes learned from external sources.

                Subclass of AvdModel.
                """
                match_internal: MatchInternal
                """
                Redistribute OSPFv3 routes learned from internal sources.

                Subclass of AvdModel.
                """
                match_nssa_external: MatchNssaExternal
                """
                Redistribute OSPFv3 routes learned from external NSSA sources.

                Subclass of AvdModel.
                """
                route_map: str | None
                include_leaked: bool | None
                """Include following routes while redistributing."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospfv3.


                        Subclass of AvdModel.

                        Args:
                            enabled: Redistribute OSPFv3 routes.
                            match_external:
                               Redistribute OSPFv3 routes learned from external sources.

                               Subclass of AvdModel.
                            match_internal:
                               Redistribute OSPFv3 routes learned from internal sources.

                               Subclass of AvdModel.
                            match_nssa_external:
                               Redistribute OSPFv3 routes learned from external NSSA sources.

                               Subclass of AvdModel.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """

            class Rip(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                enabled: bool
                route_map: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                        """
                        Rip.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            route_map: route_map

                        """

            class Static(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "include_leaked": {"type": bool}}
                enabled: bool
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """
                include_leaked: bool | None
                """Include following routes while redistributing."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Static.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """

            class User(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}}
                enabled: bool
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | UndefinedType = Undefined, rcf: str | None | UndefinedType = Undefined) -> None:
                        """
                        User.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.

                        """

            _fields: ClassVar[dict] = {
                "attached_host": {"type": AttachedHost},
                "bgp": {"type": Bgp},
                "connected": {"type": Connected},
                "dynamic": {"type": Dynamic},
                "isis": {"type": Isis},
                "ospf": {"type": Ospf},
                "ospfv3": {"type": Ospfv3},
                "rip": {"type": Rip},
                "static": {"type": Static},
                "user": {"type": User},
            }
            attached_host: AttachedHost
            """Subclass of AvdModel."""
            bgp: Bgp
            """Subclass of AvdModel."""
            connected: Connected
            """Subclass of AvdModel."""
            dynamic: Dynamic
            """Subclass of AvdModel."""
            isis: Isis
            """Subclass of AvdModel."""
            ospf: Ospf
            """Subclass of AvdModel."""
            ospfv3: Ospfv3
            """Subclass of AvdModel."""
            rip: Rip
            """Subclass of AvdModel."""
            static: Static
            """Subclass of AvdModel."""
            user: User
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    attached_host: AttachedHost | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    connected: Connected | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    isis: Isis | UndefinedType = Undefined,
                    ospf: Ospf | UndefinedType = Undefined,
                    ospfv3: Ospfv3 | UndefinedType = Undefined,
                    rip: Rip | UndefinedType = Undefined,
                    static: Static | UndefinedType = Undefined,
                    user: User | UndefinedType = Undefined,
                ) -> None:
                    """
                    Redistribute.


                    Subclass of AvdModel.

                    Args:
                        attached_host: Subclass of AvdModel.
                        bgp: Subclass of AvdModel.
                        connected: Subclass of AvdModel.
                        dynamic: Subclass of AvdModel.
                        isis: Subclass of AvdModel.
                        ospf: Subclass of AvdModel.
                        ospfv3: Subclass of AvdModel.
                        rip: Subclass of AvdModel.
                        static: Subclass of AvdModel.
                        user: Subclass of AvdModel.

                    """

        class RedistributeRoutesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "source_protocol": {"type": str},
                "route_map": {"type": str},
                "rcf": {"type": str},
                "include_leaked": {"type": bool},
                "ospf_route_type": {"type": str},
            }
            source_protocol: Literal["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
            route_map: str | None
            rcf: str | None
            """
            RCF function name with parenthesis.
            Example: MyFunction(myarg).
            `route_map` and `rcf` are mutually
            exclusive. `route_map` takes precedence.
            Only applicable if `source_protocol` is one of `connected`,
            `static`, `isis`, `user`, `dynamic`.
            """
            include_leaked: bool | None
            ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
            """
            Routes learned by the OSPF protocol.
            The `ospf_route_type` is valid for source_protocols 'ospf' and
            'ospfv3'.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    source_protocol: Literal["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                    | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                    ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RedistributeRoutesItem.


                    Subclass of AvdModel.

                    Args:
                        source_protocol: source_protocol
                        route_map: route_map
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                           Only applicable if `source_protocol` is one of `connected`,
                           `static`, `isis`, `user`, `dynamic`.
                        include_leaked: include_leaked
                        ospf_route_type:
                           Routes learned by the OSPF protocol.
                           The `ospf_route_type` is valid for source_protocols 'ospf' and
                           'ospfv3'.

                    """

        class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
            """Subclass of AvdList with `RedistributeRoutesItem` items."""

        RedistributeRoutes._item_type = RedistributeRoutesItem

        class VlanAwareBundlesItem(AvdModel):
            """Subclass of AvdModel."""

            class RdEvpnDomain(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"domain": {"type": str}, "rd": {"type": str}}
                domain: Literal["remote", "all"] | None
                rd: str | None
                """Route distinguisher."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, domain: Literal["remote", "all"] | None | UndefinedType = Undefined, rd: str | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        RdEvpnDomain.


                        Subclass of AvdModel.

                        Args:
                            domain: domain
                            rd: Route distinguisher.

                        """

            class RouteTargets(AvdModel):
                """Subclass of AvdModel."""

                class Both(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Both._item_type = str

                class Import(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Import._item_type = str

                class Export(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Export._item_type = str

                class ImportEvpnDomainsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"domain": {"type": str}, "route_target": {"type": str}}
                    domain: Literal["remote", "all"] | None
                    route_target: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, domain: Literal["remote", "all"] | None | UndefinedType = Undefined, route_target: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            ImportEvpnDomainsItem.


                            Subclass of AvdModel.

                            Args:
                                domain: domain
                                route_target: route_target

                            """

                class ImportEvpnDomains(AvdList[ImportEvpnDomainsItem]):
                    """Subclass of AvdList with `ImportEvpnDomainsItem` items."""

                ImportEvpnDomains._item_type = ImportEvpnDomainsItem

                class ExportEvpnDomainsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"domain": {"type": str}, "route_target": {"type": str}}
                    domain: Literal["remote", "all"] | None
                    route_target: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, domain: Literal["remote", "all"] | None | UndefinedType = Undefined, route_target: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            ExportEvpnDomainsItem.


                            Subclass of AvdModel.

                            Args:
                                domain: domain
                                route_target: route_target

                            """

                class ExportEvpnDomains(AvdList[ExportEvpnDomainsItem]):
                    """Subclass of AvdList with `ExportEvpnDomainsItem` items."""

                ExportEvpnDomains._item_type = ExportEvpnDomainsItem

                class ImportExportEvpnDomainsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"domain": {"type": str}, "route_target": {"type": str}}
                    domain: Literal["remote", "all"] | None
                    route_target: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, domain: Literal["remote", "all"] | None | UndefinedType = Undefined, route_target: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            ImportExportEvpnDomainsItem.


                            Subclass of AvdModel.

                            Args:
                                domain: domain
                                route_target: route_target

                            """

                class ImportExportEvpnDomains(AvdList[ImportExportEvpnDomainsItem]):
                    """Subclass of AvdList with `ImportExportEvpnDomainsItem` items."""

                ImportExportEvpnDomains._item_type = ImportExportEvpnDomainsItem

                _fields: ClassVar[dict] = {
                    "both": {"type": Both},
                    "field_import": {"type": Import},
                    "export": {"type": Export},
                    "import_evpn_domains": {"type": ImportEvpnDomains},
                    "export_evpn_domains": {"type": ExportEvpnDomains},
                    "import_export_evpn_domains": {"type": ImportExportEvpnDomains},
                }
                _field_to_key_map: ClassVar[dict] = {"field_import": "import"}
                _key_to_field_map: ClassVar[dict] = {"import": "field_import"}
                both: Both
                """Subclass of AvdList with `str` items."""
                field_import: Import
                """Subclass of AvdList with `str` items."""
                export: Export
                """Subclass of AvdList with `str` items."""
                import_evpn_domains: ImportEvpnDomains
                """Subclass of AvdList with `ImportEvpnDomainsItem` items."""
                export_evpn_domains: ExportEvpnDomains
                """Subclass of AvdList with `ExportEvpnDomainsItem` items."""
                import_export_evpn_domains: ImportExportEvpnDomains
                """Subclass of AvdList with `ImportExportEvpnDomainsItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        both: Both | UndefinedType = Undefined,
                        field_import: Import | UndefinedType = Undefined,
                        export: Export | UndefinedType = Undefined,
                        import_evpn_domains: ImportEvpnDomains | UndefinedType = Undefined,
                        export_evpn_domains: ExportEvpnDomains | UndefinedType = Undefined,
                        import_export_evpn_domains: ImportExportEvpnDomains | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RouteTargets.


                        Subclass of AvdModel.

                        Args:
                            both: Subclass of AvdList with `str` items.
                            field_import: Subclass of AvdList with `str` items.
                            export: Subclass of AvdList with `str` items.
                            import_evpn_domains: Subclass of AvdList with `ImportEvpnDomainsItem` items.
                            export_evpn_domains: Subclass of AvdList with `ExportEvpnDomainsItem` items.
                            import_export_evpn_domains: Subclass of AvdList with `ImportExportEvpnDomainsItem` items.

                        """

            class RedistributeRoutes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            RedistributeRoutes._item_type = str

            class NoRedistributeRoutes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            NoRedistributeRoutes._item_type = str

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "tenant": {"type": str},
                "description": {"type": str},
                "rd": {"type": str},
                "rd_evpn_domain": {"type": RdEvpnDomain},
                "route_targets": {"type": RouteTargets},
                "redistribute_routes": {"type": RedistributeRoutes},
                "no_redistribute_routes": {"type": NoRedistributeRoutes},
                "vlan": {"type": str},
                "eos_cli": {"type": str},
            }
            name: str
            """VLAN aware bundle name."""
            tenant: str | None
            """Key only used for documentation or validation purposes."""
            description: str | None
            """Key only used for documentation or validation purposes."""
            rd: str | None
            """Route distinguisher."""
            rd_evpn_domain: RdEvpnDomain
            """Subclass of AvdModel."""
            route_targets: RouteTargets
            """Subclass of AvdModel."""
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `str` items."""
            no_redistribute_routes: NoRedistributeRoutes
            """Subclass of AvdList with `str` items."""
            vlan: str | None
            """VLAN range as string. Example "100-200,300"."""
            eos_cli: str | None
            """
            Multiline EOS CLI rendered directly on the Router BGP, VLAN-aware-bundle definition in the final EOS
            configuration.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    tenant: str | None | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    rd: str | None | UndefinedType = Undefined,
                    rd_evpn_domain: RdEvpnDomain | UndefinedType = Undefined,
                    route_targets: RouteTargets | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    no_redistribute_routes: NoRedistributeRoutes | UndefinedType = Undefined,
                    vlan: str | None | UndefinedType = Undefined,
                    eos_cli: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    VlanAwareBundlesItem.


                    Subclass of AvdModel.

                    Args:
                        name: VLAN aware bundle name.
                        tenant: Key only used for documentation or validation purposes.
                        description: Key only used for documentation or validation purposes.
                        rd: Route distinguisher.
                        rd_evpn_domain: Subclass of AvdModel.
                        route_targets: Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `str` items.
                        no_redistribute_routes: Subclass of AvdList with `str` items.
                        vlan: VLAN range as string. Example "100-200,300".
                        eos_cli:
                           Multiline EOS CLI rendered directly on the Router BGP, VLAN-aware-bundle definition in the final EOS
                           configuration.

                    """

        class VlanAwareBundles(AvdIndexedList[str, VlanAwareBundlesItem]):
            """Subclass of AvdIndexedList with `VlanAwareBundlesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        VlanAwareBundles._item_type = VlanAwareBundlesItem

        class VlansItem(AvdModel):
            """Subclass of AvdModel."""

            class RdEvpnDomain(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"domain": {"type": str}, "rd": {"type": str}}
                domain: Literal["remote", "all"] | None
                rd: str | None
                """Route distinguisher."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, domain: Literal["remote", "all"] | None | UndefinedType = Undefined, rd: str | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        RdEvpnDomain.


                        Subclass of AvdModel.

                        Args:
                            domain: domain
                            rd: Route distinguisher.

                        """

            class RouteTargets(AvdModel):
                """Subclass of AvdModel."""

                class Both(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Both._item_type = str

                class Import(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Import._item_type = str

                class Export(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Export._item_type = str

                class ImportEvpnDomainsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"domain": {"type": str}, "route_target": {"type": str}}
                    domain: Literal["remote", "all"] | None
                    route_target: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, domain: Literal["remote", "all"] | None | UndefinedType = Undefined, route_target: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            ImportEvpnDomainsItem.


                            Subclass of AvdModel.

                            Args:
                                domain: domain
                                route_target: route_target

                            """

                class ImportEvpnDomains(AvdList[ImportEvpnDomainsItem]):
                    """Subclass of AvdList with `ImportEvpnDomainsItem` items."""

                ImportEvpnDomains._item_type = ImportEvpnDomainsItem

                class ExportEvpnDomainsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"domain": {"type": str}, "route_target": {"type": str}}
                    domain: Literal["remote", "all"] | None
                    route_target: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, domain: Literal["remote", "all"] | None | UndefinedType = Undefined, route_target: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            ExportEvpnDomainsItem.


                            Subclass of AvdModel.

                            Args:
                                domain: domain
                                route_target: route_target

                            """

                class ExportEvpnDomains(AvdList[ExportEvpnDomainsItem]):
                    """Subclass of AvdList with `ExportEvpnDomainsItem` items."""

                ExportEvpnDomains._item_type = ExportEvpnDomainsItem

                class ImportExportEvpnDomainsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"domain": {"type": str}, "route_target": {"type": str}}
                    domain: Literal["remote", "all"] | None
                    route_target: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, domain: Literal["remote", "all"] | None | UndefinedType = Undefined, route_target: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            ImportExportEvpnDomainsItem.


                            Subclass of AvdModel.

                            Args:
                                domain: domain
                                route_target: route_target

                            """

                class ImportExportEvpnDomains(AvdList[ImportExportEvpnDomainsItem]):
                    """Subclass of AvdList with `ImportExportEvpnDomainsItem` items."""

                ImportExportEvpnDomains._item_type = ImportExportEvpnDomainsItem

                _fields: ClassVar[dict] = {
                    "both": {"type": Both},
                    "field_import": {"type": Import},
                    "export": {"type": Export},
                    "import_evpn_domains": {"type": ImportEvpnDomains},
                    "export_evpn_domains": {"type": ExportEvpnDomains},
                    "import_export_evpn_domains": {"type": ImportExportEvpnDomains},
                }
                _field_to_key_map: ClassVar[dict] = {"field_import": "import"}
                _key_to_field_map: ClassVar[dict] = {"import": "field_import"}
                both: Both
                """Subclass of AvdList with `str` items."""
                field_import: Import
                """Subclass of AvdList with `str` items."""
                export: Export
                """Subclass of AvdList with `str` items."""
                import_evpn_domains: ImportEvpnDomains
                """Subclass of AvdList with `ImportEvpnDomainsItem` items."""
                export_evpn_domains: ExportEvpnDomains
                """Subclass of AvdList with `ExportEvpnDomainsItem` items."""
                import_export_evpn_domains: ImportExportEvpnDomains
                """Subclass of AvdList with `ImportExportEvpnDomainsItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        both: Both | UndefinedType = Undefined,
                        field_import: Import | UndefinedType = Undefined,
                        export: Export | UndefinedType = Undefined,
                        import_evpn_domains: ImportEvpnDomains | UndefinedType = Undefined,
                        export_evpn_domains: ExportEvpnDomains | UndefinedType = Undefined,
                        import_export_evpn_domains: ImportExportEvpnDomains | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RouteTargets.


                        Subclass of AvdModel.

                        Args:
                            both: Subclass of AvdList with `str` items.
                            field_import: Subclass of AvdList with `str` items.
                            export: Subclass of AvdList with `str` items.
                            import_evpn_domains: Subclass of AvdList with `ImportEvpnDomainsItem` items.
                            export_evpn_domains: Subclass of AvdList with `ExportEvpnDomainsItem` items.
                            import_export_evpn_domains: Subclass of AvdList with `ImportExportEvpnDomainsItem` items.

                        """

            class RedistributeRoutes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            RedistributeRoutes._item_type = str

            class NoRedistributeRoutes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            NoRedistributeRoutes._item_type = str

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "tenant": {"type": str},
                "rd": {"type": str},
                "rd_evpn_domain": {"type": RdEvpnDomain},
                "route_targets": {"type": RouteTargets},
                "redistribute_routes": {"type": RedistributeRoutes},
                "no_redistribute_routes": {"type": NoRedistributeRoutes},
                "eos_cli": {"type": str},
            }
            id: int
            tenant: str | None
            """Key only used for documentation or validation purposes."""
            rd: str | None
            """Route distinguisher."""
            rd_evpn_domain: RdEvpnDomain
            """Subclass of AvdModel."""
            route_targets: RouteTargets
            """Subclass of AvdModel."""
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `str` items."""
            no_redistribute_routes: NoRedistributeRoutes
            """Subclass of AvdList with `str` items."""
            eos_cli: str | None
            """
            Multiline EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS
            configuration.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    tenant: str | None | UndefinedType = Undefined,
                    rd: str | None | UndefinedType = Undefined,
                    rd_evpn_domain: RdEvpnDomain | UndefinedType = Undefined,
                    route_targets: RouteTargets | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    no_redistribute_routes: NoRedistributeRoutes | UndefinedType = Undefined,
                    eos_cli: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    VlansItem.


                    Subclass of AvdModel.

                    Args:
                        id: id
                        tenant: Key only used for documentation or validation purposes.
                        rd: Route distinguisher.
                        rd_evpn_domain: Subclass of AvdModel.
                        route_targets: Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `str` items.
                        no_redistribute_routes: Subclass of AvdList with `str` items.
                        eos_cli:
                           Multiline EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS
                           configuration.

                    """

        class Vlans(AvdIndexedList[int, VlansItem]):
            """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        Vlans._item_type = VlansItem

        class VpwsItem(AvdModel):
            """Subclass of AvdModel."""

            class RouteTargets(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"import_export": {"type": str}}
                import_export: str | None
                """Route Target."""

                if TYPE_CHECKING:

                    def __init__(self, *, import_export: str | None | UndefinedType = Undefined) -> None:
                        """
                        RouteTargets.


                        Subclass of AvdModel.

                        Args:
                            import_export: Route Target.

                        """

            class PseudowiresItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "id_local": {"type": int}, "id_remote": {"type": int}}
                name: str
                """Pseudowire name."""
                id_local: int | None
                """Must match id_remote on other pe."""
                id_remote: int | None
                """Must match id_local on other pe."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        id_local: int | None | UndefinedType = Undefined,
                        id_remote: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PseudowiresItem.


                        Subclass of AvdModel.

                        Args:
                            name: Pseudowire name.
                            id_local: Must match id_remote on other pe.
                            id_remote: Must match id_local on other pe.

                        """

            class Pseudowires(AvdIndexedList[str, PseudowiresItem]):
                """Subclass of AvdIndexedList with `PseudowiresItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Pseudowires._item_type = PseudowiresItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "rd": {"type": str},
                "route_targets": {"type": RouteTargets},
                "mpls_control_word": {"type": bool},
                "label_flow": {"type": bool},
                "mtu": {"type": int},
                "pseudowires": {"type": Pseudowires},
            }
            name: str
            """VPWS instance name."""
            rd: str | None
            """Route distinguisher."""
            route_targets: RouteTargets
            """Subclass of AvdModel."""
            mpls_control_word: bool | None
            label_flow: bool | None
            mtu: int | None
            pseudowires: Pseudowires
            """Subclass of AvdIndexedList with `PseudowiresItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    rd: str | None | UndefinedType = Undefined,
                    route_targets: RouteTargets | UndefinedType = Undefined,
                    mpls_control_word: bool | None | UndefinedType = Undefined,
                    label_flow: bool | None | UndefinedType = Undefined,
                    mtu: int | None | UndefinedType = Undefined,
                    pseudowires: Pseudowires | UndefinedType = Undefined,
                ) -> None:
                    """
                    VpwsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VPWS instance name.
                        rd: Route distinguisher.
                        route_targets: Subclass of AvdModel.
                        mpls_control_word: mpls_control_word
                        label_flow: label_flow
                        mtu: mtu
                        pseudowires: Subclass of AvdIndexedList with `PseudowiresItem` items. Primary key is `name` (`str`).

                    """

        class Vpws(AvdIndexedList[str, VpwsItem]):
            """Subclass of AvdIndexedList with `VpwsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vpws._item_type = VpwsItem

        class AddressFamilyEvpn(AvdModel):
            """Subclass of AvdModel."""

            class NeighborDefault(AvdModel):
                """Subclass of AvdModel."""

                class NextHopSelfReceivedEvpnRoutes(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enable": {"type": bool}, "inter_domain": {"type": bool}}
                    enable: bool | None
                    inter_domain: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enable: bool | None | UndefinedType = Undefined, inter_domain: bool | None | UndefinedType = Undefined) -> None:
                            """
                            NextHopSelfReceivedEvpnRoutes.


                            Subclass of AvdModel.

                            Args:
                                enable: enable
                                inter_domain: inter_domain

                            """

                _fields: ClassVar[dict] = {
                    "encapsulation": {"type": str},
                    "next_hop_self_source_interface": {"type": str},
                    "next_hop_self_received_evpn_routes": {"type": NextHopSelfReceivedEvpnRoutes},
                }
                encapsulation: Literal["vxlan", "mpls", "path-selection"] | None
                """Transport encapsulation for neighbor."""
                next_hop_self_source_interface: str | None
                """Source interface name for MPLS encapsulation. Requires `encapsulation` to be set as `mpls`."""
                next_hop_self_received_evpn_routes: NextHopSelfReceivedEvpnRoutes
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        encapsulation: Literal["vxlan", "mpls", "path-selection"] | None | UndefinedType = Undefined,
                        next_hop_self_source_interface: str | None | UndefinedType = Undefined,
                        next_hop_self_received_evpn_routes: NextHopSelfReceivedEvpnRoutes | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborDefault.


                        Subclass of AvdModel.

                        Args:
                            encapsulation: Transport encapsulation for neighbor.
                            next_hop_self_source_interface: Source interface name for MPLS encapsulation. Requires `encapsulation` to be set as `mpls`.
                            next_hop_self_received_evpn_routes: Subclass of AvdModel.

                        """

            class NextHopMplsResolutionRibsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"rib_type": {"type": str}, "rib_name": {"type": str}}
                rib_type: Literal["system-connected", "tunnel-rib-colored", "tunnel-rib"]
                """Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use."""
                rib_name: str | None
                """The name of the tunnel-rib to use when using 'tunnel-rib' type."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        rib_type: Literal["system-connected", "tunnel-rib-colored", "tunnel-rib"] | UndefinedType = Undefined,
                        rib_name: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NextHopMplsResolutionRibsItem.


                        Subclass of AvdModel.

                        Args:
                            rib_type: Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use.
                            rib_name: The name of the tunnel-rib to use when using 'tunnel-rib' type.

                        """

            class NextHopMplsResolutionRibs(AvdList[NextHopMplsResolutionRibsItem]):
                """Subclass of AvdList with `NextHopMplsResolutionRibsItem` items."""

            NextHopMplsResolutionRibs._item_type = NextHopMplsResolutionRibsItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRoute(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}}
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRoute.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                route_map: route_map

                            """

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                    "additional_paths": {"type": AdditionalPaths},
                    "encapsulation": {"type": str},
                    "next_hop_self_source_interface": {"type": str},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                """Subclass of AvdModel."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                encapsulation: Literal["vxlan", "mpls", "path-selection"] | None
                """Transport encapsulation for the neighbor."""
                next_hop_self_source_interface: str | None
                """Source interface name for MPLS encapsulation. Requires `encapsulation` to be set as `mpls`."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_route: DefaultRoute | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        encapsulation: Literal["vxlan", "mpls", "path-selection"] | None | UndefinedType = Undefined,
                        next_hop_self_source_interface: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_route: Subclass of AvdModel.
                            additional_paths: Subclass of AvdModel.
                            encapsulation: Transport encapsulation for the neighbor.
                            next_hop_self_source_interface: Source interface name for MPLS encapsulation. Requires `encapsulation` to be set as `mpls`.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRoute(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}}
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRoute.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                route_map: route_map

                            """

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                    "domain_remote": {"type": bool},
                    "encapsulation": {"type": str},
                    "next_hop_self_source_interface": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                """Subclass of AvdModel."""
                domain_remote: bool | None
                encapsulation: Literal["vxlan", "mpls", "path-selection"] | None
                """Transport encapsulation for the peer-group."""
                next_hop_self_source_interface: str | None
                """Source interface name for MPLS encapsulation. Requires `encapsulation` to be set as `mpls`."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_route: DefaultRoute | UndefinedType = Undefined,
                        domain_remote: bool | None | UndefinedType = Undefined,
                        encapsulation: Literal["vxlan", "mpls", "path-selection"] | None | UndefinedType = Undefined,
                        next_hop_self_source_interface: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_route: Subclass of AvdModel.
                            domain_remote: domain_remote
                            encapsulation: Transport encapsulation for the peer-group.
                            next_hop_self_source_interface: Source interface name for MPLS encapsulation. Requires `encapsulation` to be set as `mpls`.
                            additional_paths: Subclass of AvdModel.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class EvpnHostflapDetection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "window": {"type": int}, "threshold": {"type": int}, "expiry_timeout": {"type": int}}
                enabled: bool | None
                window: int | None
                """Time (in seconds) to detect a MAC duplication issue."""
                threshold: int | None
                """Minimum number of MAC moves that indicate a MAC Duplication issue."""
                expiry_timeout: int | None
                """Time (in seconds) to purge a MAC duplication issue."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        window: int | None | UndefinedType = Undefined,
                        threshold: int | None | UndefinedType = Undefined,
                        expiry_timeout: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        EvpnHostflapDetection.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            window: Time (in seconds) to detect a MAC duplication issue.
                            threshold: Minimum number of MAC moves that indicate a MAC Duplication issue.
                            expiry_timeout: Time (in seconds) to purge a MAC duplication issue.

                        """

            class NextHop(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"resolution_disabled": {"type": bool}}
                resolution_disabled: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, resolution_disabled: bool | None | UndefinedType = Undefined) -> None:
                        """
                        NextHop.


                        Subclass of AvdModel.

                        Args:
                            resolution_disabled: resolution_disabled

                        """

            class Route(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "import_match_failure_action": {"type": str},
                    "import_ethernet_segment_ip_mass_withdraw": {"type": bool},
                    "import_overlay_index_gateway": {"type": bool},
                    "export_ethernet_segment_ip_mass_withdraw": {"type": bool},
                }
                import_match_failure_action: Literal["discard"] | None
                import_ethernet_segment_ip_mass_withdraw: bool | None
                import_overlay_index_gateway: bool | None
                export_ethernet_segment_ip_mass_withdraw: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        import_match_failure_action: Literal["discard"] | None | UndefinedType = Undefined,
                        import_ethernet_segment_ip_mass_withdraw: bool | None | UndefinedType = Undefined,
                        import_overlay_index_gateway: bool | None | UndefinedType = Undefined,
                        export_ethernet_segment_ip_mass_withdraw: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Route.


                        Subclass of AvdModel.

                        Args:
                            import_match_failure_action: import_match_failure_action
                            import_ethernet_segment_ip_mass_withdraw: import_ethernet_segment_ip_mass_withdraw
                            import_overlay_index_gateway: import_overlay_index_gateway
                            export_ethernet_segment_ip_mass_withdraw: export_ethernet_segment_ip_mass_withdraw

                        """

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                _fields: ClassVar[dict] = {"additional_paths": {"type": AdditionalPaths}}
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, additional_paths: AdditionalPaths | UndefinedType = Undefined) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            additional_paths: Subclass of AvdModel.

                        """

            class Layer2FecInPlaceUpdate(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "timeout": {"type": int}}
                enabled: bool
                timeout: int | None
                """In-place FEC update tracking timeout in seconds."""

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | UndefinedType = Undefined, timeout: int | None | UndefinedType = Undefined) -> None:
                        """
                        Layer2FecInPlaceUpdate.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            timeout: In-place FEC update tracking timeout in seconds.

                        """

            class EvpnEthernetSegmentItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"domain": {"type": str}, "identifier": {"type": str}, "route_target_import": {"type": str}}
                domain: Literal["all", "local", "remote"]
                identifier: str | None
                """EVPN Ethernet Segment Identifier (Type 1 format)."""
                route_target_import: str | None
                """Low-order 6 bytes of ES-Import Route Target."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        domain: Literal["all", "local", "remote"] | UndefinedType = Undefined,
                        identifier: str | None | UndefinedType = Undefined,
                        route_target_import: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        EvpnEthernetSegmentItem.


                        Subclass of AvdModel.

                        Args:
                            domain: domain
                            identifier: EVPN Ethernet Segment Identifier (Type 1 format).
                            route_target_import: Low-order 6 bytes of ES-Import Route Target.

                        """

            class EvpnEthernetSegment(AvdIndexedList[str, EvpnEthernetSegmentItem]):
                """Subclass of AvdIndexedList with `EvpnEthernetSegmentItem` items. Primary key is `domain` (`str`)."""

                _primary_key: ClassVar[str] = "domain"

            EvpnEthernetSegment._item_type = EvpnEthernetSegmentItem

            class BgpAdditionalPaths(AvdModel):
                """Subclass of AvdModel."""

                class Send(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "any": {"type": bool},
                        "backup": {"type": bool},
                        "ecmp": {"type": bool},
                        "ecmp_limit": {"type": int},
                        "limit": {"type": int},
                    }
                    any: bool | None
                    """Any eligible path."""
                    backup: bool | None
                    """Best path and installed backup path."""
                    ecmp: bool | None
                    """All paths in best path ECMP group."""
                    ecmp_limit: int | None
                    """Amount of ECMP paths to send."""
                    limit: int | None
                    """Amount of paths to send."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            any: bool | None | UndefinedType = Undefined,
                            backup: bool | None | UndefinedType = Undefined,
                            ecmp: bool | None | UndefinedType = Undefined,
                            ecmp_limit: int | None | UndefinedType = Undefined,
                            limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Send.


                            Subclass of AvdModel.

                            Args:
                                any: Any eligible path.
                                backup: Best path and installed backup path.
                                ecmp: All paths in best path ECMP group.
                                ecmp_limit: Amount of ECMP paths to send.
                                limit: Amount of paths to send.

                            """

                _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": Send}}
                receive: bool | None
                """Receive multiple paths."""
                send: Send
                """
                Send multiple paths.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, receive: bool | None | UndefinedType = Undefined, send: Send | UndefinedType = Undefined) -> None:
                        """
                        BgpAdditionalPaths.


                        Subclass of AvdModel.

                        Args:
                            receive: Receive multiple paths.
                            send:
                               Send multiple paths.

                               Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "domain_identifier": {"type": str},
                "domain_identifier_remote": {"type": str},
                "neighbor_default": {"type": NeighborDefault},
                "next_hop_mpls_resolution_ribs": {"type": NextHopMplsResolutionRibs},
                "neighbors": {"type": Neighbors},
                "peer_groups": {"type": PeerGroups},
                "evpn_hostflap_detection": {"type": EvpnHostflapDetection},
                "next_hop": {"type": NextHop},
                "route": {"type": Route},
                "next_hop_unchanged": {"type": bool},
                "bgp": {"type": Bgp},
                "layer_2_fec_in_place_update": {"type": Layer2FecInPlaceUpdate},
                "evpn_ethernet_segment": {"type": EvpnEthernetSegment},
                "bgp_additional_paths": {"type": BgpAdditionalPaths},
            }
            domain_identifier: str | None
            domain_identifier_remote: str | None
            neighbor_default: NeighborDefault
            """Subclass of AvdModel."""
            next_hop_mpls_resolution_ribs: NextHopMplsResolutionRibs
            """
            Specify the RIBs used to resolve MPLS next-hops. The order of this list determines the order of RIB
            lookups.

            Subclass of AvdList with `NextHopMplsResolutionRibsItem` items.
            """
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            evpn_hostflap_detection: EvpnHostflapDetection
            """Subclass of AvdModel."""
            next_hop: NextHop
            """Subclass of AvdModel."""
            route: Route
            """Subclass of AvdModel."""
            next_hop_unchanged: bool | None
            bgp: Bgp
            """Subclass of AvdModel."""
            layer_2_fec_in_place_update: Layer2FecInPlaceUpdate
            """
            BGP layer-2 in-place FEC operation.

            Subclass of AvdModel.
            """
            evpn_ethernet_segment: EvpnEthernetSegment
            """Subclass of AvdIndexedList with `EvpnEthernetSegmentItem` items. Primary key is `domain` (`str`)."""
            bgp_additional_paths: BgpAdditionalPaths
            """
            BGP additional-paths commands.

            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    domain_identifier: str | None | UndefinedType = Undefined,
                    domain_identifier_remote: str | None | UndefinedType = Undefined,
                    neighbor_default: NeighborDefault | UndefinedType = Undefined,
                    next_hop_mpls_resolution_ribs: NextHopMplsResolutionRibs | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    evpn_hostflap_detection: EvpnHostflapDetection | UndefinedType = Undefined,
                    next_hop: NextHop | UndefinedType = Undefined,
                    route: Route | UndefinedType = Undefined,
                    next_hop_unchanged: bool | None | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    layer_2_fec_in_place_update: Layer2FecInPlaceUpdate | UndefinedType = Undefined,
                    evpn_ethernet_segment: EvpnEthernetSegment | UndefinedType = Undefined,
                    bgp_additional_paths: BgpAdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyEvpn.


                    Subclass of AvdModel.

                    Args:
                        domain_identifier: domain_identifier
                        domain_identifier_remote: domain_identifier_remote
                        neighbor_default: Subclass of AvdModel.
                        next_hop_mpls_resolution_ribs:
                           Specify the RIBs used to resolve MPLS next-hops. The order of this list determines the order of RIB
                           lookups.

                           Subclass of AvdList with `NextHopMplsResolutionRibsItem` items.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        evpn_hostflap_detection: Subclass of AvdModel.
                        next_hop: Subclass of AvdModel.
                        route: Subclass of AvdModel.
                        next_hop_unchanged: next_hop_unchanged
                        bgp: Subclass of AvdModel.
                        layer_2_fec_in_place_update:
                           BGP layer-2 in-place FEC operation.

                           Subclass of AvdModel.
                        evpn_ethernet_segment: Subclass of AvdIndexedList with `EvpnEthernetSegmentItem` items. Primary key is `domain` (`str`).
                        bgp_additional_paths:
                           BGP additional-paths commands.

                           Subclass of AvdModel.

                    """

        class AddressFamilyRtc(AvdModel):
            """Subclass of AvdModel."""

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRouteTarget(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"only": {"type": bool}, "encoding_origin_as_omit": {"type": str}}
                    only: bool | None
                    encoding_origin_as_omit: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, only: bool | None | UndefinedType = Undefined, encoding_origin_as_omit: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            DefaultRouteTarget.


                            Subclass of AvdModel.

                            Args:
                                only: only
                                encoding_origin_as_omit: encoding_origin_as_omit

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "activate": {"type": bool}, "default_route_target": {"type": DefaultRouteTarget}}
                name: str
                """Peer-group name."""
                activate: bool | None
                default_route_target: DefaultRouteTarget
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        default_route_target: DefaultRouteTarget | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            default_route_target: Subclass of AvdModel.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {"peer_groups": {"type": PeerGroups}}
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(self, *, peer_groups: PeerGroups | UndefinedType = Undefined) -> None:
                    """
                    AddressFamilyRtc.


                    Subclass of AvdModel.

                    Args:
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).

                    """

        class AddressFamilyIpv4(AvdModel):
            """Subclass of AvdModel."""

            class NetworksItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}}
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None
                """Route-map name."""

                if TYPE_CHECKING:

                    def __init__(self, *, prefix: str | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                        """
                        NetworksItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: Route-map name.

                        """

            class Networks(AvdIndexedList[str, NetworksItem]):
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "install": {"type": bool},
                        "install_ecmp_primary": {"type": bool},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                    }
                    install: bool | None
                    """Install BGP backup path."""
                    install_ecmp_primary: bool | None
                    """Allow additional path with ECMP primary path."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            install: bool | None | UndefinedType = Undefined,
                            install_ecmp_primary: bool | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                install: Install BGP backup path.
                                install_ecmp_primary: Allow additional path with ECMP primary path.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                _fields: ClassVar[dict] = {"additional_paths": {"type": AdditionalPaths}, "redistribute_internal": {"type": bool}}
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                redistribute_internal: bool | None
                """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, additional_paths: AdditionalPaths | UndefinedType = Undefined, redistribute_internal: bool | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            additional_paths: Subclass of AvdModel.
                            redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.

                        """

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultOriginate(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"always": {"type": bool}, "route_map": {"type": str}}
                    always: bool | None
                    route_map: str | None
                    """Route-map name."""

                    if TYPE_CHECKING:

                        def __init__(self, *, always: bool | None | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            DefaultOriginate.


                            Subclass of AvdModel.

                            Args:
                                always: always
                                route_map: Route-map name.

                            """

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"prefix_list": {"type": str}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    prefix_list: str | None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefix_list: str | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                prefix_list: Apply the configurations only to the routes matching the prefix list.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                class NextHop(AvdModel):
                    """Subclass of AvdModel."""

                    class AddressFamilyIpv6(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "originate": {"type": bool}}
                        enabled: bool
                        originate: bool | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, originate: bool | None | UndefinedType = Undefined) -> None:
                                """
                                AddressFamilyIpv6.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    originate: originate

                                """

                    _fields: ClassVar[dict] = {"address_family_ipv6": {"type": AddressFamilyIpv6}}
                    address_family_ipv6: AddressFamilyIpv6
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined) -> None:
                            """
                            NextHop.


                            Subclass of AvdModel.

                            Args:
                                address_family_ipv6: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_originate": {"type": DefaultOriginate},
                    "prefix_list_in": {"type": str},
                    "prefix_list_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                    "next_hop": {"type": NextHop},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_originate: DefaultOriginate
                """Subclass of AvdModel."""
                prefix_list_in: str | None
                """Inbound prefix-list name."""
                prefix_list_out: str | None
                """Outbound prefix-list name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                next_hop: NextHop
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_originate: DefaultOriginate | UndefinedType = Undefined,
                        prefix_list_in: str | None | UndefinedType = Undefined,
                        prefix_list_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        next_hop: NextHop | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_originate: Subclass of AvdModel.
                            prefix_list_in: Inbound prefix-list name.
                            prefix_list_out: Outbound prefix-list name.
                            additional_paths: Subclass of AvdModel.
                            next_hop: Subclass of AvdModel.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultOriginate(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"always": {"type": bool}, "route_map": {"type": str}}
                    always: bool | None
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, always: bool | None | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            DefaultOriginate.


                            Subclass of AvdModel.

                            Args:
                                always: always
                                route_map: route_map

                            """

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"prefix_list": {"type": str}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    prefix_list: str | None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefix_list: str | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                prefix_list: Apply the configurations only to the routes matching the prefix list.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                class NextHop(AvdModel):
                    """Subclass of AvdModel."""

                    class AddressFamilyIpv6(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "originate": {"type": bool}}
                        enabled: bool
                        """Enables advertising the Extended Next Hop Encoding capability."""
                        originate: bool | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, originate: bool | None | UndefinedType = Undefined) -> None:
                                """
                                AddressFamilyIpv6.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Enables advertising the Extended Next Hop Encoding capability.
                                    originate: originate

                                """

                    _fields: ClassVar[dict] = {"address_family_ipv6": {"type": AddressFamilyIpv6}}
                    address_family_ipv6: AddressFamilyIpv6
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined) -> None:
                            """
                            NextHop.


                            Subclass of AvdModel.

                            Args:
                                address_family_ipv6: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "prefix_list_in": {"type": str},
                    "prefix_list_out": {"type": str},
                    "default_originate": {"type": DefaultOriginate},
                    "additional_paths": {"type": AdditionalPaths},
                    "next_hop": {"type": NextHop},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                prefix_list_in: str | None
                """Inbound prefix-list name."""
                prefix_list_out: str | None
                """Prefix-list name."""
                default_originate: DefaultOriginate
                """Subclass of AvdModel."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                next_hop: NextHop
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        prefix_list_in: str | None | UndefinedType = Undefined,
                        prefix_list_out: str | None | UndefinedType = Undefined,
                        default_originate: DefaultOriginate | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        next_hop: NextHop | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            prefix_list_in: Inbound prefix-list name.
                            prefix_list_out: Prefix-list name.
                            default_originate: Subclass of AvdModel.
                            additional_paths: Subclass of AvdModel.
                            next_hop: Subclass of AvdModel.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class AttachedHost(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            AttachedHost.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """

                class Dynamic(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dynamic.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.

                            """

                class Isis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool
                    isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """

                class Ospf(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool | None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPF routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPF routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPF routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospf.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPF routes.
                                match_external:
                                   Redistribute OSPF routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPF routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPF routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """

                class Ospfv3(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPFv3 routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPFv3 routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPFv3 routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPFv3 routes.
                                match_external:
                                   Redistribute OSPFv3 routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPFv3 routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPFv3 routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """

                class Rip(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            Rip.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """

                class User(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}}
                    enabled: bool
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, rcf: str | None | UndefinedType = Undefined) -> None:
                            """
                            User.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.

                            """

                _fields: ClassVar[dict] = {
                    "attached_host": {"type": AttachedHost},
                    "bgp": {"type": Bgp},
                    "connected": {"type": Connected},
                    "dynamic": {"type": Dynamic},
                    "isis": {"type": Isis},
                    "ospf": {"type": Ospf},
                    "ospfv3": {"type": Ospfv3},
                    "rip": {"type": Rip},
                    "static": {"type": Static},
                    "user": {"type": User},
                }
                attached_host: AttachedHost
                """Subclass of AvdModel."""
                bgp: Bgp
                """Subclass of AvdModel."""
                connected: Connected
                """Subclass of AvdModel."""
                dynamic: Dynamic
                """Subclass of AvdModel."""
                isis: Isis
                """Subclass of AvdModel."""
                ospf: Ospf
                """Subclass of AvdModel."""
                ospfv3: Ospfv3
                """Subclass of AvdModel."""
                rip: Rip
                """Subclass of AvdModel."""
                static: Static
                """Subclass of AvdModel."""
                user: User
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        attached_host: AttachedHost | UndefinedType = Undefined,
                        bgp: Bgp | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospf: Ospf | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        rip: Rip | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        user: User | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            attached_host: Subclass of AvdModel.
                            bgp: Subclass of AvdModel.
                            connected: Subclass of AvdModel.
                            dynamic: Subclass of AvdModel.
                            isis: Subclass of AvdModel.
                            ospf: Subclass of AvdModel.
                            ospfv3: Subclass of AvdModel.
                            rip: Subclass of AvdModel.
                            static: Subclass of AvdModel.
                            user: Subclass of AvdModel.

                        """

            class RedistributeRoutesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "source_protocol": {"type": str},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                }
                source_protocol: Literal["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                route_map: str | None
                include_leaked: bool | None
                """Only applicable if `source_protocol` is one of `connected`, `static`, `isis`, `ospf`, `ospfv3`."""
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is one of `connected`,
                `static`, `isis`, `user`, `dynamic`.
                """
                ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_protocol: Literal["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                        | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                        | None
                        | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.


                        Subclass of AvdModel.

                        Args:
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: Only applicable if `source_protocol` is one of `connected`, `static`, `isis`, `ospf`, `ospfv3`.
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is one of `connected`,
                               `static`, `isis`, `user`, `dynamic`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.

                        """

            class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

            RedistributeRoutes._item_type = RedistributeRoutesItem

            _fields: ClassVar[dict] = {
                "networks": {"type": Networks},
                "bgp": {"type": Bgp},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": RedistributeRoutes},
            }
            networks: Networks
            """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
            bgp: Bgp
            """Subclass of AvdModel."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            redistribute: Redistribute
            """
            Redistribute routes in to BGP.

            Subclass of AvdModel.
            """
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `RedistributeRoutesItem` items."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    networks: Networks | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv4.


                    Subclass of AvdModel.

                    Args:
                        networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                        bgp: Subclass of AvdModel.
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        redistribute:
                           Redistribute routes in to BGP.

                           Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.

                    """

        class AddressFamilyIpv4LabeledUnicast(AvdModel):
            """Subclass of AvdModel."""

            class AigpSession(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"confederation": {"type": bool}, "ebgp": {"type": bool}, "ibgp": {"type": bool}}
                confederation: bool | None
                ebgp: bool | None
                ibgp: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        confederation: bool | None | UndefinedType = Undefined,
                        ebgp: bool | None | UndefinedType = Undefined,
                        ibgp: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AigpSession.


                        Subclass of AvdModel.

                        Args:
                            confederation: confederation
                            ebgp: ebgp
                            ibgp: ibgp

                        """

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    class DirectionIn(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                        }
                        action: Literal["deny", "permit", "deny-in-out"]
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionIn.


                                Subclass of AvdModel.

                                Args:
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.

                                """

                    class DirectionOut(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                        }
                        action: Literal["deny", "permit", "deny-in-out"]
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionOut.


                                Subclass of AvdModel.

                                Args:
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.

                                """

                    _fields: ClassVar[dict] = {"direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}}
                    direction_in: DirectionIn
                    """
                    Missing policy inbound direction.

                    Subclass of AvdModel.
                    """
                    direction_out: DirectionOut
                    """
                    Missing policy outbound direction.

                    Subclass of AvdModel.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, direction_in: DirectionIn | UndefinedType = Undefined, direction_out: DirectionOut | UndefinedType = Undefined
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in:
                                   Missing policy inbound direction.

                                   Subclass of AvdModel.
                                direction_out:
                                   Missing policy outbound direction.

                                   Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {
                    "additional_paths": {"type": AdditionalPaths},
                    "missing_policy": {"type": MissingPolicy},
                    "next_hop_unchanged": {"type": bool},
                }
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                missing_policy: MissingPolicy
                """
                Missing policy configuration for all address-families.

                Subclass of AvdModel.
                """
                next_hop_unchanged: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        next_hop_unchanged: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            additional_paths: Subclass of AvdModel.
                            missing_policy:
                               Missing policy configuration for all address-families.

                               Subclass of AvdModel.
                            next_hop_unchanged: next_hop_unchanged

                        """

            class NeighborDefault(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"next_hop_self": {"type": bool}}
                next_hop_self: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, next_hop_self: bool | None | UndefinedType = Undefined) -> None:
                        """
                        NeighborDefault.


                        Subclass of AvdModel.

                        Args:
                            next_hop_self: next_hop_self

                        """

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                class GracefulRestartHelper(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"stale_route_map": {"type": str}}
                    stale_route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, stale_route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            GracefulRestartHelper.


                            Subclass of AvdModel.

                            Args:
                                stale_route_map: stale_route_map

                            """

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    class DirectionIn(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                        }
                        action: Literal["deny", "permit", "deny-in-out"]
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionIn.


                                Subclass of AvdModel.

                                Args:
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.

                                """

                    class DirectionOut(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                        }
                        action: Literal["deny", "permit", "deny-in-out"]
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionOut.


                                Subclass of AvdModel.

                                Args:
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.

                                """

                    _fields: ClassVar[dict] = {"direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}}
                    direction_in: DirectionIn
                    """
                    Missing policy inbound direction.

                    Subclass of AvdModel.
                    """
                    direction_out: DirectionOut
                    """
                    Missing policy outbound direction.

                    Subclass of AvdModel.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, direction_in: DirectionIn | UndefinedType = Undefined, direction_out: DirectionOut | UndefinedType = Undefined
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in:
                                   Missing policy inbound direction.

                                   Subclass of AvdModel.
                                direction_out:
                                   Missing policy outbound direction.

                                   Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                    "aigp_session": {"type": bool},
                    "graceful_restart": {"type": bool},
                    "graceful_restart_helper": {"type": GracefulRestartHelper},
                    "maximum_advertised_routes": {"type": int},
                    "maximum_advertised_routes_warning_limit": {"type": str},
                    "missing_policy": {"type": MissingPolicy},
                    "multi_path": {"type": bool},
                    "next_hop_self": {"type": bool},
                    "next_hop_self_source_interface": {"type": str},
                    "next_hop_self_v4_mapped_v6_source_interface": {"type": str},
                    "next_hop_unchanged": {"type": bool},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                aigp_session: bool | None
                graceful_restart: bool | None
                graceful_restart_helper: GracefulRestartHelper
                """Subclass of AvdModel."""
                maximum_advertised_routes: int | None
                """Maximum number of routes (0 means unlimited)."""
                maximum_advertised_routes_warning_limit: str | None
                """
                Maximum number of routes after which a warning is issued (0 means never warn) or
                Percentage of
                maximum number of routes at which to warn ("<1-100> percent").
                """
                missing_policy: MissingPolicy
                """
                Missing policy configuration for BGP Labeled-Unicast neighbor.

                Subclass of AvdModel.
                """
                multi_path: bool | None
                next_hop_self: bool | None
                next_hop_self_source_interface: str | None
                """Source interface name."""
                next_hop_self_v4_mapped_v6_source_interface: str | None
                """v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface."""
                next_hop_unchanged: bool | None
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        aigp_session: bool | None | UndefinedType = Undefined,
                        graceful_restart: bool | None | UndefinedType = Undefined,
                        graceful_restart_helper: GracefulRestartHelper | UndefinedType = Undefined,
                        maximum_advertised_routes: int | None | UndefinedType = Undefined,
                        maximum_advertised_routes_warning_limit: str | None | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        multi_path: bool | None | UndefinedType = Undefined,
                        next_hop_self: bool | None | UndefinedType = Undefined,
                        next_hop_self_source_interface: str | None | UndefinedType = Undefined,
                        next_hop_self_v4_mapped_v6_source_interface: str | None | UndefinedType = Undefined,
                        next_hop_unchanged: bool | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            additional_paths: Subclass of AvdModel.
                            aigp_session: aigp_session
                            graceful_restart: graceful_restart
                            graceful_restart_helper: Subclass of AvdModel.
                            maximum_advertised_routes: Maximum number of routes (0 means unlimited).
                            maximum_advertised_routes_warning_limit:
                               Maximum number of routes after which a warning is issued (0 means never warn) or
                               Percentage of
                               maximum number of routes at which to warn ("<1-100> percent").
                            missing_policy:
                               Missing policy configuration for BGP Labeled-Unicast neighbor.

                               Subclass of AvdModel.
                            multi_path: multi_path
                            next_hop_self: next_hop_self
                            next_hop_self_source_interface: Source interface name.
                            next_hop_self_v4_mapped_v6_source_interface: v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface.
                            next_hop_unchanged: next_hop_unchanged
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                class GracefulRestartHelper(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"stale_route_map": {"type": str}}
                    stale_route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, stale_route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            GracefulRestartHelper.


                            Subclass of AvdModel.

                            Args:
                                stale_route_map: stale_route_map

                            """

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    class DirectionIn(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                        }
                        action: Literal["deny", "permit", "deny-in-out"]
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionIn.


                                Subclass of AvdModel.

                                Args:
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.

                                """

                    class DirectionOut(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                        }
                        action: Literal["deny", "permit", "deny-in-out"]
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionOut.


                                Subclass of AvdModel.

                                Args:
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.

                                """

                    _fields: ClassVar[dict] = {"direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}}
                    direction_in: DirectionIn
                    """
                    Missing policy inbound direction.

                    Subclass of AvdModel.
                    """
                    direction_out: DirectionOut
                    """
                    Missing policy outbound direction.

                    Subclass of AvdModel.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, direction_in: DirectionIn | UndefinedType = Undefined, direction_out: DirectionOut | UndefinedType = Undefined
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in:
                                   Missing policy inbound direction.

                                   Subclass of AvdModel.
                                direction_out:
                                   Missing policy outbound direction.

                                   Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                    "aigp_session": {"type": bool},
                    "graceful_restart": {"type": bool},
                    "graceful_restart_helper": {"type": GracefulRestartHelper},
                    "maximum_advertised_routes": {"type": int},
                    "maximum_advertised_routes_warning_limit": {"type": str},
                    "missing_policy": {"type": MissingPolicy},
                    "multi_path": {"type": bool},
                    "next_hop_self": {"type": bool},
                    "next_hop_self_source_interface": {"type": str},
                    "next_hop_self_v4_mapped_v6_source_interface": {"type": str},
                    "next_hop_unchanged": {"type": bool},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                }
                ip_address: str
                activate: bool | None
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                aigp_session: bool | None
                graceful_restart: bool | None
                graceful_restart_helper: GracefulRestartHelper
                """Subclass of AvdModel."""
                maximum_advertised_routes: int | None
                """Maximum number of routes (0 means unlimited)."""
                maximum_advertised_routes_warning_limit: str | None
                """
                Maximum number of routes after which a warning is issued (0 means never warn) or
                Percentage of
                maximum number of routes at which to warn ("<1-100> percent").
                """
                missing_policy: MissingPolicy
                """
                Missing policy configuration for BGP Labeled-Unicast neighbor.

                Subclass of AvdModel.
                """
                multi_path: bool | None
                next_hop_self: bool | None
                next_hop_self_source_interface: str | None
                """Source interface name."""
                next_hop_self_v4_mapped_v6_source_interface: str | None
                """v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface."""
                next_hop_unchanged: bool | None
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        aigp_session: bool | None | UndefinedType = Undefined,
                        graceful_restart: bool | None | UndefinedType = Undefined,
                        graceful_restart_helper: GracefulRestartHelper | UndefinedType = Undefined,
                        maximum_advertised_routes: int | None | UndefinedType = Undefined,
                        maximum_advertised_routes_warning_limit: str | None | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        multi_path: bool | None | UndefinedType = Undefined,
                        next_hop_self: bool | None | UndefinedType = Undefined,
                        next_hop_self_source_interface: str | None | UndefinedType = Undefined,
                        next_hop_self_v4_mapped_v6_source_interface: str | None | UndefinedType = Undefined,
                        next_hop_unchanged: bool | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            additional_paths: Subclass of AvdModel.
                            aigp_session: aigp_session
                            graceful_restart: graceful_restart
                            graceful_restart_helper: Subclass of AvdModel.
                            maximum_advertised_routes: Maximum number of routes (0 means unlimited).
                            maximum_advertised_routes_warning_limit:
                               Maximum number of routes after which a warning is issued (0 means never warn) or
                               Percentage of
                               maximum number of routes at which to warn ("<1-100> percent").
                            missing_policy:
                               Missing policy configuration for BGP Labeled-Unicast neighbor.

                               Subclass of AvdModel.
                            multi_path: multi_path
                            next_hop_self: next_hop_self
                            next_hop_self_source_interface: Source interface name.
                            next_hop_self_v4_mapped_v6_source_interface: v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface.
                            next_hop_unchanged: next_hop_unchanged
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class NetworksItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}}
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None
                """Route-map name."""

                if TYPE_CHECKING:

                    def __init__(self, *, prefix: str | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                        """
                        NetworksItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: Route-map name.

                        """

            class Networks(AvdIndexedList[str, NetworksItem]):
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class NextHopsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ip_address": {"type": str}, "lfib_backup_ip_forwarding": {"type": bool}}
                ip_address: str
                lfib_backup_ip_forwarding: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self, *, ip_address: str | UndefinedType = Undefined, lfib_backup_ip_forwarding: bool | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        NextHopsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            lfib_backup_ip_forwarding: lfib_backup_ip_forwarding

                        """

            class NextHops(AvdIndexedList[str, NextHopsItem]):
                """Subclass of AvdIndexedList with `NextHopsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            NextHops._item_type = NextHopsItem

            class NextHopResolutionRibsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"rib_type": {"type": str}, "rib_name": {"type": str}}
                rib_type: Literal["system-connected", "tunnel-rib-colored", "tunnel-rib"]
                """Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use."""
                rib_name: str | None
                """The name of the tunnel-rib to use when using 'tunnel-rib' type."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        rib_type: Literal["system-connected", "tunnel-rib-colored", "tunnel-rib"] | UndefinedType = Undefined,
                        rib_name: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NextHopResolutionRibsItem.


                        Subclass of AvdModel.

                        Args:
                            rib_type: Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use.
                            rib_name: The name of the tunnel-rib to use when using 'tunnel-rib' type.

                        """

            class NextHopResolutionRibs(AvdList[NextHopResolutionRibsItem]):
                """Subclass of AvdList with `NextHopResolutionRibsItem` items."""

            NextHopResolutionRibs._item_type = NextHopResolutionRibsItem

            class TunnelSourceProtocolsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"protocol": {"type": str}, "rcf": {"type": str}}
                protocol: Literal["isis segment-routing", "ldp"]
                rcf: str | None
                """
                Optional RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """

                if TYPE_CHECKING:

                    def __init__(
                        self, *, protocol: Literal["isis segment-routing", "ldp"] | UndefinedType = Undefined, rcf: str | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        TunnelSourceProtocolsItem.


                        Subclass of AvdModel.

                        Args:
                            protocol: protocol
                            rcf:
                               Optional RCF function name with parenthesis.
                               Example: MyFunction(myarg).

                        """

            class TunnelSourceProtocols(AvdIndexedList[str, TunnelSourceProtocolsItem]):
                """
                Subclass of AvdIndexedList with `TunnelSourceProtocolsItem` items. Primary key is `protocol`
                (`str`).
                """

                _primary_key: ClassVar[str] = "protocol"

            TunnelSourceProtocols._item_type = TunnelSourceProtocolsItem

            _fields: ClassVar[dict] = {
                "aigp_session": {"type": AigpSession},
                "bgp": {"type": Bgp},
                "graceful_restart": {"type": bool},
                "label_local_termination": {"type": str},
                "lfib_entry_installation_skipped": {"type": bool},
                "neighbor_default": {"type": NeighborDefault},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "networks": {"type": Networks},
                "next_hops": {"type": NextHops},
                "next_hop_resolution_ribs": {"type": NextHopResolutionRibs},
                "tunnel_source_protocols": {"type": TunnelSourceProtocols},
                "update_wait_for_convergence": {"type": bool},
            }
            aigp_session: AigpSession
            """Subclass of AvdModel."""
            bgp: Bgp
            """Subclass of AvdModel."""
            graceful_restart: bool | None
            label_local_termination: Literal["explicit-null", "implicit-null"] | None
            lfib_entry_installation_skipped: bool | None
            """Skip LFIB entry installation and next hop self route advertisements."""
            neighbor_default: NeighborDefault
            """Subclass of AvdModel."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            networks: Networks
            """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
            next_hops: NextHops
            """Subclass of AvdIndexedList with `NextHopsItem` items. Primary key is `ip_address` (`str`)."""
            next_hop_resolution_ribs: NextHopResolutionRibs
            """
            Specify the RIBs used to resolve next-hops. The order of this list determines the order of RIB
            lookups.

            Subclass of AvdList with `NextHopResolutionRibsItem` items.
            """
            tunnel_source_protocols: TunnelSourceProtocols
            """
            Subclass of AvdIndexedList with `TunnelSourceProtocolsItem` items. Primary key is `protocol`
            (`str`).
            """
            update_wait_for_convergence: bool | None
            """Wait for BGP to converge before sending out any route updates."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    aigp_session: AigpSession | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    graceful_restart: bool | None | UndefinedType = Undefined,
                    label_local_termination: Literal["explicit-null", "implicit-null"] | None | UndefinedType = Undefined,
                    lfib_entry_installation_skipped: bool | None | UndefinedType = Undefined,
                    neighbor_default: NeighborDefault | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    networks: Networks | UndefinedType = Undefined,
                    next_hops: NextHops | UndefinedType = Undefined,
                    next_hop_resolution_ribs: NextHopResolutionRibs | UndefinedType = Undefined,
                    tunnel_source_protocols: TunnelSourceProtocols | UndefinedType = Undefined,
                    update_wait_for_convergence: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv4LabeledUnicast.


                    Subclass of AvdModel.

                    Args:
                        aigp_session: Subclass of AvdModel.
                        bgp: Subclass of AvdModel.
                        graceful_restart: graceful_restart
                        label_local_termination: label_local_termination
                        lfib_entry_installation_skipped: Skip LFIB entry installation and next hop self route advertisements.
                        neighbor_default: Subclass of AvdModel.
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                        next_hops: Subclass of AvdIndexedList with `NextHopsItem` items. Primary key is `ip_address` (`str`).
                        next_hop_resolution_ribs:
                           Specify the RIBs used to resolve next-hops. The order of this list determines the order of RIB
                           lookups.

                           Subclass of AvdList with `NextHopResolutionRibsItem` items.
                        tunnel_source_protocols:
                           Subclass of AvdIndexedList with `TunnelSourceProtocolsItem` items. Primary key is `protocol`
                           (`str`).
                        update_wait_for_convergence: Wait for BGP to converge before sending out any route updates.

                    """

        class AddressFamilyIpv4Multicast(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}}
                    receive: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, receive: bool | None | UndefinedType = Undefined) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: receive

                            """

                _fields: ClassVar[dict] = {"additional_paths": {"type": AdditionalPaths}}
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, additional_paths: AdditionalPaths | UndefinedType = Undefined) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            additional_paths: Subclass of AvdModel.

                        """

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}}
                    receive: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, receive: bool | None | UndefinedType = Undefined) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: receive

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            additional_paths: Subclass of AvdModel.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}}
                    receive: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, receive: bool | None | UndefinedType = Undefined) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: receive

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            additional_paths: Subclass of AvdModel.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class AttachedHost(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            AttachedHost.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                class Isis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool
                    isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """

                class Ospf(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "nssa_type": {"type": int}, "route_map": {"type": str}}
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                    }
                    enabled: bool | None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPF routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPF routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPF routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospf.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPF routes.
                                match_external:
                                   Redistribute OSPF routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPF routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPF routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map

                            """

                class Ospfv3(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "nssa_type": {"type": int}, "route_map": {"type": str}}
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                    }
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPFv3 routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPFv3 routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPFv3 routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPFv3 routes.
                                match_external:
                                   Redistribute OSPFv3 routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPFv3 routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPFv3 routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map

                            """

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                _fields: ClassVar[dict] = {
                    "attached_host": {"type": AttachedHost},
                    "connected": {"type": Connected},
                    "isis": {"type": Isis},
                    "ospf": {"type": Ospf},
                    "ospfv3": {"type": Ospfv3},
                    "static": {"type": Static},
                }
                attached_host: AttachedHost
                """Subclass of AvdModel."""
                connected: Connected
                """Subclass of AvdModel."""
                isis: Isis
                """Subclass of AvdModel."""
                ospf: Ospf
                """Subclass of AvdModel."""
                ospfv3: Ospfv3
                """Subclass of AvdModel."""
                static: Static
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        attached_host: AttachedHost | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospf: Ospf | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            attached_host: Subclass of AvdModel.
                            connected: Subclass of AvdModel.
                            isis: Subclass of AvdModel.
                            ospf: Subclass of AvdModel.
                            ospfv3: Subclass of AvdModel.
                            static: Subclass of AvdModel.

                        """

            class RedistributeRoutesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "source_protocol": {"type": str},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                }
                source_protocol: str
                route_map: str | None
                include_leaked: bool | None
                """Only applicable if `source_protocol` is `isis`."""
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is `isis`.
                """
                ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_protocol: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                        | None
                        | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.


                        Subclass of AvdModel.

                        Args:
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: Only applicable if `source_protocol` is `isis`.
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is `isis`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.

                        """

            class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

            RedistributeRoutes._item_type = RedistributeRoutesItem

            _fields: ClassVar[dict] = {
                "bgp": {"type": Bgp},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": RedistributeRoutes},
            }
            bgp: Bgp
            """Subclass of AvdModel."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            redistribute: Redistribute
            """
            Redistribute routes in to BGP.

            Subclass of AvdModel.
            """
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `RedistributeRoutesItem` items."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bgp: Bgp | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv4Multicast.


                    Subclass of AvdModel.

                    Args:
                        bgp: Subclass of AvdModel.
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        redistribute:
                           Redistribute routes in to BGP.

                           Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.

                    """

        class AddressFamilyIpv4SrTe(AvdModel):
            """Subclass of AvdModel."""

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {"neighbors": {"type": Neighbors}, "peer_groups": {"type": PeerGroups}}
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(self, *, neighbors: Neighbors | UndefinedType = Undefined, peer_groups: PeerGroups | UndefinedType = Undefined) -> None:
                    """
                    AddressFamilyIpv4SrTe.


                    Subclass of AvdModel.

                    Args:
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).

                    """

        class AddressFamilyIpv6(AvdModel):
            """Subclass of AvdModel."""

            class NetworksItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}}
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None
                """Route-map name."""

                if TYPE_CHECKING:

                    def __init__(self, *, prefix: str | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                        """
                        NetworksItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: Route-map name.

                        """

            class Networks(AvdIndexedList[str, NetworksItem]):
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "install": {"type": bool},
                        "install_ecmp_primary": {"type": bool},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                    }
                    install: bool | None
                    """Install BGP backup path."""
                    install_ecmp_primary: bool | None
                    """Allow additional path with ECMP primary path."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            install: bool | None | UndefinedType = Undefined,
                            install_ecmp_primary: bool | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                install: Install BGP backup path.
                                install_ecmp_primary: Allow additional path with ECMP primary path.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                _fields: ClassVar[dict] = {"redistribute_internal": {"type": bool}, "additional_paths": {"type": AdditionalPaths}}
                redistribute_internal: bool | None
                """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, redistribute_internal: bool | None | UndefinedType = Undefined, additional_paths: AdditionalPaths | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.
                            additional_paths: Subclass of AvdModel.

                        """

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"prefix_list": {"type": str}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    prefix_list: str | None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefix_list: str | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                prefix_list: Apply the configurations only to the routes matching the prefix list.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "prefix_list_in": {"type": str},
                    "prefix_list_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                prefix_list_in: str | None
                """Inbound prefix-list name."""
                prefix_list_out: str | None
                """Outbound prefix-list name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        prefix_list_in: str | None | UndefinedType = Undefined,
                        prefix_list_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            prefix_list_in: Inbound prefix-list name.
                            prefix_list_out: Outbound prefix-list name.
                            additional_paths: Subclass of AvdModel.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"prefix_list": {"type": str}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    prefix_list: str | None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefix_list: str | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                prefix_list: Apply the configurations only to the routes matching the prefix list.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "prefix_list_in": {"type": str},
                    "prefix_list_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                prefix_list_in: str | None
                """Inbound prefix-list name."""
                prefix_list_out: str | None
                """Outbound prefix-list name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        prefix_list_in: str | None | UndefinedType = Undefined,
                        prefix_list_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            prefix_list_in: Inbound prefix-list name.
                            prefix_list_out: Outbound prefix-list name.
                            additional_paths: Subclass of AvdModel.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class AttachedHost(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            AttachedHost.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """

                class Dhcp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            Dhcp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                class Dynamic(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dynamic.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.

                            """

                class Isis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool
                    isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """

                class Ospfv3(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPFv3 routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPFv3 routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPFv3 routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPFv3 routes.
                                match_external:
                                   Redistribute OSPFv3 routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPFv3 routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPFv3 routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """

                class User(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}}
                    enabled: bool
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, rcf: str | None | UndefinedType = Undefined) -> None:
                            """
                            User.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.

                            """

                _fields: ClassVar[dict] = {
                    "attached_host": {"type": AttachedHost},
                    "bgp": {"type": Bgp},
                    "connected": {"type": Connected},
                    "dhcp": {"type": Dhcp},
                    "dynamic": {"type": Dynamic},
                    "isis": {"type": Isis},
                    "ospfv3": {"type": Ospfv3},
                    "static": {"type": Static},
                    "user": {"type": User},
                }
                attached_host: AttachedHost
                """Subclass of AvdModel."""
                bgp: Bgp
                """Subclass of AvdModel."""
                connected: Connected
                """Subclass of AvdModel."""
                dhcp: Dhcp
                """Subclass of AvdModel."""
                dynamic: Dynamic
                """Subclass of AvdModel."""
                isis: Isis
                """Subclass of AvdModel."""
                ospfv3: Ospfv3
                """Subclass of AvdModel."""
                static: Static
                """Subclass of AvdModel."""
                user: User
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        attached_host: AttachedHost | UndefinedType = Undefined,
                        bgp: Bgp | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        dhcp: Dhcp | UndefinedType = Undefined,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        user: User | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            attached_host: Subclass of AvdModel.
                            bgp: Subclass of AvdModel.
                            connected: Subclass of AvdModel.
                            dhcp: Subclass of AvdModel.
                            dynamic: Subclass of AvdModel.
                            isis: Subclass of AvdModel.
                            ospfv3: Subclass of AvdModel.
                            static: Subclass of AvdModel.
                            user: Subclass of AvdModel.

                        """

            class RedistributeRoutesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "source_protocol": {"type": str},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                }
                source_protocol: str
                route_map: str | None
                include_leaked: bool | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only used if `source_protocol` is one of `connected`,
                `static`, `isis`, `user`, `dynamic`.
                """
                ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospfv3'.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_protocol: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                        | None
                        | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.


                        Subclass of AvdModel.

                        Args:
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: include_leaked
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only used if `source_protocol` is one of `connected`,
                               `static`, `isis`, `user`, `dynamic`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospfv3'.

                        """

            class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

            RedistributeRoutes._item_type = RedistributeRoutesItem

            _fields: ClassVar[dict] = {
                "networks": {"type": Networks},
                "bgp": {"type": Bgp},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": RedistributeRoutes},
            }
            networks: Networks
            """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
            bgp: Bgp
            """Subclass of AvdModel."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            redistribute: Redistribute
            """
            Redistribute routes in to BGP.

            Subclass of AvdModel.
            """
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `RedistributeRoutesItem` items."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    networks: Networks | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv6.


                    Subclass of AvdModel.

                    Args:
                        networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                        bgp: Subclass of AvdModel.
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        redistribute:
                           Redistribute routes in to BGP.

                           Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.

                    """

        class AddressFamilyIpv6Multicast(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                    direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                    direction_out_action: Literal["deny", "deny-in-out", "permit"] | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}}
                    receive: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, receive: bool | None | UndefinedType = Undefined) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: receive

                            """

                _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}, "additional_paths": {"type": AdditionalPaths}}
                missing_policy: MissingPolicy
                """Subclass of AvdModel."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, missing_policy: MissingPolicy | UndefinedType = Undefined, additional_paths: AdditionalPaths | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            missing_policy: Subclass of AvdModel.
                            additional_paths: Subclass of AvdModel.

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}}
                    receive: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, receive: bool | None | UndefinedType = Undefined) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: receive

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            additional_paths: Subclass of AvdModel.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}}
                    receive: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, receive: bool | None | UndefinedType = Undefined) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: receive

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "activate": {"type": bool}, "additional_paths": {"type": AdditionalPaths}}
                name: str
                """Peer-group name."""
                activate: bool | None
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            additional_paths: Subclass of AvdModel.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NetworksItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}}
                prefix: str
                """IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, prefix: str | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                        """
                        NetworksItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: route_map

                        """

            class Networks(AvdIndexedList[str, NetworksItem]):
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                class Isis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool
                    isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """

                class Ospf(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "nssa_type": {"type": int}, "route_map": {"type": str}}
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                    }
                    enabled: bool | None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPF routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPF routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPF routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospf.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPF routes.
                                match_external:
                                   Redistribute OSPF routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPF routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPF routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map

                            """

                class Ospfv3(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "nssa_type": {"type": int}, "route_map": {"type": str}}
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                    }
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPFv3 routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPFv3 routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPFv3 routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPFv3 routes.
                                match_external:
                                   Redistribute OSPFv3 routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPFv3 routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPFv3 routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map

                            """

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                _fields: ClassVar[dict] = {
                    "connected": {"type": Connected},
                    "isis": {"type": Isis},
                    "ospf": {"type": Ospf},
                    "ospfv3": {"type": Ospfv3},
                    "static": {"type": Static},
                }
                connected: Connected
                """Subclass of AvdModel."""
                isis: Isis
                """Subclass of AvdModel."""
                ospf: Ospf
                """Subclass of AvdModel."""
                ospfv3: Ospfv3
                """Subclass of AvdModel."""
                static: Static
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        connected: Connected | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospf: Ospf | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            connected: Subclass of AvdModel.
                            isis: Subclass of AvdModel.
                            ospf: Subclass of AvdModel.
                            ospfv3: Subclass of AvdModel.
                            static: Subclass of AvdModel.

                        """

            class RedistributeRoutesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "source_protocol": {"type": str},
                    "include_leaked": {"type": bool},
                    "route_map": {"type": str},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                }
                source_protocol: Literal["connected", "isis", "ospf", "ospfv3", "static"]
                include_leaked: bool | None
                """Only applicable if `source_protocol` is `isis`."""
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is `isis`.
                """
                ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_protocol: Literal["connected", "isis", "ospf", "ospfv3", "static"] | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                        | None
                        | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.


                        Subclass of AvdModel.

                        Args:
                            source_protocol: source_protocol
                            include_leaked: Only applicable if `source_protocol` is `isis`.
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is `isis`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.

                        """

            class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

            RedistributeRoutes._item_type = RedistributeRoutesItem

            _fields: ClassVar[dict] = {
                "bgp": {"type": Bgp},
                "neighbors": {"type": Neighbors},
                "peer_groups": {"type": PeerGroups},
                "networks": {"type": Networks},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": RedistributeRoutes},
            }
            bgp: Bgp
            """Subclass of AvdModel."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            networks: Networks
            """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
            redistribute: Redistribute
            """
            Redistribute routes in to BGP.

            Subclass of AvdModel.
            """
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `RedistributeRoutesItem` items."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    networks: Networks | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv6Multicast.


                    Subclass of AvdModel.

                    Args:
                        bgp: Subclass of AvdModel.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                        redistribute:
                           Redistribute routes in to BGP.

                           Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.

                    """

        class AddressFamilyIpv6SrTe(AvdModel):
            """Subclass of AvdModel."""

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {"neighbors": {"type": Neighbors}, "peer_groups": {"type": PeerGroups}}
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(self, *, neighbors: Neighbors | UndefinedType = Undefined, peer_groups: PeerGroups | UndefinedType = Undefined) -> None:
                    """
                    AddressFamilyIpv6SrTe.


                    Subclass of AvdModel.

                    Args:
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).

                    """

        class AddressFamilyLinkState(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                    direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                    direction_out_action: Literal["deny", "deny-in-out", "permit"] | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """

                _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}}
                missing_policy: MissingPolicy
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, missing_policy: MissingPolicy | UndefinedType = Undefined) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            missing_policy: Subclass of AvdModel.

                        """

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                    direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                    direction_out_action: Literal["deny", "deny-in-out", "permit"] | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "activate": {"type": bool}, "missing_policy": {"type": MissingPolicy}}
                name: str
                """Peer-group name."""
                activate: bool | None
                missing_policy: MissingPolicy
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            missing_policy: Subclass of AvdModel.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                    direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                    direction_out_action: Literal["deny", "deny-in-out", "permit"] | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """

                _fields: ClassVar[dict] = {"ip_address": {"type": str}, "activate": {"type": bool}, "missing_policy": {"type": MissingPolicy}}
                ip_address: str
                activate: bool | None
                missing_policy: MissingPolicy
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            missing_policy: Subclass of AvdModel.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PathSelection(AvdModel):
                """Subclass of AvdModel."""

                class Roles(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"producer": {"type": bool}, "consumer": {"type": bool}, "propagator": {"type": bool}}
                    producer: bool | None
                    consumer: bool | None
                    propagator: bool | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            producer: bool | None | UndefinedType = Undefined,
                            consumer: bool | None | UndefinedType = Undefined,
                            propagator: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Roles.


                            Subclass of AvdModel.

                            Args:
                                producer: producer
                                consumer: consumer
                                propagator: propagator

                            """

                _fields: ClassVar[dict] = {"roles": {"type": Roles}}
                roles: Roles
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, roles: Roles | UndefinedType = Undefined) -> None:
                        """
                        PathSelection.


                        Subclass of AvdModel.

                        Args:
                            roles: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "bgp": {"type": Bgp},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "path_selection": {"type": PathSelection},
            }
            bgp: Bgp
            """Subclass of AvdModel."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            path_selection: PathSelection
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bgp: Bgp | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    path_selection: PathSelection | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyLinkState.


                    Subclass of AvdModel.

                    Args:
                        bgp: Subclass of AvdModel.
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        path_selection: Subclass of AvdModel.

                    """

        class AddressFamilyFlowSpecIpv4(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                    direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                    direction_out_action: Literal["deny", "deny-in-out", "permit"] | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """

                _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}}
                missing_policy: MissingPolicy
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, missing_policy: MissingPolicy | UndefinedType = Undefined) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            missing_policy: Subclass of AvdModel.

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ip_address": {"type": str}, "activate": {"type": bool}}
                ip_address: str
                activate: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, ip_address: str | UndefinedType = Undefined, activate: bool | None | UndefinedType = Undefined) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "activate": {"type": bool}}
                name: str
                """Peer-group name."""
                activate: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, activate: bool | None | UndefinedType = Undefined) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {"bgp": {"type": Bgp}, "neighbors": {"type": Neighbors}, "peer_groups": {"type": PeerGroups}}
            bgp: Bgp
            """Subclass of AvdModel."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyFlowSpecIpv4.


                    Subclass of AvdModel.

                    Args:
                        bgp: Subclass of AvdModel.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).

                    """

        class AddressFamilyFlowSpecIpv6(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                    direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                    direction_out_action: Literal["deny", "deny-in-out", "permit"] | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """

                _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}}
                missing_policy: MissingPolicy
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, missing_policy: MissingPolicy | UndefinedType = Undefined) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            missing_policy: Subclass of AvdModel.

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ip_address": {"type": str}, "activate": {"type": bool}}
                ip_address: str
                activate: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, ip_address: str | UndefinedType = Undefined, activate: bool | None | UndefinedType = Undefined) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "activate": {"type": bool}}
                name: str
                """Peer-group name."""
                activate: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, activate: bool | None | UndefinedType = Undefined) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {"bgp": {"type": Bgp}, "neighbors": {"type": Neighbors}, "peer_groups": {"type": PeerGroups}}
            bgp: Bgp
            """Subclass of AvdModel."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyFlowSpecIpv6.


                    Subclass of AvdModel.

                    Args:
                        bgp: Subclass of AvdModel.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).

                    """

        class AddressFamilyPathSelection(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                _fields: ClassVar[dict] = {"additional_paths": {"type": AdditionalPaths}}
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, additional_paths: AdditionalPaths | UndefinedType = Undefined) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            additional_paths: Subclass of AvdModel.

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                _fields: ClassVar[dict] = {"ip_address": {"type": str}, "activate": {"type": bool}, "additional_paths": {"type": AdditionalPaths}}
                ip_address: str
                activate: bool | None
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            additional_paths: Subclass of AvdModel.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "activate": {"type": bool}, "additional_paths": {"type": AdditionalPaths}}
                name: str
                """Peer-group name."""
                activate: bool | None
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            additional_paths: Subclass of AvdModel.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {"bgp": {"type": Bgp}, "neighbors": {"type": Neighbors}, "peer_groups": {"type": PeerGroups}}
            bgp: Bgp
            """Subclass of AvdModel."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyPathSelection.


                    Subclass of AvdModel.

                    Args:
                        bgp: Subclass of AvdModel.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).

                    """

        class AddressFamilyVpnIpv4(AvdModel):
            """Subclass of AvdModel."""

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRoute(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}}
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRoute.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                route_map: route_map

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_route: DefaultRoute | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_route: Subclass of AvdModel.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class Route(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"import_match_failure_action": {"type": str}}
                import_match_failure_action: Literal["discard"] | None

                if TYPE_CHECKING:

                    def __init__(self, *, import_match_failure_action: Literal["discard"] | None | UndefinedType = Undefined) -> None:
                        """
                        Route.


                        Subclass of AvdModel.

                        Args:
                            import_match_failure_action: import_match_failure_action

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRoute(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}}
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRoute.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                route_map: route_map

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_route: DefaultRoute | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_route: Subclass of AvdModel.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class NeighborDefaultEncapsulationMplsNextHopSelf(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"source_interface": {"type": str}}
                source_interface: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, source_interface: str | None | UndefinedType = Undefined) -> None:
                        """
                        NeighborDefaultEncapsulationMplsNextHopSelf.


                        Subclass of AvdModel.

                        Args:
                            source_interface: source_interface

                        """

            _fields: ClassVar[dict] = {
                "domain_identifier": {"type": str},
                "peer_groups": {"type": PeerGroups},
                "route": {"type": Route},
                "neighbors": {"type": Neighbors},
                "neighbor_default_encapsulation_mpls_next_hop_self": {"type": NeighborDefaultEncapsulationMplsNextHopSelf},
            }
            domain_identifier: str | None
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            route: Route
            """Subclass of AvdModel."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    domain_identifier: str | None | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    route: Route | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyVpnIpv4.


                    Subclass of AvdModel.

                    Args:
                        domain_identifier: domain_identifier
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        route: Subclass of AvdModel.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        neighbor_default_encapsulation_mpls_next_hop_self: Subclass of AvdModel.

                    """

        class AddressFamilyVpnIpv6(AvdModel):
            """Subclass of AvdModel."""

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRoute(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}}
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRoute.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                route_map: route_map

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_route: DefaultRoute | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_route: Subclass of AvdModel.

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class Route(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"import_match_failure_action": {"type": str}}
                import_match_failure_action: Literal["discard"] | None

                if TYPE_CHECKING:

                    def __init__(self, *, import_match_failure_action: Literal["discard"] | None | UndefinedType = Undefined) -> None:
                        """
                        Route.


                        Subclass of AvdModel.

                        Args:
                            import_match_failure_action: import_match_failure_action

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRoute(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}}
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRoute.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                route_map: route_map

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_route: DefaultRoute | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_route: Subclass of AvdModel.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class NeighborDefaultEncapsulationMplsNextHopSelf(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"source_interface": {"type": str}}
                source_interface: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, source_interface: str | None | UndefinedType = Undefined) -> None:
                        """
                        NeighborDefaultEncapsulationMplsNextHopSelf.


                        Subclass of AvdModel.

                        Args:
                            source_interface: source_interface

                        """

            _fields: ClassVar[dict] = {
                "domain_identifier": {"type": str},
                "peer_groups": {"type": PeerGroups},
                "route": {"type": Route},
                "neighbors": {"type": Neighbors},
                "neighbor_default_encapsulation_mpls_next_hop_self": {"type": NeighborDefaultEncapsulationMplsNextHopSelf},
            }
            domain_identifier: str | None
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            route: Route
            """Subclass of AvdModel."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    domain_identifier: str | None | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    route: Route | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyVpnIpv6.


                    Subclass of AvdModel.

                    Args:
                        domain_identifier: domain_identifier
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        route: Subclass of AvdModel.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        neighbor_default_encapsulation_mpls_next_hop_self: Subclass of AvdModel.

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "install": {"type": bool},
                        "install_ecmp_primary": {"type": bool},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                    }
                    install: bool | None
                    """Install BGP backup path."""
                    install_ecmp_primary: bool | None
                    """Allow additional path with ECMP primary path."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            install: bool | None | UndefinedType = Undefined,
                            install_ecmp_primary: bool | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                install: Install BGP backup path.
                                install_ecmp_primary: Allow additional path with ECMP primary path.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                _fields: ClassVar[dict] = {"redistribute_internal": {"type": bool}, "additional_paths": {"type": AdditionalPaths}}
                redistribute_internal: bool | None
                """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, redistribute_internal: bool | None | UndefinedType = Undefined, additional_paths: AdditionalPaths | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.
                            additional_paths: Subclass of AvdModel.

                        """

            class EvpnMulticastAddressFamily(AvdModel):
                """Subclass of AvdModel."""

                class Ipv4(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"transit": {"type": bool}}
                    transit: bool | None
                    """Enable EVPN multicast transit mode."""

                    if TYPE_CHECKING:

                        def __init__(self, *, transit: bool | None | UndefinedType = Undefined) -> None:
                            """
                            Ipv4.


                            Subclass of AvdModel.

                            Args:
                                transit: Enable EVPN multicast transit mode.

                            """

                _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}}
                ipv4: Ipv4
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, ipv4: Ipv4 | UndefinedType = Undefined) -> None:
                        """
                        EvpnMulticastAddressFamily.


                        Subclass of AvdModel.

                        Args:
                            ipv4: Subclass of AvdModel.

                        """

            class EvpnMulticastGatewayDrElection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"algorithm": {"type": str}, "preference_value": {"type": int}}
                algorithm: Literal["hrw", "modulus", "preference"]
                """
                DR election algorithms:
                  hrw: Default selection based on highest random weight.
                  modulus:
                Selection based on VLAN ID modulo number of candidates.
                  preference: Selection based on a
                configured preference value.
                """
                preference_value: int | None
                """Required when `algorithm` is `preference`."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        algorithm: Literal["hrw", "modulus", "preference"] | UndefinedType = Undefined,
                        preference_value: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        EvpnMulticastGatewayDrElection.


                        Subclass of AvdModel.

                        Args:
                            algorithm:
                               DR election algorithms:
                                 hrw: Default selection based on highest random weight.
                                 modulus:
                               Selection based on VLAN ID modulo number of candidates.
                                 preference: Selection based on a
                               configured preference value.
                            preference_value: Required when `algorithm` is `preference`.

                        """

            class DefaultRouteExportsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"address_family": {"type": str}, "always": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                address_family: Literal["evpn", "vpn-ipv4", "vpn-ipv6"]
                always: bool | None
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        address_family: Literal["evpn", "vpn-ipv4", "vpn-ipv6"] | UndefinedType = Undefined,
                        always: bool | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultRouteExportsItem.


                        Subclass of AvdModel.

                        Args:
                            address_family: address_family
                            always: always
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).

                        """

            class DefaultRouteExports(AvdIndexedList[str, DefaultRouteExportsItem]):
                """
                Subclass of AvdIndexedList with `DefaultRouteExportsItem` items. Primary key is `address_family`
                (`str`).
                """

                _primary_key: ClassVar[str] = "address_family"

            DefaultRouteExports._item_type = DefaultRouteExportsItem

            class RouteTargets(AvdModel):
                """Subclass of AvdModel."""

                class ImportItem(AvdModel):
                    """Subclass of AvdModel."""

                    class RouteTargets(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    RouteTargets._item_type = str

                    _fields: ClassVar[dict] = {
                        "address_family": {"type": str},
                        "route_targets": {"type": RouteTargets},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "vpn_route_filter_rcf": {"type": str},
                    }
                    address_family: str
                    route_targets: RouteTargets
                    """Subclass of AvdList with `str` items."""
                    route_map: str | None
                    """Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`."""
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    Only applicable if `address_family`
                    is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                    """
                    vpn_route_filter_rcf: str | None
                    """
                    RCF function name with parenthesis for filtering VPN routes. Also requires `rcf` to be set.
                    Example:
                    MyFunction(myarg).
                    Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            address_family: str | UndefinedType = Undefined,
                            route_targets: RouteTargets | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            vpn_route_filter_rcf: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ImportItem.


                            Subclass of AvdModel.

                            Args:
                                address_family: address_family
                                route_targets: Subclass of AvdList with `str` items.
                                route_map: Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   Only applicable if `address_family`
                                   is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                                vpn_route_filter_rcf:
                                   RCF function name with parenthesis for filtering VPN routes. Also requires `rcf` to be set.
                                   Example:  # fmt: skip
                                   MyFunction(myarg).
                                   Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.

                            """

                class Import(AvdIndexedList[str, ImportItem]):
                    """Subclass of AvdIndexedList with `ImportItem` items. Primary key is `address_family` (`str`)."""

                    _primary_key: ClassVar[str] = "address_family"

                Import._item_type = ImportItem

                class ExportItem(AvdModel):
                    """Subclass of AvdModel."""

                    class RouteTargets(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    RouteTargets._item_type = str

                    _fields: ClassVar[dict] = {
                        "address_family": {"type": str},
                        "route_targets": {"type": RouteTargets},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "vrf_route_filter_rcf": {"type": str},
                    }
                    address_family: str
                    route_targets: RouteTargets
                    """Subclass of AvdList with `str` items."""
                    route_map: str | None
                    """Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`."""
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    Only applicable if `address_family`
                    is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                    """
                    vrf_route_filter_rcf: str | None
                    """
                    RCF function name with parenthesis for filtering VRF routes. Also requires `rcf` to be set.
                    Example:
                    MyFunction(myarg).
                    Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            address_family: str | UndefinedType = Undefined,
                            route_targets: RouteTargets | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            vrf_route_filter_rcf: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ExportItem.


                            Subclass of AvdModel.

                            Args:
                                address_family: address_family
                                route_targets: Subclass of AvdList with `str` items.
                                route_map: Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   Only applicable if `address_family`
                                   is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                                vrf_route_filter_rcf:
                                   RCF function name with parenthesis for filtering VRF routes. Also requires `rcf` to be set.
                                   Example:  # fmt: skip
                                   MyFunction(myarg).
                                   Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.

                            """

                class Export(AvdIndexedList[str, ExportItem]):
                    """Subclass of AvdIndexedList with `ExportItem` items. Primary key is `address_family` (`str`)."""

                    _primary_key: ClassVar[str] = "address_family"

                Export._item_type = ExportItem

                _fields: ClassVar[dict] = {"field_import": {"type": Import}, "export": {"type": Export}}
                _field_to_key_map: ClassVar[dict] = {"field_import": "import"}
                _key_to_field_map: ClassVar[dict] = {"import": "field_import"}
                field_import: Import
                """Subclass of AvdIndexedList with `ImportItem` items. Primary key is `address_family` (`str`)."""
                export: Export
                """Subclass of AvdIndexedList with `ExportItem` items. Primary key is `address_family` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(self, *, field_import: Import | UndefinedType = Undefined, export: Export | UndefinedType = Undefined) -> None:
                        """
                        RouteTargets.


                        Subclass of AvdModel.

                        Args:
                            field_import: Subclass of AvdIndexedList with `ImportItem` items. Primary key is `address_family` (`str`).
                            export: Subclass of AvdIndexedList with `ExportItem` items. Primary key is `address_family` (`str`).

                        """

            class GracefulRestart(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "restart_time": {"type": int}, "stalepath_time": {"type": int}}
                enabled: bool
                restart_time: int | None
                """Number of seconds."""
                stalepath_time: int | None
                """Number of seconds."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        restart_time: int | None | UndefinedType = Undefined,
                        stalepath_time: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GracefulRestart.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            restart_time: Number of seconds.
                            stalepath_time: Number of seconds.

                        """

            class NetworksItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}}
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, prefix: str | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                        """
                        NetworksItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: route_map

                        """

            class Networks(AvdIndexedList[str, NetworksItem]):
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class MaximumPaths(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"paths": {"type": int}, "ecmp": {"type": int}}
                paths: int
                ecmp: int | None

                if TYPE_CHECKING:

                    def __init__(self, *, paths: int | UndefinedType = Undefined, ecmp: int | None | UndefinedType = Undefined) -> None:
                        """
                        MaximumPaths.


                        Subclass of AvdModel.

                        Args:
                            paths: paths
                            ecmp: ecmp

                        """

            class Updates(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"wait_for_convergence": {"type": bool}, "wait_install": {"type": bool}}
                wait_for_convergence: bool | None
                """
                Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                convergence state is reached.
                """
                wait_install: bool | None
                """
                Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                This
                will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                that may not yet be installed into the forwarding plane.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self, *, wait_for_convergence: bool | None | UndefinedType = Undefined, wait_install: bool | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        Updates.


                        Subclass of AvdModel.

                        Args:
                            wait_for_convergence:
                               Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                               convergence state is reached.
                            wait_install:
                               Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                               This
                               will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                               that may not yet be installed into the forwarding plane.

                        """

            class ListenRangesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "prefix": {"type": str},
                    "peer_id_include_router_id": {"type": bool},
                    "peer_group": {"type": str},
                    "peer_filter": {"type": str},
                    "remote_as": {"type": str},
                }
                prefix: str | None
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                peer_id_include_router_id: bool | None
                """Include router ID as part of peer filter."""
                peer_group: str | None
                """Peer-group name."""
                peer_filter: str | None
                """
                Peer-filter name.
                note: `peer_filter`` or `remote_as` is required but mutually exclusive.
                If both
                are defined, peer_filter takes precedence.
                """
                remote_as: str | None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        prefix: str | None | UndefinedType = Undefined,
                        peer_id_include_router_id: bool | None | UndefinedType = Undefined,
                        peer_group: str | None | UndefinedType = Undefined,
                        peer_filter: str | None | UndefinedType = Undefined,
                        remote_as: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ListenRangesItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            peer_id_include_router_id: Include router ID as part of peer filter.
                            peer_group: Peer-group name.
                            peer_filter:
                               Peer-filter name.
                               note: `peer_filter`` or `remote_as` is required but mutually exclusive.
                               If both
                               are defined, peer_filter takes precedence.
                            remote_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.

                        """

            class ListenRanges(AvdList[ListenRangesItem]):
                """Subclass of AvdList with `ListenRangesItem` items."""

            ListenRanges._item_type = ListenRangesItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class RemovePrivateAs(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "all": {"type": bool}, "replace_as": {"type": bool}}
                    enabled: bool | None
                    all: bool | None
                    replace_as: bool | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            all: bool | None | UndefinedType = Undefined,
                            replace_as: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RemovePrivateAs.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                all: all
                                replace_as: replace_as

                            """

                class RemovePrivateAsIngress(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "replace_as": {"type": bool}}
                    enabled: bool | None
                    replace_as: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, replace_as: bool | None | UndefinedType = Undefined) -> None:
                            """
                            RemovePrivateAsIngress.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                replace_as: replace_as

                            """

                class AsPath(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"remote_as_replace_out": {"type": bool}, "prepend_own_disabled": {"type": bool}}
                    remote_as_replace_out: bool | None
                    """Replace AS number with local AS number."""
                    prepend_own_disabled: bool | None
                    """Disable prepending own AS number to AS path."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            remote_as_replace_out: bool | None | UndefinedType = Undefined,
                            prepend_own_disabled: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AsPath.


                            Subclass of AvdModel.

                            Args:
                                remote_as_replace_out: Replace AS number with local AS number.
                                prepend_own_disabled: Disable prepending own AS number to AS path.

                            """

                class BfdTimers(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}}
                    interval: int
                    """Interval in milliseconds."""
                    min_rx: int
                    """Rate in milliseconds."""
                    multiplier: int

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            interval: int | UndefinedType = Undefined,
                            min_rx: int | UndefinedType = Undefined,
                            multiplier: int | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BfdTimers.


                            Subclass of AvdModel.

                            Args:
                                interval: Interval in milliseconds.
                                min_rx: Rate in milliseconds.
                                multiplier: multiplier

                            """

                class RibInPrePolicyRetain(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "all": {"type": bool}}
                    enabled: bool | None
                    all: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, all: bool | None | UndefinedType = Undefined) -> None:
                            """
                            RibInPrePolicyRetain.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                all: all

                            """

                class AllowasIn(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "times": {"type": int}}
                    enabled: bool | None
                    times: int | None
                    """Number of local ASNs allowed in a BGP update."""

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, times: int | None | UndefinedType = Undefined) -> None:
                            """
                            AllowasIn.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                times: Number of local ASNs allowed in a BGP update.

                            """

                class DefaultOriginate(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "always": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool | None
                    always: bool | None
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            always: bool | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultOriginate.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                always: always
                                route_map: route_map

                            """

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "peer_group": {"type": str},
                    "remote_as": {"type": str},
                    "password": {"type": str},
                    "passive": {"type": bool},
                    "remove_private_as": {"type": RemovePrivateAs},
                    "remove_private_as_ingress": {"type": RemovePrivateAsIngress},
                    "weight": {"type": int},
                    "local_as": {"type": str},
                    "as_path": {"type": AsPath},
                    "description": {"type": str},
                    "route_reflector_client": {"type": bool},
                    "ebgp_multihop": {"type": int},
                    "next_hop_peer": {"type": bool},
                    "next_hop_self": {"type": bool},
                    "shutdown": {"type": bool},
                    "bfd": {"type": bool},
                    "bfd_timers": {"type": BfdTimers},
                    "timers": {"type": str},
                    "rib_in_pre_policy_retain": {"type": RibInPrePolicyRetain},
                    "send_community": {"type": str},
                    "maximum_routes": {"type": int},
                    "maximum_routes_warning_limit": {"type": str},
                    "maximum_routes_warning_only": {"type": bool},
                    "allowas_in": {"type": AllowasIn},
                    "default_originate": {"type": DefaultOriginate},
                    "update_source": {"type": str},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "peer_tag_in": {"type": str},
                    "peer_tag_out_discard": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                ip_address: str
                peer_group: str | None
                """Peer-group name."""
                remote_as: str | None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                password: str | None
                passive: bool | None
                remove_private_as: RemovePrivateAs
                """
                Remove private AS numbers in outbound AS path.

                Subclass of AvdModel.
                """
                remove_private_as_ingress: RemovePrivateAsIngress
                """Subclass of AvdModel."""
                weight: int | None
                local_as: str | None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                as_path: AsPath
                """
                BGP AS-PATH options.

                Subclass of AvdModel.
                """
                description: str | None
                route_reflector_client: bool | None
                ebgp_multihop: int | None
                """Time-to-live in range of hops."""
                next_hop_peer: bool | None
                next_hop_self: bool | None
                shutdown: bool | None
                bfd: bool | None
                """Enable BFD."""
                bfd_timers: BfdTimers
                """
                Override default BFD timers. BFD must be enabled with `bfd: true`.

                Subclass of AvdModel.
                """
                timers: str | None
                """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
                rib_in_pre_policy_retain: RibInPrePolicyRetain
                """Subclass of AvdModel."""
                send_community: str | None
                """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
                maximum_routes: int | None
                maximum_routes_warning_limit: str | None
                """
                Maximum number of routes after which a warning is issued (0 means never warn) or
                Percentage of
                maximum number of routes at which to warn ("<1-100> percent").
                """
                maximum_routes_warning_only: bool | None
                allowas_in: AllowasIn
                """Subclass of AvdModel."""
                default_originate: DefaultOriginate
                """Subclass of AvdModel."""
                update_source: str | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                peer_tag_in: str | None
                """Inbound peer tag name."""
                peer_tag_out_discard: str | None
                """Outbound discard peer tag name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        peer_group: str | None | UndefinedType = Undefined,
                        remote_as: str | None | UndefinedType = Undefined,
                        password: str | None | UndefinedType = Undefined,
                        passive: bool | None | UndefinedType = Undefined,
                        remove_private_as: RemovePrivateAs | UndefinedType = Undefined,
                        remove_private_as_ingress: RemovePrivateAsIngress | UndefinedType = Undefined,
                        weight: int | None | UndefinedType = Undefined,
                        local_as: str | None | UndefinedType = Undefined,
                        as_path: AsPath | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                        route_reflector_client: bool | None | UndefinedType = Undefined,
                        ebgp_multihop: int | None | UndefinedType = Undefined,
                        next_hop_peer: bool | None | UndefinedType = Undefined,
                        next_hop_self: bool | None | UndefinedType = Undefined,
                        shutdown: bool | None | UndefinedType = Undefined,
                        bfd: bool | None | UndefinedType = Undefined,
                        bfd_timers: BfdTimers | UndefinedType = Undefined,
                        timers: str | None | UndefinedType = Undefined,
                        rib_in_pre_policy_retain: RibInPrePolicyRetain | UndefinedType = Undefined,
                        send_community: str | None | UndefinedType = Undefined,
                        maximum_routes: int | None | UndefinedType = Undefined,
                        maximum_routes_warning_limit: str | None | UndefinedType = Undefined,
                        maximum_routes_warning_only: bool | None | UndefinedType = Undefined,
                        allowas_in: AllowasIn | UndefinedType = Undefined,
                        default_originate: DefaultOriginate | UndefinedType = Undefined,
                        update_source: str | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        peer_tag_in: str | None | UndefinedType = Undefined,
                        peer_tag_out_discard: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            peer_group: Peer-group name.
                            remote_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                            password: password
                            passive: passive
                            remove_private_as:
                               Remove private AS numbers in outbound AS path.

                               Subclass of AvdModel.
                            remove_private_as_ingress: Subclass of AvdModel.
                            weight: weight
                            local_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                            as_path:
                               BGP AS-PATH options.

                               Subclass of AvdModel.
                            description: description
                            route_reflector_client: route_reflector_client
                            ebgp_multihop: Time-to-live in range of hops.
                            next_hop_peer: next_hop_peer
                            next_hop_self: next_hop_self
                            shutdown: shutdown
                            bfd: Enable BFD.
                            bfd_timers:
                               Override default BFD timers. BFD must be enabled with `bfd: true`.

                               Subclass of AvdModel.
                            timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                            rib_in_pre_policy_retain: Subclass of AvdModel.
                            send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                            maximum_routes: maximum_routes
                            maximum_routes_warning_limit:
                               Maximum number of routes after which a warning is issued (0 means never warn) or
                               Percentage of
                               maximum number of routes at which to warn ("<1-100> percent").
                            maximum_routes_warning_only: maximum_routes_warning_only
                            allowas_in: Subclass of AvdModel.
                            default_originate: Subclass of AvdModel.
                            update_source: update_source
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            peer_tag_in: Inbound peer tag name.
                            peer_tag_out_discard: Outbound discard peer tag name.
                            additional_paths: Subclass of AvdModel.

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class NeighborInterfacesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "remote_as": {"type": str},
                    "peer_group": {"type": str},
                    "peer_filter": {"type": str},
                    "description": {"type": str},
                }
                name: str
                """Interface name."""
                remote_as: str | None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                peer_group: str | None
                """Peer-group name."""
                peer_filter: str | None
                """Peer-filter name."""
                description: str | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        remote_as: str | None | UndefinedType = Undefined,
                        peer_group: str | None | UndefinedType = Undefined,
                        peer_filter: str | None | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborInterfacesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Interface name.
                            remote_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                            peer_group: Peer-group name.
                            peer_filter: Peer-filter name.
                            description: description

                        """

            class NeighborInterfaces(AvdIndexedList[str, NeighborInterfacesItem]):
                """Subclass of AvdIndexedList with `NeighborInterfacesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            NeighborInterfaces._item_type = NeighborInterfacesItem

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class AttachedHost(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            AttachedHost.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """

                class Dynamic(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dynamic.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.

                            """

                class Isis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool
                    isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """

                class Ospf(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool | None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPF routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPF routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPF routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospf.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPF routes.
                                match_external:
                                   Redistribute OSPF routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPF routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPF routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """

                class Ospfv3(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPFv3 routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPFv3 routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPFv3 routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPFv3 routes.
                                match_external:
                                   Redistribute OSPFv3 routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPFv3 routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPFv3 routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """

                class Rip(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                    enabled: bool
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            Rip.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map

                            """

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """

                class User(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}}
                    enabled: bool
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | UndefinedType = Undefined, rcf: str | None | UndefinedType = Undefined) -> None:
                            """
                            User.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.

                            """

                _fields: ClassVar[dict] = {
                    "attached_host": {"type": AttachedHost},
                    "bgp": {"type": Bgp},
                    "connected": {"type": Connected},
                    "dynamic": {"type": Dynamic},
                    "isis": {"type": Isis},
                    "ospf": {"type": Ospf},
                    "ospfv3": {"type": Ospfv3},
                    "rip": {"type": Rip},
                    "static": {"type": Static},
                    "user": {"type": User},
                }
                attached_host: AttachedHost
                """Subclass of AvdModel."""
                bgp: Bgp
                """Subclass of AvdModel."""
                connected: Connected
                """Subclass of AvdModel."""
                dynamic: Dynamic
                """Subclass of AvdModel."""
                isis: Isis
                """Subclass of AvdModel."""
                ospf: Ospf
                """Subclass of AvdModel."""
                ospfv3: Ospfv3
                """Subclass of AvdModel."""
                rip: Rip
                """Subclass of AvdModel."""
                static: Static
                """Subclass of AvdModel."""
                user: User
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        attached_host: AttachedHost | UndefinedType = Undefined,
                        bgp: Bgp | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospf: Ospf | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        rip: Rip | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        user: User | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            attached_host: Subclass of AvdModel.
                            bgp: Subclass of AvdModel.
                            connected: Subclass of AvdModel.
                            dynamic: Subclass of AvdModel.
                            isis: Subclass of AvdModel.
                            ospf: Subclass of AvdModel.
                            ospfv3: Subclass of AvdModel.
                            rip: Subclass of AvdModel.
                            static: Subclass of AvdModel.
                            user: Subclass of AvdModel.

                        """

            class RedistributeRoutesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "source_protocol": {"type": str},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                }
                source_protocol: str
                route_map: str | None
                include_leaked: bool | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is one of `connected`,
                `dynamic`, `isis`, `static` and `user`.
                """
                ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_protocol: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                        | None
                        | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.


                        Subclass of AvdModel.

                        Args:
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: include_leaked
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is one of `connected`,
                               `dynamic`, `isis`, `static` and `user`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.

                        """

            class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

            RedistributeRoutes._item_type = RedistributeRoutesItem

            class AggregateAddressesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "prefix": {"type": str},
                    "advertise_only": {"type": bool},
                    "as_set": {"type": bool},
                    "summary_only": {"type": bool},
                    "attribute_map": {"type": str},
                    "match_map": {"type": str},
                }
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                advertise_only: bool | None
                as_set: bool | None
                summary_only: bool | None
                attribute_map: str | None
                match_map: str | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        prefix: str | UndefinedType = Undefined,
                        advertise_only: bool | None | UndefinedType = Undefined,
                        as_set: bool | None | UndefinedType = Undefined,
                        summary_only: bool | None | UndefinedType = Undefined,
                        attribute_map: str | None | UndefinedType = Undefined,
                        match_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AggregateAddressesItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            advertise_only: advertise_only
                            as_set: as_set
                            summary_only: summary_only
                            attribute_map: attribute_map
                            match_map: match_map

                        """

            class AggregateAddresses(AvdIndexedList[str, AggregateAddressesItem]):
                """Subclass of AvdIndexedList with `AggregateAddressesItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            AggregateAddresses._item_type = AggregateAddressesItem

            class AddressFamilyIpv4(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    class MissingPolicy(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                        direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                        direction_out_action: Literal["deny", "deny-in-out", "permit"] | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.


                                Subclass of AvdModel.

                                Args:
                                    direction_in_action: direction_in_action
                                    direction_out_action: direction_out_action

                                """

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "install": {"type": bool},
                            "install_ecmp_primary": {"type": bool},
                            "receive": {"type": bool},
                            "send": {"type": str},
                            "send_limit": {"type": int},
                        }
                        install: bool | None
                        """Install BGP backup path."""
                        install_ecmp_primary: bool | None
                        """Allow additional path with ECMP primary path."""
                        receive: bool | None
                        """Enable or disable reception of additional-paths."""
                        send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: int | None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                install: bool | None | UndefinedType = Undefined,
                                install_ecmp_primary: bool | None | UndefinedType = Undefined,
                                receive: bool | None | UndefinedType = Undefined,
                                send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                                send_limit: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    install: Install BGP backup path.
                                    install_ecmp_primary: Allow additional path with ECMP primary path.
                                    receive: Enable or disable reception of additional-paths.
                                    send:
                                       Select an option to send multiple paths for same prefix through bgp updates.
                                       any: Send any eligible
                                       path.
                                       backup: Best path and installed backup path.
                                       ecmp: All paths in best path ECMP group.
                                       limit:
                                       Limit to n eligible paths.
                                       disabled: Disable sending any paths.
                                    send_limit:
                                       Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                       `ecmp`.

                                """

                    _fields: ClassVar[dict] = {
                        "missing_policy": {"type": MissingPolicy},
                        "additional_paths": {"type": AdditionalPaths},
                        "redistribute_internal": {"type": bool},
                    }
                    missing_policy: MissingPolicy
                    """Subclass of AvdModel."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""
                    redistribute_internal: bool | None
                    """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            missing_policy: MissingPolicy | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                            redistribute_internal: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                missing_policy: Subclass of AvdModel.
                                additional_paths: Subclass of AvdModel.
                                redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.

                            """

                class NeighborsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class NextHop(AvdModel):
                        """Subclass of AvdModel."""

                        class AddressFamilyIpv6(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "originate": {"type": bool}}
                            enabled: bool
                            originate: bool | None

                            if TYPE_CHECKING:

                                def __init__(self, *, enabled: bool | UndefinedType = Undefined, originate: bool | None | UndefinedType = Undefined) -> None:
                                    """
                                    AddressFamilyIpv6.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        originate: originate

                                    """

                        _fields: ClassVar[dict] = {"address_family_ipv6": {"type": AddressFamilyIpv6}}
                        address_family_ipv6: AddressFamilyIpv6
                        """Subclass of AvdModel."""

                        if TYPE_CHECKING:

                            def __init__(self, *, address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined) -> None:
                                """
                                NextHop.


                                Subclass of AvdModel.

                                Args:
                                    address_family_ipv6: Subclass of AvdModel.

                                """

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                        receive: bool | None
                        """Enable or disable reception of additional-paths."""
                        send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: int | None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                receive: bool | None | UndefinedType = Undefined,
                                send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                                send_limit: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    receive: Enable or disable reception of additional-paths.
                                    send:
                                       Select an option to send multiple paths for same prefix through bgp updates.
                                       any: Send any eligible
                                       path.
                                       backup: Best path and installed backup path.
                                       ecmp: All paths in best path ECMP group.
                                       limit:
                                       Limit to n eligible paths.
                                       disabled: Disable sending any paths.
                                    send_limit:
                                       Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                       `ecmp`.

                                """

                    _fields: ClassVar[dict] = {
                        "ip_address": {"type": str},
                        "activate": {"type": bool},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "peer_tag_in": {"type": str},
                        "peer_tag_out_discard": {"type": str},
                        "rcf_in": {"type": str},
                        "rcf_out": {"type": str},
                        "prefix_list_in": {"type": str},
                        "prefix_list_out": {"type": str},
                        "next_hop": {"type": NextHop},
                        "additional_paths": {"type": AdditionalPaths},
                    }
                    ip_address: str
                    activate: bool | None
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    peer_tag_in: str | None
                    """Inbound peer tag name."""
                    peer_tag_out_discard: str | None
                    """Outbound discard peer tag name."""
                    rcf_in: str | None
                    """
                    Inbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    rcf_out: str | None
                    """
                    Outbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    prefix_list_in: str | None
                    """Inbound prefix-list name."""
                    prefix_list_out: str | None
                    """Outbound prefix-list name."""
                    next_hop: NextHop
                    """Subclass of AvdModel."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ip_address: str | UndefinedType = Undefined,
                            activate: bool | None | UndefinedType = Undefined,
                            route_map_in: str | None | UndefinedType = Undefined,
                            route_map_out: str | None | UndefinedType = Undefined,
                            peer_tag_in: str | None | UndefinedType = Undefined,
                            peer_tag_out_discard: str | None | UndefinedType = Undefined,
                            rcf_in: str | None | UndefinedType = Undefined,
                            rcf_out: str | None | UndefinedType = Undefined,
                            prefix_list_in: str | None | UndefinedType = Undefined,
                            prefix_list_out: str | None | UndefinedType = Undefined,
                            next_hop: NextHop | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NeighborsItem.


                            Subclass of AvdModel.

                            Args:
                                ip_address: ip_address
                                activate: activate
                                route_map_in: Inbound route-map name.
                                route_map_out: Outbound route-map name.
                                peer_tag_in: Inbound peer tag name.
                                peer_tag_out_discard: Outbound discard peer tag name.
                                rcf_in:
                                   Inbound RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                rcf_out:
                                   Outbound RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                prefix_list_in: Inbound prefix-list name.
                                prefix_list_out: Outbound prefix-list name.
                                next_hop: Subclass of AvdModel.
                                additional_paths: Subclass of AvdModel.

                            """

                class Neighbors(AvdIndexedList[str, NeighborsItem]):
                    """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                class NetworksItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}}
                    prefix: str
                    """IPv4 prefix "A.B.C.D/E"."""
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, prefix: str | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            NetworksItem.


                            Subclass of AvdModel.

                            Args:
                                prefix: IPv4 prefix "A.B.C.D/E".
                                route_map: route_map

                            """

                class Networks(AvdIndexedList[str, NetworksItem]):
                    """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                    _primary_key: ClassVar[str] = "prefix"

                Networks._item_type = NetworksItem

                class Redistribute(AvdModel):
                    """Subclass of AvdModel."""

                    class AttachedHost(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                AttachedHost.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class Bgp(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                Bgp.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class Connected(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Connected.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.

                                """

                    class Dynamic(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Dynamic.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.

                                """

                    class Isis(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "isis_level": {"type": str},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                        """Redistribute IS-IS route level."""
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Isis.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    isis_level: Redistribute IS-IS route level.
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.

                                """

                    class Ospf(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool | None
                        """Redistribute OSPF routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPF routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPF routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPF routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospf.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPF routes.
                                    match_external:
                                       Redistribute OSPF routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPF routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPF routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class Ospfv3(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool | None
                        """Redistribute OSPFv3 routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPFv3 routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPFv3 routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPFv3 routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospfv3.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPFv3 routes.
                                    match_external:
                                       Redistribute OSPFv3 routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPFv3 routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPFv3 routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class Rip(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                Rip.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class Static(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Static.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.

                                """

                    class User(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}}
                        enabled: bool
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, rcf: str | None | UndefinedType = Undefined) -> None:
                                """
                                User.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.

                                """

                    _fields: ClassVar[dict] = {
                        "attached_host": {"type": AttachedHost},
                        "bgp": {"type": Bgp},
                        "connected": {"type": Connected},
                        "dynamic": {"type": Dynamic},
                        "isis": {"type": Isis},
                        "ospf": {"type": Ospf},
                        "ospfv3": {"type": Ospfv3},
                        "rip": {"type": Rip},
                        "static": {"type": Static},
                        "user": {"type": User},
                    }
                    attached_host: AttachedHost
                    """Subclass of AvdModel."""
                    bgp: Bgp
                    """Subclass of AvdModel."""
                    connected: Connected
                    """Subclass of AvdModel."""
                    dynamic: Dynamic
                    """Subclass of AvdModel."""
                    isis: Isis
                    """Subclass of AvdModel."""
                    ospf: Ospf
                    """Subclass of AvdModel."""
                    ospfv3: Ospfv3
                    """Subclass of AvdModel."""
                    rip: Rip
                    """Subclass of AvdModel."""
                    static: Static
                    """Subclass of AvdModel."""
                    user: User
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            attached_host: AttachedHost | UndefinedType = Undefined,
                            bgp: Bgp | UndefinedType = Undefined,
                            connected: Connected | UndefinedType = Undefined,
                            dynamic: Dynamic | UndefinedType = Undefined,
                            isis: Isis | UndefinedType = Undefined,
                            ospf: Ospf | UndefinedType = Undefined,
                            ospfv3: Ospfv3 | UndefinedType = Undefined,
                            rip: Rip | UndefinedType = Undefined,
                            static: Static | UndefinedType = Undefined,
                            user: User | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Redistribute.


                            Subclass of AvdModel.

                            Args:
                                attached_host: Subclass of AvdModel.
                                bgp: Subclass of AvdModel.
                                connected: Subclass of AvdModel.
                                dynamic: Subclass of AvdModel.
                                isis: Subclass of AvdModel.
                                ospf: Subclass of AvdModel.
                                ospfv3: Subclass of AvdModel.
                                rip: Subclass of AvdModel.
                                static: Subclass of AvdModel.
                                user: Subclass of AvdModel.

                            """

                class RedistributeRoutesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "source_protocol": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "rcf": {"type": str},
                        "ospf_route_type": {"type": str},
                    }
                    source_protocol: Literal["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                    route_map: str | None
                    include_leaked: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is one of `connected`,
                    `dynamic`, `isis`, `static` and `user`.
                    """
                    ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospf' and
                    'ospfv3'.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            source_protocol: Literal["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                            | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                            | None
                            | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RedistributeRoutesItem.


                            Subclass of AvdModel.

                            Args:
                                source_protocol: source_protocol
                                route_map: route_map
                                include_leaked: include_leaked
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                   Only applicable if `source_protocol` is one of `connected`,
                                   `dynamic`, `isis`, `static` and `user`.
                                ospf_route_type:
                                   Routes learned by the OSPF protocol.
                                   The `ospf_route_type` is valid for source_protocols 'ospf' and
                                   'ospfv3'.

                            """

                class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                    """Subclass of AvdList with `RedistributeRoutesItem` items."""

                RedistributeRoutes._item_type = RedistributeRoutesItem

                _fields: ClassVar[dict] = {
                    "bgp": {"type": Bgp},
                    "neighbors": {"type": Neighbors},
                    "networks": {"type": Networks},
                    "redistribute": {"type": Redistribute},
                    "redistribute_routes": {"type": RedistributeRoutes},
                }
                bgp: Bgp
                """Subclass of AvdModel."""
                neighbors: Neighbors
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
                networks: Networks
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
                redistribute: Redistribute
                """
                Redistribute routes in to BGP.

                Subclass of AvdModel.
                """
                redistribute_routes: RedistributeRoutes
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bgp: Bgp | UndefinedType = Undefined,
                        neighbors: Neighbors | UndefinedType = Undefined,
                        networks: Networks | UndefinedType = Undefined,
                        redistribute: Redistribute | UndefinedType = Undefined,
                        redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressFamilyIpv4.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                            networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                            redistribute:
                               Redistribute routes in to BGP.

                               Subclass of AvdModel.
                            redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.

                        """

            class AddressFamilyIpv6(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    class MissingPolicy(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                        direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                        direction_out_action: Literal["deny", "deny-in-out", "permit"] | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.


                                Subclass of AvdModel.

                                Args:
                                    direction_in_action: direction_in_action
                                    direction_out_action: direction_out_action

                                """

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "install": {"type": bool},
                            "install_ecmp_primary": {"type": bool},
                            "receive": {"type": bool},
                            "send": {"type": str},
                            "send_limit": {"type": int},
                        }
                        install: bool | None
                        """Install BGP backup path."""
                        install_ecmp_primary: bool | None
                        """Allow additional path with ECMP primary path."""
                        receive: bool | None
                        """Enable or disable reception of additional-paths."""
                        send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: int | None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                install: bool | None | UndefinedType = Undefined,
                                install_ecmp_primary: bool | None | UndefinedType = Undefined,
                                receive: bool | None | UndefinedType = Undefined,
                                send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                                send_limit: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    install: Install BGP backup path.
                                    install_ecmp_primary: Allow additional path with ECMP primary path.
                                    receive: Enable or disable reception of additional-paths.
                                    send:
                                       Select an option to send multiple paths for same prefix through bgp updates.
                                       any: Send any eligible
                                       path.
                                       backup: Best path and installed backup path.
                                       ecmp: All paths in best path ECMP group.
                                       limit:
                                       Limit to n eligible paths.
                                       disabled: Disable sending any paths.
                                    send_limit:
                                       Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                       `ecmp`.

                                """

                    _fields: ClassVar[dict] = {
                        "missing_policy": {"type": MissingPolicy},
                        "additional_paths": {"type": AdditionalPaths},
                        "redistribute_internal": {"type": bool},
                    }
                    missing_policy: MissingPolicy
                    """Subclass of AvdModel."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""
                    redistribute_internal: bool | None
                    """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            missing_policy: MissingPolicy | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                            redistribute_internal: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                missing_policy: Subclass of AvdModel.
                                additional_paths: Subclass of AvdModel.
                                redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.

                            """

                class NeighborsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                        receive: bool | None
                        """Enable or disable reception of additional-paths."""
                        send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: int | None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                receive: bool | None | UndefinedType = Undefined,
                                send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                                send_limit: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    receive: Enable or disable reception of additional-paths.
                                    send:
                                       Select an option to send multiple paths for same prefix through bgp updates.
                                       any: Send any eligible
                                       path.
                                       backup: Best path and installed backup path.
                                       ecmp: All paths in best path ECMP group.
                                       limit:
                                       Limit to n eligible paths.
                                       disabled: Disable sending any paths.
                                    send_limit:
                                       Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                       `ecmp`.

                                """

                    _fields: ClassVar[dict] = {
                        "ip_address": {"type": str},
                        "activate": {"type": bool},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "peer_tag_in": {"type": str},
                        "peer_tag_out_discard": {"type": str},
                        "rcf_in": {"type": str},
                        "rcf_out": {"type": str},
                        "prefix_list_in": {"type": str},
                        "prefix_list_out": {"type": str},
                        "additional_paths": {"type": AdditionalPaths},
                    }
                    ip_address: str
                    activate: bool | None
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    peer_tag_in: str | None
                    """Inbound peer tag name."""
                    peer_tag_out_discard: str | None
                    """Outbound discard peer tag name."""
                    rcf_in: str | None
                    """
                    Inbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    rcf_out: str | None
                    """
                    Outbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    prefix_list_in: str | None
                    """Inbound prefix-list name."""
                    prefix_list_out: str | None
                    """Outbound prefix-list name."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ip_address: str | UndefinedType = Undefined,
                            activate: bool | None | UndefinedType = Undefined,
                            route_map_in: str | None | UndefinedType = Undefined,
                            route_map_out: str | None | UndefinedType = Undefined,
                            peer_tag_in: str | None | UndefinedType = Undefined,
                            peer_tag_out_discard: str | None | UndefinedType = Undefined,
                            rcf_in: str | None | UndefinedType = Undefined,
                            rcf_out: str | None | UndefinedType = Undefined,
                            prefix_list_in: str | None | UndefinedType = Undefined,
                            prefix_list_out: str | None | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NeighborsItem.


                            Subclass of AvdModel.

                            Args:
                                ip_address: ip_address
                                activate: activate
                                route_map_in: Inbound route-map name.
                                route_map_out: Outbound route-map name.
                                peer_tag_in: Inbound peer tag name.
                                peer_tag_out_discard: Outbound discard peer tag name.
                                rcf_in:
                                   Inbound RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                rcf_out:
                                   Outbound RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                prefix_list_in: Inbound prefix-list name.
                                prefix_list_out: Outbound prefix-list name.
                                additional_paths: Subclass of AvdModel.

                            """

                class Neighbors(AvdIndexedList[str, NeighborsItem]):
                    """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                class NetworksItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}}
                    prefix: str
                    """IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, prefix: str | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            NetworksItem.


                            Subclass of AvdModel.

                            Args:
                                prefix: IPv6 prefix "A:B:C:D:E:F:G:H/I".
                                route_map: route_map

                            """

                class Networks(AvdIndexedList[str, NetworksItem]):
                    """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                    _primary_key: ClassVar[str] = "prefix"

                Networks._item_type = NetworksItem

                class Redistribute(AvdModel):
                    """Subclass of AvdModel."""

                    class AttachedHost(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                AttachedHost.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class Bgp(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                Bgp.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class Connected(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Connected.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.

                                """

                    class Dhcp(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                Dhcp.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class Dynamic(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Dynamic.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.

                                """

                    class Isis(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "isis_level": {"type": str},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                        """Redistribute IS-IS route level."""
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Isis.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    isis_level: Redistribute IS-IS route level.
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.

                                """

                    class Ospfv3(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool | None
                        """Redistribute OSPFv3 routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPFv3 routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPFv3 routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPFv3 routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospfv3.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPFv3 routes.
                                    match_external:
                                       Redistribute OSPFv3 routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPFv3 routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPFv3 routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class Static(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Static.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.

                                """

                    class User(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}}
                        enabled: bool
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, rcf: str | None | UndefinedType = Undefined) -> None:
                                """
                                User.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.

                                """

                    _fields: ClassVar[dict] = {
                        "attached_host": {"type": AttachedHost},
                        "bgp": {"type": Bgp},
                        "connected": {"type": Connected},
                        "dhcp": {"type": Dhcp},
                        "dynamic": {"type": Dynamic},
                        "isis": {"type": Isis},
                        "ospfv3": {"type": Ospfv3},
                        "static": {"type": Static},
                        "user": {"type": User},
                    }
                    attached_host: AttachedHost
                    """Subclass of AvdModel."""
                    bgp: Bgp
                    """Subclass of AvdModel."""
                    connected: Connected
                    """Subclass of AvdModel."""
                    dhcp: Dhcp
                    """Subclass of AvdModel."""
                    dynamic: Dynamic
                    """Subclass of AvdModel."""
                    isis: Isis
                    """Subclass of AvdModel."""
                    ospfv3: Ospfv3
                    """Subclass of AvdModel."""
                    static: Static
                    """Subclass of AvdModel."""
                    user: User
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            attached_host: AttachedHost | UndefinedType = Undefined,
                            bgp: Bgp | UndefinedType = Undefined,
                            connected: Connected | UndefinedType = Undefined,
                            dhcp: Dhcp | UndefinedType = Undefined,
                            dynamic: Dynamic | UndefinedType = Undefined,
                            isis: Isis | UndefinedType = Undefined,
                            ospfv3: Ospfv3 | UndefinedType = Undefined,
                            static: Static | UndefinedType = Undefined,
                            user: User | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Redistribute.


                            Subclass of AvdModel.

                            Args:
                                attached_host: Subclass of AvdModel.
                                bgp: Subclass of AvdModel.
                                connected: Subclass of AvdModel.
                                dhcp: Subclass of AvdModel.
                                dynamic: Subclass of AvdModel.
                                isis: Subclass of AvdModel.
                                ospfv3: Subclass of AvdModel.
                                static: Subclass of AvdModel.
                                user: Subclass of AvdModel.

                            """

                class RedistributeRoutesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "source_protocol": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "rcf": {"type": str},
                        "ospf_route_type": {"type": str},
                    }
                    source_protocol: Literal["attached-host", "bgp", "connected", "dhcp", "dynamic", "isis", "ospfv3", "static", "user"]
                    route_map: str | None
                    include_leaked: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is one of `connected`,
                    `dynamic`, `isis`, `static` and `user`.
                    """
                    ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospfv3'.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            source_protocol: Literal["attached-host", "bgp", "connected", "dhcp", "dynamic", "isis", "ospfv3", "static", "user"]
                            | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                            | None
                            | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RedistributeRoutesItem.


                            Subclass of AvdModel.

                            Args:
                                source_protocol: source_protocol
                                route_map: route_map
                                include_leaked: include_leaked
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                   Only applicable if `source_protocol` is one of `connected`,
                                   `dynamic`, `isis`, `static` and `user`.
                                ospf_route_type:
                                   Routes learned by the OSPF protocol.
                                   The `ospf_route_type` is valid for source_protocols 'ospfv3'.

                            """

                class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                    """Subclass of AvdList with `RedistributeRoutesItem` items."""

                RedistributeRoutes._item_type = RedistributeRoutesItem

                _fields: ClassVar[dict] = {
                    "bgp": {"type": Bgp},
                    "neighbors": {"type": Neighbors},
                    "networks": {"type": Networks},
                    "redistribute": {"type": Redistribute},
                    "redistribute_routes": {"type": RedistributeRoutes},
                }
                bgp: Bgp
                """Subclass of AvdModel."""
                neighbors: Neighbors
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
                networks: Networks
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
                redistribute: Redistribute
                """
                Redistribute routes in to BGP.

                Subclass of AvdModel.
                """
                redistribute_routes: RedistributeRoutes
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bgp: Bgp | UndefinedType = Undefined,
                        neighbors: Neighbors | UndefinedType = Undefined,
                        networks: Networks | UndefinedType = Undefined,
                        redistribute: Redistribute | UndefinedType = Undefined,
                        redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressFamilyIpv6.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                            networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                            redistribute:
                               Redistribute routes in to BGP.

                               Subclass of AvdModel.
                            redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.

                        """

            class AddressFamilyIpv4Multicast(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    class MissingPolicy(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                        direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                        direction_out_action: Literal["deny", "deny-in-out", "permit"] | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.


                                Subclass of AvdModel.

                                Args:
                                    direction_in_action: direction_in_action
                                    direction_out_action: direction_out_action

                                """

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"receive": {"type": bool}}
                        receive: bool | None

                        if TYPE_CHECKING:

                            def __init__(self, *, receive: bool | None | UndefinedType = Undefined) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    receive: receive

                                """

                    _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}, "additional_paths": {"type": AdditionalPaths}}
                    missing_policy: MissingPolicy
                    """Subclass of AvdModel."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, missing_policy: MissingPolicy | UndefinedType = Undefined, additional_paths: AdditionalPaths | UndefinedType = Undefined
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                missing_policy: Subclass of AvdModel.
                                additional_paths: Subclass of AvdModel.

                            """

                class NeighborsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"receive": {"type": bool}}
                        receive: bool | None

                        if TYPE_CHECKING:

                            def __init__(self, *, receive: bool | None | UndefinedType = Undefined) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    receive: receive

                                """

                    _fields: ClassVar[dict] = {
                        "ip_address": {"type": str},
                        "activate": {"type": bool},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "peer_tag_in": {"type": str},
                        "peer_tag_out_discard": {"type": str},
                        "additional_paths": {"type": AdditionalPaths},
                    }
                    ip_address: str
                    activate: bool | None
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    peer_tag_in: str | None
                    """Inbound peer tag name."""
                    peer_tag_out_discard: str | None
                    """Outbound discard peer tag name."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ip_address: str | UndefinedType = Undefined,
                            activate: bool | None | UndefinedType = Undefined,
                            route_map_in: str | None | UndefinedType = Undefined,
                            route_map_out: str | None | UndefinedType = Undefined,
                            peer_tag_in: str | None | UndefinedType = Undefined,
                            peer_tag_out_discard: str | None | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NeighborsItem.


                            Subclass of AvdModel.

                            Args:
                                ip_address: ip_address
                                activate: activate
                                route_map_in: Inbound route-map name.
                                route_map_out: Outbound route-map name.
                                peer_tag_in: Inbound peer tag name.
                                peer_tag_out_discard: Outbound discard peer tag name.
                                additional_paths: Subclass of AvdModel.

                            """

                class Neighbors(AvdIndexedList[str, NeighborsItem]):
                    """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                class NetworksItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}}
                    prefix: str
                    """IPv6 prefix "A.B.C.D/E"."""
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, prefix: str | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            NetworksItem.


                            Subclass of AvdModel.

                            Args:
                                prefix: IPv6 prefix "A.B.C.D/E".
                                route_map: route_map

                            """

                class Networks(AvdIndexedList[str, NetworksItem]):
                    """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                    _primary_key: ClassVar[str] = "prefix"

                Networks._item_type = NetworksItem

                class Redistribute(AvdModel):
                    """Subclass of AvdModel."""

                    class AttachedHost(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                AttachedHost.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class Connected(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                Connected.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class Isis(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "isis_level": {"type": str},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                        """Redistribute IS-IS route level."""
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Isis.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    isis_level: Redistribute IS-IS route level.
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.

                                """

                    class Ospf(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                            enabled: bool
                            route_map: str | None

                            if TYPE_CHECKING:

                                def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                            enabled: bool
                            route_map: str | None

                            if TYPE_CHECKING:

                                def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "nssa_type": {"type": int}, "route_map": {"type": str}}
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                        }
                        enabled: bool | None
                        """Redistribute OSPF routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPF routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPF routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPF routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospf.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPF routes.
                                    match_external:
                                       Redistribute OSPF routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPF routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPF routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map

                                """

                    class Ospfv3(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool | None
                        """Redistribute OSPFv3 routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPFv3 routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPFv3 routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPFv3 routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospfv3.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPFv3 routes.
                                    match_external:
                                       Redistribute OSPFv3 routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPFv3 routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPFv3 routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """

                    class Static(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                Static.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    _fields: ClassVar[dict] = {
                        "attached_host": {"type": AttachedHost},
                        "connected": {"type": Connected},
                        "isis": {"type": Isis},
                        "ospf": {"type": Ospf},
                        "ospfv3": {"type": Ospfv3},
                        "static": {"type": Static},
                    }
                    attached_host: AttachedHost
                    """Subclass of AvdModel."""
                    connected: Connected
                    """Subclass of AvdModel."""
                    isis: Isis
                    """Subclass of AvdModel."""
                    ospf: Ospf
                    """Subclass of AvdModel."""
                    ospfv3: Ospfv3
                    """Subclass of AvdModel."""
                    static: Static
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            attached_host: AttachedHost | UndefinedType = Undefined,
                            connected: Connected | UndefinedType = Undefined,
                            isis: Isis | UndefinedType = Undefined,
                            ospf: Ospf | UndefinedType = Undefined,
                            ospfv3: Ospfv3 | UndefinedType = Undefined,
                            static: Static | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Redistribute.


                            Subclass of AvdModel.

                            Args:
                                attached_host: Subclass of AvdModel.
                                connected: Subclass of AvdModel.
                                isis: Subclass of AvdModel.
                                ospf: Subclass of AvdModel.
                                ospfv3: Subclass of AvdModel.
                                static: Subclass of AvdModel.

                            """

                class RedistributeRoutesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "source_protocol": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "rcf": {"type": str},
                        "ospf_route_type": {"type": str},
                    }
                    source_protocol: Literal["attached-host", "connected", "isis", "ospf", "ospfv3", "static"]
                    route_map: str | None
                    include_leaked: bool | None
                    """Only applicable if `source_protocol` is `isis`."""
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is `isis`.
                    """
                    ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospf' and
                    'ospfv3'.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            source_protocol: Literal["attached-host", "connected", "isis", "ospf", "ospfv3", "static"] | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                            | None
                            | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RedistributeRoutesItem.


                            Subclass of AvdModel.

                            Args:
                                source_protocol: source_protocol
                                route_map: route_map
                                include_leaked: Only applicable if `source_protocol` is `isis`.
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                   Only applicable if `source_protocol` is `isis`.
                                ospf_route_type:
                                   Routes learned by the OSPF protocol.
                                   The `ospf_route_type` is valid for source_protocols 'ospf' and
                                   'ospfv3'.

                            """

                class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                    """Subclass of AvdList with `RedistributeRoutesItem` items."""

                RedistributeRoutes._item_type = RedistributeRoutesItem

                _fields: ClassVar[dict] = {
                    "bgp": {"type": Bgp},
                    "neighbors": {"type": Neighbors},
                    "networks": {"type": Networks},
                    "redistribute": {"type": Redistribute},
                    "redistribute_routes": {"type": RedistributeRoutes},
                }
                bgp: Bgp
                """Subclass of AvdModel."""
                neighbors: Neighbors
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
                networks: Networks
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
                redistribute: Redistribute
                """
                Redistribute routes in to BGP.

                Subclass of AvdModel.
                """
                redistribute_routes: RedistributeRoutes
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bgp: Bgp | UndefinedType = Undefined,
                        neighbors: Neighbors | UndefinedType = Undefined,
                        networks: Networks | UndefinedType = Undefined,
                        redistribute: Redistribute | UndefinedType = Undefined,
                        redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressFamilyIpv4Multicast.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                            networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                            redistribute:
                               Redistribute routes in to BGP.

                               Subclass of AvdModel.
                            redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.

                        """

            class AddressFamilyIpv6Multicast(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    class MissingPolicy(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                        direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                        direction_out_action: Literal["deny", "deny-in-out", "permit"] | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.


                                Subclass of AvdModel.

                                Args:
                                    direction_in_action: direction_in_action
                                    direction_out_action: direction_out_action

                                """

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"receive": {"type": bool}}
                        receive: bool | None

                        if TYPE_CHECKING:

                            def __init__(self, *, receive: bool | None | UndefinedType = Undefined) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    receive: receive

                                """

                    _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}, "additional_paths": {"type": AdditionalPaths}}
                    missing_policy: MissingPolicy
                    """Subclass of AvdModel."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, missing_policy: MissingPolicy | UndefinedType = Undefined, additional_paths: AdditionalPaths | UndefinedType = Undefined
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                missing_policy: Subclass of AvdModel.
                                additional_paths: Subclass of AvdModel.

                            """

                class NeighborsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"receive": {"type": bool}}
                        receive: bool | None

                        if TYPE_CHECKING:

                            def __init__(self, *, receive: bool | None | UndefinedType = Undefined) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    receive: receive

                                """

                    _fields: ClassVar[dict] = {
                        "ip_address": {"type": str},
                        "activate": {"type": bool},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "peer_tag_in": {"type": str},
                        "peer_tag_out_discard": {"type": str},
                        "additional_paths": {"type": AdditionalPaths},
                    }
                    ip_address: str
                    activate: bool | None
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    peer_tag_in: str | None
                    """Inbound peer tag name."""
                    peer_tag_out_discard: str | None
                    """Outbound discard peer tag name."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ip_address: str | UndefinedType = Undefined,
                            activate: bool | None | UndefinedType = Undefined,
                            route_map_in: str | None | UndefinedType = Undefined,
                            route_map_out: str | None | UndefinedType = Undefined,
                            peer_tag_in: str | None | UndefinedType = Undefined,
                            peer_tag_out_discard: str | None | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NeighborsItem.


                            Subclass of AvdModel.

                            Args:
                                ip_address: ip_address
                                activate: activate
                                route_map_in: Inbound route-map name.
                                route_map_out: Outbound route-map name.
                                peer_tag_in: Inbound peer tag name.
                                peer_tag_out_discard: Outbound discard peer tag name.
                                additional_paths: Subclass of AvdModel.

                            """

                class Neighbors(AvdIndexedList[str, NeighborsItem]):
                    """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                class NetworksItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}}
                    prefix: str
                    """IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                    route_map: str | None

                    if TYPE_CHECKING:

                        def __init__(self, *, prefix: str | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                            """
                            NetworksItem.


                            Subclass of AvdModel.

                            Args:
                                prefix: IPv6 prefix "A:B:C:D:E:F:G:H/I".
                                route_map: route_map

                            """

                class Networks(AvdIndexedList[str, NetworksItem]):
                    """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                    _primary_key: ClassVar[str] = "prefix"

                Networks._item_type = NetworksItem

                class Redistribute(AvdModel):
                    """Subclass of AvdModel."""

                    class Connected(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                Connected.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    class Isis(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "isis_level": {"type": str},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        enabled: bool
                        isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                        """Redistribute IS-IS route level."""
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Isis.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    isis_level: Redistribute IS-IS route level.
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.

                                """

                    class Ospf(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                            enabled: bool
                            route_map: str | None

                            if TYPE_CHECKING:

                                def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                            enabled: bool
                            route_map: str | None

                            if TYPE_CHECKING:

                                def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "nssa_type": {"type": int}, "route_map": {"type": str}}
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                        }
                        enabled: bool | None
                        """Redistribute OSPF routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPF routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPF routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPF routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospf.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPF routes.
                                    match_external:
                                       Redistribute OSPF routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPF routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPF routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map

                                """

                    class Ospfv3(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                            enabled: bool
                            route_map: str | None

                            if TYPE_CHECKING:

                                def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                            enabled: bool
                            route_map: str | None

                            if TYPE_CHECKING:

                                def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "nssa_type": {"type": int}, "route_map": {"type": str}}
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                        }
                        enabled: bool | None
                        """Redistribute OSPFv3 routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPFv3 routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPFv3 routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPFv3 routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospfv3.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPFv3 routes.
                                    match_external:
                                       Redistribute OSPFv3 routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPFv3 routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPFv3 routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map

                                """

                    class Static(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}}
                        enabled: bool
                        route_map: str | None

                        if TYPE_CHECKING:

                            def __init__(self, *, enabled: bool | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                                """
                                Static.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map

                                """

                    _fields: ClassVar[dict] = {
                        "connected": {"type": Connected},
                        "isis": {"type": Isis},
                        "ospf": {"type": Ospf},
                        "ospfv3": {"type": Ospfv3},
                        "static": {"type": Static},
                    }
                    connected: Connected
                    """Subclass of AvdModel."""
                    isis: Isis
                    """Subclass of AvdModel."""
                    ospf: Ospf
                    """Subclass of AvdModel."""
                    ospfv3: Ospfv3
                    """Subclass of AvdModel."""
                    static: Static
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            connected: Connected | UndefinedType = Undefined,
                            isis: Isis | UndefinedType = Undefined,
                            ospf: Ospf | UndefinedType = Undefined,
                            ospfv3: Ospfv3 | UndefinedType = Undefined,
                            static: Static | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Redistribute.


                            Subclass of AvdModel.

                            Args:
                                connected: Subclass of AvdModel.
                                isis: Subclass of AvdModel.
                                ospf: Subclass of AvdModel.
                                ospfv3: Subclass of AvdModel.
                                static: Subclass of AvdModel.

                            """

                class RedistributeRoutesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "source_protocol": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "rcf": {"type": str},
                        "ospf_route_type": {"type": str},
                    }
                    source_protocol: Literal["connected", "isis", "ospf", "ospfv3", "static"]
                    route_map: str | None
                    include_leaked: bool | None
                    """Only applicable if `source_protocol` is `isis`."""
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is `isis`.
                    """
                    ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospf' and
                    'ospfv3'.
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            source_protocol: Literal["connected", "isis", "ospf", "ospfv3", "static"] | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                            | None
                            | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RedistributeRoutesItem.


                            Subclass of AvdModel.

                            Args:
                                source_protocol: source_protocol
                                route_map: route_map
                                include_leaked: Only applicable if `source_protocol` is `isis`.
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                   Only applicable if `source_protocol` is `isis`.
                                ospf_route_type:
                                   Routes learned by the OSPF protocol.
                                   The `ospf_route_type` is valid for source_protocols 'ospf' and
                                   'ospfv3'.

                            """

                class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                    """Subclass of AvdList with `RedistributeRoutesItem` items."""

                RedistributeRoutes._item_type = RedistributeRoutesItem

                _fields: ClassVar[dict] = {
                    "bgp": {"type": Bgp},
                    "neighbors": {"type": Neighbors},
                    "networks": {"type": Networks},
                    "redistribute": {"type": Redistribute},
                    "redistribute_routes": {"type": RedistributeRoutes},
                }
                bgp: Bgp
                """Subclass of AvdModel."""
                neighbors: Neighbors
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
                networks: Networks
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
                redistribute: Redistribute
                """
                Redistribute routes in to BGP.

                Subclass of AvdModel.
                """
                redistribute_routes: RedistributeRoutes
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bgp: Bgp | UndefinedType = Undefined,
                        neighbors: Neighbors | UndefinedType = Undefined,
                        networks: Networks | UndefinedType = Undefined,
                        redistribute: Redistribute | UndefinedType = Undefined,
                        redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressFamilyIpv6Multicast.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                            networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                            redistribute:
                               Redistribute routes in to BGP.

                               Subclass of AvdModel.
                            redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.

                        """

            class AddressFamilyFlowSpecIpv4(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    class MissingPolicy(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                        direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                        direction_out_action: Literal["deny", "deny-in-out", "permit"] | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.


                                Subclass of AvdModel.

                                Args:
                                    direction_in_action: direction_in_action
                                    direction_out_action: direction_out_action

                                """

                    _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}}
                    missing_policy: MissingPolicy
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, missing_policy: MissingPolicy | UndefinedType = Undefined) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                missing_policy: Subclass of AvdModel.

                            """

                class NeighborsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ip_address": {"type": str}, "activate": {"type": bool}}
                    ip_address: str
                    activate: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, ip_address: str | UndefinedType = Undefined, activate: bool | None | UndefinedType = Undefined) -> None:
                            """
                            NeighborsItem.


                            Subclass of AvdModel.

                            Args:
                                ip_address: ip_address
                                activate: activate

                            """

                class Neighbors(AvdIndexedList[str, NeighborsItem]):
                    """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                _fields: ClassVar[dict] = {"bgp": {"type": Bgp}, "neighbors": {"type": Neighbors}}
                bgp: Bgp
                """Subclass of AvdModel."""
                neighbors: Neighbors
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(self, *, bgp: Bgp | UndefinedType = Undefined, neighbors: Neighbors | UndefinedType = Undefined) -> None:
                        """
                        AddressFamilyFlowSpecIpv4.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).

                        """

            class AddressFamilyFlowSpecIpv6(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    class MissingPolicy(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                        direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                        direction_out_action: Literal["deny", "deny-in-out", "permit"] | None

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.


                                Subclass of AvdModel.

                                Args:
                                    direction_in_action: direction_in_action
                                    direction_out_action: direction_out_action

                                """

                    _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}}
                    missing_policy: MissingPolicy
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, missing_policy: MissingPolicy | UndefinedType = Undefined) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                missing_policy: Subclass of AvdModel.

                            """

                class NeighborsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ip_address": {"type": str}, "activate": {"type": bool}}
                    ip_address: str
                    activate: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, ip_address: str | UndefinedType = Undefined, activate: bool | None | UndefinedType = Undefined) -> None:
                            """
                            NeighborsItem.


                            Subclass of AvdModel.

                            Args:
                                ip_address: ip_address
                                activate: activate

                            """

                class Neighbors(AvdIndexedList[str, NeighborsItem]):
                    """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                _fields: ClassVar[dict] = {"bgp": {"type": Bgp}, "neighbors": {"type": Neighbors}}
                bgp: Bgp
                """Subclass of AvdModel."""
                neighbors: Neighbors
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                if TYPE_CHECKING:

                    def __init__(self, *, bgp: Bgp | UndefinedType = Undefined, neighbors: Neighbors | UndefinedType = Undefined) -> None:
                        """
                        AddressFamilyFlowSpecIpv6.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "bgp": {"type": Bgp},
                "rd": {"type": str},
                "evpn_multicast": {"type": bool},
                "evpn_multicast_address_family": {"type": EvpnMulticastAddressFamily},
                "evpn_multicast_gateway_dr_election": {"type": EvpnMulticastGatewayDrElection},
                "default_route_exports": {"type": DefaultRouteExports},
                "route_targets": {"type": RouteTargets},
                "router_id": {"type": str},
                "timers": {"type": str},
                "graceful_restart": {"type": GracefulRestart},
                "networks": {"type": Networks},
                "maximum_paths": {"type": MaximumPaths},
                "updates": {"type": Updates},
                "listen_ranges": {"type": ListenRanges},
                "neighbors": {"type": Neighbors},
                "neighbor_interfaces": {"type": NeighborInterfaces},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": RedistributeRoutes},
                "aggregate_addresses": {"type": AggregateAddresses},
                "address_family_ipv4": {"type": AddressFamilyIpv4},
                "address_family_ipv6": {"type": AddressFamilyIpv6},
                "address_family_ipv4_multicast": {"type": AddressFamilyIpv4Multicast},
                "address_family_ipv6_multicast": {"type": AddressFamilyIpv6Multicast},
                "address_family_flow_spec_ipv4": {"type": AddressFamilyFlowSpecIpv4},
                "address_family_flow_spec_ipv6": {"type": AddressFamilyFlowSpecIpv6},
                "eos_cli": {"type": str},
            }
            name: str
            """VRF name."""
            bgp: Bgp
            """Subclass of AvdModel."""
            rd: str | None
            """Route distinguisher."""
            evpn_multicast: bool | None
            evpn_multicast_address_family: EvpnMulticastAddressFamily
            """
            Enable per-AF EVPN multicast settings.

            Subclass of AvdModel.
            """
            evpn_multicast_gateway_dr_election: EvpnMulticastGatewayDrElection
            """Subclass of AvdModel."""
            default_route_exports: DefaultRouteExports
            """
            Enable default-originate per VRF/address-family.

            Subclass of AvdIndexedList with
            `DefaultRouteExportsItem` items. Primary key is `address_family` (`str`).
            """
            route_targets: RouteTargets
            """Subclass of AvdModel."""
            router_id: str | None
            """in IP address format A.B.C.D."""
            timers: str | None
            """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
            graceful_restart: GracefulRestart
            """Subclass of AvdModel."""
            networks: Networks
            """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
            maximum_paths: MaximumPaths
            """Subclass of AvdModel."""
            updates: Updates
            """Subclass of AvdModel."""
            listen_ranges: ListenRanges
            """
            Improved "listen_ranges" data model to support multiple listen ranges and additional filter
            capabilities.


            Subclass of AvdList with `ListenRangesItem` items.
            """
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            neighbor_interfaces: NeighborInterfaces
            """Subclass of AvdIndexedList with `NeighborInterfacesItem` items. Primary key is `name` (`str`)."""
            redistribute: Redistribute
            """
            Redistribute routes in to BGP.

            Subclass of AvdModel.
            """
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `RedistributeRoutesItem` items."""
            aggregate_addresses: AggregateAddresses
            """Subclass of AvdIndexedList with `AggregateAddressesItem` items. Primary key is `prefix` (`str`)."""
            address_family_ipv4: AddressFamilyIpv4
            """Subclass of AvdModel."""
            address_family_ipv6: AddressFamilyIpv6
            """Subclass of AvdModel."""
            address_family_ipv4_multicast: AddressFamilyIpv4Multicast
            """Subclass of AvdModel."""
            address_family_ipv6_multicast: AddressFamilyIpv6Multicast
            """Subclass of AvdModel."""
            address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4
            """Subclass of AvdModel."""
            address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6
            """Subclass of AvdModel."""
            eos_cli: str | None
            """
            Multiline EOS CLI rendered directly on the Router BGP, VRF definition in the final EOS
            configuration.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    rd: str | None | UndefinedType = Undefined,
                    evpn_multicast: bool | None | UndefinedType = Undefined,
                    evpn_multicast_address_family: EvpnMulticastAddressFamily | UndefinedType = Undefined,
                    evpn_multicast_gateway_dr_election: EvpnMulticastGatewayDrElection | UndefinedType = Undefined,
                    default_route_exports: DefaultRouteExports | UndefinedType = Undefined,
                    route_targets: RouteTargets | UndefinedType = Undefined,
                    router_id: str | None | UndefinedType = Undefined,
                    timers: str | None | UndefinedType = Undefined,
                    graceful_restart: GracefulRestart | UndefinedType = Undefined,
                    networks: Networks | UndefinedType = Undefined,
                    maximum_paths: MaximumPaths | UndefinedType = Undefined,
                    updates: Updates | UndefinedType = Undefined,
                    listen_ranges: ListenRanges | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    neighbor_interfaces: NeighborInterfaces | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    aggregate_addresses: AggregateAddresses | UndefinedType = Undefined,
                    address_family_ipv4: AddressFamilyIpv4 | UndefinedType = Undefined,
                    address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
                    address_family_ipv4_multicast: AddressFamilyIpv4Multicast | UndefinedType = Undefined,
                    address_family_ipv6_multicast: AddressFamilyIpv6Multicast | UndefinedType = Undefined,
                    address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4 | UndefinedType = Undefined,
                    address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6 | UndefinedType = Undefined,
                    eos_cli: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        bgp: Subclass of AvdModel.
                        rd: Route distinguisher.
                        evpn_multicast: evpn_multicast
                        evpn_multicast_address_family:
                           Enable per-AF EVPN multicast settings.

                           Subclass of AvdModel.
                        evpn_multicast_gateway_dr_election: Subclass of AvdModel.
                        default_route_exports:
                           Enable default-originate per VRF/address-family.

                           Subclass of AvdIndexedList with
                           `DefaultRouteExportsItem` items. Primary key is `address_family` (`str`).
                        route_targets: Subclass of AvdModel.
                        router_id: in IP address format A.B.C.D.
                        timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                        graceful_restart: Subclass of AvdModel.
                        networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                        maximum_paths: Subclass of AvdModel.
                        updates: Subclass of AvdModel.
                        listen_ranges:
                           Improved "listen_ranges" data model to support multiple listen ranges and additional filter
                           capabilities.


                           Subclass of AvdList with `ListenRangesItem` items.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        neighbor_interfaces: Subclass of AvdIndexedList with `NeighborInterfacesItem` items. Primary key is `name` (`str`).
                        redistribute:
                           Redistribute routes in to BGP.

                           Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                        aggregate_addresses: Subclass of AvdIndexedList with `AggregateAddressesItem` items. Primary key is `prefix` (`str`).
                        address_family_ipv4: Subclass of AvdModel.
                        address_family_ipv6: Subclass of AvdModel.
                        address_family_ipv4_multicast: Subclass of AvdModel.
                        address_family_ipv6_multicast: Subclass of AvdModel.
                        address_family_flow_spec_ipv4: Subclass of AvdModel.
                        address_family_flow_spec_ipv6: Subclass of AvdModel.
                        eos_cli:
                           Multiline EOS CLI rendered directly on the Router BGP, VRF definition in the final EOS
                           configuration.

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class SessionTrackersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "recovery_delay": {"type": int}}
            name: str
            """Name of session tracker."""
            recovery_delay: int | None
            """Recovery delay in seconds."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, recovery_delay: int | None | UndefinedType = Undefined) -> None:
                    """
                    SessionTrackersItem.


                    Subclass of AvdModel.

                    Args:
                        name: Name of session tracker.
                        recovery_delay: Recovery delay in seconds.

                    """

        class SessionTrackers(AvdIndexedList[str, SessionTrackersItem]):
            """Subclass of AvdIndexedList with `SessionTrackersItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        SessionTrackers._item_type = SessionTrackersItem

        _fields: ClassVar[dict] = {
            "field_as": {"type": str},
            "as_notation": {"type": str},
            "router_id": {"type": str},
            "timers": {"type": Timers},
            "distance": {"type": Distance},
            "graceful_restart": {"type": GracefulRestart},
            "graceful_restart_helper": {"type": GracefulRestartHelper},
            "maximum_paths": {"type": MaximumPaths},
            "updates": {"type": Updates},
            "bgp_cluster_id": {"type": str},
            "bgp_defaults": {"type": BgpDefaults},
            "bgp": {"type": Bgp},
            "listen_ranges": {"type": ListenRanges},
            "neighbor_default": {"type": NeighborDefault},
            "peer_groups": {"type": PeerGroups},
            "neighbors": {"type": Neighbors},
            "neighbor_interfaces": {"type": NeighborInterfaces},
            "aggregate_addresses": {"type": AggregateAddresses},
            "redistribute": {"type": Redistribute},
            "redistribute_routes": {"type": RedistributeRoutes},
            "vlan_aware_bundles": {"type": VlanAwareBundles},
            "vlans": {"type": Vlans},
            "vpws": {"type": Vpws},
            "address_family_evpn": {"type": AddressFamilyEvpn},
            "address_family_rtc": {"type": AddressFamilyRtc},
            "address_family_ipv4": {"type": AddressFamilyIpv4},
            "address_family_ipv4_labeled_unicast": {"type": AddressFamilyIpv4LabeledUnicast},
            "address_family_ipv4_multicast": {"type": AddressFamilyIpv4Multicast},
            "address_family_ipv4_sr_te": {"type": AddressFamilyIpv4SrTe},
            "address_family_ipv6": {"type": AddressFamilyIpv6},
            "address_family_ipv6_multicast": {"type": AddressFamilyIpv6Multicast},
            "address_family_ipv6_sr_te": {"type": AddressFamilyIpv6SrTe},
            "address_family_link_state": {"type": AddressFamilyLinkState},
            "address_family_flow_spec_ipv4": {"type": AddressFamilyFlowSpecIpv4},
            "address_family_flow_spec_ipv6": {"type": AddressFamilyFlowSpecIpv6},
            "address_family_path_selection": {"type": AddressFamilyPathSelection},
            "address_family_vpn_ipv4": {"type": AddressFamilyVpnIpv4},
            "address_family_vpn_ipv6": {"type": AddressFamilyVpnIpv6},
            "vrfs": {"type": Vrfs},
            "session_trackers": {"type": SessionTrackers},
            "eos_cli": {"type": str},
        }
        _field_to_key_map: ClassVar[dict] = {"field_as": "as"}
        _key_to_field_map: ClassVar[dict] = {"as": "field_as"}
        field_as: str | None
        """
        BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
        For asdot notation in
        YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
        number.
        """
        as_notation: Literal["asdot", "asplain"] | None
        """
        BGP AS can be deplayed in the asplain <1-4294967295> or asdot notation "<1-65535>.<0-65535>". This
        flag indicates which mode is preferred - asplain is the default.
        """
        router_id: str | None
        """In IP address format A.B.C.D."""
        timers: Timers
        """Subclass of AvdModel."""
        distance: Distance
        """Subclass of AvdModel."""
        graceful_restart: GracefulRestart
        """Subclass of AvdModel."""
        graceful_restart_helper: GracefulRestartHelper
        """Subclass of AvdModel."""
        maximum_paths: MaximumPaths
        """Subclass of AvdModel."""
        updates: Updates
        """Subclass of AvdModel."""
        bgp_cluster_id: str | None
        """IP Address A.B.C.D."""
        bgp_defaults: BgpDefaults
        """
        BGP command as string.

        Subclass of AvdList with `str` items.
        """
        bgp: Bgp
        """Subclass of AvdModel."""
        listen_ranges: ListenRanges
        """
        Improved "listen_ranges" data model to support multiple listen ranges and additional filter
        capabilities.


        Subclass of AvdList with `ListenRangesItem` items.
        """
        neighbor_default: NeighborDefault
        """Subclass of AvdModel."""
        peer_groups: PeerGroups
        """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
        neighbors: Neighbors
        """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
        neighbor_interfaces: NeighborInterfaces
        """Subclass of AvdIndexedList with `NeighborInterfacesItem` items. Primary key is `name` (`str`)."""
        aggregate_addresses: AggregateAddresses
        """Subclass of AvdIndexedList with `AggregateAddressesItem` items. Primary key is `prefix` (`str`)."""
        redistribute: Redistribute
        """
        Redistribute routes in to BGP.

        Subclass of AvdModel.
        """
        redistribute_routes: RedistributeRoutes
        """Subclass of AvdList with `RedistributeRoutesItem` items."""
        vlan_aware_bundles: VlanAwareBundles
        """Subclass of AvdIndexedList with `VlanAwareBundlesItem` items. Primary key is `name` (`str`)."""
        vlans: Vlans
        """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""
        vpws: Vpws
        """Subclass of AvdIndexedList with `VpwsItem` items. Primary key is `name` (`str`)."""
        address_family_evpn: AddressFamilyEvpn
        """Subclass of AvdModel."""
        address_family_rtc: AddressFamilyRtc
        """Subclass of AvdModel."""
        address_family_ipv4: AddressFamilyIpv4
        """Subclass of AvdModel."""
        address_family_ipv4_labeled_unicast: AddressFamilyIpv4LabeledUnicast
        """Subclass of AvdModel."""
        address_family_ipv4_multicast: AddressFamilyIpv4Multicast
        """Subclass of AvdModel."""
        address_family_ipv4_sr_te: AddressFamilyIpv4SrTe
        """Subclass of AvdModel."""
        address_family_ipv6: AddressFamilyIpv6
        """Subclass of AvdModel."""
        address_family_ipv6_multicast: AddressFamilyIpv6Multicast
        """Subclass of AvdModel."""
        address_family_ipv6_sr_te: AddressFamilyIpv6SrTe
        """Subclass of AvdModel."""
        address_family_link_state: AddressFamilyLinkState
        """Subclass of AvdModel."""
        address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4
        """Subclass of AvdModel."""
        address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6
        """Subclass of AvdModel."""
        address_family_path_selection: AddressFamilyPathSelection
        """Subclass of AvdModel."""
        address_family_vpn_ipv4: AddressFamilyVpnIpv4
        """Subclass of AvdModel."""
        address_family_vpn_ipv6: AddressFamilyVpnIpv6
        """Subclass of AvdModel."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        session_trackers: SessionTrackers
        """Subclass of AvdIndexedList with `SessionTrackersItem` items. Primary key is `name` (`str`)."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the Router BGP in the final EOS configuration."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                field_as: str | None | UndefinedType = Undefined,
                as_notation: Literal["asdot", "asplain"] | None | UndefinedType = Undefined,
                router_id: str | None | UndefinedType = Undefined,
                timers: Timers | UndefinedType = Undefined,
                distance: Distance | UndefinedType = Undefined,
                graceful_restart: GracefulRestart | UndefinedType = Undefined,
                graceful_restart_helper: GracefulRestartHelper | UndefinedType = Undefined,
                maximum_paths: MaximumPaths | UndefinedType = Undefined,
                updates: Updates | UndefinedType = Undefined,
                bgp_cluster_id: str | None | UndefinedType = Undefined,
                bgp_defaults: BgpDefaults | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                listen_ranges: ListenRanges | UndefinedType = Undefined,
                neighbor_default: NeighborDefault | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                neighbor_interfaces: NeighborInterfaces | UndefinedType = Undefined,
                aggregate_addresses: AggregateAddresses | UndefinedType = Undefined,
                redistribute: Redistribute | UndefinedType = Undefined,
                redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                vlan_aware_bundles: VlanAwareBundles | UndefinedType = Undefined,
                vlans: Vlans | UndefinedType = Undefined,
                vpws: Vpws | UndefinedType = Undefined,
                address_family_evpn: AddressFamilyEvpn | UndefinedType = Undefined,
                address_family_rtc: AddressFamilyRtc | UndefinedType = Undefined,
                address_family_ipv4: AddressFamilyIpv4 | UndefinedType = Undefined,
                address_family_ipv4_labeled_unicast: AddressFamilyIpv4LabeledUnicast | UndefinedType = Undefined,
                address_family_ipv4_multicast: AddressFamilyIpv4Multicast | UndefinedType = Undefined,
                address_family_ipv4_sr_te: AddressFamilyIpv4SrTe | UndefinedType = Undefined,
                address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
                address_family_ipv6_multicast: AddressFamilyIpv6Multicast | UndefinedType = Undefined,
                address_family_ipv6_sr_te: AddressFamilyIpv6SrTe | UndefinedType = Undefined,
                address_family_link_state: AddressFamilyLinkState | UndefinedType = Undefined,
                address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4 | UndefinedType = Undefined,
                address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6 | UndefinedType = Undefined,
                address_family_path_selection: AddressFamilyPathSelection | UndefinedType = Undefined,
                address_family_vpn_ipv4: AddressFamilyVpnIpv4 | UndefinedType = Undefined,
                address_family_vpn_ipv6: AddressFamilyVpnIpv6 | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                session_trackers: SessionTrackers | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                RouterBgp.


                Subclass of AvdModel.

                Args:
                    field_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    as_notation:
                       BGP AS can be deplayed in the asplain <1-4294967295> or asdot notation "<1-65535>.<0-65535>". This
                       flag indicates which mode is preferred - asplain is the default.
                    router_id: In IP address format A.B.C.D.
                    timers: Subclass of AvdModel.
                    distance: Subclass of AvdModel.
                    graceful_restart: Subclass of AvdModel.
                    graceful_restart_helper: Subclass of AvdModel.
                    maximum_paths: Subclass of AvdModel.
                    updates: Subclass of AvdModel.
                    bgp_cluster_id: IP Address A.B.C.D.
                    bgp_defaults:
                       BGP command as string.

                       Subclass of AvdList with `str` items.
                    bgp: Subclass of AvdModel.
                    listen_ranges:
                       Improved "listen_ranges" data model to support multiple listen ranges and additional filter
                       capabilities.


                       Subclass of AvdList with `ListenRangesItem` items.
                    neighbor_default: Subclass of AvdModel.
                    peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                    neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                    neighbor_interfaces: Subclass of AvdIndexedList with `NeighborInterfacesItem` items. Primary key is `name` (`str`).
                    aggregate_addresses: Subclass of AvdIndexedList with `AggregateAddressesItem` items. Primary key is `prefix` (`str`).
                    redistribute:
                       Redistribute routes in to BGP.

                       Subclass of AvdModel.
                    redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                    vlan_aware_bundles: Subclass of AvdIndexedList with `VlanAwareBundlesItem` items. Primary key is `name` (`str`).
                    vlans: Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`).
                    vpws: Subclass of AvdIndexedList with `VpwsItem` items. Primary key is `name` (`str`).
                    address_family_evpn: Subclass of AvdModel.
                    address_family_rtc: Subclass of AvdModel.
                    address_family_ipv4: Subclass of AvdModel.
                    address_family_ipv4_labeled_unicast: Subclass of AvdModel.
                    address_family_ipv4_multicast: Subclass of AvdModel.
                    address_family_ipv4_sr_te: Subclass of AvdModel.
                    address_family_ipv6: Subclass of AvdModel.
                    address_family_ipv6_multicast: Subclass of AvdModel.
                    address_family_ipv6_sr_te: Subclass of AvdModel.
                    address_family_link_state: Subclass of AvdModel.
                    address_family_flow_spec_ipv4: Subclass of AvdModel.
                    address_family_flow_spec_ipv6: Subclass of AvdModel.
                    address_family_path_selection: Subclass of AvdModel.
                    address_family_vpn_ipv4: Subclass of AvdModel.
                    address_family_vpn_ipv6: Subclass of AvdModel.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    session_trackers: Subclass of AvdIndexedList with `SessionTrackersItem` items. Primary key is `name` (`str`).
                    eos_cli: Multiline EOS CLI rendered directly on the Router BGP in the final EOS configuration.

                """

    class RouterGeneral(AvdModel):
        """Subclass of AvdModel."""

        class RouterId(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4": {"type": str}, "ipv6": {"type": str}}
            ipv4: str | None
            """IPv4 Address."""
            ipv6: str | None
            """IPv6 Address."""

            if TYPE_CHECKING:

                def __init__(self, *, ipv4: str | None | UndefinedType = Undefined, ipv6: str | None | UndefinedType = Undefined) -> None:
                    """
                    RouterId.


                    Subclass of AvdModel.

                    Args:
                        ipv4: IPv4 Address.
                        ipv6: IPv6 Address.

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class LeakRoutesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"source_vrf": {"type": str}, "subscribe_policy": {"type": str}, "subscribe_rcf": {"type": str}}
                source_vrf: str | None
                subscribe_policy: str | None
                """Route-Map Policy."""
                subscribe_rcf: str | None
                """
                RCF Policy name with parenthesis.
                Example: MyFunction(myarg).
                Mutually exclusive with
                `subscribe_policy`, if both are defined `subscribe_policy` takes precedence.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_vrf: str | None | UndefinedType = Undefined,
                        subscribe_policy: str | None | UndefinedType = Undefined,
                        subscribe_rcf: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LeakRoutesItem.


                        Subclass of AvdModel.

                        Args:
                            source_vrf: source_vrf
                            subscribe_policy: Route-Map Policy.
                            subscribe_rcf:
                               RCF Policy name with parenthesis.
                               Example: MyFunction(myarg).
                               Mutually exclusive with
                               `subscribe_policy`, if both are defined `subscribe_policy` takes precedence.

                        """

            class LeakRoutes(AvdList[LeakRoutesItem]):
                """Subclass of AvdList with `LeakRoutesItem` items."""

            LeakRoutes._item_type = LeakRoutesItem

            class Routes(AvdModel):
                """Subclass of AvdModel."""

                class DynamicPrefixListsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}}
                    name: str | None
                    """Dynamic Prefix List Name."""

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | None | UndefinedType = Undefined) -> None:
                            """
                            DynamicPrefixListsItem.


                            Subclass of AvdModel.

                            Args:
                                name: Dynamic Prefix List Name.

                            """

                class DynamicPrefixLists(AvdList[DynamicPrefixListsItem]):
                    """Subclass of AvdList with `DynamicPrefixListsItem` items."""

                DynamicPrefixLists._item_type = DynamicPrefixListsItem

                _fields: ClassVar[dict] = {"dynamic_prefix_lists": {"type": DynamicPrefixLists}}
                dynamic_prefix_lists: DynamicPrefixLists
                """Subclass of AvdList with `DynamicPrefixListsItem` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, dynamic_prefix_lists: DynamicPrefixLists | UndefinedType = Undefined) -> None:
                        """
                        Routes.


                        Subclass of AvdModel.

                        Args:
                            dynamic_prefix_lists: Subclass of AvdList with `DynamicPrefixListsItem` items.

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "leak_routes": {"type": LeakRoutes},
                "routes": {"type": Routes},
                "software_forwarding_hardware_offload_mtu": {"type": int},
            }
            name: str
            """Destination-VRF."""
            leak_routes: LeakRoutes
            """Subclass of AvdList with `LeakRoutesItem` items."""
            routes: Routes
            """Subclass of AvdModel."""
            software_forwarding_hardware_offload_mtu: int | None
            """
            MTU value for software-forwarded packets within a specific VRF that use hardware offload.
            This
            setting overrides the global config for a specific vrf.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    leak_routes: LeakRoutes | UndefinedType = Undefined,
                    routes: Routes | UndefinedType = Undefined,
                    software_forwarding_hardware_offload_mtu: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Destination-VRF.
                        leak_routes: Subclass of AvdList with `LeakRoutesItem` items.
                        routes: Subclass of AvdModel.
                        software_forwarding_hardware_offload_mtu:
                           MTU value for software-forwarded packets within a specific VRF that use hardware offload.
                           This
                           setting overrides the global config for a specific vrf.

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class ControlFunctions(AvdModel):
            """Subclass of AvdModel."""

            class CodeUnitsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "content": {"type": str}}
                name: str
                """Name of the code unit."""
                content: str
                """
                Content of route control function.
                e.g.
                function ACCEPT_ALL() {
                  return true;
                  }
                EOF
                """

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, content: str | UndefinedType = Undefined) -> None:
                        """
                        CodeUnitsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Name of the code unit.
                            content:
                               Content of route control function.
                               e.g.
                               function ACCEPT_ALL() {
                                 return true;
                                 }
                               EOF

                        """

            class CodeUnits(AvdIndexedList[str, CodeUnitsItem]):
                """Subclass of AvdIndexedList with `CodeUnitsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            CodeUnits._item_type = CodeUnitsItem

            _fields: ClassVar[dict] = {"code_units": {"type": CodeUnits}}
            code_units: CodeUnits
            """Subclass of AvdIndexedList with `CodeUnitsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(self, *, code_units: CodeUnits | UndefinedType = Undefined) -> None:
                    """
                    ControlFunctions.


                    Subclass of AvdModel.

                    Args:
                        code_units: Subclass of AvdIndexedList with `CodeUnitsItem` items. Primary key is `name` (`str`).

                    """

        _fields: ClassVar[dict] = {
            "router_id": {"type": RouterId},
            "nexthop_fast_failover": {"type": bool, "default": False},
            "software_forwarding_hardware_offload_mtu": {"type": int},
            "vrfs": {"type": Vrfs},
            "control_functions": {"type": ControlFunctions},
        }
        router_id: RouterId
        """Subclass of AvdModel."""
        nexthop_fast_failover: bool
        """Default value: `False`"""
        software_forwarding_hardware_offload_mtu: int | None
        """MTU value for software-forwarded packets across all vrfs that use hardware offload."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        control_functions: ControlFunctions
        """
        Routing control functions (RCF) used to filter and update routes from a peer or during
        redistributions.
        Warning:
        This configuration cannot be pushed with `eos_config_deploy_eapi`, because
        of limitations in `arista.eos` and `ansible.netcommon` plugins.
        The configuration can be pushed via
        CloudVision with `eos_config_deploy_cvp` or `cv_deploy`.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                router_id: RouterId | UndefinedType = Undefined,
                nexthop_fast_failover: bool | UndefinedType = Undefined,
                software_forwarding_hardware_offload_mtu: int | None | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                control_functions: ControlFunctions | UndefinedType = Undefined,
            ) -> None:
                """
                RouterGeneral.


                Subclass of AvdModel.

                Args:
                    router_id: Subclass of AvdModel.
                    nexthop_fast_failover: nexthop_fast_failover
                    software_forwarding_hardware_offload_mtu: MTU value for software-forwarded packets across all vrfs that use hardware offload.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    control_functions:
                       Routing control functions (RCF) used to filter and update routes from a peer or during
                       redistributions.

                Warning:
                       This configuration cannot be pushed with `eos_config_deploy_eapi`, because
                       of limitations in `arista.eos` and `ansible.netcommon` plugins.
                       The configuration can be pushed via
                       CloudVision with `eos_config_deploy_cvp` or `cv_deploy`.

                       Subclass of AvdModel.

                """

    class RouterIgmp(AvdModel):
        """Subclass of AvdModel."""

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "host_proxy_match_mroute": {"type": str}}
            name: str
            """VRF name."""
            host_proxy_match_mroute: Literal["all", "iif"] | None
            """
            Specify conditions for sending IGMP joins for host-proxy.
            'iif' will enable igmp host-proxy to work
            in iif aware.
            'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
            """

            if TYPE_CHECKING:

                def __init__(
                    self, *, name: str | UndefinedType = Undefined, host_proxy_match_mroute: Literal["all", "iif"] | None | UndefinedType = Undefined
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        host_proxy_match_mroute:
                           Specify conditions for sending IGMP joins for host-proxy.
                           'iif' will enable igmp host-proxy to work
                           in iif aware.
                           'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {"host_proxy_match_mroute": {"type": str}, "ssm_aware": {"type": bool}, "vrfs": {"type": Vrfs}}
        host_proxy_match_mroute: Literal["all", "iif"] | None
        """
        Specify conditions for sending IGMP joins for host-proxy.
        'iif' will enable igmp host-proxy to work
        in iif aware.
        'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
        """
        ssm_aware: bool | None
        vrfs: Vrfs
        """
        Configure IGMP in a VRF.
        VRF 'default' is not supported in EOS, please see keys directly under
        'router_igmp'.

        Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                host_proxy_match_mroute: Literal["all", "iif"] | None | UndefinedType = Undefined,
                ssm_aware: bool | None | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
            ) -> None:
                """
                RouterIgmp.


                Subclass of AvdModel.

                Args:
                    host_proxy_match_mroute:
                       Specify conditions for sending IGMP joins for host-proxy.
                       'iif' will enable igmp host-proxy to work
                       in iif aware.
                       'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
                    ssm_aware: ssm_aware
                    vrfs:
                       Configure IGMP in a VRF.
                       VRF 'default' is not supported in EOS, please see keys directly under
                       'router_igmp'.

                       Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).

                """

    class RouterInternetExit(AvdModel):
        """Subclass of AvdModel."""

        class PoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class ExitGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}}
                name: str

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined) -> None:
                        """
                        ExitGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name

                        """

            class ExitGroups(AvdIndexedList[str, ExitGroupsItem]):
                """Subclass of AvdIndexedList with `ExitGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            ExitGroups._item_type = ExitGroupsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "exit_groups": {"type": ExitGroups}}
            name: str
            exit_groups: ExitGroups
            """
            The exit groups that are configured under a policy are strictly ordered, meaning an exit group
            appearing first has more priority than the exit group that follows it.

            Subclass of AvdIndexedList
            with `ExitGroupsItem` items. Primary key is `name` (`str`).
            """

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, exit_groups: ExitGroups | UndefinedType = Undefined) -> None:
                    """
                    PoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        exit_groups:
                           The exit groups that are configured under a policy are strictly ordered, meaning an exit group
                           appearing first has more priority than the exit group that follows it.

                           Subclass of AvdIndexedList
                           with `ExitGroupsItem` items. Primary key is `name` (`str`).

                    """

        class Policies(AvdIndexedList[str, PoliciesItem]):
            """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        class ExitGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            class LocalConnectionsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}}
                name: str

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined) -> None:
                        """
                        LocalConnectionsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name

                        """

            class LocalConnections(AvdIndexedList[str, LocalConnectionsItem]):
                """Subclass of AvdIndexedList with `LocalConnectionsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            LocalConnections._item_type = LocalConnectionsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "fib_default": {"type": bool}, "local_connections": {"type": LocalConnections}}
            name: str
            fib_default: bool | None
            """
            Fib default exit indicates that the flows that select this exit will follow the default route
            available in the VRF of the flow.
            """
            local_connections: LocalConnections
            """
            Local connections refer to connections configured under the `router_service_insertion`.
            The service-
            insertion module reports the health of the connection and the exit will qualify for use only when it
            is healthy.

            Subclass of AvdIndexedList with `LocalConnectionsItem` items. Primary key is `name`
            (`str`).
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    fib_default: bool | None | UndefinedType = Undefined,
                    local_connections: LocalConnections | UndefinedType = Undefined,
                ) -> None:
                    """
                    ExitGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        fib_default:
                           Fib default exit indicates that the flows that select this exit will follow the default route
                           available in the VRF of the flow.
                        local_connections:
                           Local connections refer to connections configured under the `router_service_insertion`.
                           The service-
                           insertion module reports the health of the connection and the exit will qualify for use only when it
                           is healthy.

                           Subclass of AvdIndexedList with `LocalConnectionsItem` items. Primary key is `name`
                           (`str`).

                    """

        class ExitGroups(AvdIndexedList[str, ExitGroupsItem]):
            """Subclass of AvdIndexedList with `ExitGroupsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        ExitGroups._item_type = ExitGroupsItem

        _fields: ClassVar[dict] = {"policies": {"type": Policies}, "exit_groups": {"type": ExitGroups}}
        policies: Policies
        """
        Internet-exit policy represent a policy which can be attached to a virtual topology profile.
        Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).
        """
        exit_groups: ExitGroups
        """
        Exit groups represent a group of exit options (connections).
        Traffic flows are load balanced in a
        round robin fashion across all the members (exits) of the exit-group.

        Subclass of AvdIndexedList
        with `ExitGroupsItem` items. Primary key is `name` (`str`).
        """

        if TYPE_CHECKING:

            def __init__(self, *, policies: Policies | UndefinedType = Undefined, exit_groups: ExitGroups | UndefinedType = Undefined) -> None:
                """
                RouterInternetExit.


                Subclass of AvdModel.

                Args:
                    policies:
                       Internet-exit policy represent a policy which can be attached to a virtual topology profile.
                       Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).
                    exit_groups:
                       Exit groups represent a group of exit options (connections).
                       Traffic flows are load balanced in a
                       round robin fashion across all the members (exits) of the exit-group.

                       Subclass of AvdIndexedList
                       with `ExitGroupsItem` items. Primary key is `name` (`str`).

                """

    class RouterIsis(AvdModel):
        """Subclass of AvdModel."""

        class Timers(AvdModel):
            """Subclass of AvdModel."""

            class LocalConvergence(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"protected_prefixes": {"type": bool}, "delay": {"type": int, "default": 10000}}
                protected_prefixes: bool | None
                delay: int
                """
                Delay in milliseconds.

                Default value: `10000`
                """

                if TYPE_CHECKING:

                    def __init__(self, *, protected_prefixes: bool | None | UndefinedType = Undefined, delay: int | UndefinedType = Undefined) -> None:
                        """
                        LocalConvergence.


                        Subclass of AvdModel.

                        Args:
                            protected_prefixes: protected_prefixes
                            delay: Delay in milliseconds.

                        """

            class Lsp(AvdModel):
                """Subclass of AvdModel."""

                class Generation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"interval": {"type": int}, "initial_wait_time": {"type": int}, "wait_time": {"type": int}}
                    interval: int
                    """Maximum interval (in seconds) between generating two LSPs."""
                    initial_wait_time: int | None
                    """Initial wait time (in milliseconds) before generating LSPs."""
                    wait_time: int | None
                    """Wait time (in milliseconds) between generating the first and second LSPs."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            interval: int | UndefinedType = Undefined,
                            initial_wait_time: int | None | UndefinedType = Undefined,
                            wait_time: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Generation.


                            Subclass of AvdModel.

                            Args:
                                interval: Maximum interval (in seconds) between generating two LSPs.
                                initial_wait_time: Initial wait time (in milliseconds) before generating LSPs.
                                wait_time: Wait time (in milliseconds) between generating the first and second LSPs.

                            """

                _fields: ClassVar[dict] = {
                    "generation": {"type": Generation},
                    "out_delay": {"type": int},
                    "refresh_interval": {"type": int},
                    "min_remaining_lifetime": {"type": int},
                }
                generation: Generation
                """Subclass of AvdModel."""
                out_delay: int | None
                """Transmit delay (in milliseconds) for link state packets."""
                refresh_interval: int | None
                """Interval (in seconds) between two LSP refreshes."""
                min_remaining_lifetime: int | None
                """Minimum remaining lifetime for LSPs (in seconds)."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        generation: Generation | UndefinedType = Undefined,
                        out_delay: int | None | UndefinedType = Undefined,
                        refresh_interval: int | None | UndefinedType = Undefined,
                        min_remaining_lifetime: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Lsp.


                        Subclass of AvdModel.

                        Args:
                            generation: Subclass of AvdModel.
                            out_delay: Transmit delay (in milliseconds) for link state packets.
                            refresh_interval: Interval (in seconds) between two LSP refreshes.
                            min_remaining_lifetime: Minimum remaining lifetime for LSPs (in seconds).

                        """

            class Csnp(AvdModel):
                """Subclass of AvdModel."""

                class Generation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"interval": {"type": int}, "p2p_disabled": {"type": bool}}
                    interval: int | None
                    """Transmit frequency (in seconds) for CSN packets."""
                    p2p_disabled: bool | None
                    """Disable periodic CSN packets for P2P links."""

                    if TYPE_CHECKING:

                        def __init__(self, *, interval: int | None | UndefinedType = Undefined, p2p_disabled: bool | None | UndefinedType = Undefined) -> None:
                            """
                            Generation.


                            Subclass of AvdModel.

                            Args:
                                interval: Transmit frequency (in seconds) for CSN packets.
                                p2p_disabled: Disable periodic CSN packets for P2P links.

                            """

                _fields: ClassVar[dict] = {"generation": {"type": Generation}}
                generation: Generation
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, generation: Generation | UndefinedType = Undefined) -> None:
                        """
                        Csnp.


                        Subclass of AvdModel.

                        Args:
                            generation: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"local_convergence": {"type": LocalConvergence}, "lsp": {"type": Lsp}, "csnp": {"type": Csnp}}
            local_convergence: LocalConvergence
            """Subclass of AvdModel."""
            lsp: Lsp
            """
            Link State Packet timers.

            Subclass of AvdModel.
            """
            csnp: Csnp
            """
            CSN Packet timers.

            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    local_convergence: LocalConvergence | UndefinedType = Undefined,
                    lsp: Lsp | UndefinedType = Undefined,
                    csnp: Csnp | UndefinedType = Undefined,
                ) -> None:
                    """
                    Timers.


                    Subclass of AvdModel.

                    Args:
                        local_convergence: Subclass of AvdModel.
                        lsp:
                           Link State Packet timers.

                           Subclass of AvdModel.
                        csnp:
                           CSN Packet timers.

                           Subclass of AvdModel.

                    """

        class SetOverloadBit(AvdModel):
            """Subclass of AvdModel."""

            class OnStartup(AvdModel):
                """Subclass of AvdModel."""

                class WaitForBgp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "timeout": {"type": int}}
                    enabled: bool | None
                    timeout: int | None
                    """Number of seconds."""

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, timeout: int | None | UndefinedType = Undefined) -> None:
                            """
                            WaitForBgp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                timeout: Number of seconds.

                            """

                _fields: ClassVar[dict] = {"delay": {"type": int}, "wait_for_bgp": {"type": WaitForBgp}}
                delay: int | None
                """Number of seconds."""
                wait_for_bgp: WaitForBgp
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, delay: int | None | UndefinedType = Undefined, wait_for_bgp: WaitForBgp | UndefinedType = Undefined) -> None:
                        """
                        OnStartup.


                        Subclass of AvdModel.

                        Args:
                            delay: Number of seconds.
                            wait_for_bgp: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "on_startup": {"type": OnStartup}}
            enabled: bool | None
            on_startup: OnStartup
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, on_startup: OnStartup | UndefinedType = Undefined) -> None:
                    """
                    SetOverloadBit.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        on_startup: Subclass of AvdModel.

                    """

        class Authentication(AvdModel):
            """Subclass of AvdModel."""

            class Both(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}}
                    key_id: int

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Both.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.

                        """

            class Level1(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}}
                    key_id: int

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level1.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.

                        """

            class Level2(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}}
                    key_id: int

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level2.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.

                        """

            _fields: ClassVar[dict] = {"both": {"type": Both}, "level_1": {"type": Level1}, "level_2": {"type": Level2}}
            both: Both
            """
            Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
            'level_2' settings.

            Subclass of AvdModel.
            """
            level_1: Level1
            """
            Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """
            level_2: Level2
            """
            Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self, *, both: Both | UndefinedType = Undefined, level_1: Level1 | UndefinedType = Undefined, level_2: Level2 | UndefinedType = Undefined
                ) -> None:
                    """
                    Authentication.


                    Subclass of AvdModel.

                    Args:
                        both:
                           Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
                           'level_2' settings.

                           Subclass of AvdModel.
                        level_1:
                           Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.
                        level_2:
                           Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.

                    """

        class Advertise(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"passive_only": {"type": bool}}
            passive_only: bool | None

            if TYPE_CHECKING:

                def __init__(self, *, passive_only: bool | None | UndefinedType = Undefined) -> None:
                    """
                    Advertise.


                    Subclass of AvdModel.

                    Args:
                        passive_only: passive_only

                    """

        class RedistributeRoutesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "source_protocol": {"type": str},
                "route_map": {"type": str},
                "include_leaked": {"type": bool},
                "ospf_route_type": {"type": str},
            }
            source_protocol: Literal["bgp", "connected", "isis", "ospf", "ospfv3", "static"]
            route_map: str | None
            """Route-map name."""
            include_leaked: bool | None
            ospf_route_type: Literal["external", "internal", "nssa-external"] | None
            """ospf_route_type is required with source_protocols 'ospf' and 'ospfv3'."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    source_protocol: Literal["bgp", "connected", "isis", "ospf", "ospfv3", "static"] | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                    ospf_route_type: Literal["external", "internal", "nssa-external"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RedistributeRoutesItem.


                    Subclass of AvdModel.

                    Args:
                        source_protocol: source_protocol
                        route_map: Route-map name.
                        include_leaked: include_leaked
                        ospf_route_type: ospf_route_type is required with source_protocols 'ospf' and 'ospfv3'.

                    """

        class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
            """Subclass of AvdList with `RedistributeRoutesItem` items."""

        RedistributeRoutes._item_type = RedistributeRoutesItem

        class AddressFamilyIpv4(AvdModel):
            """Subclass of AvdModel."""

            class FastRerouteTiLfa(AvdModel):
                """Subclass of AvdModel."""

                class Srlg(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enable": {"type": bool}, "strict": {"type": bool}}
                    enable: bool | None
                    strict: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enable: bool | None | UndefinedType = Undefined, strict: bool | None | UndefinedType = Undefined) -> None:
                            """
                            Srlg.


                            Subclass of AvdModel.

                            Args:
                                enable: enable
                                strict: strict

                            """

                _fields: ClassVar[dict] = {"mode": {"type": str}, "level": {"type": str}, "srlg": {"type": Srlg}}
                mode: Literal["link-protection", "node-protection"] | None
                level: Literal["level-1", "level-2"] | None
                srlg: Srlg
                """
                Shared Risk Link Group.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mode: Literal["link-protection", "node-protection"] | None | UndefinedType = Undefined,
                        level: Literal["level-1", "level-2"] | None | UndefinedType = Undefined,
                        srlg: Srlg | UndefinedType = Undefined,
                    ) -> None:
                        """
                        FastRerouteTiLfa.


                        Subclass of AvdModel.

                        Args:
                            mode: mode
                            level: level
                            srlg:
                               Shared Risk Link Group.

                               Subclass of AvdModel.

                        """

            class TunnelSourceLabeledUnicast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}}
                enabled: bool | None
                rcf: str | None
                """Route Control Function."""

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, rcf: str | None | UndefinedType = Undefined) -> None:
                        """
                        TunnelSourceLabeledUnicast.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            rcf: Route Control Function.

                        """

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "maximum_paths": {"type": int},
                "bfd_all_interfaces": {"type": bool},
                "fast_reroute_ti_lfa": {"type": FastRerouteTiLfa},
                "tunnel_source_labeled_unicast": {"type": TunnelSourceLabeledUnicast},
            }
            enabled: bool
            maximum_paths: int | None
            bfd_all_interfaces: bool | None
            """Enable BFD on all interfaces."""
            fast_reroute_ti_lfa: FastRerouteTiLfa
            """Subclass of AvdModel."""
            tunnel_source_labeled_unicast: TunnelSourceLabeledUnicast
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    maximum_paths: int | None | UndefinedType = Undefined,
                    bfd_all_interfaces: bool | None | UndefinedType = Undefined,
                    fast_reroute_ti_lfa: FastRerouteTiLfa | UndefinedType = Undefined,
                    tunnel_source_labeled_unicast: TunnelSourceLabeledUnicast | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv4.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        maximum_paths: maximum_paths
                        bfd_all_interfaces: Enable BFD on all interfaces.
                        fast_reroute_ti_lfa: Subclass of AvdModel.
                        tunnel_source_labeled_unicast: Subclass of AvdModel.

                    """

        class AddressFamilyIpv6(AvdModel):
            """Subclass of AvdModel."""

            class FastRerouteTiLfa(AvdModel):
                """Subclass of AvdModel."""

                class Srlg(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enable": {"type": bool}, "strict": {"type": bool}}
                    enable: bool | None
                    strict: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enable: bool | None | UndefinedType = Undefined, strict: bool | None | UndefinedType = Undefined) -> None:
                            """
                            Srlg.


                            Subclass of AvdModel.

                            Args:
                                enable: enable
                                strict: strict

                            """

                _fields: ClassVar[dict] = {"mode": {"type": str}, "level": {"type": str}, "srlg": {"type": Srlg}}
                mode: Literal["link-protection", "node-protection"] | None
                level: Literal["level-1", "level-2"] | None
                """Optional, default is to protect all levels."""
                srlg: Srlg
                """
                Shared Risk Link Group.

                Subclass of AvdModel.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mode: Literal["link-protection", "node-protection"] | None | UndefinedType = Undefined,
                        level: Literal["level-1", "level-2"] | None | UndefinedType = Undefined,
                        srlg: Srlg | UndefinedType = Undefined,
                    ) -> None:
                        """
                        FastRerouteTiLfa.


                        Subclass of AvdModel.

                        Args:
                            mode: mode
                            level: Optional, default is to protect all levels.
                            srlg:
                               Shared Risk Link Group.

                               Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "maximum_paths": {"type": int},
                "bfd_all_interfaces": {"type": bool},
                "fast_reroute_ti_lfa": {"type": FastRerouteTiLfa},
            }
            enabled: bool
            maximum_paths: int | None
            bfd_all_interfaces: bool | None
            """Enable BFD on all interfaces."""
            fast_reroute_ti_lfa: FastRerouteTiLfa
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    maximum_paths: int | None | UndefinedType = Undefined,
                    bfd_all_interfaces: bool | None | UndefinedType = Undefined,
                    fast_reroute_ti_lfa: FastRerouteTiLfa | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv6.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        maximum_paths: maximum_paths
                        bfd_all_interfaces: Enable BFD on all interfaces.
                        fast_reroute_ti_lfa: Subclass of AvdModel.

                    """

        class SegmentRoutingMpls(AvdModel):
            """Subclass of AvdModel."""

            class PrefixSegmentsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "index": {"type": int}}
                prefix: str | None
                index: int | None

                if TYPE_CHECKING:

                    def __init__(self, *, prefix: str | None | UndefinedType = Undefined, index: int | None | UndefinedType = Undefined) -> None:
                        """
                        PrefixSegmentsItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: prefix
                            index: index

                        """

            class PrefixSegments(AvdList[PrefixSegmentsItem]):
                """Subclass of AvdList with `PrefixSegmentsItem` items."""

            PrefixSegments._item_type = PrefixSegmentsItem

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "router_id": {"type": str}, "prefix_segments": {"type": PrefixSegments}}
            enabled: bool | None
            router_id: str | None
            prefix_segments: PrefixSegments
            """Subclass of AvdList with `PrefixSegmentsItem` items."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    router_id: str | None | UndefinedType = Undefined,
                    prefix_segments: PrefixSegments | UndefinedType = Undefined,
                ) -> None:
                    """
                    SegmentRoutingMpls.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        router_id: router_id
                        prefix_segments: Subclass of AvdList with `PrefixSegmentsItem` items.

                    """

        class SpfInterval(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "interval": {"type": int},
                "interval_unit": {"type": str},
                "wait_interval": {"type": int},
                "hold_interval": {"type": int},
            }
            interval: int | None
            """
            Maximum interval between two SPFs in seconds or milliseconds.
            Range in seconds: <1-300>
            Range in
            milliseconds: <1-300000>
            """
            interval_unit: Literal["seconds", "milliseconds"] | None
            """If interval unit is not defined EOS takes `seconds` by default."""
            wait_interval: int | None
            """Initial wait interval for SPF in milliseconds."""
            hold_interval: int | None
            """Hold interval between the first and second SPF runs in milliseconds."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    interval: int | None | UndefinedType = Undefined,
                    interval_unit: Literal["seconds", "milliseconds"] | None | UndefinedType = Undefined,
                    wait_interval: int | None | UndefinedType = Undefined,
                    hold_interval: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SpfInterval.


                    Subclass of AvdModel.

                    Args:
                        interval:
                           Maximum interval between two SPFs in seconds or milliseconds.
                           Range in seconds: <1-300>
                           Range in
                           milliseconds: <1-300000>
                        interval_unit: If interval unit is not defined EOS takes `seconds` by default.
                        wait_interval: Initial wait interval for SPF in milliseconds.
                        hold_interval: Hold interval between the first and second SPF runs in milliseconds.

                    """

        class GracefulRestart(AvdModel):
            """Subclass of AvdModel."""

            class T2(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level_1_wait_time": {"type": int}, "level_2_wait_time": {"type": int}}
                level_1_wait_time: int | None
                """Level-1 LSP database sync wait time in seconds."""
                level_2_wait_time: int | None
                """Level-2 LSP database sync wait time in seconds."""

                if TYPE_CHECKING:

                    def __init__(
                        self, *, level_1_wait_time: int | None | UndefinedType = Undefined, level_2_wait_time: int | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        T2.


                        Subclass of AvdModel.

                        Args:
                            level_1_wait_time: Level-1 LSP database sync wait time in seconds.
                            level_2_wait_time: Level-2 LSP database sync wait time in seconds.

                        """

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "restart_hold_time": {"type": int}, "t2": {"type": T2}}
            enabled: bool | None
            restart_hold_time: int | None
            """Number of seconds."""
            t2: T2
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    restart_hold_time: int | None | UndefinedType = Undefined,
                    t2: T2 | UndefinedType = Undefined,
                ) -> None:
                    """
                    GracefulRestart.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        restart_hold_time: Number of seconds.
                        t2: Subclass of AvdModel.

                    """

        _fields: ClassVar[dict] = {
            "instance": {"type": str},
            "net": {"type": str},
            "router_id": {"type": str},
            "is_hostname": {"type": str},
            "is_type": {"type": str},
            "log_adjacency_changes": {"type": bool},
            "mpls_ldp_sync_default": {"type": bool},
            "timers": {"type": Timers},
            "set_overload_bit": {"type": SetOverloadBit},
            "authentication": {"type": Authentication},
            "advertise": {"type": Advertise},
            "redistribute_routes": {"type": RedistributeRoutes},
            "address_family_ipv4": {"type": AddressFamilyIpv4},
            "address_family_ipv6": {"type": AddressFamilyIpv6},
            "segment_routing_mpls": {"type": SegmentRoutingMpls},
            "spf_interval": {"type": SpfInterval},
            "graceful_restart": {"type": GracefulRestart},
            "eos_cli": {"type": str},
        }
        instance: str
        """ISIS Instance Name."""
        net: str | None
        """CLNS Address like "49.0001.0001.0000.0001.00"."""
        router_id: str | None
        """IPv4 Address."""
        is_hostname: str | None
        """Hostname of Intermediate System."""
        is_type: Literal["level-1", "level-1-2", "level-2"] | None
        log_adjacency_changes: bool | None
        mpls_ldp_sync_default: bool | None
        timers: Timers
        """Subclass of AvdModel."""
        set_overload_bit: SetOverloadBit
        """Subclass of AvdModel."""
        authentication: Authentication
        """Subclass of AvdModel."""
        advertise: Advertise
        """Subclass of AvdModel."""
        redistribute_routes: RedistributeRoutes
        """Subclass of AvdList with `RedistributeRoutesItem` items."""
        address_family_ipv4: AddressFamilyIpv4
        """Subclass of AvdModel."""
        address_family_ipv6: AddressFamilyIpv6
        """Subclass of AvdModel."""
        segment_routing_mpls: SegmentRoutingMpls
        """Subclass of AvdModel."""
        spf_interval: SpfInterval
        """Subclass of AvdModel."""
        graceful_restart: GracefulRestart
        """Subclass of AvdModel."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the router isis in the final EOS configuration."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                instance: str | UndefinedType = Undefined,
                net: str | None | UndefinedType = Undefined,
                router_id: str | None | UndefinedType = Undefined,
                is_hostname: str | None | UndefinedType = Undefined,
                is_type: Literal["level-1", "level-1-2", "level-2"] | None | UndefinedType = Undefined,
                log_adjacency_changes: bool | None | UndefinedType = Undefined,
                mpls_ldp_sync_default: bool | None | UndefinedType = Undefined,
                timers: Timers | UndefinedType = Undefined,
                set_overload_bit: SetOverloadBit | UndefinedType = Undefined,
                authentication: Authentication | UndefinedType = Undefined,
                advertise: Advertise | UndefinedType = Undefined,
                redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                address_family_ipv4: AddressFamilyIpv4 | UndefinedType = Undefined,
                address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
                segment_routing_mpls: SegmentRoutingMpls | UndefinedType = Undefined,
                spf_interval: SpfInterval | UndefinedType = Undefined,
                graceful_restart: GracefulRestart | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                RouterIsis.


                Subclass of AvdModel.

                Args:
                    instance: ISIS Instance Name.
                    net: CLNS Address like "49.0001.0001.0000.0001.00".
                    router_id: IPv4 Address.
                    is_hostname: Hostname of Intermediate System.
                    is_type: is_type
                    log_adjacency_changes: log_adjacency_changes
                    mpls_ldp_sync_default: mpls_ldp_sync_default
                    timers: Subclass of AvdModel.
                    set_overload_bit: Subclass of AvdModel.
                    authentication: Subclass of AvdModel.
                    advertise: Subclass of AvdModel.
                    redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                    address_family_ipv4: Subclass of AvdModel.
                    address_family_ipv6: Subclass of AvdModel.
                    segment_routing_mpls: Subclass of AvdModel.
                    spf_interval: Subclass of AvdModel.
                    graceful_restart: Subclass of AvdModel.
                    eos_cli: Multiline EOS CLI rendered directly on the router isis in the final EOS configuration.

                """

    class RouterL2Vpn(AvdModel):
        """Subclass of AvdModel."""

        class ArpProxy(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"prefix_list": {"type": str}}
            prefix_list: str | None
            """Prefix-list name. ARP Proxying is disabled for IPv4 addresses defined in the prefix-list."""

            if TYPE_CHECKING:

                def __init__(self, *, prefix_list: str | None | UndefinedType = Undefined) -> None:
                    """
                    ArpProxy.


                    Subclass of AvdModel.

                    Args:
                        prefix_list: Prefix-list name. ARP Proxying is disabled for IPv4 addresses defined in the prefix-list.

                    """

        class NdProxy(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"prefix_list": {"type": str}}
            prefix_list: str | None
            """
            Prefix-list name. Neighbor Discovery Proxying is disabled for IPv6 addresses defined in the prefix-
            list.
            """

            if TYPE_CHECKING:

                def __init__(self, *, prefix_list: str | None | UndefinedType = Undefined) -> None:
                    """
                    NdProxy.


                    Subclass of AvdModel.

                    Args:
                        prefix_list:
                           Prefix-list name. Neighbor Discovery Proxying is disabled for IPv6 addresses defined in the prefix-
                           list.

                    """

        _fields: ClassVar[dict] = {
            "arp_learning_bridged": {"type": bool},
            "arp_proxy": {"type": ArpProxy},
            "arp_selective_install": {"type": bool},
            "nd_learning_bridged": {"type": bool},
            "nd_proxy": {"type": NdProxy},
            "nd_rs_flooding_disabled": {"type": bool},
            "virtual_router_nd_ra_flooding_disabled": {"type": bool},
        }
        arp_learning_bridged: bool | None
        arp_proxy: ArpProxy
        """Subclass of AvdModel."""
        arp_selective_install: bool | None
        nd_learning_bridged: bool | None
        nd_proxy: NdProxy
        """Subclass of AvdModel."""
        nd_rs_flooding_disabled: bool | None
        virtual_router_nd_ra_flooding_disabled: bool | None

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                arp_learning_bridged: bool | None | UndefinedType = Undefined,
                arp_proxy: ArpProxy | UndefinedType = Undefined,
                arp_selective_install: bool | None | UndefinedType = Undefined,
                nd_learning_bridged: bool | None | UndefinedType = Undefined,
                nd_proxy: NdProxy | UndefinedType = Undefined,
                nd_rs_flooding_disabled: bool | None | UndefinedType = Undefined,
                virtual_router_nd_ra_flooding_disabled: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                RouterL2Vpn.


                Subclass of AvdModel.

                Args:
                    arp_learning_bridged: arp_learning_bridged
                    arp_proxy: Subclass of AvdModel.
                    arp_selective_install: arp_selective_install
                    nd_learning_bridged: nd_learning_bridged
                    nd_proxy: Subclass of AvdModel.
                    nd_rs_flooding_disabled: nd_rs_flooding_disabled
                    virtual_router_nd_ra_flooding_disabled: virtual_router_nd_ra_flooding_disabled

                """

    class RouterMsdp(AvdModel):
        """Subclass of AvdModel."""

        class GroupLimitsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"source_prefix": {"type": str}, "limit": {"type": int}}
            source_prefix: str
            """Source address prefix."""
            limit: int
            """Limit for SAs matching the source address prefix."""

            if TYPE_CHECKING:

                def __init__(self, *, source_prefix: str | UndefinedType = Undefined, limit: int | UndefinedType = Undefined) -> None:
                    """
                    GroupLimitsItem.


                    Subclass of AvdModel.

                    Args:
                        source_prefix: Source address prefix.
                        limit: Limit for SAs matching the source address prefix.

                    """

        class GroupLimits(AvdIndexedList[str, GroupLimitsItem]):
            """Subclass of AvdIndexedList with `GroupLimitsItem` items. Primary key is `source_prefix` (`str`)."""

            _primary_key: ClassVar[str] = "source_prefix"

        GroupLimits._item_type = GroupLimitsItem

        class PeersItem(AvdModel):
            """Subclass of AvdModel."""

            class DefaultPeer(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "prefix_list": {"type": str}}
                enabled: bool | None
                prefix_list: str | None
                """Prefix list to filter source of SA messages."""

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, prefix_list: str | None | UndefinedType = Undefined) -> None:
                        """
                        DefaultPeer.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            prefix_list: Prefix list to filter source of SA messages.

                        """

            class MeshGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}}
                name: str
                """Mesh group name."""

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined) -> None:
                        """
                        MeshGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Mesh group name.

                        """

            class MeshGroups(AvdIndexedList[str, MeshGroupsItem]):
                """Subclass of AvdIndexedList with `MeshGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            MeshGroups._item_type = MeshGroupsItem

            class Keepalive(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"keepalive_timer": {"type": int}, "hold_timer": {"type": int}}
                keepalive_timer: int
                hold_timer: int
                """Must be greater than keepalive timer."""

                if TYPE_CHECKING:

                    def __init__(self, *, keepalive_timer: int | UndefinedType = Undefined, hold_timer: int | UndefinedType = Undefined) -> None:
                        """
                        Keepalive.


                        Subclass of AvdModel.

                        Args:
                            keepalive_timer: keepalive_timer
                            hold_timer: Must be greater than keepalive timer.

                        """

            class SaFilter(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"in_list": {"type": str}, "out_list": {"type": str}}
                in_list: str | None
                """ACL to filter inbound SA messages."""
                out_list: str | None
                """ACL to filter outbound SA messages."""

                if TYPE_CHECKING:

                    def __init__(self, *, in_list: str | None | UndefinedType = Undefined, out_list: str | None | UndefinedType = Undefined) -> None:
                        """
                        SaFilter.


                        Subclass of AvdModel.

                        Args:
                            in_list: ACL to filter inbound SA messages.
                            out_list: ACL to filter outbound SA messages.

                        """

            _fields: ClassVar[dict] = {
                "ipv4_address": {"type": str},
                "default_peer": {"type": DefaultPeer},
                "local_interface": {"type": str},
                "description": {"type": str},
                "disabled": {"type": bool},
                "sa_limit": {"type": int},
                "mesh_groups": {"type": MeshGroups},
                "keepalive": {"type": Keepalive},
                "sa_filter": {"type": SaFilter},
            }
            ipv4_address: str
            """Peer IP Address."""
            default_peer: DefaultPeer
            """Subclass of AvdModel."""
            local_interface: str | None
            description: str | None
            disabled: bool | None
            """Disable the MSDP peer."""
            sa_limit: int | None
            """Maximum number of SA messages allowed in cache."""
            mesh_groups: MeshGroups
            """Subclass of AvdIndexedList with `MeshGroupsItem` items. Primary key is `name` (`str`)."""
            keepalive: Keepalive
            """Subclass of AvdModel."""
            sa_filter: SaFilter
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4_address: str | UndefinedType = Undefined,
                    default_peer: DefaultPeer | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    disabled: bool | None | UndefinedType = Undefined,
                    sa_limit: int | None | UndefinedType = Undefined,
                    mesh_groups: MeshGroups | UndefinedType = Undefined,
                    keepalive: Keepalive | UndefinedType = Undefined,
                    sa_filter: SaFilter | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeersItem.


                    Subclass of AvdModel.

                    Args:
                        ipv4_address: Peer IP Address.
                        default_peer: Subclass of AvdModel.
                        local_interface: local_interface
                        description: description
                        disabled: Disable the MSDP peer.
                        sa_limit: Maximum number of SA messages allowed in cache.
                        mesh_groups: Subclass of AvdIndexedList with `MeshGroupsItem` items. Primary key is `name` (`str`).
                        keepalive: Subclass of AvdModel.
                        sa_filter: Subclass of AvdModel.

                    """

        class Peers(AvdIndexedList[str, PeersItem]):
            """Subclass of AvdIndexedList with `PeersItem` items. Primary key is `ipv4_address` (`str`)."""

            _primary_key: ClassVar[str] = "ipv4_address"

        Peers._item_type = PeersItem

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class GroupLimitsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"source_prefix": {"type": str}, "limit": {"type": int}}
                source_prefix: str
                """Source address prefix."""
                limit: int
                """Limit for SAs matching the source address prefix."""

                if TYPE_CHECKING:

                    def __init__(self, *, source_prefix: str | UndefinedType = Undefined, limit: int | UndefinedType = Undefined) -> None:
                        """
                        GroupLimitsItem.


                        Subclass of AvdModel.

                        Args:
                            source_prefix: Source address prefix.
                            limit: Limit for SAs matching the source address prefix.

                        """

            class GroupLimits(AvdIndexedList[str, GroupLimitsItem]):
                """Subclass of AvdIndexedList with `GroupLimitsItem` items. Primary key is `source_prefix` (`str`)."""

                _primary_key: ClassVar[str] = "source_prefix"

            GroupLimits._item_type = GroupLimitsItem

            class PeersItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultPeer(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "prefix_list": {"type": str}}
                    enabled: bool | None
                    prefix_list: str | None
                    """Prefix list to filter source of SA messages."""

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, prefix_list: str | None | UndefinedType = Undefined) -> None:
                            """
                            DefaultPeer.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                prefix_list: Prefix list to filter source of SA messages.

                            """

                class MeshGroupsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}}
                    name: str
                    """Mesh group name."""

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | UndefinedType = Undefined) -> None:
                            """
                            MeshGroupsItem.


                            Subclass of AvdModel.

                            Args:
                                name: Mesh group name.

                            """

                class MeshGroups(AvdIndexedList[str, MeshGroupsItem]):
                    """Subclass of AvdIndexedList with `MeshGroupsItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                MeshGroups._item_type = MeshGroupsItem

                class Keepalive(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"keepalive_timer": {"type": int}, "hold_timer": {"type": int}}
                    keepalive_timer: int
                    hold_timer: int
                    """Must be greater than keepalive timer."""

                    if TYPE_CHECKING:

                        def __init__(self, *, keepalive_timer: int | UndefinedType = Undefined, hold_timer: int | UndefinedType = Undefined) -> None:
                            """
                            Keepalive.


                            Subclass of AvdModel.

                            Args:
                                keepalive_timer: keepalive_timer
                                hold_timer: Must be greater than keepalive timer.

                            """

                class SaFilter(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"in_list": {"type": str}, "out_list": {"type": str}}
                    in_list: str | None
                    """ACL to filter inbound SA messages."""
                    out_list: str | None
                    """ACL to filter outbound SA messages."""

                    if TYPE_CHECKING:

                        def __init__(self, *, in_list: str | None | UndefinedType = Undefined, out_list: str | None | UndefinedType = Undefined) -> None:
                            """
                            SaFilter.


                            Subclass of AvdModel.

                            Args:
                                in_list: ACL to filter inbound SA messages.
                                out_list: ACL to filter outbound SA messages.

                            """

                _fields: ClassVar[dict] = {
                    "ipv4_address": {"type": str},
                    "default_peer": {"type": DefaultPeer},
                    "local_interface": {"type": str},
                    "description": {"type": str},
                    "disabled": {"type": bool},
                    "sa_limit": {"type": int},
                    "mesh_groups": {"type": MeshGroups},
                    "keepalive": {"type": Keepalive},
                    "sa_filter": {"type": SaFilter},
                }
                ipv4_address: str
                """Peer IP Address."""
                default_peer: DefaultPeer
                """Subclass of AvdModel."""
                local_interface: str | None
                description: str | None
                disabled: bool | None
                """Disable the MSDP peer."""
                sa_limit: int | None
                """Maximum number of SA messages allowed in cache."""
                mesh_groups: MeshGroups
                """Subclass of AvdIndexedList with `MeshGroupsItem` items. Primary key is `name` (`str`)."""
                keepalive: Keepalive
                """Subclass of AvdModel."""
                sa_filter: SaFilter
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ipv4_address: str | UndefinedType = Undefined,
                        default_peer: DefaultPeer | UndefinedType = Undefined,
                        local_interface: str | None | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                        disabled: bool | None | UndefinedType = Undefined,
                        sa_limit: int | None | UndefinedType = Undefined,
                        mesh_groups: MeshGroups | UndefinedType = Undefined,
                        keepalive: Keepalive | UndefinedType = Undefined,
                        sa_filter: SaFilter | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeersItem.


                        Subclass of AvdModel.

                        Args:
                            ipv4_address: Peer IP Address.
                            default_peer: Subclass of AvdModel.
                            local_interface: local_interface
                            description: description
                            disabled: Disable the MSDP peer.
                            sa_limit: Maximum number of SA messages allowed in cache.
                            mesh_groups: Subclass of AvdIndexedList with `MeshGroupsItem` items. Primary key is `name` (`str`).
                            keepalive: Subclass of AvdModel.
                            sa_filter: Subclass of AvdModel.

                        """

            class Peers(AvdIndexedList[str, PeersItem]):
                """Subclass of AvdIndexedList with `PeersItem` items. Primary key is `ipv4_address` (`str`)."""

                _primary_key: ClassVar[str] = "ipv4_address"

            Peers._item_type = PeersItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "originator_id_local_interface": {"type": str},
                "rejected_limit": {"type": int},
                "forward_register_packets": {"type": bool},
                "connection_retry_interval": {"type": int},
                "group_limits": {"type": GroupLimits},
                "peers": {"type": Peers},
            }
            name: str
            """VRF name."""
            originator_id_local_interface: str | None
            """Interface to use for originator ID."""
            rejected_limit: int | None
            """Maximum number of rejected SA messages allowed in cache."""
            forward_register_packets: bool | None
            connection_retry_interval: int | None
            group_limits: GroupLimits
            """Subclass of AvdIndexedList with `GroupLimitsItem` items. Primary key is `source_prefix` (`str`)."""
            peers: Peers
            """Subclass of AvdIndexedList with `PeersItem` items. Primary key is `ipv4_address` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    originator_id_local_interface: str | None | UndefinedType = Undefined,
                    rejected_limit: int | None | UndefinedType = Undefined,
                    forward_register_packets: bool | None | UndefinedType = Undefined,
                    connection_retry_interval: int | None | UndefinedType = Undefined,
                    group_limits: GroupLimits | UndefinedType = Undefined,
                    peers: Peers | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        originator_id_local_interface: Interface to use for originator ID.
                        rejected_limit: Maximum number of rejected SA messages allowed in cache.
                        forward_register_packets: forward_register_packets
                        connection_retry_interval: connection_retry_interval
                        group_limits: Subclass of AvdIndexedList with `GroupLimitsItem` items. Primary key is `source_prefix` (`str`).
                        peers: Subclass of AvdIndexedList with `PeersItem` items. Primary key is `ipv4_address` (`str`).

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "originator_id_local_interface": {"type": str},
            "rejected_limit": {"type": int},
            "forward_register_packets": {"type": bool},
            "connection_retry_interval": {"type": int},
            "group_limits": {"type": GroupLimits},
            "peers": {"type": Peers},
            "vrfs": {"type": Vrfs},
        }
        originator_id_local_interface: str | None
        """Interface to use for originator ID."""
        rejected_limit: int | None
        """Maximum number of rejected SA messages allowed in cache."""
        forward_register_packets: bool | None
        connection_retry_interval: int | None
        group_limits: GroupLimits
        """Subclass of AvdIndexedList with `GroupLimitsItem` items. Primary key is `source_prefix` (`str`)."""
        peers: Peers
        """Subclass of AvdIndexedList with `PeersItem` items. Primary key is `ipv4_address` (`str`)."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                originator_id_local_interface: str | None | UndefinedType = Undefined,
                rejected_limit: int | None | UndefinedType = Undefined,
                forward_register_packets: bool | None | UndefinedType = Undefined,
                connection_retry_interval: int | None | UndefinedType = Undefined,
                group_limits: GroupLimits | UndefinedType = Undefined,
                peers: Peers | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
            ) -> None:
                """
                RouterMsdp.


                Subclass of AvdModel.

                Args:
                    originator_id_local_interface: Interface to use for originator ID.
                    rejected_limit: Maximum number of rejected SA messages allowed in cache.
                    forward_register_packets: forward_register_packets
                    connection_retry_interval: connection_retry_interval
                    group_limits: Subclass of AvdIndexedList with `GroupLimitsItem` items. Primary key is `source_prefix` (`str`).
                    peers: Subclass of AvdIndexedList with `PeersItem` items. Primary key is `ipv4_address` (`str`).
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).

                """

    class RouterMulticast(AvdModel):
        """Subclass of AvdModel."""

        class Ipv4(AvdModel):
            """Subclass of AvdModel."""

            class Counters(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"rate_period_decay": {"type": int}}
                rate_period_decay: int | None
                """Rate in seconds."""

                if TYPE_CHECKING:

                    def __init__(self, *, rate_period_decay: int | None | UndefinedType = Undefined) -> None:
                        """
                        Counters.


                        Subclass of AvdModel.

                        Args:
                            rate_period_decay: Rate in seconds.

                        """

            class Rpf(AvdModel):
                """Subclass of AvdModel."""

                class RoutesItem(AvdModel):
                    """Subclass of AvdModel."""

                    class DestinationsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"nexthop": {"type": str}, "distance": {"type": int}}
                        nexthop: str
                        """Next-hop IP address or interface name."""
                        distance: int | None
                        """Administrative distance for this route."""

                        if TYPE_CHECKING:

                            def __init__(self, *, nexthop: str | UndefinedType = Undefined, distance: int | None | UndefinedType = Undefined) -> None:
                                """
                                DestinationsItem.


                                Subclass of AvdModel.

                                Args:
                                    nexthop: Next-hop IP address or interface name.
                                    distance: Administrative distance for this route.

                                """

                    class Destinations(AvdList[DestinationsItem]):
                        """Subclass of AvdList with `DestinationsItem` items."""

                    Destinations._item_type = DestinationsItem

                    _fields: ClassVar[dict] = {"source_prefix": {"type": str}, "destinations": {"type": Destinations}}
                    source_prefix: str
                    """Source address A.B.C.D or Source prefix A.B.C.D/E."""
                    destinations: Destinations
                    """Subclass of AvdList with `DestinationsItem` items."""

                    if TYPE_CHECKING:

                        def __init__(self, *, source_prefix: str | UndefinedType = Undefined, destinations: Destinations | UndefinedType = Undefined) -> None:
                            """
                            RoutesItem.


                            Subclass of AvdModel.

                            Args:
                                source_prefix: Source address A.B.C.D or Source prefix A.B.C.D/E.
                                destinations: Subclass of AvdList with `DestinationsItem` items.

                            """

                class Routes(AvdList[RoutesItem]):
                    """Subclass of AvdList with `RoutesItem` items."""

                Routes._item_type = RoutesItem

                _fields: ClassVar[dict] = {"routes": {"type": Routes}}
                routes: Routes
                """Subclass of AvdList with `RoutesItem` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, routes: Routes | UndefinedType = Undefined) -> None:
                        """
                        Rpf.


                        Subclass of AvdModel.

                        Args:
                            routes: Subclass of AvdList with `RoutesItem` items.

                        """

            _fields: ClassVar[dict] = {
                "activity_polling_interval": {"type": int},
                "counters": {"type": Counters},
                "routing": {"type": bool},
                "multipath": {"type": str},
                "software_forwarding": {"type": str},
                "rpf": {"type": Rpf},
            }
            activity_polling_interval: int | None
            """MFIB entry activity polling interval."""
            counters: Counters
            """Subclass of AvdModel."""
            routing: bool | None
            multipath: Literal["none", "deterministic", "deterministic color", "deterministic router-id"] | None
            software_forwarding: Literal["kernel", "sfe"] | None
            rpf: Rpf
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    activity_polling_interval: int | None | UndefinedType = Undefined,
                    counters: Counters | UndefinedType = Undefined,
                    routing: bool | None | UndefinedType = Undefined,
                    multipath: Literal["none", "deterministic", "deterministic color", "deterministic router-id"] | None | UndefinedType = Undefined,
                    software_forwarding: Literal["kernel", "sfe"] | None | UndefinedType = Undefined,
                    rpf: Rpf | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4.


                    Subclass of AvdModel.

                    Args:
                        activity_polling_interval: MFIB entry activity polling interval.
                        counters: Subclass of AvdModel.
                        routing: routing
                        multipath: multipath
                        software_forwarding: software_forwarding
                        rpf: Subclass of AvdModel.

                    """

        class Ipv6(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"activity_polling_interval": {"type": int}}
            activity_polling_interval: int | None
            """MFIB entry activity polling interval."""

            if TYPE_CHECKING:

                def __init__(self, *, activity_polling_interval: int | None | UndefinedType = Undefined) -> None:
                    """
                    Ipv6.


                    Subclass of AvdModel.

                    Args:
                        activity_polling_interval: MFIB entry activity polling interval.

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"routing": {"type": bool}}
                routing: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, routing: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            routing: routing

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "ipv4": {"type": Ipv4}}
            name: str
            ipv4: Ipv4
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, ipv4: Ipv4 | UndefinedType = Undefined) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        ipv4: Subclass of AvdModel.

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}, "vrfs": {"type": Vrfs}}
        ipv4: Ipv4
        """Subclass of AvdModel."""
        ipv6: Ipv6
        """Subclass of AvdModel."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self, *, ipv4: Ipv4 | UndefinedType = Undefined, ipv6: Ipv6 | UndefinedType = Undefined, vrfs: Vrfs | UndefinedType = Undefined
            ) -> None:
                """
                RouterMulticast.


                Subclass of AvdModel.

                Args:
                    ipv4: Subclass of AvdModel.
                    ipv6: Subclass of AvdModel.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).

                """

    class RouterOspf(AvdModel):
        """Subclass of AvdModel."""

        class ProcessIdsItem(AvdModel):
            """Subclass of AvdModel."""

            class Distance(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"external": {"type": int}, "inter_area": {"type": int}, "intra_area": {"type": int}}
                external: int | None
                inter_area: int | None
                intra_area: int | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        external: int | None | UndefinedType = Undefined,
                        inter_area: int | None | UndefinedType = Undefined,
                        intra_area: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Distance.


                        Subclass of AvdModel.

                        Args:
                            external: external
                            inter_area: inter_area
                            intra_area: intra_area

                        """

            class NetworkPrefixesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4_prefix": {"type": str}, "area": {"type": str}}
                ipv4_prefix: str
                area: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, ipv4_prefix: str | UndefinedType = Undefined, area: str | None | UndefinedType = Undefined) -> None:
                        """
                        NetworkPrefixesItem.


                        Subclass of AvdModel.

                        Args:
                            ipv4_prefix: ipv4_prefix
                            area: area

                        """

            class NetworkPrefixes(AvdIndexedList[str, NetworkPrefixesItem]):
                """Subclass of AvdIndexedList with `NetworkPrefixesItem` items. Primary key is `ipv4_prefix` (`str`)."""

                _primary_key: ClassVar[str] = "ipv4_prefix"

            NetworkPrefixes._item_type = NetworkPrefixesItem

            class NoPassiveInterfaces(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            NoPassiveInterfaces._item_type = str

            class DistributeListIn(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"route_map": {"type": str}}
                route_map: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, route_map: str | None | UndefinedType = Undefined) -> None:
                        """
                        DistributeListIn.


                        Subclass of AvdModel.

                        Args:
                            route_map: route_map

                        """

            class Timers(AvdModel):
                """Subclass of AvdModel."""

                class Lsa(AvdModel):
                    """Subclass of AvdModel."""

                    class TxDelay(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"initial": {"type": int}, "min": {"type": int}, "max": {"type": int}}
                        initial: int | None
                        """Delay to generate first occurrence of LSA in msecs."""
                        min: int | None
                        """Min delay between originating the same LSA in msecs."""
                        max: int | None
                        """1-600000 Maximum delay between originating the same LSA in msec."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                initial: int | None | UndefinedType = Undefined,
                                min: int | None | UndefinedType = Undefined,
                                max: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                TxDelay.


                                Subclass of AvdModel.

                                Args:
                                    initial: Delay to generate first occurrence of LSA in msecs.
                                    min: Min delay between originating the same LSA in msecs.
                                    max: 1-600000 Maximum delay between originating the same LSA in msec.

                                """

                    _fields: ClassVar[dict] = {"rx_min_interval": {"type": int}, "tx_delay": {"type": TxDelay}}
                    rx_min_interval: int | None
                    """Min interval in msecs between accepting the same LSA."""
                    tx_delay: TxDelay
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(self, *, rx_min_interval: int | None | UndefinedType = Undefined, tx_delay: TxDelay | UndefinedType = Undefined) -> None:
                            """
                            Lsa.


                            Subclass of AvdModel.

                            Args:
                                rx_min_interval: Min interval in msecs between accepting the same LSA.
                                tx_delay: Subclass of AvdModel.

                            """

                class SpfDelay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"initial": {"type": int}, "min": {"type": int}, "max": {"type": int}}
                    initial: int | None
                    """Initial SPF schedule delay in msecs."""
                    min: int | None
                    """Min Hold time between two SPFs in msecs."""
                    max: int | None
                    """Max wait time between two SPFs in msecs."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            initial: int | None | UndefinedType = Undefined,
                            min: int | None | UndefinedType = Undefined,
                            max: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SpfDelay.


                            Subclass of AvdModel.

                            Args:
                                initial: Initial SPF schedule delay in msecs.
                                min: Min Hold time between two SPFs in msecs.
                                max: Max wait time between two SPFs in msecs.

                            """

                _fields: ClassVar[dict] = {"lsa": {"type": Lsa}, "spf_delay": {"type": SpfDelay}}
                lsa: Lsa
                """Subclass of AvdModel."""
                spf_delay: SpfDelay
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, lsa: Lsa | UndefinedType = Undefined, spf_delay: SpfDelay | UndefinedType = Undefined) -> None:
                        """
                        Timers.


                        Subclass of AvdModel.

                        Args:
                            lsa: Subclass of AvdModel.
                            spf_delay: Subclass of AvdModel.

                        """

            class DefaultInformationOriginate(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"always": {"type": bool}, "metric": {"type": int}, "metric_type": {"type": int}}
                always: bool | None
                metric: int | None
                """Metric for default route."""
                metric_type: Literal[1, 2] | None
                """OSPF metric type for default route."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        always: bool | None | UndefinedType = Undefined,
                        metric: int | None | UndefinedType = Undefined,
                        metric_type: Literal[1, 2] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultInformationOriginate.


                        Subclass of AvdModel.

                        Args:
                            always: always
                            metric: Metric for default route.
                            metric_type: OSPF metric type for default route.

                        """

            class SummaryAddressesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "tag": {"type": int}, "attribute_map": {"type": str}, "not_advertise": {"type": bool}}
                prefix: str
                """Summary Prefix Address."""
                tag: int | None
                attribute_map: str | None
                not_advertise: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        prefix: str | UndefinedType = Undefined,
                        tag: int | None | UndefinedType = Undefined,
                        attribute_map: str | None | UndefinedType = Undefined,
                        not_advertise: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SummaryAddressesItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: Summary Prefix Address.
                            tag: tag
                            attribute_map: attribute_map
                            not_advertise: not_advertise

                        """

            class SummaryAddresses(AvdIndexedList[str, SummaryAddressesItem]):
                """Subclass of AvdIndexedList with `SummaryAddressesItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            SummaryAddresses._item_type = SummaryAddressesItem

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    """Route Map Name."""
                    include_leaked: bool | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: Route Map Name.
                                include_leaked: include_leaked

                            """

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    """Route Map Name."""
                    include_leaked: bool | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: Route Map Name.
                                include_leaked: include_leaked

                            """

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "include_leaked": {"type": bool}}
                    enabled: bool
                    route_map: str | None
                    """Route Map Name."""
                    include_leaked: bool | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: Route Map Name.
                                include_leaked: include_leaked

                            """

                _fields: ClassVar[dict] = {"static": {"type": Static}, "connected": {"type": Connected}, "bgp": {"type": Bgp}}
                static: Static
                """Subclass of AvdModel."""
                connected: Connected
                """Subclass of AvdModel."""
                bgp: Bgp
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        static: Static | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        bgp: Bgp | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            static: Subclass of AvdModel.
                            connected: Subclass of AvdModel.
                            bgp: Subclass of AvdModel.

                        """

            class AreasItem(AvdModel):
                """Subclass of AvdModel."""

                class Filter(AvdModel):
                    """Subclass of AvdModel."""

                    class Networks(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Networks._item_type = str

                    _fields: ClassVar[dict] = {"networks": {"type": Networks}, "prefix_list": {"type": str}}
                    networks: Networks
                    """Subclass of AvdList with `str` items."""
                    prefix_list: str | None
                    """Prefix-List Name."""

                    if TYPE_CHECKING:

                        def __init__(self, *, networks: Networks | UndefinedType = Undefined, prefix_list: str | None | UndefinedType = Undefined) -> None:
                            """
                            Filter.


                            Subclass of AvdModel.

                            Args:
                                networks: Subclass of AvdList with `str` items.
                                prefix_list: Prefix-List Name.

                            """

                class DefaultInformationOriginate(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"metric": {"type": int}, "metric_type": {"type": int}}
                    metric: int | None
                    """Metric for default route."""
                    metric_type: Literal[1, 2] | None
                    """OSPF metric type for default route."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, metric: int | None | UndefinedType = Undefined, metric_type: Literal[1, 2] | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            DefaultInformationOriginate.


                            Subclass of AvdModel.

                            Args:
                                metric: Metric for default route.
                                metric_type: OSPF metric type for default route.

                            """

                _fields: ClassVar[dict] = {
                    "id": {"type": str},
                    "filter": {"type": Filter},
                    "type": {"type": str, "default": "normal"},
                    "no_summary": {"type": bool},
                    "nssa_only": {"type": bool},
                    "default_information_originate": {"type": DefaultInformationOriginate},
                }
                id: str
                filter: Filter
                """Subclass of AvdModel."""
                type: Literal["normal", "stub", "nssa"]
                """Default value: `"normal"`"""
                no_summary: bool | None
                nssa_only: bool | None
                default_information_originate: DefaultInformationOriginate
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: str | UndefinedType = Undefined,
                        filter: Filter | UndefinedType = Undefined,
                        type: Literal["normal", "stub", "nssa"] | UndefinedType = Undefined,
                        no_summary: bool | None | UndefinedType = Undefined,
                        nssa_only: bool | None | UndefinedType = Undefined,
                        default_information_originate: DefaultInformationOriginate | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AreasItem.


                        Subclass of AvdModel.

                        Args:
                            id: id
                            filter: Subclass of AvdModel.
                            type: type
                            no_summary: no_summary
                            nssa_only: nssa_only
                            default_information_originate: Subclass of AvdModel.

                        """

            class Areas(AvdIndexedList[str, AreasItem]):
                """Subclass of AvdIndexedList with `AreasItem` items. Primary key is `id` (`str`)."""

                _primary_key: ClassVar[str] = "id"

            Areas._item_type = AreasItem

            class MaxMetric(AvdModel):
                """Subclass of AvdModel."""

                class RouterLsa(AvdModel):
                    """Subclass of AvdModel."""

                    class ExternalLsa(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"override_metric": {"type": int}}
                        override_metric: int | None

                        if TYPE_CHECKING:

                            def __init__(self, *, override_metric: int | None | UndefinedType = Undefined) -> None:
                                """
                                ExternalLsa.


                                Subclass of AvdModel.

                                Args:
                                    override_metric: override_metric

                                """

                    class SummaryLsa(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"override_metric": {"type": int}}
                        override_metric: int | None

                        if TYPE_CHECKING:

                            def __init__(self, *, override_metric: int | None | UndefinedType = Undefined) -> None:
                                """
                                SummaryLsa.


                                Subclass of AvdModel.

                                Args:
                                    override_metric: override_metric

                                """

                    _fields: ClassVar[dict] = {
                        "external_lsa": {"type": ExternalLsa},
                        "include_stub": {"type": bool},
                        "on_startup": {"type": str},
                        "summary_lsa": {"type": SummaryLsa},
                    }
                    external_lsa: ExternalLsa
                    """Subclass of AvdModel."""
                    include_stub: bool | None
                    on_startup: str | None
                    """
                    "wait-for-bgp" or Integer 5-86400.
                    Example: "wait-for-bgp" Or "222"
                    """
                    summary_lsa: SummaryLsa
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            external_lsa: ExternalLsa | UndefinedType = Undefined,
                            include_stub: bool | None | UndefinedType = Undefined,
                            on_startup: str | None | UndefinedType = Undefined,
                            summary_lsa: SummaryLsa | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RouterLsa.


                            Subclass of AvdModel.

                            Args:
                                external_lsa: Subclass of AvdModel.
                                include_stub: include_stub
                                on_startup:
                                   "wait-for-bgp" or Integer 5-86400.
                                   Example: "wait-for-bgp" Or "222"
                                summary_lsa: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {"router_lsa": {"type": RouterLsa}}
                router_lsa: RouterLsa
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, router_lsa: RouterLsa | UndefinedType = Undefined) -> None:
                        """
                        MaxMetric.


                        Subclass of AvdModel.

                        Args:
                            router_lsa: Subclass of AvdModel.

                        """

            class GracefulRestart(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "grace_period": {"type": int}}
                enabled: bool
                grace_period: int | None
                """Specify maximum time in seconds to wait for graceful-restart to complete."""

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | UndefinedType = Undefined, grace_period: int | None | UndefinedType = Undefined) -> None:
                        """
                        GracefulRestart.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            grace_period: Specify maximum time in seconds to wait for graceful-restart to complete.

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "vrf": {"type": str},
                "passive_interface_default": {"type": bool},
                "router_id": {"type": str},
                "distance": {"type": Distance},
                "log_adjacency_changes_detail": {"type": bool},
                "network_prefixes": {"type": NetworkPrefixes},
                "bfd_enable": {"type": bool},
                "bfd_adjacency_state_any": {"type": bool},
                "no_passive_interfaces": {"type": NoPassiveInterfaces},
                "distribute_list_in": {"type": DistributeListIn},
                "max_lsa": {"type": int},
                "timers": {"type": Timers},
                "default_information_originate": {"type": DefaultInformationOriginate},
                "summary_addresses": {"type": SummaryAddresses},
                "redistribute": {"type": Redistribute},
                "auto_cost_reference_bandwidth": {"type": int},
                "areas": {"type": Areas},
                "maximum_paths": {"type": int},
                "max_metric": {"type": MaxMetric},
                "graceful_restart": {"type": GracefulRestart},
                "graceful_restart_helper": {"type": bool},
                "mpls_ldp_sync_default": {"type": bool},
                "eos_cli": {"type": str},
            }
            id: int
            """OSPF Process ID."""
            vrf: str | None
            """VRF Name for OSPF Process."""
            passive_interface_default: bool | None
            router_id: str | None
            """IPv4 Address."""
            distance: Distance
            """Subclass of AvdModel."""
            log_adjacency_changes_detail: bool | None
            network_prefixes: NetworkPrefixes
            """Subclass of AvdIndexedList with `NetworkPrefixesItem` items. Primary key is `ipv4_prefix` (`str`)."""
            bfd_enable: bool | None
            bfd_adjacency_state_any: bool | None
            no_passive_interfaces: NoPassiveInterfaces
            """Subclass of AvdList with `str` items."""
            distribute_list_in: DistributeListIn
            """Subclass of AvdModel."""
            max_lsa: int | None
            timers: Timers
            """Subclass of AvdModel."""
            default_information_originate: DefaultInformationOriginate
            """Subclass of AvdModel."""
            summary_addresses: SummaryAddresses
            """Subclass of AvdIndexedList with `SummaryAddressesItem` items. Primary key is `prefix` (`str`)."""
            redistribute: Redistribute
            """Subclass of AvdModel."""
            auto_cost_reference_bandwidth: int | None
            """Bandwidth in mbps."""
            areas: Areas
            """Subclass of AvdIndexedList with `AreasItem` items. Primary key is `id` (`str`)."""
            maximum_paths: int | None
            max_metric: MaxMetric
            """Subclass of AvdModel."""
            graceful_restart: GracefulRestart
            """Subclass of AvdModel."""
            graceful_restart_helper: bool | None
            mpls_ldp_sync_default: bool | None
            eos_cli: str | None
            """Multiline EOS CLI rendered directly on the Router OSPF process ID in the final EOS configuration."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    passive_interface_default: bool | None | UndefinedType = Undefined,
                    router_id: str | None | UndefinedType = Undefined,
                    distance: Distance | UndefinedType = Undefined,
                    log_adjacency_changes_detail: bool | None | UndefinedType = Undefined,
                    network_prefixes: NetworkPrefixes | UndefinedType = Undefined,
                    bfd_enable: bool | None | UndefinedType = Undefined,
                    bfd_adjacency_state_any: bool | None | UndefinedType = Undefined,
                    no_passive_interfaces: NoPassiveInterfaces | UndefinedType = Undefined,
                    distribute_list_in: DistributeListIn | UndefinedType = Undefined,
                    max_lsa: int | None | UndefinedType = Undefined,
                    timers: Timers | UndefinedType = Undefined,
                    default_information_originate: DefaultInformationOriginate | UndefinedType = Undefined,
                    summary_addresses: SummaryAddresses | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    auto_cost_reference_bandwidth: int | None | UndefinedType = Undefined,
                    areas: Areas | UndefinedType = Undefined,
                    maximum_paths: int | None | UndefinedType = Undefined,
                    max_metric: MaxMetric | UndefinedType = Undefined,
                    graceful_restart: GracefulRestart | UndefinedType = Undefined,
                    graceful_restart_helper: bool | None | UndefinedType = Undefined,
                    mpls_ldp_sync_default: bool | None | UndefinedType = Undefined,
                    eos_cli: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProcessIdsItem.


                    Subclass of AvdModel.

                    Args:
                        id: OSPF Process ID.
                        vrf: VRF Name for OSPF Process.
                        passive_interface_default: passive_interface_default
                        router_id: IPv4 Address.
                        distance: Subclass of AvdModel.
                        log_adjacency_changes_detail: log_adjacency_changes_detail
                        network_prefixes: Subclass of AvdIndexedList with `NetworkPrefixesItem` items. Primary key is `ipv4_prefix` (`str`).
                        bfd_enable: bfd_enable
                        bfd_adjacency_state_any: bfd_adjacency_state_any
                        no_passive_interfaces: Subclass of AvdList with `str` items.
                        distribute_list_in: Subclass of AvdModel.
                        max_lsa: max_lsa
                        timers: Subclass of AvdModel.
                        default_information_originate: Subclass of AvdModel.
                        summary_addresses: Subclass of AvdIndexedList with `SummaryAddressesItem` items. Primary key is `prefix` (`str`).
                        redistribute: Subclass of AvdModel.
                        auto_cost_reference_bandwidth: Bandwidth in mbps.
                        areas: Subclass of AvdIndexedList with `AreasItem` items. Primary key is `id` (`str`).
                        maximum_paths: maximum_paths
                        max_metric: Subclass of AvdModel.
                        graceful_restart: Subclass of AvdModel.
                        graceful_restart_helper: graceful_restart_helper
                        mpls_ldp_sync_default: mpls_ldp_sync_default
                        eos_cli: Multiline EOS CLI rendered directly on the Router OSPF process ID in the final EOS configuration.

                    """

        class ProcessIds(AvdIndexedList[int, ProcessIdsItem]):
            """Subclass of AvdIndexedList with `ProcessIdsItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        ProcessIds._item_type = ProcessIdsItem

        _fields: ClassVar[dict] = {"process_ids": {"type": ProcessIds}}
        process_ids: ProcessIds
        """Subclass of AvdIndexedList with `ProcessIdsItem` items. Primary key is `id` (`int`)."""

        if TYPE_CHECKING:

            def __init__(self, *, process_ids: ProcessIds | UndefinedType = Undefined) -> None:
                """
                RouterOspf.


                Subclass of AvdModel.

                Args:
                    process_ids: Subclass of AvdIndexedList with `ProcessIdsItem` items. Primary key is `id` (`int`).

                """

    class RouterPathSelection(AvdModel):
        """Subclass of AvdModel."""

        class MtuDiscoveryHosts(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "fragmentation_needed_rate_limit": {"type": int}}
            enabled: bool | None
            """Enable MTU discovery for hosts."""
            fragmentation_needed_rate_limit: int | None
            """Maximum rate of ICMP packet generation per CPU core(packets per second)."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, enabled: bool | None | UndefinedType = Undefined, fragmentation_needed_rate_limit: int | None | UndefinedType = Undefined
                ) -> None:
                    """
                    MtuDiscoveryHosts.


                    Subclass of AvdModel.

                    Args:
                        enabled: Enable MTU discovery for hosts.
                        fragmentation_needed_rate_limit: Maximum rate of ICMP packet generation per CPU core(packets per second).

                    """

        class PathGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            class LocalInterfacesItem(AvdModel):
                """Subclass of AvdModel."""

                class Stun(AvdModel):
                    """Subclass of AvdModel."""

                    class ServerProfiles(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    ServerProfiles._item_type = str

                    _fields: ClassVar[dict] = {"server_profiles": {"type": ServerProfiles}}
                    server_profiles: ServerProfiles
                    """
                    STUN server-profile names.

                    Subclass of AvdList with `str` items.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, server_profiles: ServerProfiles | UndefinedType = Undefined) -> None:
                            """
                            Stun.


                            Subclass of AvdModel.

                            Args:
                                server_profiles:
                                   STUN server-profile names.

                                   Subclass of AvdList with `str` items.

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "public_address": {"type": str}, "stun": {"type": Stun}}
                name: str
                """Local interface name."""
                public_address: str | None
                """Public IP assigned by NAT."""
                stun: Stun
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        public_address: str | None | UndefinedType = Undefined,
                        stun: Stun | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LocalInterfacesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Local interface name.
                            public_address: Public IP assigned by NAT.
                            stun: Subclass of AvdModel.

                        """

            class LocalInterfaces(AvdIndexedList[str, LocalInterfacesItem]):
                """Subclass of AvdIndexedList with `LocalInterfacesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            LocalInterfaces._item_type = LocalInterfacesItem

            class LocalIpsItem(AvdModel):
                """Subclass of AvdModel."""

                class Stun(AvdModel):
                    """Subclass of AvdModel."""

                    class ServerProfiles(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    ServerProfiles._item_type = str

                    _fields: ClassVar[dict] = {"server_profiles": {"type": ServerProfiles}}
                    server_profiles: ServerProfiles
                    """
                    STUN server-profile names.

                    Subclass of AvdList with `str` items.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, server_profiles: ServerProfiles | UndefinedType = Undefined) -> None:
                            """
                            Stun.


                            Subclass of AvdModel.

                            Args:
                                server_profiles:
                                   STUN server-profile names.

                                   Subclass of AvdList with `str` items.

                            """

                _fields: ClassVar[dict] = {"ip_address": {"type": str}, "public_address": {"type": str}, "stun": {"type": Stun}}
                ip_address: str
                public_address: str | None
                """Public IP assigned by NAT."""
                stun: Stun
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        public_address: str | None | UndefinedType = Undefined,
                        stun: Stun | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LocalIpsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            public_address: Public IP assigned by NAT.
                            stun: Subclass of AvdModel.

                        """

            class LocalIps(AvdIndexedList[str, LocalIpsItem]):
                """Subclass of AvdIndexedList with `LocalIpsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            LocalIps._item_type = LocalIpsItem

            class DynamicPeers(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "ip_local": {"type": bool}, "ipsec": {"type": bool}}
                enabled: bool | None
                """Enable `peer dynamic`."""
                ip_local: bool | None
                """Prefer local IP address."""
                ipsec: bool | None
                """IPsec configuration for dynamic peers."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        ip_local: bool | None | UndefinedType = Undefined,
                        ipsec: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DynamicPeers.


                        Subclass of AvdModel.

                        Args:
                            enabled: Enable `peer dynamic`.
                            ip_local: Prefer local IP address.
                            ipsec: IPsec configuration for dynamic peers.

                        """

            class StaticPeersItem(AvdModel):
                """Subclass of AvdModel."""

                class Ipv4Addresses(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Ipv4Addresses._item_type = str

                _fields: ClassVar[dict] = {"router_ip": {"type": str}, "name": {"type": str}, "ipv4_addresses": {"type": Ipv4Addresses}}
                router_ip: str
                """Peer router IP."""
                name: str | None
                """Name of the site."""
                ipv4_addresses: Ipv4Addresses
                """
                Static IPv4 addresses.

                Subclass of AvdList with `str` items.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        router_ip: str | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                        ipv4_addresses: Ipv4Addresses | UndefinedType = Undefined,
                    ) -> None:
                        """
                        StaticPeersItem.


                        Subclass of AvdModel.

                        Args:
                            router_ip: Peer router IP.
                            name: Name of the site.
                            ipv4_addresses:
                               Static IPv4 addresses.

                               Subclass of AvdList with `str` items.

                        """

            class StaticPeers(AvdIndexedList[str, StaticPeersItem]):
                """Subclass of AvdIndexedList with `StaticPeersItem` items. Primary key is `router_ip` (`str`)."""

                _primary_key: ClassVar[str] = "router_ip"

            StaticPeers._item_type = StaticPeersItem

            class Keepalive(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"auto": {"type": bool, "default": False}, "interval": {"type": int}, "failure_threshold": {"type": int}}
                auto: bool
                """
                Enable adaptive keepalive and feedback interval.

                Default value: `False`
                """
                interval: int | None
                """Interval in milliseconds."""
                failure_threshold: int | None
                """Failure threshold in number of intervals. Required when `interval` is set."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        auto: bool | UndefinedType = Undefined,
                        interval: int | None | UndefinedType = Undefined,
                        failure_threshold: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Keepalive.


                        Subclass of AvdModel.

                        Args:
                            auto: Enable adaptive keepalive and feedback interval.
                            interval: Interval in milliseconds.
                            failure_threshold: Failure threshold in number of intervals. Required when `interval` is set.

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "id": {"type": int},
                "ipsec_profile": {"type": str},
                "flow_assignment": {"type": str},
                "local_interfaces": {"type": LocalInterfaces},
                "local_ips": {"type": LocalIps},
                "dynamic_peers": {"type": DynamicPeers},
                "static_peers": {"type": StaticPeers},
                "keepalive": {"type": Keepalive},
            }
            name: str
            """Path group name."""
            id: int | None
            """Path group ID."""
            ipsec_profile: str | None
            """IPSec profile for the path group."""
            flow_assignment: Literal["lan"] | None
            """Flow assignment `lan` can not be configured in a path group with dynamic peers."""
            local_interfaces: LocalInterfaces
            """Subclass of AvdIndexedList with `LocalInterfacesItem` items. Primary key is `name` (`str`)."""
            local_ips: LocalIps
            """Subclass of AvdIndexedList with `LocalIpsItem` items. Primary key is `ip_address` (`str`)."""
            dynamic_peers: DynamicPeers
            """
            Flow assignment `lan` can not be configured in a path group with dynamic peers.

            Subclass of
            AvdModel.
            """
            static_peers: StaticPeers
            """Subclass of AvdIndexedList with `StaticPeersItem` items. Primary key is `router_ip` (`str`)."""
            keepalive: Keepalive
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    id: int | None | UndefinedType = Undefined,
                    ipsec_profile: str | None | UndefinedType = Undefined,
                    flow_assignment: Literal["lan"] | None | UndefinedType = Undefined,
                    local_interfaces: LocalInterfaces | UndefinedType = Undefined,
                    local_ips: LocalIps | UndefinedType = Undefined,
                    dynamic_peers: DynamicPeers | UndefinedType = Undefined,
                    static_peers: StaticPeers | UndefinedType = Undefined,
                    keepalive: Keepalive | UndefinedType = Undefined,
                ) -> None:
                    """
                    PathGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Path group name.
                        id: Path group ID.
                        ipsec_profile: IPSec profile for the path group.
                        flow_assignment: Flow assignment `lan` can not be configured in a path group with dynamic peers.
                        local_interfaces: Subclass of AvdIndexedList with `LocalInterfacesItem` items. Primary key is `name` (`str`).
                        local_ips: Subclass of AvdIndexedList with `LocalIpsItem` items. Primary key is `ip_address` (`str`).
                        dynamic_peers:
                           Flow assignment `lan` can not be configured in a path group with dynamic peers.

                           Subclass of
                           AvdModel.
                        static_peers: Subclass of AvdIndexedList with `StaticPeersItem` items. Primary key is `router_ip` (`str`).
                        keepalive: Subclass of AvdModel.

                    """

        class PathGroups(AvdIndexedList[str, PathGroupsItem]):
            """Subclass of AvdIndexedList with `PathGroupsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        PathGroups._item_type = PathGroupsItem

        class LoadBalancePoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class PathGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "priority": {"type": int}}
                name: str
                """Path-group name."""
                priority: int | None
                """
                Priority for this path-group.
                The EOS default value is 1.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, priority: int | None | UndefinedType = Undefined) -> None:
                        """
                        PathGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Path-group name.
                            priority:
                               Priority for this path-group.
                               The EOS default value is 1.

                        """

            class PathGroups(AvdIndexedList[str, PathGroupsItem]):
                """Subclass of AvdIndexedList with `PathGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PathGroups._item_type = PathGroupsItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "lowest_hop_count": {"type": bool},
                "jitter": {"type": int},
                "latency": {"type": int},
                "loss_rate": {"type": str},
                "path_groups": {"type": PathGroups},
            }
            name: str
            """Load-balance policy name."""
            lowest_hop_count: bool | None
            """Prefer paths with lowest hop-count."""
            jitter: int | None
            """Jitter requirement for this load balance policy in milliseconds."""
            latency: int | None
            """One way delay requirement for this load balance policy in milliseconds."""
            loss_rate: str | None
            """
            Loss Rate requirement in percentage for this load balance policy.
            Value between 0.00 and 100.00.
            """
            path_groups: PathGroups
            """
            List of path-groups to use for this load balance policy.

            Subclass of AvdIndexedList with
            `PathGroupsItem` items. Primary key is `name` (`str`).
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    lowest_hop_count: bool | None | UndefinedType = Undefined,
                    jitter: int | None | UndefinedType = Undefined,
                    latency: int | None | UndefinedType = Undefined,
                    loss_rate: str | None | UndefinedType = Undefined,
                    path_groups: PathGroups | UndefinedType = Undefined,
                ) -> None:
                    """
                    LoadBalancePoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Load-balance policy name.
                        lowest_hop_count: Prefer paths with lowest hop-count.
                        jitter: Jitter requirement for this load balance policy in milliseconds.
                        latency: One way delay requirement for this load balance policy in milliseconds.
                        loss_rate:
                           Loss Rate requirement in percentage for this load balance policy.
                           Value between 0.00 and 100.00.
                        path_groups:
                           List of path-groups to use for this load balance policy.

                           Subclass of AvdIndexedList with
                           `PathGroupsItem` items. Primary key is `name` (`str`).

                    """

        class LoadBalancePolicies(AvdIndexedList[str, LoadBalancePoliciesItem]):
            """Subclass of AvdIndexedList with `LoadBalancePoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        LoadBalancePolicies._item_type = LoadBalancePoliciesItem

        class PoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class DefaultMatch(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"load_balance": {"type": str}}
                load_balance: str | None
                """Name of the load-balance policy."""

                if TYPE_CHECKING:

                    def __init__(self, *, load_balance: str | None | UndefinedType = Undefined) -> None:
                        """
                        DefaultMatch.


                        Subclass of AvdModel.

                        Args:
                            load_balance: Name of the load-balance policy.

                        """

            class RulesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"id": {"type": int}, "application_profile": {"type": str}, "load_balance": {"type": str}}
                id: int
                """Rule ID."""
                application_profile: str
                load_balance: str | None
                """Name of the load-balance policy."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: int | UndefinedType = Undefined,
                        application_profile: str | UndefinedType = Undefined,
                        load_balance: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RulesItem.


                        Subclass of AvdModel.

                        Args:
                            id: Rule ID.
                            application_profile: application_profile
                            load_balance: Name of the load-balance policy.

                        """

            class Rules(AvdIndexedList[int, RulesItem]):
                """Subclass of AvdIndexedList with `RulesItem` items. Primary key is `id` (`int`)."""

                _primary_key: ClassVar[str] = "id"

            Rules._item_type = RulesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "default_match": {"type": DefaultMatch}, "rules": {"type": Rules}}
            name: str
            """DPS policy name."""
            default_match: DefaultMatch
            """Subclass of AvdModel."""
            rules: Rules
            """Subclass of AvdIndexedList with `RulesItem` items. Primary key is `id` (`int`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    default_match: DefaultMatch | UndefinedType = Undefined,
                    rules: Rules | UndefinedType = Undefined,
                ) -> None:
                    """
                    PoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: DPS policy name.
                        default_match: Subclass of AvdModel.
                        rules: Subclass of AvdIndexedList with `RulesItem` items. Primary key is `id` (`int`).

                    """

        class Policies(AvdIndexedList[str, PoliciesItem]):
            """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "path_selection_policy": {"type": str}}
            name: str
            """VRF name."""
            path_selection_policy: str | None
            """DPS policy name to use for this VRF."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, path_selection_policy: str | None | UndefinedType = Undefined) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        path_selection_policy: DPS policy name to use for this VRF.

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class TcpMssCeiling(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4_segment_size": {"type": str}, "ipv4": {"type": str}, "direction": {"type": str, "default": "ingress"}}
            ipv4_segment_size: str | None
            """
            Segment Size for IPv4.
            Can be an integer in the range 64-65515 or "auto".
            "auto" will enable auto-
            discovery which clamps the TCP MSS value to the minimum of all the direct paths
            and multi-hop path
            MTU towards a remote VTEP (minus 40bytes to account for IP + TCP header).
            """
            ipv4: str | None
            """
            Segment Size for IPv4.
            Can be an integer in the range 64-65515 or "auto".
            "auto" will enable auto-
            discovery which clamps the TCP MSS value to the minimum of all the direct paths
            and multi-hop path
            MTU towards a remote VTEP (minus 40bytes to account for IP + TCP header).
            """
            direction: Literal["ingress"]
            """
            Enforce on packets through DPS tunnel for a specific direction.
            Only 'ingress' direction is
            supported.

            Default value: `"ingress"`
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4_segment_size: str | None | UndefinedType = Undefined,
                    ipv4: str | None | UndefinedType = Undefined,
                    direction: Literal["ingress"] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TcpMssCeiling.


                    Subclass of AvdModel.

                    Args:
                        ipv4_segment_size:
                           Segment Size for IPv4.
                           Can be an integer in the range 64-65515 or "auto".
                           "auto" will enable auto-
                           discovery which clamps the TCP MSS value to the minimum of all the direct paths
                           and multi-hop path
                           MTU towards a remote VTEP (minus 40bytes to account for IP + TCP header).
                        ipv4:
                           Segment Size for IPv4.
                           Can be an integer in the range 64-65515 or "auto".
                           "auto" will enable auto-
                           discovery which clamps the TCP MSS value to the minimum of all the direct paths
                           and multi-hop path
                           MTU towards a remote VTEP (minus 40bytes to account for IP + TCP header).
                        direction:
                           Enforce on packets through DPS tunnel for a specific direction.
                           Only 'ingress' direction is
                           supported.

                    """

        class InterfacesItem(AvdModel):
            """Subclass of AvdModel."""

            class MetricBandwidth(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"receive": {"type": int}, "transmit": {"type": int}}
                receive: int | None
                """Maximum receive bandwidth in Mbps."""
                transmit: int | None
                """Maximum transmit bandwidth in Mbps."""

                if TYPE_CHECKING:

                    def __init__(self, *, receive: int | None | UndefinedType = Undefined, transmit: int | None | UndefinedType = Undefined) -> None:
                        """
                        MetricBandwidth.


                        Subclass of AvdModel.

                        Args:
                            receive: Maximum receive bandwidth in Mbps.
                            transmit: Maximum transmit bandwidth in Mbps.

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "metric_bandwidth": {"type": MetricBandwidth}}
            name: str
            metric_bandwidth: MetricBandwidth
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, metric_bandwidth: MetricBandwidth | UndefinedType = Undefined) -> None:
                    """
                    InterfacesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        metric_bandwidth: Subclass of AvdModel.

                    """

        class Interfaces(AvdIndexedList[str, InterfacesItem]):
            """Subclass of AvdIndexedList with `InterfacesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Interfaces._item_type = InterfacesItem

        _fields: ClassVar[dict] = {
            "peer_dynamic_source": {"type": str},
            "mtu_discovery_interval": {"type": int},
            "mtu_discovery_hosts": {"type": MtuDiscoveryHosts},
            "path_groups": {"type": PathGroups},
            "load_balance_policies": {"type": LoadBalancePolicies},
            "policies": {"type": Policies},
            "vrfs": {"type": Vrfs},
            "tcp_mss_ceiling": {"type": TcpMssCeiling},
            "interfaces": {"type": Interfaces},
        }
        peer_dynamic_source: Literal["stun"] | None
        """Source of dynamic peer discovery."""
        mtu_discovery_interval: int | None
        """MTU discovery interval in seconds."""
        mtu_discovery_hosts: MtuDiscoveryHosts
        """Subclass of AvdModel."""
        path_groups: PathGroups
        """Subclass of AvdIndexedList with `PathGroupsItem` items. Primary key is `name` (`str`)."""
        load_balance_policies: LoadBalancePolicies
        """Subclass of AvdIndexedList with `LoadBalancePoliciesItem` items. Primary key is `name` (`str`)."""
        policies: Policies
        """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        tcp_mss_ceiling: TcpMssCeiling
        """Subclass of AvdModel."""
        interfaces: Interfaces
        """Subclass of AvdIndexedList with `InterfacesItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                peer_dynamic_source: Literal["stun"] | None | UndefinedType = Undefined,
                mtu_discovery_interval: int | None | UndefinedType = Undefined,
                mtu_discovery_hosts: MtuDiscoveryHosts | UndefinedType = Undefined,
                path_groups: PathGroups | UndefinedType = Undefined,
                load_balance_policies: LoadBalancePolicies | UndefinedType = Undefined,
                policies: Policies | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                tcp_mss_ceiling: TcpMssCeiling | UndefinedType = Undefined,
                interfaces: Interfaces | UndefinedType = Undefined,
            ) -> None:
                """
                RouterPathSelection.


                Subclass of AvdModel.

                Args:
                    peer_dynamic_source: Source of dynamic peer discovery.
                    mtu_discovery_interval: MTU discovery interval in seconds.
                    mtu_discovery_hosts: Subclass of AvdModel.
                    path_groups: Subclass of AvdIndexedList with `PathGroupsItem` items. Primary key is `name` (`str`).
                    load_balance_policies: Subclass of AvdIndexedList with `LoadBalancePoliciesItem` items. Primary key is `name` (`str`).
                    policies: Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    tcp_mss_ceiling: Subclass of AvdModel.
                    interfaces: Subclass of AvdIndexedList with `InterfacesItem` items. Primary key is `name` (`str`).

                """

    class RouterPimSparseMode(AvdModel):
        """Subclass of AvdModel."""

        class Ipv4(AvdModel):
            """Subclass of AvdModel."""

            class RpAddressesItem(AvdModel):
                """Subclass of AvdModel."""

                class Groups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Groups._item_type = str

                class AccessLists(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                AccessLists._item_type = str

                _fields: ClassVar[dict] = {
                    "address": {"type": str},
                    "groups": {"type": Groups},
                    "access_lists": {"type": AccessLists},
                    "priority": {"type": int},
                    "hashmask": {"type": int},
                    "override": {"type": bool},
                }
                address: str
                """RP Address."""
                groups: Groups
                """Subclass of AvdList with `str` items."""
                access_lists: AccessLists
                """Subclass of AvdList with `str` items."""
                priority: int | None
                hashmask: int | None
                override: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        address: str | UndefinedType = Undefined,
                        groups: Groups | UndefinedType = Undefined,
                        access_lists: AccessLists | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        hashmask: int | None | UndefinedType = Undefined,
                        override: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RpAddressesItem.


                        Subclass of AvdModel.

                        Args:
                            address: RP Address.
                            groups: Subclass of AvdList with `str` items.
                            access_lists: Subclass of AvdList with `str` items.
                            priority: priority
                            hashmask: hashmask
                            override: override

                        """

            class RpAddresses(AvdList[RpAddressesItem]):
                """Subclass of AvdList with `RpAddressesItem` items."""

            RpAddresses._item_type = RpAddressesItem

            class AnycastRpsItem(AvdModel):
                """Subclass of AvdModel."""

                class OtherAnycastRpAddressesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"address": {"type": str}, "register_count": {"type": int}}
                    address: str
                    """Other Anycast RP Address."""
                    register_count: int | None

                    if TYPE_CHECKING:

                        def __init__(self, *, address: str | UndefinedType = Undefined, register_count: int | None | UndefinedType = Undefined) -> None:
                            """
                            OtherAnycastRpAddressesItem.


                            Subclass of AvdModel.

                            Args:
                                address: Other Anycast RP Address.
                                register_count: register_count

                            """

                class OtherAnycastRpAddresses(AvdIndexedList[str, OtherAnycastRpAddressesItem]):
                    """
                    Subclass of AvdIndexedList with `OtherAnycastRpAddressesItem` items. Primary key is `address`
                    (`str`).
                    """

                    _primary_key: ClassVar[str] = "address"

                OtherAnycastRpAddresses._item_type = OtherAnycastRpAddressesItem

                _fields: ClassVar[dict] = {"address": {"type": str}, "other_anycast_rp_addresses": {"type": OtherAnycastRpAddresses}}
                address: str
                """Anycast RP Address."""
                other_anycast_rp_addresses: OtherAnycastRpAddresses
                """
                Subclass of AvdIndexedList with `OtherAnycastRpAddressesItem` items. Primary key is `address`
                (`str`).
                """

                if TYPE_CHECKING:

                    def __init__(
                        self, *, address: str | UndefinedType = Undefined, other_anycast_rp_addresses: OtherAnycastRpAddresses | UndefinedType = Undefined
                    ) -> None:
                        """
                        AnycastRpsItem.


                        Subclass of AvdModel.

                        Args:
                            address: Anycast RP Address.
                            other_anycast_rp_addresses:
                               Subclass of AvdIndexedList with `OtherAnycastRpAddressesItem` items. Primary key is `address`
                               (`str`).

                        """

            class AnycastRps(AvdIndexedList[str, AnycastRpsItem]):
                """Subclass of AvdIndexedList with `AnycastRpsItem` items. Primary key is `address` (`str`)."""

                _primary_key: ClassVar[str] = "address"

            AnycastRps._item_type = AnycastRpsItem

            _fields: ClassVar[dict] = {
                "bfd": {"type": bool},
                "make_before_break": {"type": bool},
                "ssm_range": {"type": str},
                "rp_addresses": {"type": RpAddresses},
                "anycast_rps": {"type": AnycastRps},
            }
            bfd: bool | None
            """Enable/Disable BFD."""
            make_before_break: bool | None
            """Enable/Disable Make-Before-Break."""
            ssm_range: str | None
            """IPv4 Prefix associated with SSM."""
            rp_addresses: RpAddresses
            """Subclass of AvdList with `RpAddressesItem` items."""
            anycast_rps: AnycastRps
            """Subclass of AvdIndexedList with `AnycastRpsItem` items. Primary key is `address` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bfd: bool | None | UndefinedType = Undefined,
                    make_before_break: bool | None | UndefinedType = Undefined,
                    ssm_range: str | None | UndefinedType = Undefined,
                    rp_addresses: RpAddresses | UndefinedType = Undefined,
                    anycast_rps: AnycastRps | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4.


                    Subclass of AvdModel.

                    Args:
                        bfd: Enable/Disable BFD.
                        make_before_break: Enable/Disable Make-Before-Break.
                        ssm_range: IPv4 Prefix associated with SSM.
                        rp_addresses: Subclass of AvdList with `RpAddressesItem` items.
                        anycast_rps: Subclass of AvdIndexedList with `AnycastRpsItem` items. Primary key is `address` (`str`).

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class RpAddressesItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Groups(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Groups._item_type = str

                    class AccessLists(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    AccessLists._item_type = str

                    _fields: ClassVar[dict] = {
                        "address": {"type": str},
                        "groups": {"type": Groups},
                        "access_lists": {"type": AccessLists},
                        "priority": {"type": int},
                        "hashmask": {"type": int},
                        "override": {"type": bool},
                    }
                    address: str
                    """RP Address."""
                    groups: Groups
                    """Subclass of AvdList with `str` items."""
                    access_lists: AccessLists
                    """Subclass of AvdList with `str` items."""
                    priority: int | None
                    hashmask: int | None
                    override: bool | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            address: str | UndefinedType = Undefined,
                            groups: Groups | UndefinedType = Undefined,
                            access_lists: AccessLists | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            hashmask: int | None | UndefinedType = Undefined,
                            override: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RpAddressesItem.


                            Subclass of AvdModel.

                            Args:
                                address: RP Address.
                                groups: Subclass of AvdList with `str` items.
                                access_lists: Subclass of AvdList with `str` items.
                                priority: priority
                                hashmask: hashmask
                                override: override

                            """

                class RpAddresses(AvdList[RpAddressesItem]):
                    """Subclass of AvdList with `RpAddressesItem` items."""

                RpAddresses._item_type = RpAddressesItem

                _fields: ClassVar[dict] = {"bfd": {"type": bool}, "make_before_break": {"type": bool}, "rp_addresses": {"type": RpAddresses}}
                bfd: bool | None
                """Enable/Disable BFD."""
                make_before_break: bool | None
                """Enable/Disable Make-Before-Break."""
                rp_addresses: RpAddresses
                """Subclass of AvdList with `RpAddressesItem` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bfd: bool | None | UndefinedType = Undefined,
                        make_before_break: bool | None | UndefinedType = Undefined,
                        rp_addresses: RpAddresses | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            bfd: Enable/Disable BFD.
                            make_before_break: Enable/Disable Make-Before-Break.
                            rp_addresses: Subclass of AvdList with `RpAddressesItem` items.

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "ipv4": {"type": Ipv4}}
            name: str
            """VRF Name."""
            ipv4: Ipv4
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, ipv4: Ipv4 | UndefinedType = Undefined) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF Name.
                        ipv4: Subclass of AvdModel.

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "vrfs": {"type": Vrfs}}
        ipv4: Ipv4
        """Subclass of AvdModel."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(self, *, ipv4: Ipv4 | UndefinedType = Undefined, vrfs: Vrfs | UndefinedType = Undefined) -> None:
                """
                RouterPimSparseMode.


                Subclass of AvdModel.

                Args:
                    ipv4: Subclass of AvdModel.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).

                """

    class RouterRip(AvdModel):
        """Subclass of AvdModel."""

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class Networks(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Networks._item_type = str

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "vrf": {"type": str}, "metric_default": {"type": int}, "networks": {"type": Networks}}
            enabled: bool | None
            vrf: str
            metric_default: int | None
            """Set default metric for the routes."""
            networks: Networks
            """Subclass of AvdList with `str` items."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    vrf: str | UndefinedType = Undefined,
                    metric_default: int | None | UndefinedType = Undefined,
                    networks: Networks | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        vrf: vrf
                        metric_default: Set default metric for the routes.
                        networks: Subclass of AvdList with `str` items.

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `vrf` (`str`)."""

            _primary_key: ClassVar[str] = "vrf"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {"vrfs": {"type": Vrfs}}
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `vrf` (`str`)."""

        if TYPE_CHECKING:

            def __init__(self, *, vrfs: Vrfs | UndefinedType = Undefined) -> None:
                """
                RouterRip.


                Subclass of AvdModel.

                Args:
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `vrf` (`str`).

                """

    class RouterSegmentSecurity(AvdModel):
        """Subclass of AvdModel."""

        class PoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class SequenceNumbersItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "sequence": {"type": int},
                    "application": {"type": str},
                    "action": {"type": str},
                    "log": {"type": bool},
                    "stateless": {"type": bool, "default": True},
                    "next_hop": {"type": str},
                }
                sequence: int
                """Sequence ID."""
                application: str
                """The name of the application."""
                action: Literal["forward", "drop", "redirect"]
                """
                The action to take - note that platform support for the redirect action is limited. The "redirect"
                action also requires the 'next_hop' to be configured.
                """
                log: bool | None
                """Enable logging - note that platform support is limited."""
                stateless: bool
                """
                Take action, regardless of state. Should be set to 'true' for MSS-G.

                Default value: `True`
                """
                next_hop: str | None
                """When the action is 'redirect', this indicates the IPv4 next hop to redirect to."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        sequence: int | UndefinedType = Undefined,
                        application: str | UndefinedType = Undefined,
                        action: Literal["forward", "drop", "redirect"] | UndefinedType = Undefined,
                        log: bool | None | UndefinedType = Undefined,
                        stateless: bool | UndefinedType = Undefined,
                        next_hop: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SequenceNumbersItem.


                        Subclass of AvdModel.

                        Args:
                            sequence: Sequence ID.
                            application: The name of the application.
                            action:
                               The action to take - note that platform support for the redirect action is limited. The "redirect"
                               action also requires the 'next_hop' to be configured.
                            log: Enable logging - note that platform support is limited.
                            stateless: Take action, regardless of state. Should be set to 'true' for MSS-G.
                            next_hop: When the action is 'redirect', this indicates the IPv4 next hop to redirect to.

                        """

            class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
                """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

                _primary_key: ClassVar[str] = "sequence"

            SequenceNumbers._item_type = SequenceNumbersItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
            name: str
            """Policy name."""
            sequence_numbers: SequenceNumbers
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, sequence_numbers: SequenceNumbers | UndefinedType = Undefined) -> None:
                    """
                    PoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Policy name.
                        sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).

                    """

        class Policies(AvdIndexedList[str, PoliciesItem]):
            """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class SegmentsItem(AvdModel):
                """Subclass of AvdModel."""

                class Definition(AvdModel):
                    """Subclass of AvdModel."""

                    class Interfaces(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Interfaces._item_type = str

                    class MatchListsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"address_family": {"type": str}, "covered_prefix_list": {"type": str}, "prefix": {"type": str}}
                        address_family: Literal["ipv4", "ipv6"]
                        """Indicate which address-family the match list belongs to e.g. ipv4 or ipv6."""
                        covered_prefix_list: str | None
                        """
                        The name of the prefix-list. You can have a maximum of one per address-family. Mutually exclusive to
                        the use of match_list.  If both are configured prefix takes precedence.
                        """
                        prefix: str | None
                        """
                        The name of the match-list. You can have a maximum of one per address-family. Mutually exclusive to
                        the use of covered_prefix_list. If both are configured prefix takes precedence.
                        """

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                address_family: Literal["ipv4", "ipv6"] | UndefinedType = Undefined,
                                covered_prefix_list: str | None | UndefinedType = Undefined,
                                prefix: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchListsItem.


                                Subclass of AvdModel.

                                Args:
                                    address_family: Indicate which address-family the match list belongs to e.g. ipv4 or ipv6.
                                    covered_prefix_list:
                                       The name of the prefix-list. You can have a maximum of one per address-family. Mutually exclusive to
                                       the use of match_list.  If both are configured prefix takes precedence.
                                    prefix:
                                       The name of the match-list. You can have a maximum of one per address-family. Mutually exclusive to
                                       the use of covered_prefix_list. If both are configured prefix takes precedence.

                                """

                    class MatchLists(AvdIndexedList[str, MatchListsItem]):
                        """Subclass of AvdIndexedList with `MatchListsItem` items. Primary key is `address_family` (`str`)."""

                        _primary_key: ClassVar[str] = "address_family"

                    MatchLists._item_type = MatchListsItem

                    _fields: ClassVar[dict] = {"interfaces": {"type": Interfaces}, "match_lists": {"type": MatchLists}}
                    interfaces: Interfaces
                    """
                    The names of the source interface e.g. Port-Channel1 - note that platform support is limited.
                    Subclass of AvdList with `str` items.
                    """
                    match_lists: MatchLists
                    """
                    The set of lists that define the segment. These can be a mix of IPv4 and IPv6 prefix or match lists.
                    Subclass of AvdIndexedList with `MatchListsItem` items. Primary key is `address_family` (`str`).
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, interfaces: Interfaces | UndefinedType = Undefined, match_lists: MatchLists | UndefinedType = Undefined) -> None:
                            """
                            Definition.


                            Subclass of AvdModel.

                            Args:
                                interfaces:
                                   The names of the source interface e.g. Port-Channel1 - note that platform support is limited.
                                   Subclass of AvdList with `str` items.
                                match_lists:
                                   The set of lists that define the segment. These can be a mix of IPv4 and IPv6 prefix or match lists.
                                   Subclass of AvdIndexedList with `MatchListsItem` items. Primary key is `address_family` (`str`).

                            """

                class PoliciesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"field_from": {"type": str}, "policy": {"type": str}}
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str
                    """The name of the source segment or 'forwarding-segments' for all segments."""
                    policy: str | None
                    """
                    The name of the policy to apply. The built-in policies are 'policy-forward-all' and 'policy-drop-
                    all'.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, field_from: str | UndefinedType = Undefined, policy: str | None | UndefinedType = Undefined) -> None:
                            """
                            PoliciesItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: The name of the source segment or 'forwarding-segments' for all segments.
                                policy:
                                   The name of the policy to apply. The built-in policies are 'policy-forward-all' and 'policy-drop-
                                   all'.

                            """

                class Policies(AvdIndexedList[str, PoliciesItem]):
                    """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `field_from` (`str`)."""

                    _primary_key: ClassVar[str] = "field_from"

                Policies._item_type = PoliciesItem

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "definition": {"type": Definition},
                    "policies": {"type": Policies},
                    "fallback_policy": {"type": str},
                }
                name: str
                """Segment name."""
                definition: Definition
                """Subclass of AvdModel."""
                policies: Policies
                """
                The policies controlling traffic into the segment.

                Subclass of AvdIndexedList with `PoliciesItem`
                items. Primary key is `field_from` (`str`).
                """
                fallback_policy: str | None
                """
                Only supported on the R3 series platforms, this allows a per-segment default policy to be specified
                by name.
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        definition: Definition | UndefinedType = Undefined,
                        policies: Policies | UndefinedType = Undefined,
                        fallback_policy: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SegmentsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Segment name.
                            definition: Subclass of AvdModel.
                            policies:
                               The policies controlling traffic into the segment.

                               Subclass of AvdIndexedList with `PoliciesItem`
                               items. Primary key is `field_from` (`str`).
                            fallback_policy:
                               Only supported on the R3 series platforms, this allows a per-segment default policy to be specified
                               by name.

                        """

            class Segments(AvdIndexedList[str, SegmentsItem]):
                """Subclass of AvdIndexedList with `SegmentsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Segments._item_type = SegmentsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "segments": {"type": Segments}}
            name: str
            segments: Segments
            """Subclass of AvdIndexedList with `SegmentsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, segments: Segments | UndefinedType = Undefined) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        segments: Subclass of AvdIndexedList with `SegmentsItem` items. Primary key is `name` (`str`).

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "policies": {"type": Policies}, "vrfs": {"type": Vrfs}}
        enabled: bool | None
        policies: Policies
        """
        Customised application policies.
        Using the Application Traffic Recognition L4 profiles, custom
        policies can be defined. The built-in application 'app-match-all' can be used to match any packets.
        Note that this is stateless, so both the source and destination flows need to be considered.
        Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).
        """
        vrfs: Vrfs
        """
        The name of the VRF that the segments and policies are defined in.

        Subclass of AvdIndexedList with
        `VrfsItem` items. Primary key is `name` (`str`).
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enabled: bool | None | UndefinedType = Undefined,
                policies: Policies | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
            ) -> None:
                """
                RouterSegmentSecurity.


                Subclass of AvdModel.

                Args:
                    enabled: enabled
                    policies:
                       Customised application policies.
                       Using the Application Traffic Recognition L4 profiles, custom
                       policies can be defined. The built-in application 'app-match-all' can be used to match any packets.
                       Note that this is stateless, so both the source and destination flows need to be considered.
                       Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).
                    vrfs:
                       The name of the VRF that the segments and policies are defined in.

                       Subclass of AvdIndexedList with
                       `VrfsItem` items. Primary key is `name` (`str`).

                """

    class RouterServiceInsertion(AvdModel):
        """Subclass of AvdModel."""

        class ConnectionsItem(AvdModel):
            """Subclass of AvdModel."""

            class EthernetInterface(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "next_hop": {"type": str}}
                name: str
                """e.g. Ethernet2 or Ethernet2/2.2"""
                next_hop: str
                """Next-hop IPv4 address (without mask)."""

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, next_hop: str | UndefinedType = Undefined) -> None:
                        """
                        EthernetInterface.


                        Subclass of AvdModel.

                        Args:
                            name: e.g. Ethernet2 or Ethernet2/2.2
                            next_hop: Next-hop IPv4 address (without mask).

                        """

            class TunnelInterface(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"primary": {"type": str}, "secondary": {"type": str}}
                primary: str | None
                """e.g. Tunnel2"""
                secondary: str | None
                """e.g. Tunnel3"""

                if TYPE_CHECKING:

                    def __init__(self, *, primary: str | None | UndefinedType = Undefined, secondary: str | None | UndefinedType = Undefined) -> None:
                        """
                        TunnelInterface.


                        Subclass of AvdModel.

                        Args:
                            primary: e.g. Tunnel2
                            secondary: e.g. Tunnel3

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "ethernet_interface": {"type": EthernetInterface},
                "tunnel_interface": {"type": TunnelInterface},
                "monitor_connectivity_host": {"type": str},
            }
            name: str
            """Connection name."""
            ethernet_interface: EthernetInterface
            """
            Outgoing physical interface or subinterface to use for the connection.
            If both `ethernet_interface`
            and `tunnel_interface` are configured, `ethernet_interface` will be used.

            Subclass of AvdModel.
            """
            tunnel_interface: TunnelInterface
            """
            Outgoing tunnel interface(s) to use for this connection.
            If both `ethernet_interface` and
            `tunnel_interface` are configured, `ethernet_interface` will be used.

            Subclass of AvdModel.
            """
            monitor_connectivity_host: str | None
            """
            Name of the host defined under `monitor_connectivity.hosts` used to derive the health of the
            connection.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    ethernet_interface: EthernetInterface | UndefinedType = Undefined,
                    tunnel_interface: TunnelInterface | UndefinedType = Undefined,
                    monitor_connectivity_host: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ConnectionsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Connection name.
                        ethernet_interface:
                           Outgoing physical interface or subinterface to use for the connection.
                           If both `ethernet_interface`
                           and `tunnel_interface` are configured, `ethernet_interface` will be used.

                           Subclass of AvdModel.
                        tunnel_interface:
                           Outgoing tunnel interface(s) to use for this connection.
                           If both `ethernet_interface` and
                           `tunnel_interface` are configured, `ethernet_interface` will be used.

                           Subclass of AvdModel.
                        monitor_connectivity_host:
                           Name of the host defined under `monitor_connectivity.hosts` used to derive the health of the
                           connection.

                    """

        class Connections(AvdIndexedList[str, ConnectionsItem]):
            """Subclass of AvdIndexedList with `ConnectionsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Connections._item_type = ConnectionsItem

        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "connections": {"type": Connections}}
        enabled: bool | None
        connections: Connections
        """Subclass of AvdIndexedList with `ConnectionsItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, connections: Connections | UndefinedType = Undefined) -> None:
                """
                RouterServiceInsertion.


                Subclass of AvdModel.

                Args:
                    enabled: enabled
                    connections: Subclass of AvdIndexedList with `ConnectionsItem` items. Primary key is `name` (`str`).

                """

    class RouterTrafficEngineering(AvdModel):
        """Subclass of AvdModel."""

        class RouterId(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4": {"type": str}, "ipv6": {"type": str}}
            ipv4: str | None
            ipv6: str | None

            if TYPE_CHECKING:

                def __init__(self, *, ipv4: str | None | UndefinedType = Undefined, ipv6: str | None | UndefinedType = Undefined) -> None:
                    """
                    RouterId.


                    Subclass of AvdModel.

                    Args:
                        ipv4: ipv4
                        ipv6: ipv6

                    """

        class SegmentRouting(AvdModel):
            """Subclass of AvdModel."""

            class PolicyEndpointsItem(AvdModel):
                """Subclass of AvdModel."""

                class ColorsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class PathGroupItem(AvdModel):
                        """Subclass of AvdModel."""

                        class SegmentListItem(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"label_stack": {"type": str}, "weight": {"type": int}, "index": {"type": int}}
                            label_stack: str | None
                            """
                            Label Stack as string.
                            Example: "100 2000 30"
                            """
                            weight: int | None
                            index: int | None

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    label_stack: str | None | UndefinedType = Undefined,
                                    weight: int | None | UndefinedType = Undefined,
                                    index: int | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    SegmentListItem.


                                    Subclass of AvdModel.

                                    Args:
                                        label_stack:
                                           Label Stack as string.
                                           Example: "100 2000 30"
                                        weight: weight
                                        index: index

                                    """

                        class SegmentList(AvdList[SegmentListItem]):
                            """Subclass of AvdList with `SegmentListItem` items."""

                        SegmentList._item_type = SegmentListItem

                        _fields: ClassVar[dict] = {"preference": {"type": int}, "explicit_null": {"type": str}, "segment_list": {"type": SegmentList}}
                        preference: int | None
                        explicit_null: Literal["ipv4", "ipv6", "ipv4 ipv6", "none"] | None
                        segment_list: SegmentList
                        """Subclass of AvdList with `SegmentListItem` items."""

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                preference: int | None | UndefinedType = Undefined,
                                explicit_null: Literal["ipv4", "ipv6", "ipv4 ipv6", "none"] | None | UndefinedType = Undefined,
                                segment_list: SegmentList | UndefinedType = Undefined,
                            ) -> None:
                                """
                                PathGroupItem.


                                Subclass of AvdModel.

                                Args:
                                    preference: preference
                                    explicit_null: explicit_null
                                    segment_list: Subclass of AvdList with `SegmentListItem` items.

                                """

                    class PathGroup(AvdList[PathGroupItem]):
                        """Subclass of AvdList with `PathGroupItem` items."""

                    PathGroup._item_type = PathGroupItem

                    _fields: ClassVar[dict] = {
                        "value": {"type": int},
                        "binding_sid": {"type": int},
                        "description": {"type": str},
                        "name": {"type": str},
                        "sbfd_remote_discriminator": {"type": str},
                        "path_group": {"type": PathGroup},
                    }
                    value: int
                    binding_sid: int | None
                    description: str | None
                    name: str | None
                    sbfd_remote_discriminator: str | None
                    """IPv4 address or 32 bit integer."""
                    path_group: PathGroup
                    """Subclass of AvdList with `PathGroupItem` items."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            value: int | UndefinedType = Undefined,
                            binding_sid: int | None | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            sbfd_remote_discriminator: str | None | UndefinedType = Undefined,
                            path_group: PathGroup | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ColorsItem.


                            Subclass of AvdModel.

                            Args:
                                value: value
                                binding_sid: binding_sid
                                description: description
                                name: name
                                sbfd_remote_discriminator: IPv4 address or 32 bit integer.
                                path_group: Subclass of AvdList with `PathGroupItem` items.

                            """

                class Colors(AvdIndexedList[int, ColorsItem]):
                    """Subclass of AvdIndexedList with `ColorsItem` items. Primary key is `value` (`int`)."""

                    _primary_key: ClassVar[str] = "value"

                Colors._item_type = ColorsItem

                _fields: ClassVar[dict] = {"address": {"type": str}, "colors": {"type": Colors}}
                address: str | None
                """IPv4 or IPv6 address."""
                colors: Colors
                """Subclass of AvdIndexedList with `ColorsItem` items. Primary key is `value` (`int`)."""

                if TYPE_CHECKING:

                    def __init__(self, *, address: str | None | UndefinedType = Undefined, colors: Colors | UndefinedType = Undefined) -> None:
                        """
                        PolicyEndpointsItem.


                        Subclass of AvdModel.

                        Args:
                            address: IPv4 or IPv6 address.
                            colors: Subclass of AvdIndexedList with `ColorsItem` items. Primary key is `value` (`int`).

                        """

            class PolicyEndpoints(AvdList[PolicyEndpointsItem]):
                """Subclass of AvdList with `PolicyEndpointsItem` items."""

            PolicyEndpoints._item_type = PolicyEndpointsItem

            _fields: ClassVar[dict] = {"colored_tunnel_rib": {"type": bool}, "policy_endpoints": {"type": PolicyEndpoints}}
            colored_tunnel_rib: bool | None
            policy_endpoints: PolicyEndpoints
            """Subclass of AvdList with `PolicyEndpointsItem` items."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, colored_tunnel_rib: bool | None | UndefinedType = Undefined, policy_endpoints: PolicyEndpoints | UndefinedType = Undefined
                ) -> None:
                    """
                    SegmentRouting.


                    Subclass of AvdModel.

                    Args:
                        colored_tunnel_rib: colored_tunnel_rib
                        policy_endpoints: Subclass of AvdList with `PolicyEndpointsItem` items.

                    """

        class FlexAlgosItem(AvdModel):
            """Subclass of AvdModel."""

            class AdministrativeGroup(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"include_all": {"type": str}, "include_any": {"type": str}, "exclude": {"type": str}}
                include_all: str | None
                """
                Comma-separated list of individual group numbers in decimal (0-127), hexadecimal, named or decimal
                range (A-B, where value of A must be less than the value of B) formats. Example. 0xA,RED,31-33,127
                """
                include_any: str | None
                """
                Comma-separated list of individual group numbers in decimal (0-127), hexadecimal, named or decimal
                range (A-B, where value of A must be less than the value of B) formats. Example. 0xA,RED,31-33,127
                """
                exclude: str | None
                """
                Comma-separated list of individual group numbers in decimal (0-127), hexadecimal, named or decimal
                range (A-B, where value of A must be less than the value of B) formats. Example. 0xA,RED,31-33,127
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        include_all: str | None | UndefinedType = Undefined,
                        include_any: str | None | UndefinedType = Undefined,
                        exclude: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdministrativeGroup.


                        Subclass of AvdModel.

                        Args:
                            include_all:
                               Comma-separated list of individual group numbers in decimal (0-127), hexadecimal, named or decimal
                               range (A-B, where value of A must be less than the value of B) formats. Example. 0xA,RED,31-33,127
                            include_any:
                               Comma-separated list of individual group numbers in decimal (0-127), hexadecimal, named or decimal
                               range (A-B, where value of A must be less than the value of B) formats. Example. 0xA,RED,31-33,127
                            exclude:
                               Comma-separated list of individual group numbers in decimal (0-127), hexadecimal, named or decimal
                               range (A-B, where value of A must be less than the value of B) formats. Example. 0xA,RED,31-33,127

                        """

            _fields: ClassVar[dict] = {
                "number": {"type": int},
                "name": {"type": str},
                "administrative_group": {"type": AdministrativeGroup},
                "metric": {"type": str},
                "priority": {"type": int},
                "color": {"type": int},
                "srlg_exclude": {"type": str},
            }
            number: int
            """Flex-algo number, must be unique across all flex-algo definitions."""
            name: str
            """Flex-algo name, must be unique across all flex-algo definitions."""
            administrative_group: AdministrativeGroup
            """Subclass of AvdModel."""
            metric: Literal["0", "1", "2", "igp-metric", "min-delay", "te-metric"] | None
            """
            Metric can be specified as an integer or named type, 0 = igp-metric, 1 = min-delay, 2 = te-metric.
            Device CLI will show the name regardless.
            """
            priority: int | None
            color: int | None
            srlg_exclude: str | None
            """
            Comma-separated list of individual SRLG numbers in decimal (0-4294967295), named or decimal range
            (A-B, where value of A must be less than the value of B) formats. Example. 30-34,55,RED
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    number: int | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    administrative_group: AdministrativeGroup | UndefinedType = Undefined,
                    metric: Literal["0", "1", "2", "igp-metric", "min-delay", "te-metric"] | None | UndefinedType = Undefined,
                    priority: int | None | UndefinedType = Undefined,
                    color: int | None | UndefinedType = Undefined,
                    srlg_exclude: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    FlexAlgosItem.


                    Subclass of AvdModel.

                    Args:
                        number: Flex-algo number, must be unique across all flex-algo definitions.
                        name: Flex-algo name, must be unique across all flex-algo definitions.
                        administrative_group: Subclass of AvdModel.
                        metric:
                           Metric can be specified as an integer or named type, 0 = igp-metric, 1 = min-delay, 2 = te-metric.
                           Device CLI will show the name regardless.
                        priority: priority
                        color: color
                        srlg_exclude:
                           Comma-separated list of individual SRLG numbers in decimal (0-4294967295), named or decimal range
                           (A-B, where value of A must be less than the value of B) formats. Example. 30-34,55,RED

                    """

        class FlexAlgos(AvdIndexedList[int, FlexAlgosItem]):
            """Subclass of AvdIndexedList with `FlexAlgosItem` items. Primary key is `number` (`int`)."""

            _primary_key: ClassVar[str] = "number"

        FlexAlgos._item_type = FlexAlgosItem

        _fields: ClassVar[dict] = {
            "enabled": {"type": bool},
            "router_id": {"type": RouterId},
            "segment_routing": {"type": SegmentRouting},
            "twamp_light_sender_profile": {"type": str},
            "flex_algos": {"type": FlexAlgos},
        }
        enabled: bool
        router_id: RouterId
        """Subclass of AvdModel."""
        segment_routing: SegmentRouting
        """Subclass of AvdModel."""
        twamp_light_sender_profile: str | None
        """Apply a twamp-light sender profile, defined under monitor_twamp.twamp_light.sender_profiles."""
        flex_algos: FlexAlgos
        """Subclass of AvdIndexedList with `FlexAlgosItem` items. Primary key is `number` (`int`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enabled: bool | UndefinedType = Undefined,
                router_id: RouterId | UndefinedType = Undefined,
                segment_routing: SegmentRouting | UndefinedType = Undefined,
                twamp_light_sender_profile: str | None | UndefinedType = Undefined,
                flex_algos: FlexAlgos | UndefinedType = Undefined,
            ) -> None:
                """
                RouterTrafficEngineering.


                Subclass of AvdModel.

                Args:
                    enabled: enabled
                    router_id: Subclass of AvdModel.
                    segment_routing: Subclass of AvdModel.
                    twamp_light_sender_profile: Apply a twamp-light sender profile, defined under monitor_twamp.twamp_light.sender_profiles.
                    flex_algos: Subclass of AvdIndexedList with `FlexAlgosItem` items. Primary key is `number` (`int`).

                """

    class ServiceRoutingConfigurationBgp(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"no_equals_default": {"type": bool}}
        no_equals_default: bool | None

        if TYPE_CHECKING:

            def __init__(self, *, no_equals_default: bool | None | UndefinedType = Undefined) -> None:
                """
                ServiceRoutingConfigurationBgp.


                Subclass of AvdModel.

                Args:
                    no_equals_default: no_equals_default

                """

    class ServiceUnsupportedTransceiver(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"license_name": {"type": str}, "license_key": {"type": str}}
        license_name: str | None
        license_key: str | None

        if TYPE_CHECKING:

            def __init__(self, *, license_name: str | None | UndefinedType = Undefined, license_key: str | None | UndefinedType = Undefined) -> None:
                """
                ServiceUnsupportedTransceiver.


                Subclass of AvdModel.

                Args:
                    license_name: license_name
                    license_key: license_key

                """

    class Sflow(AvdModel):
        """Subclass of AvdModel."""

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class DestinationsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"destination": {"type": str}, "port": {"type": int}}
                destination: str
                """Sflow Destination IP Address."""
                port: int | None
                """Port Number"""

                if TYPE_CHECKING:

                    def __init__(self, *, destination: str | UndefinedType = Undefined, port: int | None | UndefinedType = Undefined) -> None:
                        """
                        DestinationsItem.


                        Subclass of AvdModel.

                        Args:
                            destination: Sflow Destination IP Address.
                            port: Port Number

                        """

            class Destinations(AvdIndexedList[str, DestinationsItem]):
                """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`)."""

                _primary_key: ClassVar[str] = "destination"

            Destinations._item_type = DestinationsItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "destinations": {"type": Destinations},
                "source": {"type": str},
                "source_interface": {"type": str},
            }
            name: str
            destinations: Destinations
            """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`)."""
            source: str | None
            """
            Source IP Address.
            "source" and "source_interface" are mutually exclusive. If both are defined,
            "source_interface" takes precedence.
            """
            source_interface: str | None
            """Source Interface."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    destinations: Destinations | UndefinedType = Undefined,
                    source: str | None | UndefinedType = Undefined,
                    source_interface: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        destinations: Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`).
                        source:
                           Source IP Address.
                           "source" and "source_interface" are mutually exclusive. If both are defined,
                           "source_interface" takes precedence.
                        source_interface: Source Interface.

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class DestinationsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"destination": {"type": str}, "port": {"type": int}}
            destination: str
            """Sflow Destination IP Address."""
            port: int | None
            """Port Number."""

            if TYPE_CHECKING:

                def __init__(self, *, destination: str | UndefinedType = Undefined, port: int | None | UndefinedType = Undefined) -> None:
                    """
                    DestinationsItem.


                    Subclass of AvdModel.

                    Args:
                        destination: Sflow Destination IP Address.
                        port: Port Number.

                    """

        class Destinations(AvdIndexedList[str, DestinationsItem]):
            """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`)."""

            _primary_key: ClassVar[str] = "destination"

        Destinations._item_type = DestinationsItem

        class ExtensionsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "enabled": {"type": bool}}
            name: str
            """Extension Name."""
            enabled: bool
            """Enable or Disable Extension."""

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, enabled: bool | UndefinedType = Undefined) -> None:
                    """
                    ExtensionsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Extension Name.
                        enabled: Enable or Disable Extension.

                    """

        class Extensions(AvdIndexedList[str, ExtensionsItem]):
            """Subclass of AvdIndexedList with `ExtensionsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Extensions._item_type = ExtensionsItem

        class Interface(AvdModel):
            """Subclass of AvdModel."""

            class Disable(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"default": {"type": bool}}
                default: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, default: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Disable.


                        Subclass of AvdModel.

                        Args:
                            default: default

                        """

            class Egress(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enable_default": {"type": bool}, "unmodified": {"type": bool}}
                enable_default: bool | None
                """Enable egress sFlow by default."""
                unmodified: bool | None
                """
                Enable egress sFlow unmodified.
                Platform dependent feature.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, enable_default: bool | None | UndefinedType = Undefined, unmodified: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Egress.


                        Subclass of AvdModel.

                        Args:
                            enable_default: Enable egress sFlow by default.
                            unmodified:
                               Enable egress sFlow unmodified.
                               Platform dependent feature.

                        """

            _fields: ClassVar[dict] = {"disable": {"type": Disable}, "egress": {"type": Egress}}
            disable: Disable
            """Subclass of AvdModel."""
            egress: Egress
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, disable: Disable | UndefinedType = Undefined, egress: Egress | UndefinedType = Undefined) -> None:
                    """
                    Interface.


                    Subclass of AvdModel.

                    Args:
                        disable: Subclass of AvdModel.
                        egress: Subclass of AvdModel.

                    """

        class HardwareAcceleration(AvdModel):
            """Subclass of AvdModel."""

            class ModulesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "enabled": {"type": bool, "default": True}}
                name: str
                enabled: bool
                """Default value: `True`"""

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, enabled: bool | UndefinedType = Undefined) -> None:
                        """
                        ModulesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            enabled: enabled

                        """

            class Modules(AvdIndexedList[str, ModulesItem]):
                """Subclass of AvdIndexedList with `ModulesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Modules._item_type = ModulesItem

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "sample": {"type": int}, "modules": {"type": Modules}}
            enabled: bool | None
            sample: int | None
            modules: Modules
            """Subclass of AvdIndexedList with `ModulesItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    sample: int | None | UndefinedType = Undefined,
                    modules: Modules | UndefinedType = Undefined,
                ) -> None:
                    """
                    HardwareAcceleration.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        sample: sample
                        modules: Subclass of AvdIndexedList with `ModulesItem` items. Primary key is `name` (`str`).

                    """

        _fields: ClassVar[dict] = {
            "sample": {"type": int},
            "sample_truncate_size": {"type": int},
            "sample_input_subinterface": {"type": bool},
            "sample_output_subinterface": {"type": bool},
            "dangerous": {"type": bool},
            "polling_interval": {"type": int},
            "vrfs": {"type": Vrfs},
            "destinations": {"type": Destinations},
            "source": {"type": str},
            "source_interface": {"type": str},
            "extensions": {"type": Extensions},
            "interface": {"type": Interface},
            "run": {"type": bool},
            "hardware_acceleration": {"type": HardwareAcceleration},
        }
        sample: int | None
        sample_truncate_size: int | None
        """Maximum sample size, in bytes."""
        sample_input_subinterface: bool | None
        sample_output_subinterface: bool | None
        dangerous: bool | None
        polling_interval: int | None
        """Polling interval in seconds."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        destinations: Destinations
        """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`)."""
        source: str | None
        """
        Source IP Address.
        "source" and "source_interface" are mutually exclusive. If both are defined,
        "source_interface" takes precedence.
        """
        source_interface: str | None
        """Source Interface."""
        extensions: Extensions
        """Subclass of AvdIndexedList with `ExtensionsItem` items. Primary key is `name` (`str`)."""
        interface: Interface
        """Subclass of AvdModel."""
        run: bool | None
        hardware_acceleration: HardwareAcceleration
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                sample: int | None | UndefinedType = Undefined,
                sample_truncate_size: int | None | UndefinedType = Undefined,
                sample_input_subinterface: bool | None | UndefinedType = Undefined,
                sample_output_subinterface: bool | None | UndefinedType = Undefined,
                dangerous: bool | None | UndefinedType = Undefined,
                polling_interval: int | None | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                destinations: Destinations | UndefinedType = Undefined,
                source: str | None | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                extensions: Extensions | UndefinedType = Undefined,
                interface: Interface | UndefinedType = Undefined,
                run: bool | None | UndefinedType = Undefined,
                hardware_acceleration: HardwareAcceleration | UndefinedType = Undefined,
            ) -> None:
                """
                Sflow.


                Subclass of AvdModel.

                Args:
                    sample: sample
                    sample_truncate_size: Maximum sample size, in bytes.
                    sample_input_subinterface: sample_input_subinterface
                    sample_output_subinterface: sample_output_subinterface
                    dangerous: dangerous
                    polling_interval: Polling interval in seconds.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    destinations: Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`).
                    source:
                       Source IP Address.
                       "source" and "source_interface" are mutually exclusive. If both are defined,
                       "source_interface" takes precedence.
                    source_interface: Source Interface.
                    extensions: Subclass of AvdIndexedList with `ExtensionsItem` items. Primary key is `name` (`str`).
                    interface: Subclass of AvdModel.
                    run: run
                    hardware_acceleration: Subclass of AvdModel.

                """

    class SnmpServer(AvdModel):
        """Subclass of AvdModel."""

        class EngineIds(AvdModel):
            """Subclass of AvdModel."""

            class RemotesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"id": {"type": str}, "address": {"type": str}, "udp_port": {"type": int}}
                id: str | None
                """Remote engine ID in hexadecimal."""
                address: str | None
                """Hostname or IP of remote engine."""
                udp_port: int | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: str | None | UndefinedType = Undefined,
                        address: str | None | UndefinedType = Undefined,
                        udp_port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RemotesItem.


                        Subclass of AvdModel.

                        Args:
                            id: Remote engine ID in hexadecimal.
                            address: Hostname or IP of remote engine.
                            udp_port: udp_port

                        """

            class Remotes(AvdList[RemotesItem]):
                """Subclass of AvdList with `RemotesItem` items."""

            Remotes._item_type = RemotesItem

            _fields: ClassVar[dict] = {"local": {"type": str}, "remotes": {"type": Remotes}}
            local: str | None
            """Engine ID in hexadecimal."""
            remotes: Remotes
            """Subclass of AvdList with `RemotesItem` items."""

            if TYPE_CHECKING:

                def __init__(self, *, local: str | None | UndefinedType = Undefined, remotes: Remotes | UndefinedType = Undefined) -> None:
                    """
                    EngineIds.


                    Subclass of AvdModel.

                    Args:
                        local: Engine ID in hexadecimal.
                        remotes: Subclass of AvdList with `RemotesItem` items.

                    """

        class CommunitiesItem(AvdModel):
            """Subclass of AvdModel."""

            class AccessListIpv4(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}}
                name: str | None
                """IPv4 access list name."""

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | None | UndefinedType = Undefined) -> None:
                        """
                        AccessListIpv4.


                        Subclass of AvdModel.

                        Args:
                            name: IPv4 access list name.

                        """

            class AccessListIpv6(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}}
                name: str | None
                """IPv6 access list name."""

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | None | UndefinedType = Undefined) -> None:
                        """
                        AccessListIpv6.


                        Subclass of AvdModel.

                        Args:
                            name: IPv6 access list name.

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "access": {"type": str},
                "access_list_ipv4": {"type": AccessListIpv4},
                "access_list_ipv6": {"type": AccessListIpv6},
                "view": {"type": str},
            }
            name: str
            """Community name."""
            access: Literal["ro", "rw"] | None
            access_list_ipv4: AccessListIpv4
            """Subclass of AvdModel."""
            access_list_ipv6: AccessListIpv6
            """Subclass of AvdModel."""
            view: str | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    access: Literal["ro", "rw"] | None | UndefinedType = Undefined,
                    access_list_ipv4: AccessListIpv4 | UndefinedType = Undefined,
                    access_list_ipv6: AccessListIpv6 | UndefinedType = Undefined,
                    view: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    CommunitiesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Community name.
                        access: access
                        access_list_ipv4: Subclass of AvdModel.
                        access_list_ipv6: Subclass of AvdModel.
                        view: view

                    """

        class Communities(AvdIndexedList[str, CommunitiesItem]):
            """Subclass of AvdIndexedList with `CommunitiesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Communities._item_type = CommunitiesItem

        class Ipv4AclsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
            name: str | None
            """IPv4 access list name."""
            vrf: str | None

            if TYPE_CHECKING:

                def __init__(self, *, name: str | None | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                    """
                    Ipv4AclsItem.


                    Subclass of AvdModel.

                    Args:
                        name: IPv4 access list name.
                        vrf: vrf

                    """

        class Ipv4Acls(AvdList[Ipv4AclsItem]):
            """Subclass of AvdList with `Ipv4AclsItem` items."""

        Ipv4Acls._item_type = Ipv4AclsItem

        class Ipv6AclsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
            name: str | None
            """IPv6 access list name."""
            vrf: str | None

            if TYPE_CHECKING:

                def __init__(self, *, name: str | None | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                    """
                    Ipv6AclsItem.


                    Subclass of AvdModel.

                    Args:
                        name: IPv6 access list name.
                        vrf: vrf

                    """

        class Ipv6Acls(AvdList[Ipv6AclsItem]):
            """Subclass of AvdList with `Ipv6AclsItem` items."""

        Ipv6Acls._item_type = Ipv6AclsItem

        class LocalInterfacesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}}
            name: str
            """Interface name."""
            vrf: str | None

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                    """
                    LocalInterfacesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Interface name.
                        vrf: vrf

                    """

        class LocalInterfaces(AvdIndexedList[str, LocalInterfacesItem]):
            """Subclass of AvdIndexedList with `LocalInterfacesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        LocalInterfaces._item_type = LocalInterfacesItem

        class ViewsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "mib_family_name": {"type": str}, "included": {"type": bool}}
            name: str | None
            """SNMP view name."""
            mib_family_name: str | None
            included: bool | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    mib_family_name: str | None | UndefinedType = Undefined,
                    included: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ViewsItem.


                    Subclass of AvdModel.

                    Args:
                        name: SNMP view name.
                        mib_family_name: mib_family_name
                        included: included

                    """

        class Views(AvdList[ViewsItem]):
            """Subclass of AvdList with `ViewsItem` items."""

        Views._item_type = ViewsItem

        class GroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "version": {"type": str},
                "authentication": {"type": str},
                "read": {"type": str},
                "write": {"type": str},
                "notify": {"type": str},
            }
            name: str | None
            """Group name."""
            version: Literal["v1", "v2c", "v3"] | None
            authentication: Literal["auth", "noauth", "priv"] | None
            read: str | None
            """Read view."""
            write: str | None
            """Write view."""
            notify: str | None
            """Notify view."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    version: Literal["v1", "v2c", "v3"] | None | UndefinedType = Undefined,
                    authentication: Literal["auth", "noauth", "priv"] | None | UndefinedType = Undefined,
                    read: str | None | UndefinedType = Undefined,
                    write: str | None | UndefinedType = Undefined,
                    notify: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    GroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Group name.
                        version: version
                        authentication: authentication
                        read: Read view.
                        write: Write view.
                        notify: Notify view.

                    """

        class Groups(AvdList[GroupsItem]):
            """Subclass of AvdList with `GroupsItem` items."""

        Groups._item_type = GroupsItem

        class UsersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "group": {"type": str},
                "remote_address": {"type": str},
                "udp_port": {"type": int},
                "version": {"type": str},
                "localized": {"type": str},
                "auth": {"type": str},
                "auth_passphrase": {"type": str},
                "priv": {"type": str},
                "priv_passphrase": {"type": str},
            }
            name: str | None
            """Username."""
            group: str | None
            """Group name."""
            remote_address: str | None
            """
            Hostname or ip of remote engine.
            The remote_address and udp_port are used for remote users.
            """
            udp_port: int | None
            """udp_port will not be used if no remote_address is configured."""
            version: Literal["v1", "v2c", "v3"] | None
            localized: str | None
            """Engine ID in hexadecimal for localizing auth and/or priv."""
            auth: str | None
            """Hash algorithm."""
            auth_passphrase: str | None
            """Hashed authentication passphrase if localized is used else cleartext authentication passphrase."""
            priv: str | None
            """Encryption algorithm."""
            priv_passphrase: str | None
            """Hashed privacy passphrase if localized is used else cleartext privacy passphrase."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    group: str | None | UndefinedType = Undefined,
                    remote_address: str | None | UndefinedType = Undefined,
                    udp_port: int | None | UndefinedType = Undefined,
                    version: Literal["v1", "v2c", "v3"] | None | UndefinedType = Undefined,
                    localized: str | None | UndefinedType = Undefined,
                    auth: str | None | UndefinedType = Undefined,
                    auth_passphrase: str | None | UndefinedType = Undefined,
                    priv: str | None | UndefinedType = Undefined,
                    priv_passphrase: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    UsersItem.


                    Subclass of AvdModel.

                    Args:
                        name: Username.
                        group: Group name.
                        remote_address:
                           Hostname or ip of remote engine.
                           The remote_address and udp_port are used for remote users.
                        udp_port: udp_port will not be used if no remote_address is configured.
                        version: version
                        localized: Engine ID in hexadecimal for localizing auth and/or priv.
                        auth: Hash algorithm.
                        auth_passphrase: Hashed authentication passphrase if localized is used else cleartext authentication passphrase.
                        priv: Encryption algorithm.
                        priv_passphrase: Hashed privacy passphrase if localized is used else cleartext privacy passphrase.

                    """

        class Users(AvdList[UsersItem]):
            """Subclass of AvdList with `UsersItem` items."""

        Users._item_type = UsersItem

        class HostsItem(AvdModel):
            """Subclass of AvdModel."""

            class UsersItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"username": {"type": str}, "authentication_level": {"type": str}}
                username: str | None
                authentication_level: Literal["auth", "noauth", "priv"] | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        username: str | None | UndefinedType = Undefined,
                        authentication_level: Literal["auth", "noauth", "priv"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        UsersItem.


                        Subclass of AvdModel.

                        Args:
                            username: username
                            authentication_level: authentication_level

                        """

            class Users(AvdList[UsersItem]):
                """Subclass of AvdList with `UsersItem` items."""

            Users._item_type = UsersItem

            _fields: ClassVar[dict] = {
                "host": {"type": str},
                "vrf": {"type": str},
                "version": {"type": str},
                "community": {"type": str},
                "users": {"type": Users},
            }
            host: str | None
            """Host IP address or name."""
            vrf: str | None
            version: Literal["1", "2c", "3"] | None
            community: str | None
            """Community name. Required with version "1" or "2c"."""
            users: Users
            """Subclass of AvdList with `UsersItem` items."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    host: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    version: Literal["1", "2c", "3"] | None | UndefinedType = Undefined,
                    community: str | None | UndefinedType = Undefined,
                    users: Users | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostsItem.


                    Subclass of AvdModel.

                    Args:
                        host: Host IP address or name.
                        vrf: vrf
                        version: version
                        community: Community name. Required with version "1" or "2c".
                        users: Subclass of AvdList with `UsersItem` items.

                    """

        class Hosts(AvdList[HostsItem]):
            """Subclass of AvdList with `HostsItem` items."""

        Hosts._item_type = HostsItem

        class Traps(AvdModel):
            """Subclass of AvdModel."""

            class SnmpTrapsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "enabled": {"type": bool}}
                name: str | None
                """
                Enable or disable specific snmp-traps and their sub_traps.
                Examples:
                - "bgp"
                - "bgp established"
                """
                enabled: bool | None
                """The trap is enabled unless this is set to false."""

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | None | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined) -> None:
                        """
                        SnmpTrapsItem.


                        Subclass of AvdModel.

                        Args:
                            name:
                               Enable or disable specific snmp-traps and their sub_traps.
                               Examples:  # fmt: skip
                               - "bgp"
                               - "bgp established"
                            enabled: The trap is enabled unless this is set to false.

                        """

            class SnmpTraps(AvdList[SnmpTrapsItem]):
                """Subclass of AvdList with `SnmpTrapsItem` items."""

            SnmpTraps._item_type = SnmpTrapsItem

            _fields: ClassVar[dict] = {"enable": {"type": bool}, "snmp_traps": {"type": SnmpTraps}}
            enable: bool | None
            """Enable or disable all snmp-traps."""
            snmp_traps: SnmpTraps
            """Subclass of AvdList with `SnmpTrapsItem` items."""

            if TYPE_CHECKING:

                def __init__(self, *, enable: bool | None | UndefinedType = Undefined, snmp_traps: SnmpTraps | UndefinedType = Undefined) -> None:
                    """
                    Traps.


                    Subclass of AvdModel.

                    Args:
                        enable: Enable or disable all snmp-traps.
                        snmp_traps: Subclass of AvdList with `SnmpTrapsItem` items.

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "enable": {"type": bool}}
            name: str
            """VRF name."""
            enable: bool | None

            if TYPE_CHECKING:

                def __init__(self, *, name: str | UndefinedType = Undefined, enable: bool | None | UndefinedType = Undefined) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        enable: enable

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "engine_ids": {"type": EngineIds},
            "contact": {"type": str},
            "location": {"type": str},
            "communities": {"type": Communities},
            "ipv4_acls": {"type": Ipv4Acls},
            "ipv6_acls": {"type": Ipv6Acls},
            "local_interfaces": {"type": LocalInterfaces},
            "views": {"type": Views},
            "groups": {"type": Groups},
            "users": {"type": Users},
            "hosts": {"type": Hosts},
            "traps": {"type": Traps},
            "vrfs": {"type": Vrfs},
            "ifmib_ifspeed_shape_rate": {"type": bool},
        }
        engine_ids: EngineIds
        """Subclass of AvdModel."""
        contact: str | None
        """SNMP contact."""
        location: str | None
        """SNMP location."""
        communities: Communities
        """Subclass of AvdIndexedList with `CommunitiesItem` items. Primary key is `name` (`str`)."""
        ipv4_acls: Ipv4Acls
        """Subclass of AvdList with `Ipv4AclsItem` items."""
        ipv6_acls: Ipv6Acls
        """Subclass of AvdList with `Ipv6AclsItem` items."""
        local_interfaces: LocalInterfaces
        """Subclass of AvdIndexedList with `LocalInterfacesItem` items. Primary key is `name` (`str`)."""
        views: Views
        """Subclass of AvdList with `ViewsItem` items."""
        groups: Groups
        """Subclass of AvdList with `GroupsItem` items."""
        users: Users
        """Subclass of AvdList with `UsersItem` items."""
        hosts: Hosts
        """Subclass of AvdList with `HostsItem` items."""
        traps: Traps
        """Subclass of AvdModel."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        ifmib_ifspeed_shape_rate: bool | None
        """SNMP ifspeed reflecting shaping rate."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                engine_ids: EngineIds | UndefinedType = Undefined,
                contact: str | None | UndefinedType = Undefined,
                location: str | None | UndefinedType = Undefined,
                communities: Communities | UndefinedType = Undefined,
                ipv4_acls: Ipv4Acls | UndefinedType = Undefined,
                ipv6_acls: Ipv6Acls | UndefinedType = Undefined,
                local_interfaces: LocalInterfaces | UndefinedType = Undefined,
                views: Views | UndefinedType = Undefined,
                groups: Groups | UndefinedType = Undefined,
                users: Users | UndefinedType = Undefined,
                hosts: Hosts | UndefinedType = Undefined,
                traps: Traps | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                ifmib_ifspeed_shape_rate: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                SnmpServer.


                Subclass of AvdModel.

                Args:
                    engine_ids: Subclass of AvdModel.
                    contact: SNMP contact.
                    location: SNMP location.
                    communities: Subclass of AvdIndexedList with `CommunitiesItem` items. Primary key is `name` (`str`).
                    ipv4_acls: Subclass of AvdList with `Ipv4AclsItem` items.
                    ipv6_acls: Subclass of AvdList with `Ipv6AclsItem` items.
                    local_interfaces: Subclass of AvdIndexedList with `LocalInterfacesItem` items. Primary key is `name` (`str`).
                    views: Subclass of AvdList with `ViewsItem` items.
                    groups: Subclass of AvdList with `GroupsItem` items.
                    users: Subclass of AvdList with `UsersItem` items.
                    hosts: Subclass of AvdList with `HostsItem` items.
                    traps: Subclass of AvdModel.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    ifmib_ifspeed_shape_rate: SNMP ifspeed reflecting shaping rate.

                """

    class SpanningTree(AvdModel):
        """Subclass of AvdModel."""

        class EdgePort(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"bpdufilter_default": {"type": bool}, "bpduguard_default": {"type": bool}}
            bpdufilter_default: bool | None
            bpduguard_default: bool | None

            if TYPE_CHECKING:

                def __init__(
                    self, *, bpdufilter_default: bool | None | UndefinedType = Undefined, bpduguard_default: bool | None | UndefinedType = Undefined
                ) -> None:
                    """
                    EdgePort.


                    Subclass of AvdModel.

                    Args:
                        bpdufilter_default: bpdufilter_default
                        bpduguard_default: bpduguard_default

                    """

        class BpduguardRateLimit(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"default": {"type": bool}, "count": {"type": int}}
            default: bool | None
            count: int | None
            """Maximum number of BPDUs per timer interval."""

            if TYPE_CHECKING:

                def __init__(self, *, default: bool | None | UndefinedType = Undefined, count: int | None | UndefinedType = Undefined) -> None:
                    """
                    BpduguardRateLimit.


                    Subclass of AvdModel.

                    Args:
                        default: default
                        count: Maximum number of BPDUs per timer interval.

                    """

        class Mst(AvdModel):
            """Subclass of AvdModel."""

            class Configuration(AvdModel):
                """Subclass of AvdModel."""

                class InstancesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"id": {"type": int}, "vlans": {"type": str}}
                    id: int
                    """Instance ID."""
                    vlans: str | None
                    """
                    "< vlan_id >, < vlan_id >-< vlan_id >"
                    Example: 15,16,17,18
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, id: int | UndefinedType = Undefined, vlans: str | None | UndefinedType = Undefined) -> None:
                            """
                            InstancesItem.


                            Subclass of AvdModel.

                            Args:
                                id: Instance ID.
                                vlans:
                                   "< vlan_id >, < vlan_id >-< vlan_id >"
                                   Example: 15,16,17,18

                            """

                class Instances(AvdIndexedList[int, InstancesItem]):
                    """Subclass of AvdIndexedList with `InstancesItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                Instances._item_type = InstancesItem

                _fields: ClassVar[dict] = {"name": {"type": str}, "revision": {"type": int}, "instances": {"type": Instances}}
                name: str | None
                revision: int | None
                """0-65535."""
                instances: Instances
                """Subclass of AvdIndexedList with `InstancesItem` items. Primary key is `id` (`int`)."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        revision: int | None | UndefinedType = Undefined,
                        instances: Instances | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Configuration.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            revision: 0-65535.
                            instances: Subclass of AvdIndexedList with `InstancesItem` items. Primary key is `id` (`int`).

                        """

            _fields: ClassVar[dict] = {"pvst_border": {"type": bool}, "configuration": {"type": Configuration}}
            pvst_border: bool | None
            configuration: Configuration
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, pvst_border: bool | None | UndefinedType = Undefined, configuration: Configuration | UndefinedType = Undefined) -> None:
                    """
                    Mst.


                    Subclass of AvdModel.

                    Args:
                        pvst_border: pvst_border
                        configuration: Subclass of AvdModel.

                    """

        class MstInstancesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": str}, "priority": {"type": int}}
            id: str
            """Instance ID."""
            priority: int | None

            if TYPE_CHECKING:

                def __init__(self, *, id: str | UndefinedType = Undefined, priority: int | None | UndefinedType = Undefined) -> None:
                    """
                    MstInstancesItem.


                    Subclass of AvdModel.

                    Args:
                        id: Instance ID.
                        priority: priority

                    """

        class MstInstances(AvdIndexedList[str, MstInstancesItem]):
            """Subclass of AvdIndexedList with `MstInstancesItem` items. Primary key is `id` (`str`)."""

            _primary_key: ClassVar[str] = "id"

        MstInstances._item_type = MstInstancesItem

        class RapidPvstInstancesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": str}, "priority": {"type": int}}
            id: str
            """
            "< vlan_id >, < vlan_id >-< vlan_id >"
            Example: 105,202,505-506
            """
            priority: int | None

            if TYPE_CHECKING:

                def __init__(self, *, id: str | UndefinedType = Undefined, priority: int | None | UndefinedType = Undefined) -> None:
                    """
                    RapidPvstInstancesItem.


                    Subclass of AvdModel.

                    Args:
                        id:
                           "< vlan_id >, < vlan_id >-< vlan_id >"
                           Example: 105,202,505-506
                        priority: priority

                    """

        class RapidPvstInstances(AvdIndexedList[str, RapidPvstInstancesItem]):
            """Subclass of AvdIndexedList with `RapidPvstInstancesItem` items. Primary key is `id` (`str`)."""

            _primary_key: ClassVar[str] = "id"

        RapidPvstInstances._item_type = RapidPvstInstancesItem

        class PortIdAllocationPortChannelRange(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"minimum": {"type": int}, "maximum": {"type": int}}
            minimum: int
            """Specify minimum value for reserved range."""
            maximum: int
            """Specify maximum value for reserved range."""

            if TYPE_CHECKING:

                def __init__(self, *, minimum: int | UndefinedType = Undefined, maximum: int | UndefinedType = Undefined) -> None:
                    """
                    PortIdAllocationPortChannelRange.


                    Subclass of AvdModel.

                    Args:
                        minimum: Specify minimum value for reserved range.
                        maximum: Specify maximum value for reserved range.

                    """

        _fields: ClassVar[dict] = {
            "root_super": {"type": bool},
            "edge_port": {"type": EdgePort},
            "mode": {"type": str},
            "bpduguard_rate_limit": {"type": BpduguardRateLimit},
            "rstp_priority": {"type": int},
            "mst": {"type": Mst},
            "mst_instances": {"type": MstInstances},
            "no_spanning_tree_vlan": {"type": str},
            "rapid_pvst_instances": {"type": RapidPvstInstances},
            "port_id_allocation_port_channel_range": {"type": PortIdAllocationPortChannelRange},
        }
        root_super: bool | None
        edge_port: EdgePort
        """Subclass of AvdModel."""
        mode: Literal["mstp", "rstp", "rapid-pvst", "none"] | None
        bpduguard_rate_limit: BpduguardRateLimit
        """Subclass of AvdModel."""
        rstp_priority: int | None
        mst: Mst
        """Subclass of AvdModel."""
        mst_instances: MstInstances
        """Subclass of AvdIndexedList with `MstInstancesItem` items. Primary key is `id` (`str`)."""
        no_spanning_tree_vlan: str | None
        """
        "< vlan_id >, < vlan_id >-< vlan_id >"
        Example: 105,202,505-506
        """
        rapid_pvst_instances: RapidPvstInstances
        """Subclass of AvdIndexedList with `RapidPvstInstancesItem` items. Primary key is `id` (`str`)."""
        port_id_allocation_port_channel_range: PortIdAllocationPortChannelRange
        """
        Specify range of port-ids to reserve for port-channels.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                root_super: bool | None | UndefinedType = Undefined,
                edge_port: EdgePort | UndefinedType = Undefined,
                mode: Literal["mstp", "rstp", "rapid-pvst", "none"] | None | UndefinedType = Undefined,
                bpduguard_rate_limit: BpduguardRateLimit | UndefinedType = Undefined,
                rstp_priority: int | None | UndefinedType = Undefined,
                mst: Mst | UndefinedType = Undefined,
                mst_instances: MstInstances | UndefinedType = Undefined,
                no_spanning_tree_vlan: str | None | UndefinedType = Undefined,
                rapid_pvst_instances: RapidPvstInstances | UndefinedType = Undefined,
                port_id_allocation_port_channel_range: PortIdAllocationPortChannelRange | UndefinedType = Undefined,
            ) -> None:
                """
                SpanningTree.


                Subclass of AvdModel.

                Args:
                    root_super: root_super
                    edge_port: Subclass of AvdModel.
                    mode: mode
                    bpduguard_rate_limit: Subclass of AvdModel.
                    rstp_priority: rstp_priority
                    mst: Subclass of AvdModel.
                    mst_instances: Subclass of AvdIndexedList with `MstInstancesItem` items. Primary key is `id` (`str`).
                    no_spanning_tree_vlan:
                       "< vlan_id >, < vlan_id >-< vlan_id >"
                       Example: 105,202,505-506
                    rapid_pvst_instances: Subclass of AvdIndexedList with `RapidPvstInstancesItem` items. Primary key is `id` (`str`).
                    port_id_allocation_port_channel_range:
                       Specify range of port-ids to reserve for port-channels.

                       Subclass of AvdModel.

                """

    class StandardAccessListsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}}
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "deny ip any any"
            """

            if TYPE_CHECKING:

                def __init__(self, *, sequence: int | UndefinedType = Undefined, action: str | UndefinedType = Undefined) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        action:
                           Action as string.
                           Example: "deny ip any any"

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "counters_per_entry": {"type": bool}, "sequence_numbers": {"type": SequenceNumbers}}
        name: str
        """Access-list Name."""
        counters_per_entry: bool | None
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                counters_per_entry: bool | None | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
            ) -> None:
                """
                StandardAccessListsItem.


                Subclass of AvdModel.

                Args:
                    name: Access-list Name.
                    counters_per_entry: counters_per_entry
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).

                """

    class StandardAccessLists(AvdIndexedList[str, StandardAccessListsItem]):
        """Subclass of AvdIndexedList with `StandardAccessListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    StandardAccessLists._item_type = StandardAccessListsItem

    class StaticRoutesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "vrf": {"type": str},
            "destination_address_prefix": {"type": str},
            "prefix": {"type": str},
            "interface": {"type": str},
            "gateway": {"type": str},
            "next_hop": {"type": str},
            "track_bfd": {"type": bool},
            "distance": {"type": int},
            "tag": {"type": int},
            "name": {"type": str},
            "metric": {"type": int},
        }
        vrf: str | None
        """VRF Name."""
        destination_address_prefix: str | None
        """IPv4_network/Mask."""
        prefix: str | None
        """IPv4_network/Mask."""
        interface: str | None
        gateway: str | None
        """IPv4 Address."""
        next_hop: str | None
        """IPv4 Address."""
        track_bfd: bool | None
        """Track next-hop using BFD."""
        distance: int | None
        tag: int | None
        name: str | None
        """Description."""
        metric: int | None

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                vrf: str | None | UndefinedType = Undefined,
                destination_address_prefix: str | None | UndefinedType = Undefined,
                prefix: str | None | UndefinedType = Undefined,
                interface: str | None | UndefinedType = Undefined,
                gateway: str | None | UndefinedType = Undefined,
                next_hop: str | None | UndefinedType = Undefined,
                track_bfd: bool | None | UndefinedType = Undefined,
                distance: int | None | UndefinedType = Undefined,
                tag: int | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                metric: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                StaticRoutesItem.


                Subclass of AvdModel.

                Args:
                    vrf: VRF Name.
                    destination_address_prefix: IPv4_network/Mask.
                    prefix: IPv4_network/Mask.
                    interface: interface
                    gateway: IPv4 Address.
                    next_hop: IPv4 Address.
                    track_bfd: Track next-hop using BFD.
                    distance: distance
                    tag: tag
                    name: Description.
                    metric: metric

                """

    class StaticRoutes(AvdList[StaticRoutesItem]):
        """Subclass of AvdList with `StaticRoutesItem` items."""

    StaticRoutes._item_type = StaticRoutesItem

    class Stun(AvdModel):
        """Subclass of AvdModel."""

        class Client(AvdModel):
            """Subclass of AvdModel."""

            class ServerProfilesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "ip_address": {"type": str}, "ssl_profile": {"type": str}, "port": {"type": int}}
                name: str
                ip_address: str | None
                ssl_profile: str | None
                """SSL profile name."""
                port: int | None
                """Destination port for the request STUN server (default - 3478)."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        ip_address: str | None | UndefinedType = Undefined,
                        ssl_profile: str | None | UndefinedType = Undefined,
                        port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ServerProfilesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            ip_address: ip_address
                            ssl_profile: SSL profile name.
                            port: Destination port for the request STUN server (default - 3478).

                        """

            class ServerProfiles(AvdIndexedList[str, ServerProfilesItem]):
                """Subclass of AvdIndexedList with `ServerProfilesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            ServerProfiles._item_type = ServerProfilesItem

            _fields: ClassVar[dict] = {"server_profiles": {"type": ServerProfiles}}
            server_profiles: ServerProfiles
            """
            List of server profiles for the client.

            Subclass of AvdIndexedList with `ServerProfilesItem` items.
            Primary key is `name` (`str`).
            """

            if TYPE_CHECKING:

                def __init__(self, *, server_profiles: ServerProfiles | UndefinedType = Undefined) -> None:
                    """
                    Client.


                    Subclass of AvdModel.

                    Args:
                        server_profiles:
                           List of server profiles for the client.

                           Subclass of AvdIndexedList with `ServerProfilesItem` items.
                           Primary key is `name` (`str`).

                    """

        class Server(AvdModel):
            """Subclass of AvdModel."""

            class LocalInterfaces(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            LocalInterfaces._item_type = str

            class SslConnectionLifetime(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"minutes": {"type": int}, "hours": {"type": int}}
                minutes: int | None
                """SSL connection lifetime in minutes (default - 120)."""
                hours: int | None
                """SSL connection lifetime in hours (default - 2)."""

                if TYPE_CHECKING:

                    def __init__(self, *, minutes: int | None | UndefinedType = Undefined, hours: int | None | UndefinedType = Undefined) -> None:
                        """
                        SslConnectionLifetime.


                        Subclass of AvdModel.

                        Args:
                            minutes: SSL connection lifetime in minutes (default - 120).
                            hours: SSL connection lifetime in hours (default - 2).

                        """

            _fields: ClassVar[dict] = {
                "local_interfaces": {"type": LocalInterfaces},
                "bindings_timeout": {"type": int},
                "ssl_profile": {"type": str},
                "ssl_connection_lifetime": {"type": SslConnectionLifetime},
                "port": {"type": int},
            }
            local_interfaces: LocalInterfaces
            """Subclass of AvdList with `str` items."""
            bindings_timeout: int | None
            """Timeout for bindings stored on STUN server in seconds."""
            ssl_profile: str | None
            """SSL profile name."""
            ssl_connection_lifetime: SslConnectionLifetime
            """
            SSL connection lifetime in minutes or hours.
            If both are specified, minutes is given higher
            precedence.

            Subclass of AvdModel.
            """
            port: int | None
            """Listening port for STUN server (default - 3478)."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    local_interfaces: LocalInterfaces | UndefinedType = Undefined,
                    bindings_timeout: int | None | UndefinedType = Undefined,
                    ssl_profile: str | None | UndefinedType = Undefined,
                    ssl_connection_lifetime: SslConnectionLifetime | UndefinedType = Undefined,
                    port: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Server.


                    Subclass of AvdModel.

                    Args:
                        local_interfaces: Subclass of AvdList with `str` items.
                        bindings_timeout: Timeout for bindings stored on STUN server in seconds.
                        ssl_profile: SSL profile name.
                        ssl_connection_lifetime:
                           SSL connection lifetime in minutes or hours.
                           If both are specified, minutes is given higher
                           precedence.

                           Subclass of AvdModel.
                        port: Listening port for STUN server (default - 3478).

                    """

        _fields: ClassVar[dict] = {"client": {"type": Client}, "server": {"type": Server}}
        client: Client
        """
        STUN client settings.

        Subclass of AvdModel.
        """
        server: Server
        """
        STUN server settings.

        Subclass of AvdModel.
        """

        if TYPE_CHECKING:

            def __init__(self, *, client: Client | UndefinedType = Undefined, server: Server | UndefinedType = Undefined) -> None:
                """
                Stun.


                Subclass of AvdModel.

                Args:
                    client:
                       STUN client settings.

                       Subclass of AvdModel.
                    server:
                       STUN server settings.

                       Subclass of AvdModel.

                """

    class SwitchportDefault(AvdModel):
        """Subclass of AvdModel."""

        class Phone(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "cos": {"type": int},
                "trunk": {"type": str},
                "vlan": {"type": int},
                "access_list_bypass": {"type": bool},
                "qos_trust": {"type": str},
            }
            cos: int | None
            trunk: Literal["tagged", "untagged", "tagged phone", "untagged phone"] | None
            vlan: int | None
            """VLAN ID."""
            access_list_bypass: bool | None
            """Bypass phone traffic from configured access-list."""
            qos_trust: Literal["cos", "dscp"] | None
            """
            Quality of Service (QoS) trust mode. Outgoing traffic class being derived from the ingress COS/DSCP
            value.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    cos: int | None | UndefinedType = Undefined,
                    trunk: Literal["tagged", "untagged", "tagged phone", "untagged phone"] | None | UndefinedType = Undefined,
                    vlan: int | None | UndefinedType = Undefined,
                    access_list_bypass: bool | None | UndefinedType = Undefined,
                    qos_trust: Literal["cos", "dscp"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Phone.


                    Subclass of AvdModel.

                    Args:
                        cos: cos
                        trunk: trunk
                        vlan: VLAN ID.
                        access_list_bypass: Bypass phone traffic from configured access-list.
                        qos_trust:
                           Quality of Service (QoS) trust mode. Outgoing traffic class being derived from the ingress COS/DSCP
                           value.

                    """

        _fields: ClassVar[dict] = {"mode": {"type": str}, "phone": {"type": Phone}}
        mode: Literal["routed", "access"] | None
        phone: Phone
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, mode: Literal["routed", "access"] | None | UndefinedType = Undefined, phone: Phone | UndefinedType = Undefined) -> None:
                """
                SwitchportDefault.


                Subclass of AvdModel.

                Args:
                    mode: mode
                    phone: Subclass of AvdModel.

                """

    class SwitchportPortSecurity(AvdModel):
        """Subclass of AvdModel."""

        class MacAddress(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"aging": {"type": bool}, "moveable": {"type": bool}}
            aging: bool | None
            moveable: bool | None

            if TYPE_CHECKING:

                def __init__(self, *, aging: bool | None | UndefinedType = Undefined, moveable: bool | None | UndefinedType = Undefined) -> None:
                    """
                    MacAddress.


                    Subclass of AvdModel.

                    Args:
                        aging: aging
                        moveable: moveable

                    """

        _fields: ClassVar[dict] = {"mac_address": {"type": MacAddress}, "persistence_disabled": {"type": bool}, "violation_protect_chip_based": {"type": bool}}
        mac_address: MacAddress
        """Subclass of AvdModel."""
        persistence_disabled: bool | None
        violation_protect_chip_based: bool | None

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                mac_address: MacAddress | UndefinedType = Undefined,
                persistence_disabled: bool | None | UndefinedType = Undefined,
                violation_protect_chip_based: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                SwitchportPortSecurity.


                Subclass of AvdModel.

                Args:
                    mac_address: Subclass of AvdModel.
                    persistence_disabled: persistence_disabled
                    violation_protect_chip_based: violation_protect_chip_based

                """

    class SyncE(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"network_option": {"type": int}}
        network_option: int

        if TYPE_CHECKING:

            def __init__(self, *, network_option: int | UndefinedType = Undefined) -> None:
                """
                SyncE.


                Subclass of AvdModel.

                Args:
                    network_option: network_option

                """

    class System(AvdModel):
        """Subclass of AvdModel."""

        class ControlPlane(AvdModel):
            """Subclass of AvdModel."""

            class TcpMss(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4": {"type": int}, "ipv6": {"type": int}}
                ipv4: int | None
                """Segment size."""
                ipv6: int | None
                """Segment size."""

                if TYPE_CHECKING:

                    def __init__(self, *, ipv4: int | None | UndefinedType = Undefined, ipv6: int | None | UndefinedType = Undefined) -> None:
                        """
                        TcpMss.


                        Subclass of AvdModel.

                        Args:
                            ipv4: Segment size.
                            ipv6: Segment size.

                        """

            class Ipv4AccessGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"acl_name": {"type": str}, "vrf": {"type": str}}
                acl_name: str
                vrf: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, acl_name: str | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                        """
                        Ipv4AccessGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            acl_name: acl_name
                            vrf: vrf

                        """

            class Ipv4AccessGroups(AvdList[Ipv4AccessGroupsItem]):
                """Subclass of AvdList with `Ipv4AccessGroupsItem` items."""

            Ipv4AccessGroups._item_type = Ipv4AccessGroupsItem

            class Ipv6AccessGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"acl_name": {"type": str}, "vrf": {"type": str}}
                acl_name: str
                vrf: str | None

                if TYPE_CHECKING:

                    def __init__(self, *, acl_name: str | UndefinedType = Undefined, vrf: str | None | UndefinedType = Undefined) -> None:
                        """
                        Ipv6AccessGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            acl_name: acl_name
                            vrf: vrf

                        """

            class Ipv6AccessGroups(AvdList[Ipv6AccessGroupsItem]):
                """Subclass of AvdList with `Ipv6AccessGroupsItem` items."""

            Ipv6AccessGroups._item_type = Ipv6AccessGroupsItem

            _fields: ClassVar[dict] = {
                "tcp_mss": {"type": TcpMss},
                "ipv4_access_group_ingress_default": {"type": str},
                "ipv4_access_groups": {"type": Ipv4AccessGroups},
                "ipv6_access_group_ingress_default": {"type": str},
                "ipv6_access_groups": {"type": Ipv6AccessGroups},
            }
            tcp_mss: TcpMss
            """Subclass of AvdModel."""
            ipv4_access_group_ingress_default: str | None
            """ACL name to be used as the default CP ACL for all VRFs."""
            ipv4_access_groups: Ipv4AccessGroups
            """Subclass of AvdList with `Ipv4AccessGroupsItem` items."""
            ipv6_access_group_ingress_default: str | None
            """ACL name to be used as the default CP ACL for all VRFs."""
            ipv6_access_groups: Ipv6AccessGroups
            """Subclass of AvdList with `Ipv6AccessGroupsItem` items."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    tcp_mss: TcpMss | UndefinedType = Undefined,
                    ipv4_access_group_ingress_default: str | None | UndefinedType = Undefined,
                    ipv4_access_groups: Ipv4AccessGroups | UndefinedType = Undefined,
                    ipv6_access_group_ingress_default: str | None | UndefinedType = Undefined,
                    ipv6_access_groups: Ipv6AccessGroups | UndefinedType = Undefined,
                ) -> None:
                    """
                    ControlPlane.


                    Subclass of AvdModel.

                    Args:
                        tcp_mss: Subclass of AvdModel.
                        ipv4_access_group_ingress_default: ACL name to be used as the default CP ACL for all VRFs.
                        ipv4_access_groups: Subclass of AvdList with `Ipv4AccessGroupsItem` items.
                        ipv6_access_group_ingress_default: ACL name to be used as the default CP ACL for all VRFs.
                        ipv6_access_groups: Subclass of AvdList with `Ipv6AccessGroupsItem` items.

                    """

        class L1(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"unsupported_speed_action": {"type": str}, "unsupported_error_correction_action": {"type": str}}
            unsupported_speed_action: Literal["error", "warn"] | None
            unsupported_error_correction_action: Literal["error", "warn"] | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    unsupported_speed_action: Literal["error", "warn"] | None | UndefinedType = Undefined,
                    unsupported_error_correction_action: Literal["error", "warn"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    L1.


                    Subclass of AvdModel.

                    Args:
                        unsupported_speed_action: unsupported_speed_action
                        unsupported_error_correction_action: unsupported_error_correction_action

                    """

        _fields: ClassVar[dict] = {"control_plane": {"type": ControlPlane}, "l1": {"type": L1}}
        control_plane: ControlPlane
        """Subclass of AvdModel."""
        l1: L1
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, control_plane: ControlPlane | UndefinedType = Undefined, l1: L1 | UndefinedType = Undefined) -> None:
                """
                System.


                Subclass of AvdModel.

                Args:
                    control_plane: Subclass of AvdModel.
                    l1: Subclass of AvdModel.

                """

    class TacacsServers(AvdModel):
        """Subclass of AvdModel."""

        class HostsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "host": {"type": str},
                "vrf": {"type": str},
                "key": {"type": str},
                "key_type": {"type": str, "default": "7"},
                "single_connection": {"type": bool},
                "timeout": {"type": int},
            }
            host: str | None
            """Host IP address or name."""
            vrf: str | None
            key: str | None
            """Encrypted key."""
            key_type: Literal["0", "7", "8a"]
            """Default value: `"7"`"""
            single_connection: bool | None
            timeout: int | None
            """Timeout in seconds."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    host: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                    single_connection: bool | None | UndefinedType = Undefined,
                    timeout: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostsItem.


                    Subclass of AvdModel.

                    Args:
                        host: Host IP address or name.
                        vrf: vrf
                        key: Encrypted key.
                        key_type: key_type
                        single_connection: single_connection
                        timeout: Timeout in seconds.

                    """

        class Hosts(AvdList[HostsItem]):
            """Subclass of AvdList with `HostsItem` items."""

        Hosts._item_type = HostsItem

        _fields: ClassVar[dict] = {"timeout": {"type": int}, "hosts": {"type": Hosts}, "policy_unknown_mandatory_attribute_ignore": {"type": bool}}
        timeout: int | None
        """Timeout in seconds."""
        hosts: Hosts
        """Subclass of AvdList with `HostsItem` items."""
        policy_unknown_mandatory_attribute_ignore: bool | None

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                timeout: int | None | UndefinedType = Undefined,
                hosts: Hosts | UndefinedType = Undefined,
                policy_unknown_mandatory_attribute_ignore: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                TacacsServers.


                Subclass of AvdModel.

                Args:
                    timeout: Timeout in seconds.
                    hosts: Subclass of AvdList with `HostsItem` items.
                    policy_unknown_mandatory_attribute_ignore: policy_unknown_mandatory_attribute_ignore

                """

    class TapAggregation(AvdModel):
        """Subclass of AvdModel."""

        class Mode(AvdModel):
            """Subclass of AvdModel."""

            class Exclusive(AvdModel):
                """Subclass of AvdModel."""

                class NoErrdisable(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                NoErrdisable._item_type = str

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "profile": {"type": str}, "no_errdisable": {"type": NoErrdisable}}
                enabled: bool | None
                profile: str | None
                """Profile Name."""
                no_errdisable: NoErrdisable
                """Subclass of AvdList with `str` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        profile: str | None | UndefinedType = Undefined,
                        no_errdisable: NoErrdisable | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Exclusive.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            profile: Profile Name.
                            no_errdisable: Subclass of AvdList with `str` items.

                        """

            _fields: ClassVar[dict] = {"exclusive": {"type": Exclusive}}
            exclusive: Exclusive
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, exclusive: Exclusive | UndefinedType = Undefined) -> None:
                    """
                    Mode.


                    Subclass of AvdModel.

                    Args:
                        exclusive: Subclass of AvdModel.

                    """

        class Mac(AvdModel):
            """Subclass of AvdModel."""

            class Timestamp(AvdModel):
                """Subclass of AvdModel."""

                class Header(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"format": {"type": str}, "eth_type": {"type": int}}
                    format: Literal["48-bit", "64-bit"] | None
                    eth_type: int | None
                    """EtherType."""

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, format: Literal["48-bit", "64-bit"] | None | UndefinedType = Undefined, eth_type: int | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            Header.


                            Subclass of AvdModel.

                            Args:
                                format: format
                                eth_type: EtherType.

                            """

                _fields: ClassVar[dict] = {"replace_source_mac": {"type": bool}, "header": {"type": Header}}
                replace_source_mac: bool | None
                header: Header
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, replace_source_mac: bool | None | UndefinedType = Undefined, header: Header | UndefinedType = Undefined) -> None:
                        """
                        Timestamp.


                        Subclass of AvdModel.

                        Args:
                            replace_source_mac: replace_source_mac
                            header: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"timestamp": {"type": Timestamp}, "fcs_append": {"type": bool}, "fcs_error": {"type": str}}
            timestamp: Timestamp
            """
            mac.timestamp.replace_source_mac and mac.timestamp.header.format are mutually exclsuive. If both are
            defined, replace_source_mac takes precedence.


            Subclass of AvdModel.
            """
            fcs_append: bool | None
            """
            mac.fcs_append and mac.fcs_error are mutually exclusive. If both are defined, mac.fcs_append takes
            precedence.
            """
            fcs_error: Literal["correct", "discard", "pass-through"] | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    timestamp: Timestamp | UndefinedType = Undefined,
                    fcs_append: bool | None | UndefinedType = Undefined,
                    fcs_error: Literal["correct", "discard", "pass-through"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Mac.


                    Subclass of AvdModel.

                    Args:
                        timestamp:
                           mac.timestamp.replace_source_mac and mac.timestamp.header.format are mutually exclsuive. If both are
                           defined, replace_source_mac takes precedence.


                           Subclass of AvdModel.
                        fcs_append:
                           mac.fcs_append and mac.fcs_error are mutually exclusive. If both are defined, mac.fcs_append takes
                           precedence.
                        fcs_error: fcs_error

                    """

        _fields: ClassVar[dict] = {
            "mode": {"type": Mode},
            "encapsulation_dot1br_strip": {"type": bool},
            "encapsulation_vn_tag_strip": {"type": bool},
            "protocol_lldp_trap": {"type": bool},
            "truncation_size": {"type": int},
            "mac": {"type": Mac},
        }
        mode: Mode
        """Subclass of AvdModel."""
        encapsulation_dot1br_strip: bool | None
        encapsulation_vn_tag_strip: bool | None
        protocol_lldp_trap: bool | None
        truncation_size: int | None
        """Allowed truncation_size values vary depending on the platform."""
        mac: Mac
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                mode: Mode | UndefinedType = Undefined,
                encapsulation_dot1br_strip: bool | None | UndefinedType = Undefined,
                encapsulation_vn_tag_strip: bool | None | UndefinedType = Undefined,
                protocol_lldp_trap: bool | None | UndefinedType = Undefined,
                truncation_size: int | None | UndefinedType = Undefined,
                mac: Mac | UndefinedType = Undefined,
            ) -> None:
                """
                TapAggregation.


                Subclass of AvdModel.

                Args:
                    mode: Subclass of AvdModel.
                    encapsulation_dot1br_strip: encapsulation_dot1br_strip
                    encapsulation_vn_tag_strip: encapsulation_vn_tag_strip
                    protocol_lldp_trap: protocol_lldp_trap
                    truncation_size: Allowed truncation_size values vary depending on the platform.
                    mac: Subclass of AvdModel.

                """

    class TcamProfile(AvdModel):
        """Subclass of AvdModel."""

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "config": {"type": str}, "source": {"type": str}}
            name: str
            """Tcam-Profile Name."""
            config: str | None
            """
            TCAM Profile Config. Since these can be very long, it is often a good idea to import the config from
            a file.
            Example: "{{ lookup('file', 'TCAM_TRAFFIC_POLICY.conf') }}"
            """
            source: str | None
            """
            TCAM profile local source path. Used to read the TCAM profile from a local path existing on the
            device.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    config: str | None | UndefinedType = Undefined,
                    source: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Tcam-Profile Name.
                        config:
                           TCAM Profile Config. Since these can be very long, it is often a good idea to import the config from
                           a file.
                           Example: "{{ lookup('file', 'TCAM_TRAFFIC_POLICY.conf') }}"
                        source:
                           TCAM profile local source path. Used to read the TCAM profile from a local path existing on the
                           device.

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        _fields: ClassVar[dict] = {"system": {"type": str}, "profiles": {"type": Profiles}}
        system: str | None
        """TCAM profile name to activate."""
        profiles: Profiles
        """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(self, *, system: str | None | UndefinedType = Undefined, profiles: Profiles | UndefinedType = Undefined) -> None:
                """
                TcamProfile.


                Subclass of AvdModel.

                Args:
                    system: TCAM profile name to activate.
                    profiles: Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`).

                """

    class Terminal(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"length": {"type": int}, "width": {"type": int}}
        length: int | None
        width: int | None

        if TYPE_CHECKING:

            def __init__(self, *, length: int | None | UndefinedType = Undefined, width: int | None | UndefinedType = Undefined) -> None:
                """
                Terminal.


                Subclass of AvdModel.

                Args:
                    length: length
                    width: width

                """

    class TrackersItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "interface": {"type": str}, "tracked_property": {"type": str, "default": "line-protocol"}}
        name: str
        """Name of tracker object."""
        interface: str
        """Name of tracked interface."""
        tracked_property: str
        """
        Property to track.

        Default value: `"line-protocol"`
        """

        if TYPE_CHECKING:

            def __init__(
                self, *, name: str | UndefinedType = Undefined, interface: str | UndefinedType = Undefined, tracked_property: str | UndefinedType = Undefined
            ) -> None:
                """
                TrackersItem.


                Subclass of AvdModel.

                Args:
                    name: Name of tracker object.
                    interface: Name of tracked interface.
                    tracked_property: Property to track.

                """

    class Trackers(AvdIndexedList[str, TrackersItem]):
        """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Trackers._item_type = TrackersItem

    class TrafficPolicies(AvdModel):
        """Subclass of AvdModel."""

        class Options(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"counter_per_interface": {"type": bool}, "counter_interface_poll_interval": {"type": int}}
            counter_per_interface: bool | None
            counter_interface_poll_interval: int | None
            """Interval between consecutive polls in seconds."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    counter_per_interface: bool | None | UndefinedType = Undefined,
                    counter_interface_poll_interval: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Options.


                    Subclass of AvdModel.

                    Args:
                        counter_per_interface: counter_per_interface
                        counter_interface_poll_interval: Interval between consecutive polls in seconds.

                    """

        class FieldSets(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4Item(AvdModel):
                """Subclass of AvdModel."""

                class Prefixes(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Prefixes._item_type = str

                class Except(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Except._item_type = str

                _fields: ClassVar[dict] = {"name": {"type": str}, "prefixes": {"type": Prefixes}, "field_except": {"type": Except}}
                _field_to_key_map: ClassVar[dict] = {"field_except": "except"}
                _key_to_field_map: ClassVar[dict] = {"except": "field_except"}
                name: str
                """IPv4 Prefix Field Set Name."""
                prefixes: Prefixes
                """Subclass of AvdList with `str` items."""
                field_except: Except
                """Subclass of AvdList with `str` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        prefixes: Prefixes | UndefinedType = Undefined,
                        field_except: Except | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4Item.


                        Subclass of AvdModel.

                        Args:
                            name: IPv4 Prefix Field Set Name.
                            prefixes: Subclass of AvdList with `str` items.
                            field_except: Subclass of AvdList with `str` items.

                        """

            class Ipv4(AvdIndexedList[str, Ipv4Item]):
                """Subclass of AvdIndexedList with `Ipv4Item` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Ipv4._item_type = Ipv4Item

            class Ipv6Item(AvdModel):
                """Subclass of AvdModel."""

                class Prefixes(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Prefixes._item_type = str

                class Except(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Except._item_type = str

                _fields: ClassVar[dict] = {"name": {"type": str}, "prefixes": {"type": Prefixes}, "field_except": {"type": Except}}
                _field_to_key_map: ClassVar[dict] = {"field_except": "except"}
                _key_to_field_map: ClassVar[dict] = {"except": "field_except"}
                name: str
                """IPv6 Prefix Field Set Name."""
                prefixes: Prefixes
                """Subclass of AvdList with `str` items."""
                field_except: Except
                """Subclass of AvdList with `str` items."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        prefixes: Prefixes | UndefinedType = Undefined,
                        field_except: Except | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv6Item.


                        Subclass of AvdModel.

                        Args:
                            name: IPv6 Prefix Field Set Name.
                            prefixes: Subclass of AvdList with `str` items.
                            field_except: Subclass of AvdList with `str` items.

                        """

            class Ipv6(AvdIndexedList[str, Ipv6Item]):
                """Subclass of AvdIndexedList with `Ipv6Item` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Ipv6._item_type = Ipv6Item

            class PortsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "port_range": {"type": str}}
                name: str
                """L4 Port Field Set Name."""
                port_range: str | None
                """Example: '10,20,80,440-450'"""

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, port_range: str | None | UndefinedType = Undefined) -> None:
                        """
                        PortsItem.


                        Subclass of AvdModel.

                        Args:
                            name: L4 Port Field Set Name.
                            port_range: Example: '10,20,80,440-450'

                        """

            class Ports(AvdIndexedList[str, PortsItem]):
                """Subclass of AvdIndexedList with `PortsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Ports._item_type = PortsItem

            _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}, "ports": {"type": Ports}}
            ipv4: Ipv4
            """Subclass of AvdIndexedList with `Ipv4Item` items. Primary key is `name` (`str`)."""
            ipv6: Ipv6
            """Subclass of AvdIndexedList with `Ipv6Item` items. Primary key is `name` (`str`)."""
            ports: Ports
            """Subclass of AvdIndexedList with `PortsItem` items. Primary key is `name` (`str`)."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, ipv4: Ipv4 | UndefinedType = Undefined, ipv6: Ipv6 | UndefinedType = Undefined, ports: Ports | UndefinedType = Undefined
                ) -> None:
                    """
                    FieldSets.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Subclass of AvdIndexedList with `Ipv4Item` items. Primary key is `name` (`str`).
                        ipv6: Subclass of AvdIndexedList with `Ipv6Item` items. Primary key is `name` (`str`).
                        ports: Subclass of AvdIndexedList with `PortsItem` items. Primary key is `name` (`str`).

                    """

        class PoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class Counters(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Counters._item_type = str

            class MatchesItem(AvdModel):
                """Subclass of AvdModel."""

                class Source(AvdModel):
                    """Subclass of AvdModel."""

                    class Prefixes(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Prefixes._item_type = str

                    class PrefixLists(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    PrefixLists._item_type = str

                    _fields: ClassVar[dict] = {"prefixes": {"type": Prefixes}, "prefix_lists": {"type": PrefixLists}}
                    prefixes: Prefixes
                    """Subclass of AvdList with `str` items."""
                    prefix_lists: PrefixLists
                    """
                    Field-set prefix lists.

                    Subclass of AvdList with `str` items.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, prefixes: Prefixes | UndefinedType = Undefined, prefix_lists: PrefixLists | UndefinedType = Undefined) -> None:
                            """
                            Source.


                            Subclass of AvdModel.

                            Args:
                                prefixes: Subclass of AvdList with `str` items.
                                prefix_lists:
                                   Field-set prefix lists.

                                   Subclass of AvdList with `str` items.

                            """

                class Destination(AvdModel):
                    """Subclass of AvdModel."""

                    class Prefixes(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Prefixes._item_type = str

                    class PrefixLists(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    PrefixLists._item_type = str

                    _fields: ClassVar[dict] = {"prefixes": {"type": Prefixes}, "prefix_lists": {"type": PrefixLists}}
                    prefixes: Prefixes
                    """Subclass of AvdList with `str` items."""
                    prefix_lists: PrefixLists
                    """
                    Field-set prefix lists.

                    Subclass of AvdList with `str` items.
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, prefixes: Prefixes | UndefinedType = Undefined, prefix_lists: PrefixLists | UndefinedType = Undefined) -> None:
                            """
                            Destination.


                            Subclass of AvdModel.

                            Args:
                                prefixes: Subclass of AvdList with `str` items.
                                prefix_lists:
                                   Field-set prefix lists.

                                   Subclass of AvdList with `str` items.

                            """

                class Fragment(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"offset": {"type": str}}
                    offset: str | None
                    """Fragment offset range."""

                    if TYPE_CHECKING:

                        def __init__(self, *, offset: str | None | UndefinedType = Undefined) -> None:
                            """
                            Fragment.


                            Subclass of AvdModel.

                            Args:
                                offset: Fragment offset range.

                            """

                class ProtocolsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Flags(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Flags._item_type = str

                    class IcmpType(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    IcmpType._item_type = str

                    _fields: ClassVar[dict] = {
                        "protocol": {"type": str},
                        "src_port": {"type": str},
                        "dst_port": {"type": str},
                        "src_field": {"type": str},
                        "dst_field": {"type": str},
                        "flags": {"type": Flags},
                        "icmp_type": {"type": IcmpType},
                        "enforce_gtsm": {"type": bool},
                    }
                    protocol: str
                    src_port: str | None
                    """Port range."""
                    dst_port: str | None
                    """Port range."""
                    src_field: str | None
                    """L4 port range field set."""
                    dst_field: str | None
                    """L4 port range field set."""
                    flags: Flags
                    """Subclass of AvdList with `str` items."""
                    icmp_type: IcmpType
                    """Subclass of AvdList with `str` items."""
                    enforce_gtsm: bool | None
                    """Enforce the GTSM for BGP speakers. Only supported when protocol is set to 'neighbors'."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            protocol: str | UndefinedType = Undefined,
                            src_port: str | None | UndefinedType = Undefined,
                            dst_port: str | None | UndefinedType = Undefined,
                            src_field: str | None | UndefinedType = Undefined,
                            dst_field: str | None | UndefinedType = Undefined,
                            flags: Flags | UndefinedType = Undefined,
                            icmp_type: IcmpType | UndefinedType = Undefined,
                            enforce_gtsm: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ProtocolsItem.


                            Subclass of AvdModel.

                            Args:
                                protocol: protocol
                                src_port: Port range.
                                dst_port: Port range.
                                src_field: L4 port range field set.
                                dst_field: L4 port range field set.
                                flags: Subclass of AvdList with `str` items.
                                icmp_type: Subclass of AvdList with `str` items.
                                enforce_gtsm: Enforce the GTSM for BGP speakers. Only supported when protocol is set to 'neighbors'.

                            """

                class Protocols(AvdIndexedList[str, ProtocolsItem]):
                    """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                    _primary_key: ClassVar[str] = "protocol"

                Protocols._item_type = ProtocolsItem

                class Actions(AvdModel):
                    """Subclass of AvdModel."""

                    class Redirect(AvdModel):
                        """Subclass of AvdModel."""

                        class AggregationGroups(AvdList[str]):
                            """Subclass of AvdList with `str` items."""

                        AggregationGroups._item_type = str

                        class NextHop(AvdModel):
                            """Subclass of AvdModel."""

                            class Ipv4Addresses(AvdList[str]):
                                """Subclass of AvdList with `str` items."""

                            Ipv4Addresses._item_type = str

                            class Ipv6Addresses(AvdList[str]):
                                """Subclass of AvdList with `str` items."""

                            Ipv6Addresses._item_type = str

                            class Groups(AvdList[str]):
                                """Subclass of AvdList with `str` items."""

                            Groups._item_type = str

                            class RecursiveIpv4Addresses(AvdList[str]):
                                """Subclass of AvdList with `str` items."""

                            RecursiveIpv4Addresses._item_type = str

                            class RecursiveIpv6Addresses(AvdList[str]):
                                """Subclass of AvdList with `str` items."""

                            RecursiveIpv6Addresses._item_type = str

                            _fields: ClassVar[dict] = {
                                "ipv4_addresses": {"type": Ipv4Addresses},
                                "ipv6_addresses": {"type": Ipv6Addresses},
                                "vrf": {"type": str},
                                "groups": {"type": Groups},
                                "recursive_ipv4_addresses": {"type": RecursiveIpv4Addresses},
                                "recursive_ipv6_addresses": {"type": RecursiveIpv6Addresses},
                                "ttl": {"type": int},
                            }
                            ipv4_addresses: Ipv4Addresses
                            """Subclass of AvdList with `str` items."""
                            ipv6_addresses: Ipv6Addresses
                            """Subclass of AvdList with `str` items."""
                            vrf: str | None
                            """
                            Resolve next-hop in a VRF for `ipv4_addresses`, `ipv6_addresses`, `recursive_ipv4_addresses` or
                            `recursive_ipv6_addresses`.
                            """
                            groups: Groups
                            """
                            Set groups to redirect flow.

                            Subclass of AvdList with `str` items.
                            """
                            recursive_ipv4_addresses: RecursiveIpv4Addresses
                            """Subclass of AvdList with `str` items."""
                            recursive_ipv6_addresses: RecursiveIpv6Addresses
                            """Subclass of AvdList with `str` items."""
                            ttl: int | None
                            """
                            Set header TTL value for `ipv4_addresses`, `ipv6_addresses`, `recursive_ipv4_addresses`,
                            `recursive_ipv6_addresses` or `groups`.
                            """

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    ipv4_addresses: Ipv4Addresses | UndefinedType = Undefined,
                                    ipv6_addresses: Ipv6Addresses | UndefinedType = Undefined,
                                    vrf: str | None | UndefinedType = Undefined,
                                    groups: Groups | UndefinedType = Undefined,
                                    recursive_ipv4_addresses: RecursiveIpv4Addresses | UndefinedType = Undefined,
                                    recursive_ipv6_addresses: RecursiveIpv6Addresses | UndefinedType = Undefined,
                                    ttl: int | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    NextHop.


                                    Subclass of AvdModel.

                                    Args:
                                        ipv4_addresses: Subclass of AvdList with `str` items.
                                        ipv6_addresses: Subclass of AvdList with `str` items.
                                        vrf:
                                           Resolve next-hop in a VRF for `ipv4_addresses`, `ipv6_addresses`, `recursive_ipv4_addresses` or
                                           `recursive_ipv6_addresses`.
                                        groups:
                                           Set groups to redirect flow.

                                           Subclass of AvdList with `str` items.
                                        recursive_ipv4_addresses: Subclass of AvdList with `str` items.
                                        recursive_ipv6_addresses: Subclass of AvdList with `str` items.
                                        ttl:
                                           Set header TTL value for `ipv4_addresses`, `ipv6_addresses`, `recursive_ipv4_addresses`,
                                           `recursive_ipv6_addresses` or `groups`.

                                    """

                        _fields: ClassVar[dict] = {"aggregation_groups": {"type": AggregationGroups}, "interface": {"type": str}, "next_hop": {"type": NextHop}}
                        aggregation_groups: AggregationGroups
                        """
                        Redirect to aggregation groups in Tap Aggregation mode.

                        Subclass of AvdList with `str` items.
                        """
                        interface: str | None
                        """
                        The allowed hardware Ethernet interface, LAG interface, InternalRecirc, Switch.
                        Ex:
                          1. Ethernet1
                        2. Et1,2
                          3. Po2-4
                        """
                        next_hop: NextHop
                        """
                        Redirect to next-hop.
                        This option is mutually exclusive with `aggregation_groups` and `interface`.
                        If all three are defined, aggregation_groups and interface take precedence over next-hop.
                        Only one
                        of the below keys can be specified, in the order of precedence: ipv4_addresses, ipv6_addresses,
                        groups, recursive_ipv4_addresses, recursive_ipv6_addresses.

                        Subclass of AvdModel.
                        """

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                aggregation_groups: AggregationGroups | UndefinedType = Undefined,
                                interface: str | None | UndefinedType = Undefined,
                                next_hop: NextHop | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Redirect.


                                Subclass of AvdModel.

                                Args:
                                    aggregation_groups:
                                       Redirect to aggregation groups in Tap Aggregation mode.

                                       Subclass of AvdList with `str` items.
                                    interface:
                                       The allowed hardware Ethernet interface, LAG interface, InternalRecirc, Switch.
                                       Ex:
                                         1. Ethernet1
                                       2. Et1,2
                                         3. Po2-4
                                    next_hop:
                                       Redirect to next-hop.
                                       This option is mutually exclusive with `aggregation_groups` and `interface`.
                                       If all three are defined, aggregation_groups and interface take precedence over next-hop.
                                       Only one
                                       of the below keys can be specified, in the order of precedence: ipv4_addresses, ipv6_addresses,
                                       groups, recursive_ipv4_addresses, recursive_ipv6_addresses.

                                       Subclass of AvdModel.

                                """

                    _fields: ClassVar[dict] = {
                        "dscp": {"type": int},
                        "traffic_class": {"type": int},
                        "count": {"type": str},
                        "drop": {"type": bool},
                        "log": {"type": bool},
                        "redirect": {"type": Redirect},
                    }
                    dscp: int | None
                    traffic_class: int | None
                    """Traffic class ID."""
                    count: str | None
                    """
                    Counter name. This should also be added to the `policies[].counters` list.
                    It will no longer be
                    added automatically to the counters in AVD 6.0.
                    """
                    drop: bool | None
                    log: bool | None
                    """Only supported when action is set to drop."""
                    redirect: Redirect
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            dscp: int | None | UndefinedType = Undefined,
                            traffic_class: int | None | UndefinedType = Undefined,
                            count: str | None | UndefinedType = Undefined,
                            drop: bool | None | UndefinedType = Undefined,
                            log: bool | None | UndefinedType = Undefined,
                            redirect: Redirect | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Actions.


                            Subclass of AvdModel.

                            Args:
                                dscp: dscp
                                traffic_class: Traffic class ID.
                                count:
                                   Counter name. This should also be added to the `policies[].counters` list.
                                   It will no longer be
                                   added automatically to the counters in AVD 6.0.
                                drop: drop
                                log: Only supported when action is set to drop.
                                redirect: Subclass of AvdModel.

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "type": {"type": str},
                    "source": {"type": Source},
                    "destination": {"type": Destination},
                    "ttl": {"type": str},
                    "fragment": {"type": Fragment},
                    "protocols": {"type": Protocols},
                    "actions": {"type": Actions},
                }
                name: str
                """Traffic Policy Item."""
                type: Literal["ipv4", "ipv6"]
                source: Source
                """Subclass of AvdModel."""
                destination: Destination
                """Subclass of AvdModel."""
                ttl: str | None
                """TTL range."""
                fragment: Fragment
                """
                The 'fragment' command is not supported when 'source port'
                or 'destination port' command is
                configured.


                Subclass of AvdModel.
                """
                protocols: Protocols
                """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""
                actions: Actions
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        type: Literal["ipv4", "ipv6"] | UndefinedType = Undefined,
                        source: Source | UndefinedType = Undefined,
                        destination: Destination | UndefinedType = Undefined,
                        ttl: str | None | UndefinedType = Undefined,
                        fragment: Fragment | UndefinedType = Undefined,
                        protocols: Protocols | UndefinedType = Undefined,
                        actions: Actions | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Traffic Policy Item.
                            type: type
                            source: Subclass of AvdModel.
                            destination: Subclass of AvdModel.
                            ttl: TTL range.
                            fragment:
                               The 'fragment' command is not supported when 'source port'
                               or 'destination port' command is
                               configured.


                               Subclass of AvdModel.
                            protocols: Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`).
                            actions: Subclass of AvdModel.

                        """

            class Matches(AvdIndexedList[str, MatchesItem]):
                """Subclass of AvdIndexedList with `MatchesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Matches._item_type = MatchesItem

            class DefaultActions(AvdModel):
                """Subclass of AvdModel."""

                class Ipv4(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "dscp": {"type": int},
                        "traffic_class": {"type": int},
                        "count": {"type": str},
                        "drop": {"type": bool},
                        "log": {"type": bool},
                    }
                    dscp: int | None
                    traffic_class: int | None
                    """Traffic class ID."""
                    count: str | None
                    """Counter name. This should also be added to the `policies[].counters` list."""
                    drop: bool | None
                    log: bool | None
                    """Only supported when action is set to drop."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            dscp: int | None | UndefinedType = Undefined,
                            traffic_class: int | None | UndefinedType = Undefined,
                            count: str | None | UndefinedType = Undefined,
                            drop: bool | None | UndefinedType = Undefined,
                            log: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ipv4.


                            Subclass of AvdModel.

                            Args:
                                dscp: dscp
                                traffic_class: Traffic class ID.
                                count: Counter name. This should also be added to the `policies[].counters` list.
                                drop: drop
                                log: Only supported when action is set to drop.

                            """

                class Ipv6(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "dscp": {"type": int},
                        "traffic_class": {"type": int},
                        "count": {"type": str},
                        "drop": {"type": bool},
                        "log": {"type": bool},
                    }
                    dscp: int | None
                    traffic_class: int | None
                    """Traffic class ID."""
                    count: str | None
                    """Counter name. This should also be added to the `policies[].counters` list."""
                    drop: bool | None
                    log: bool | None
                    """Only supported when action is set to drop."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            dscp: int | None | UndefinedType = Undefined,
                            traffic_class: int | None | UndefinedType = Undefined,
                            count: str | None | UndefinedType = Undefined,
                            drop: bool | None | UndefinedType = Undefined,
                            log: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ipv6.


                            Subclass of AvdModel.

                            Args:
                                dscp: dscp
                                traffic_class: Traffic class ID.
                                count: Counter name. This should also be added to the `policies[].counters` list.
                                drop: drop
                                log: Only supported when action is set to drop.

                            """

                _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}}
                ipv4: Ipv4
                """Subclass of AvdModel."""
                ipv6: Ipv6
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, ipv4: Ipv4 | UndefinedType = Undefined, ipv6: Ipv6 | UndefinedType = Undefined) -> None:
                        """
                        DefaultActions.


                        Subclass of AvdModel.

                        Args:
                            ipv4: Subclass of AvdModel.
                            ipv6: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "counters": {"type": Counters},
                "matches": {"type": Matches},
                "default_actions": {"type": DefaultActions},
            }
            name: str
            """Traffic Policy Name."""
            counters: Counters
            """
            Counter name.

            Subclass of AvdList with `str` items.
            """
            matches: Matches
            """Subclass of AvdIndexedList with `MatchesItem` items. Primary key is `name` (`str`)."""
            default_actions: DefaultActions
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    counters: Counters | UndefinedType = Undefined,
                    matches: Matches | UndefinedType = Undefined,
                    default_actions: DefaultActions | UndefinedType = Undefined,
                ) -> None:
                    """
                    PoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Traffic Policy Name.
                        counters:
                           Counter name.

                           Subclass of AvdList with `str` items.
                        matches: Subclass of AvdIndexedList with `MatchesItem` items. Primary key is `name` (`str`).
                        default_actions: Subclass of AvdModel.

                    """

        class Policies(AvdIndexedList[str, PoliciesItem]):
            """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        _fields: ClassVar[dict] = {"options": {"type": Options}, "field_sets": {"type": FieldSets}, "policies": {"type": Policies}}
        options: Options
        """Subclass of AvdModel."""
        field_sets: FieldSets
        """Subclass of AvdModel."""
        policies: Policies
        """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                options: Options | UndefinedType = Undefined,
                field_sets: FieldSets | UndefinedType = Undefined,
                policies: Policies | UndefinedType = Undefined,
            ) -> None:
                """
                TrafficPolicies.


                Subclass of AvdModel.

                Args:
                    options: Subclass of AvdModel.
                    field_sets: Subclass of AvdModel.
                    policies: Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).

                """

    class Transceiver(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"dom_threshold_file": {"type": str}}
        dom_threshold_file: str | None
        """
        CSV file path for DOM threshold values.
        eg. `dom_threshold_file: flash:/dom_threshold.csv`
        Note: Set
        `dom_threshold_file` to `default` for default Arista-standardized thresholds.
        eg.
        `dom_threshold_file: default`
        """

        if TYPE_CHECKING:

            def __init__(self, *, dom_threshold_file: str | None | UndefinedType = Undefined) -> None:
                """
                Transceiver.


                Subclass of AvdModel.

                Args:
                    dom_threshold_file:
                       CSV file path for DOM threshold values.
                       eg. `dom_threshold_file: flash:/dom_threshold.csv`
                       Note: Set
                       `dom_threshold_file` to `default` for default Arista-standardized thresholds.
                       eg.
                       `dom_threshold_file: default`

                """

    class TunnelInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class TcpMssCeiling(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4": {"type": int}, "ipv6": {"type": int}, "direction": {"type": str}}
            ipv4: int | None
            """Segment Size for IPv4."""
            ipv6: int | None
            """Segment Size for IPv6."""
            direction: Literal["ingress", "egress"] | None
            """Optional direction ('ingress', 'egress')  for tcp mss ceiling."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4: int | None | UndefinedType = Undefined,
                    ipv6: int | None | UndefinedType = Undefined,
                    direction: Literal["ingress", "egress"] | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TcpMssCeiling.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Segment Size for IPv4.
                        ipv6: Segment Size for IPv6.
                        direction: Optional direction ('ingress', 'egress')  for tcp mss ceiling.

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "mtu": {"type": int},
            "vrf": {"type": str},
            "underlay_vrf": {"type": str},
            "ip_address": {"type": str},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "access_group_in": {"type": str},
            "access_group_out": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "ipv6_access_group_out": {"type": str},
            "tcp_mss_ceiling": {"type": TcpMssCeiling},
            "tunnel_mode": {"type": str},
            "source_interface": {"type": str},
            "source": {"type": str},
            "destination": {"type": str},
            "path_mtu_discovery": {"type": bool},
            "ipsec_profile": {"type": str},
            "nat_profile": {"type": str},
            "eos_cli": {"type": str},
        }
        name: str
        """Tunnel Interface Name."""
        description: str | None
        shutdown: bool | None
        mtu: int | None
        vrf: str | None
        """VRF Name."""
        underlay_vrf: str | None
        """Underlay VRF Name."""
        ip_address: str | None
        """IPv4_address/Mask."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6_address/Mask."""
        access_group_in: str | None
        """IPv4 ACL Name for ingress."""
        access_group_out: str | None
        """IPv4 ACL Name for egress."""
        ipv6_access_group_in: str | None
        """IPv6 ACL Name for ingress."""
        ipv6_access_group_out: str | None
        """IPv6 ACL Name for egress."""
        tcp_mss_ceiling: TcpMssCeiling
        """Subclass of AvdModel."""
        tunnel_mode: Literal["gre", "ipsec"] | None
        """
        Tunnel encapsulation method.
        `gre`: Generic route encapsulation protocol,
        `ipsec`: IPsec-over-IP
        encapsulation.
        """
        source_interface: str | None
        """
        Tunnel Source Interface Name.
        Mutually exclusive with `source`, if both are defined
        `source_interface` takes precedence.
        """
        source: str | None
        """
        Tunnel Source IPv4/IPv6 address.
        Mutually exclusive with `source_interface`, if both are defined
        `source_interface` takes precedence.
        """
        destination: str | None
        """IPv4 or IPv6 Address Tunnel Destination."""
        path_mtu_discovery: bool | None
        """Enable Path MTU Discovery On Tunnel."""
        ipsec_profile: str | None
        """
        Used only when `tunnel_mode` is set to `ipsec`.
        It must target a defined IPsec profile.
        """
        nat_profile: str | None
        """NAT interface profile."""
        eos_cli: str | None
        """
        Multiline String with EOS CLI rendered directly on the Tunnel interface in the final EOS
        configuration.
        """

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                underlay_vrf: str | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                access_group_in: str | None | UndefinedType = Undefined,
                access_group_out: str | None | UndefinedType = Undefined,
                ipv6_access_group_in: str | None | UndefinedType = Undefined,
                ipv6_access_group_out: str | None | UndefinedType = Undefined,
                tcp_mss_ceiling: TcpMssCeiling | UndefinedType = Undefined,
                tunnel_mode: Literal["gre", "ipsec"] | None | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                source: str | None | UndefinedType = Undefined,
                destination: str | None | UndefinedType = Undefined,
                path_mtu_discovery: bool | None | UndefinedType = Undefined,
                ipsec_profile: str | None | UndefinedType = Undefined,
                nat_profile: str | None | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                TunnelInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Tunnel Interface Name.
                    description: description
                    shutdown: shutdown
                    mtu: mtu
                    vrf: VRF Name.
                    underlay_vrf: Underlay VRF Name.
                    ip_address: IPv4_address/Mask.
                    ipv6_enable: ipv6_enable
                    ipv6_address: IPv6_address/Mask.
                    access_group_in: IPv4 ACL Name for ingress.
                    access_group_out: IPv4 ACL Name for egress.
                    ipv6_access_group_in: IPv6 ACL Name for ingress.
                    ipv6_access_group_out: IPv6 ACL Name for egress.
                    tcp_mss_ceiling: Subclass of AvdModel.
                    tunnel_mode:
                       Tunnel encapsulation method.
                       `gre`: Generic route encapsulation protocol,
                       `ipsec`: IPsec-over-IP
                       encapsulation.
                    source_interface:
                       Tunnel Source Interface Name.
                       Mutually exclusive with `source`, if both are defined
                       `source_interface` takes precedence.
                    source:
                       Tunnel Source IPv4/IPv6 address.
                       Mutually exclusive with `source_interface`, if both are defined
                       `source_interface` takes precedence.
                    destination: IPv4 or IPv6 Address Tunnel Destination.
                    path_mtu_discovery: Enable Path MTU Discovery On Tunnel.
                    ipsec_profile:
                       Used only when `tunnel_mode` is set to `ipsec`.
                       It must target a defined IPsec profile.
                    nat_profile: NAT interface profile.
                    eos_cli:
                       Multiline String with EOS CLI rendered directly on the Tunnel interface in the final EOS
                       configuration.

                """

    class TunnelInterfaces(AvdIndexedList[str, TunnelInterfacesItem]):
        """Subclass of AvdIndexedList with `TunnelInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    TunnelInterfaces._item_type = TunnelInterfacesItem

    class VirtualSourceNatVrfsItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "ip_address": {"type": str}, "ipv6_address": {"type": str}}
        name: str
        """VRF Name."""
        ip_address: str | None
        """IPv4 Address."""
        ipv6_address: str | None
        """IPv6 Address."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VirtualSourceNatVrfsItem.


                Subclass of AvdModel.

                Args:
                    name: VRF Name.
                    ip_address: IPv4 Address.
                    ipv6_address: IPv6 Address.

                """

    class VirtualSourceNatVrfs(AvdIndexedList[str, VirtualSourceNatVrfsItem]):
        """Subclass of AvdIndexedList with `VirtualSourceNatVrfsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    VirtualSourceNatVrfs._item_type = VirtualSourceNatVrfsItem

    class VlanInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class Logging(AvdModel):
            """Subclass of AvdModel."""

            class Event(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"link_status": {"type": bool}}
                link_status: bool | None

                if TYPE_CHECKING:

                    def __init__(self, *, link_status: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Event.


                        Subclass of AvdModel.

                        Args:
                            link_status: link_status

                        """

            _fields: ClassVar[dict] = {"event": {"type": Event}}
            event: Event
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, event: Event | UndefinedType = Undefined) -> None:
                    """
                    Logging.


                    Subclass of AvdModel.

                    Args:
                        event: Subclass of AvdModel.

                    """

        class IpAddressSecondaries(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        IpAddressSecondaries._item_type = str

        class IpVirtualRouterAddresses(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        IpVirtualRouterAddresses._item_type = str

        class IpAddressVirtualSecondaries(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        IpAddressVirtualSecondaries._item_type = str

        class IpIgmpHostProxy(AvdModel):
            """Subclass of AvdModel."""

            class GroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class ExcludeItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}}
                    source: str

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | UndefinedType = Undefined) -> None:
                            """
                            ExcludeItem.


                            Subclass of AvdModel.

                            Args:
                                source: source

                            """

                class Exclude(AvdIndexedList[str, ExcludeItem]):
                    """Subclass of AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`)."""

                    _primary_key: ClassVar[str] = "source"

                Exclude._item_type = ExcludeItem

                class IncludeItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}}
                    source: str

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | UndefinedType = Undefined) -> None:
                            """
                            IncludeItem.


                            Subclass of AvdModel.

                            Args:
                                source: source

                            """

                class Include(AvdIndexedList[str, IncludeItem]):
                    """Subclass of AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`)."""

                    _primary_key: ClassVar[str] = "source"

                Include._item_type = IncludeItem

                _fields: ClassVar[dict] = {"group": {"type": str}, "exclude": {"type": Exclude}, "include": {"type": Include}}
                group: str
                """Multicast Address."""
                exclude: Exclude
                """
                The same source must not be present both in `exclude` and `include` list.

                Subclass of
                AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`).
                """
                include: Include
                """
                The same source must not be present both in `exclude` and `include` list.

                Subclass of
                AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`).
                """

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        group: str | UndefinedType = Undefined,
                        exclude: Exclude | UndefinedType = Undefined,
                        include: Include | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GroupsItem.


                        Subclass of AvdModel.

                        Args:
                            group: Multicast Address.
                            exclude:
                               The same source must not be present both in `exclude` and `include` list.

                               Subclass of
                               AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`).
                            include:
                               The same source must not be present both in `exclude` and `include` list.

                               Subclass of
                               AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`).

                        """

            class Groups(AvdIndexedList[str, GroupsItem]):
                """Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`)."""

                _primary_key: ClassVar[str] = "group"

            Groups._item_type = GroupsItem

            class AccessListsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}}
                name: str

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined) -> None:
                        """
                        AccessListsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name

                        """

            class AccessLists(AvdIndexedList[str, AccessListsItem]):
                """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            AccessLists._item_type = AccessListsItem

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "groups": {"type": Groups},
                "report_interval": {"type": int},
                "access_lists": {"type": AccessLists},
                "version": {"type": int},
            }
            enabled: bool | None
            groups: Groups
            """Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`)."""
            report_interval: int | None
            """Time interval between unsolicited reports."""
            access_lists: AccessLists
            """
            Non-standard Access List name.

            Subclass of AvdIndexedList with `AccessListsItem` items. Primary key
            is `name` (`str`).
            """
            version: int | None
            """IGMP version on IGMP host-proxy interface."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    groups: Groups | UndefinedType = Undefined,
                    report_interval: int | None | UndefinedType = Undefined,
                    access_lists: AccessLists | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpIgmpHostProxy.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        groups: Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`).
                        report_interval: Time interval between unsolicited reports.
                        access_lists:
                           Non-standard Access List name.

                           Subclass of AvdIndexedList with `AccessListsItem` items. Primary key
                           is `name` (`str`).
                        version: IGMP version on IGMP host-proxy interface.

                    """

        class IpHelpersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ip_helper": {"type": str}, "source_interface": {"type": str}, "vrf": {"type": str}}
            ip_helper: str
            """IP address or hostname of DHCP server."""
            source_interface: str | None
            """Interface used as source for forwarded DHCP packets."""
            vrf: str | None
            """VRF where DHCP server can be reached."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ip_helper: str | UndefinedType = Undefined,
                    source_interface: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpHelpersItem.


                    Subclass of AvdModel.

                    Args:
                        ip_helper: IP address or hostname of DHCP server.
                        source_interface: Interface used as source for forwarded DHCP packets.
                        vrf: VRF where DHCP server can be reached.

                    """

        class IpHelpers(AvdIndexedList[str, IpHelpersItem]):
            """Subclass of AvdIndexedList with `IpHelpersItem` items. Primary key is `ip_helper` (`str`)."""

            _primary_key: ClassVar[str] = "ip_helper"

        IpHelpers._item_type = IpHelpersItem

        class IpNat(AvdModel):
            """Subclass of AvdModel."""

            class Destination(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"access_list": {"type": str}, "comment": {"type": str}, "pool_name": {"type": str}, "priority": {"type": int}}
                    access_list: str
                    comment: str | None
                    pool_name: str
                    priority: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            pool_name: str | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                pool_name: pool_name
                                priority: priority

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, dynamic: Dynamic | UndefinedType = Undefined, static: Static | UndefinedType = Undefined) -> None:
                        """
                        Destination.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.

                        """

            class Source(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "nat_type": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                    }
                    access_list: str
                    comment: str | None
                    nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"]
                    pool_name: str | None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"] | UndefinedType = Undefined,
                            pool_name: str | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                nat_type: nat_type
                                pool_name:
                                   required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                                   ignored if 'nat_type' is
                                   overload.
                                priority: priority

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""

                if TYPE_CHECKING:

                    def __init__(self, *, dynamic: Dynamic | UndefinedType = Undefined, static: Static | UndefinedType = Undefined) -> None:
                        """
                        Source.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.

                        """

            _fields: ClassVar[dict] = {"destination": {"type": Destination}, "source": {"type": Source}}
            destination: Destination
            """Subclass of AvdModel."""
            source: Source
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, destination: Destination | UndefinedType = Undefined, source: Source | UndefinedType = Undefined) -> None:
                    """
                    IpNat.


                    Subclass of AvdModel.

                    Args:
                        destination: Subclass of AvdModel.
                        source: Subclass of AvdModel.

                    """

        class Ipv6AddressVirtuals(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Ipv6AddressVirtuals._item_type = str

        class Ipv6VirtualRouterAddresses(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Ipv6VirtualRouterAddresses._item_type = str

        class Ipv6NdCache(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"dynamic_capacity": {"type": int}, "expire": {"type": int}, "refresh_always": {"type": bool}}
            dynamic_capacity: int | None
            """Capacity of dynamic cache entries."""
            expire: int | None
            """Cache entries expirery in seconds."""
            refresh_always: bool | None
            """Force refresh on cache expiry."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    dynamic_capacity: int | None | UndefinedType = Undefined,
                    expire: int | None | UndefinedType = Undefined,
                    refresh_always: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6NdCache.


                    Subclass of AvdModel.

                    Args:
                        dynamic_capacity: Capacity of dynamic cache entries.
                        expire: Cache entries expirery in seconds.
                        refresh_always: Force refresh on cache expiry.

                    """

        class Ipv6NdPrefixesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "ipv6_prefix": {"type": str},
                "valid_lifetime": {"type": str},
                "preferred_lifetime": {"type": str},
                "no_autoconfig_flag": {"type": bool},
            }
            ipv6_prefix: str
            """IPv6_address/Mask."""
            valid_lifetime: str | None
            """In seconds <0-4294967295> or infinite."""
            preferred_lifetime: str | None
            """In seconds <0-4294967295> or infinite."""
            no_autoconfig_flag: bool | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv6_prefix: str | UndefinedType = Undefined,
                    valid_lifetime: str | None | UndefinedType = Undefined,
                    preferred_lifetime: str | None | UndefinedType = Undefined,
                    no_autoconfig_flag: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6NdPrefixesItem.


                    Subclass of AvdModel.

                    Args:
                        ipv6_prefix: IPv6_address/Mask.
                        valid_lifetime: In seconds <0-4294967295> or infinite.
                        preferred_lifetime: In seconds <0-4294967295> or infinite.
                        no_autoconfig_flag: no_autoconfig_flag

                    """

        class Ipv6NdPrefixes(AvdIndexedList[str, Ipv6NdPrefixesItem]):
            """Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`)."""

            _primary_key: ClassVar[str] = "ipv6_prefix"

        Ipv6NdPrefixes._item_type = Ipv6NdPrefixesItem

        class Ipv6DhcpRelayDestinationsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "address": {"type": str},
                "vrf": {"type": str},
                "local_interface": {"type": str},
                "source_address": {"type": str},
                "link_address": {"type": str},
            }
            address: str
            """DHCP server's IPv6 address."""
            vrf: str | None
            local_interface: str | None
            """Local interface to communicate with DHCP server - mutually exclusive to source_address."""
            source_address: str | None
            """Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface."""
            link_address: str | None
            """Override the default link address specified in the relayed DHCP packet."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    address: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    source_address: str | None | UndefinedType = Undefined,
                    link_address: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6DhcpRelayDestinationsItem.


                    Subclass of AvdModel.

                    Args:
                        address: DHCP server's IPv6 address.
                        vrf: vrf
                        local_interface: Local interface to communicate with DHCP server - mutually exclusive to source_address.
                        source_address: Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface.
                        link_address: Override the default link address specified in the relayed DHCP packet.

                    """

        class Ipv6DhcpRelayDestinations(AvdIndexedList[str, Ipv6DhcpRelayDestinationsItem]):
            """
            Subclass of AvdIndexedList with `Ipv6DhcpRelayDestinationsItem` items. Primary key is `address`
            (`str`).
            """

            _primary_key: ClassVar[str] = "address"

        Ipv6DhcpRelayDestinations._item_type = Ipv6DhcpRelayDestinationsItem

        class Multicast(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class BoundariesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"boundary": {"type": str}, "out": {"type": bool}}
                    boundary: str
                    """IPv4 access-list name or IPv4 multicast group prefix with mask."""
                    out: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, boundary: str | UndefinedType = Undefined, out: bool | None | UndefinedType = Undefined) -> None:
                            """
                            BoundariesItem.


                            Subclass of AvdModel.

                            Args:
                                boundary: IPv4 access-list name or IPv4 multicast group prefix with mask.
                                out: out

                            """

                class Boundaries(AvdIndexedList[str, BoundariesItem]):
                    """Subclass of AvdIndexedList with `BoundariesItem` items. Primary key is `boundary` (`str`)."""

                    _primary_key: ClassVar[str] = "boundary"

                Boundaries._item_type = BoundariesItem

                class SourceRouteExport(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "administrative_distance": {"type": int}}
                    enabled: bool
                    administrative_distance: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, enabled: bool | UndefinedType = Undefined, administrative_distance: int | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            SourceRouteExport.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                administrative_distance: administrative_distance

                            """

                _fields: ClassVar[dict] = {"boundaries": {"type": Boundaries}, "source_route_export": {"type": SourceRouteExport}, "static": {"type": bool}}
                boundaries: Boundaries
                """
                Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                of both.

                Subclass of AvdIndexedList with `BoundariesItem` items. Primary key is `boundary` (`str`).
                """
                source_route_export: SourceRouteExport
                """Subclass of AvdModel."""
                static: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        boundaries: Boundaries | UndefinedType = Undefined,
                        source_route_export: SourceRouteExport | UndefinedType = Undefined,
                        static: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            boundaries:
                               Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                               of both.

                               Subclass of AvdIndexedList with `BoundariesItem` items. Primary key is `boundary` (`str`).
                            source_route_export: Subclass of AvdModel.
                            static: static

                        """

            class Ipv6(AvdModel):
                """Subclass of AvdModel."""

                class BoundariesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"boundary": {"type": str}}
                    boundary: str
                    """IPv6 access-list name or IPv6 multicast group prefix with mask."""

                    if TYPE_CHECKING:

                        def __init__(self, *, boundary: str | UndefinedType = Undefined) -> None:
                            """
                            BoundariesItem.


                            Subclass of AvdModel.

                            Args:
                                boundary: IPv6 access-list name or IPv6 multicast group prefix with mask.

                            """

                class Boundaries(AvdIndexedList[str, BoundariesItem]):
                    """Subclass of AvdIndexedList with `BoundariesItem` items. Primary key is `boundary` (`str`)."""

                    _primary_key: ClassVar[str] = "boundary"

                Boundaries._item_type = BoundariesItem

                class SourceRouteExport(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "administrative_distance": {"type": int}}
                    enabled: bool
                    administrative_distance: int | None

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, enabled: bool | UndefinedType = Undefined, administrative_distance: int | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            SourceRouteExport.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                administrative_distance: administrative_distance

                            """

                _fields: ClassVar[dict] = {"boundaries": {"type": Boundaries}, "source_route_export": {"type": SourceRouteExport}, "static": {"type": bool}}
                boundaries: Boundaries
                """
                Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                of both.

                Subclass of AvdIndexedList with `BoundariesItem` items. Primary key is `boundary` (`str`).
                """
                source_route_export: SourceRouteExport
                """Subclass of AvdModel."""
                static: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        boundaries: Boundaries | UndefinedType = Undefined,
                        source_route_export: SourceRouteExport | UndefinedType = Undefined,
                        static: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv6.


                        Subclass of AvdModel.

                        Args:
                            boundaries:
                               Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                               of both.

                               Subclass of AvdIndexedList with `BoundariesItem` items. Primary key is `boundary` (`str`).
                            source_route_export: Subclass of AvdModel.
                            static: static

                        """

            _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}}
            ipv4: Ipv4
            """Subclass of AvdModel."""
            ipv6: Ipv6
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, ipv4: Ipv4 | UndefinedType = Undefined, ipv6: Ipv6 | UndefinedType = Undefined) -> None:
                    """
                    Multicast.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Subclass of AvdModel.
                        ipv6: Subclass of AvdModel.

                    """

        class OspfMessageDigestKeysItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": int}, "hash_algorithm": {"type": str}, "key": {"type": str}}
            id: int
            hash_algorithm: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None
            key: str | None
            """Encrypted password."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    hash_algorithm: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    OspfMessageDigestKeysItem.


                    Subclass of AvdModel.

                    Args:
                        id: id
                        hash_algorithm: hash_algorithm
                        key: Encrypted password.

                    """

        class OspfMessageDigestKeys(AvdIndexedList[int, OspfMessageDigestKeysItem]):
            """Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        OspfMessageDigestKeys._item_type = OspfMessageDigestKeysItem

        class Pim(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class Hello(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"count": {"type": str}, "interval": {"type": int}}
                    count: str | None
                    """Number of missed hellos after which the neighbor expires. Range <1.5-65535>."""
                    interval: int | None
                    """PIM hello interval in seconds."""

                    if TYPE_CHECKING:

                        def __init__(self, *, count: str | None | UndefinedType = Undefined, interval: int | None | UndefinedType = Undefined) -> None:
                            """
                            Hello.


                            Subclass of AvdModel.

                            Args:
                                count: Number of missed hellos after which the neighbor expires. Range <1.5-65535>.
                                interval: PIM hello interval in seconds.

                            """

                _fields: ClassVar[dict] = {
                    "border_router": {"type": bool},
                    "dr_priority": {"type": int},
                    "sparse_mode": {"type": bool},
                    "local_interface": {"type": str},
                    "bfd": {"type": bool},
                    "bidirectional": {"type": bool},
                    "neighbor_filter": {"type": str},
                    "hello": {"type": Hello},
                }
                border_router: bool | None
                """Configure PIM border router. EOS default is false."""
                dr_priority: int | None
                sparse_mode: bool | None
                local_interface: str | None
                bfd: bool | None
                """Set the default for whether Bidirectional Forwarding Detection is enabled for PIM."""
                bidirectional: bool | None
                neighbor_filter: str | None
                """Standard access list name."""
                hello: Hello
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        border_router: bool | None | UndefinedType = Undefined,
                        dr_priority: int | None | UndefinedType = Undefined,
                        sparse_mode: bool | None | UndefinedType = Undefined,
                        local_interface: str | None | UndefinedType = Undefined,
                        bfd: bool | None | UndefinedType = Undefined,
                        bidirectional: bool | None | UndefinedType = Undefined,
                        neighbor_filter: str | None | UndefinedType = Undefined,
                        hello: Hello | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            border_router: Configure PIM border router. EOS default is false.
                            dr_priority: dr_priority
                            sparse_mode: sparse_mode
                            local_interface: local_interface
                            bfd: Set the default for whether Bidirectional Forwarding Detection is enabled for PIM.
                            bidirectional: bidirectional
                            neighbor_filter: Standard access list name.
                            hello: Subclass of AvdModel.

                        """

            _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}}
            ipv4: Ipv4
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, ipv4: Ipv4 | UndefinedType = Undefined) -> None:
                    """
                    Pim.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Subclass of AvdModel.

                    """

        class IsisAuthentication(AvdModel):
            """Subclass of AvdModel."""

            class Both(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}}
                    key_id: int

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Both.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.

                        """

            class Level1(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}}
                    key_id: int

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level1.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.

                        """

            class Level2(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}}
                    key_id: int

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level2.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.

                        """

            _fields: ClassVar[dict] = {"both": {"type": Both}, "level_1": {"type": Level1}, "level_2": {"type": Level2}}
            both: Both
            """
            Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
            'level_2' settings.

            Subclass of AvdModel.
            """
            level_1: Level1
            """
            Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """
            level_2: Level2
            """
            Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """

            if TYPE_CHECKING:

                def __init__(
                    self, *, both: Both | UndefinedType = Undefined, level_1: Level1 | UndefinedType = Undefined, level_2: Level2 | UndefinedType = Undefined
                ) -> None:
                    """
                    IsisAuthentication.


                    Subclass of AvdModel.

                    Args:
                        both:
                           Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
                           'level_2' settings.

                           Subclass of AvdModel.
                        level_1:
                           Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.
                        level_2:
                           Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.

                    """

        class VrrpIdsItem(AvdModel):
            """Subclass of AvdModel."""

            class Advertisement(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}}
                interval: int | None
                """Interval in seconds."""

                if TYPE_CHECKING:

                    def __init__(self, *, interval: int | None | UndefinedType = Undefined) -> None:
                        """
                        Advertisement.


                        Subclass of AvdModel.

                        Args:
                            interval: Interval in seconds.

                        """

            class Preempt(AvdModel):
                """Subclass of AvdModel."""

                class Delay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"minimum": {"type": int}, "reload": {"type": int}}
                    minimum: int | None
                    """Minimum preempt delay in seconds."""
                    reload: int | None
                    """Reload preempt delay in seconds."""

                    if TYPE_CHECKING:

                        def __init__(self, *, minimum: int | None | UndefinedType = Undefined, reload: int | None | UndefinedType = Undefined) -> None:
                            """
                            Delay.


                            Subclass of AvdModel.

                            Args:
                                minimum: Minimum preempt delay in seconds.
                                reload: Reload preempt delay in seconds.

                            """

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "delay": {"type": Delay}}
                enabled: bool
                delay: Delay
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | UndefinedType = Undefined, delay: Delay | UndefinedType = Undefined) -> None:
                        """
                        Preempt.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            delay: Subclass of AvdModel.

                        """

            class Timers(AvdModel):
                """Subclass of AvdModel."""

                class Delay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"reload": {"type": int}}
                    reload: int | None
                    """Delay after reload in seconds."""

                    if TYPE_CHECKING:

                        def __init__(self, *, reload: int | None | UndefinedType = Undefined) -> None:
                            """
                            Delay.


                            Subclass of AvdModel.

                            Args:
                                reload: Delay after reload in seconds.

                            """

                _fields: ClassVar[dict] = {"delay": {"type": Delay}}
                delay: Delay
                """Subclass of AvdModel."""

                if TYPE_CHECKING:

                    def __init__(self, *, delay: Delay | UndefinedType = Undefined) -> None:
                        """
                        Timers.


                        Subclass of AvdModel.

                        Args:
                            delay: Subclass of AvdModel.

                        """

            class TrackedObjectItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "decrement": {"type": int}, "shutdown": {"type": bool}}
                name: str
                """Tracked object name."""
                decrement: int | None
                """Decrement VRRP priority by 1-254."""
                shutdown: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        decrement: int | None | UndefinedType = Undefined,
                        shutdown: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrackedObjectItem.


                        Subclass of AvdModel.

                        Args:
                            name: Tracked object name.
                            decrement: Decrement VRRP priority by 1-254.
                            shutdown: shutdown

                        """

            class TrackedObject(AvdIndexedList[str, TrackedObjectItem]):
                """Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            TrackedObject._item_type = TrackedObjectItem

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class SecondaryAddresses(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                SecondaryAddresses._item_type = str

                _fields: ClassVar[dict] = {"address": {"type": str}, "secondary_addresses": {"type": SecondaryAddresses}, "version": {"type": int}}
                address: str
                """Virtual IPv4 address."""
                secondary_addresses: SecondaryAddresses
                """
                Additional VRRP IPv4 addresses.

                Subclass of AvdList with `str` items.
                """
                version: Literal[2, 3] | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        address: str | UndefinedType = Undefined,
                        secondary_addresses: SecondaryAddresses | UndefinedType = Undefined,
                        version: Literal[2, 3] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            address: Virtual IPv4 address.
                            secondary_addresses:
                               Additional VRRP IPv4 addresses.

                               Subclass of AvdList with `str` items.
                            version: version

                        """

            class Ipv6(AvdModel):
                """Subclass of AvdModel."""

                class Addresses(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Addresses._item_type = str

                _fields: ClassVar[dict] = {"address": {"type": str}, "addresses": {"type": Addresses}}
                address: str | None
                """Virtual IPv6 address."""
                addresses: Addresses
                """
                Virtual IPv6 addresses.

                Subclass of AvdList with `str` items.
                """

                if TYPE_CHECKING:

                    def __init__(self, *, address: str | None | UndefinedType = Undefined, addresses: Addresses | UndefinedType = Undefined) -> None:
                        """
                        Ipv6.


                        Subclass of AvdModel.

                        Args:
                            address: Virtual IPv6 address.
                            addresses:
                               Virtual IPv6 addresses.

                               Subclass of AvdList with `str` items.

                        """

            class PeerAuthentication(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"mode": {"type": str}, "key": {"type": str}, "key_type": {"type": str}}
                mode: Literal["text", "ietf-md5"]
                """Authentication mode."""
                key: str
                """Authentication key."""
                key_type: Literal["0", "7", "8a"] | None
                """Authentication key type."""

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mode: Literal["text", "ietf-md5"] | UndefinedType = Undefined,
                        key: str | UndefinedType = Undefined,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerAuthentication.


                        Subclass of AvdModel.

                        Args:
                            mode: Authentication mode.
                            key: Authentication key.
                            key_type: Authentication key type.

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "priority_level": {"type": int},
                "advertisement": {"type": Advertisement},
                "preempt": {"type": Preempt},
                "timers": {"type": Timers},
                "tracked_object": {"type": TrackedObject},
                "ipv4": {"type": Ipv4},
                "ipv6": {"type": Ipv6},
                "peer_authentication": {"type": PeerAuthentication},
            }
            id: int
            """VRID."""
            priority_level: int | None
            """Instance priority."""
            advertisement: Advertisement
            """Subclass of AvdModel."""
            preempt: Preempt
            """Subclass of AvdModel."""
            timers: Timers
            """Subclass of AvdModel."""
            tracked_object: TrackedObject
            """Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`)."""
            ipv4: Ipv4
            """Subclass of AvdModel."""
            ipv6: Ipv6
            """Subclass of AvdModel."""
            peer_authentication: PeerAuthentication
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    priority_level: int | None | UndefinedType = Undefined,
                    advertisement: Advertisement | UndefinedType = Undefined,
                    preempt: Preempt | UndefinedType = Undefined,
                    timers: Timers | UndefinedType = Undefined,
                    tracked_object: TrackedObject | UndefinedType = Undefined,
                    ipv4: Ipv4 | UndefinedType = Undefined,
                    ipv6: Ipv6 | UndefinedType = Undefined,
                    peer_authentication: PeerAuthentication | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrrpIdsItem.


                    Subclass of AvdModel.

                    Args:
                        id: VRID.
                        priority_level: Instance priority.
                        advertisement: Subclass of AvdModel.
                        preempt: Subclass of AvdModel.
                        timers: Subclass of AvdModel.
                        tracked_object: Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`).
                        ipv4: Subclass of AvdModel.
                        ipv6: Subclass of AvdModel.
                        peer_authentication: Subclass of AvdModel.

                    """

        class VrrpIds(AvdIndexedList[int, VrrpIdsItem]):
            """Subclass of AvdIndexedList with `VrrpIdsItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        VrrpIds._item_type = VrrpIdsItem

        class IpAttachedHostRouteExport(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "distance": {"type": int}}
            enabled: bool
            distance: int | None

            if TYPE_CHECKING:

                def __init__(self, *, enabled: bool | UndefinedType = Undefined, distance: int | None | UndefinedType = Undefined) -> None:
                    """
                    IpAttachedHostRouteExport.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        distance: distance

                    """

        class Ipv6AttachedHostRouteExport(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "distance": {"type": int}, "prefix_length": {"type": int}}
            enabled: bool
            distance: int | None
            """Administrative distance for generated routes."""
            prefix_length: int | None
            """Prefix length for generated routes."""

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    distance: int | None | UndefinedType = Undefined,
                    prefix_length: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6AttachedHostRouteExport.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        distance: Administrative distance for generated routes.
                        prefix_length: Prefix length for generated routes.

                    """

        class Bfd(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"echo": {"type": bool}, "interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}}
            echo: bool | None
            interval: int | None
            """Rate in milliseconds."""
            min_rx: int | None
            """Minimum RX hold time in milliseconds."""
            multiplier: int | None

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    echo: bool | None | UndefinedType = Undefined,
                    interval: int | None | UndefinedType = Undefined,
                    min_rx: int | None | UndefinedType = Undefined,
                    multiplier: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bfd.


                    Subclass of AvdModel.

                    Args:
                        echo: echo
                        interval: Rate in milliseconds.
                        min_rx: Minimum RX hold time in milliseconds.
                        multiplier: multiplier

                    """

        class ServicePolicy(AvdModel):
            """Subclass of AvdModel."""

            class Pbr(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"input": {"type": str}}
                input: str | None
                """Name of policy-map used for policy based routing."""

                if TYPE_CHECKING:

                    def __init__(self, *, input: str | None | UndefinedType = Undefined) -> None:
                        """
                        Pbr.


                        Subclass of AvdModel.

                        Args:
                            input: Name of policy-map used for policy based routing.

                        """

            _fields: ClassVar[dict] = {"pbr": {"type": Pbr}}
            pbr: Pbr
            """Subclass of AvdModel."""

            if TYPE_CHECKING:

                def __init__(self, *, pbr: Pbr | UndefinedType = Undefined) -> None:
                    """
                    ServicePolicy.


                    Subclass of AvdModel.

                    Args:
                        pbr: Subclass of AvdModel.

                    """

        class Tags(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Tags._item_type = str

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "logging": {"type": Logging},
            "shutdown": {"type": bool},
            "vrf": {"type": str},
            "arp_aging_timeout": {"type": int},
            "arp_cache_dynamic_capacity": {"type": int},
            "arp_gratuitous_accept": {"type": bool},
            "arp_monitor_mac_address": {"type": bool},
            "ip_proxy_arp": {"type": bool},
            "ip_directed_broadcast": {"type": bool},
            "ip_address": {"type": str},
            "ip_address_secondaries": {"type": IpAddressSecondaries},
            "ip_virtual_router_addresses": {"type": IpVirtualRouterAddresses},
            "ip_address_virtual": {"type": str},
            "ip_address_virtual_secondaries": {"type": IpAddressVirtualSecondaries},
            "ip_verify_unicast_source_reachable_via": {"type": str},
            "ip_igmp": {"type": bool},
            "ip_igmp_version": {"type": int},
            "ip_igmp_querier_address_virtual": {"type": bool},
            "ip_igmp_host_proxy": {"type": IpIgmpHostProxy},
            "ip_helpers": {"type": IpHelpers},
            "ip_dhcp_relay_all_subnets": {"type": bool},
            "ip_nat": {"type": IpNat},
            "dhcp_server_ipv4": {"type": bool},
            "dhcp_server_ipv6": {"type": bool},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "ipv6_address_virtuals": {"type": Ipv6AddressVirtuals},
            "ipv6_address_link_local": {"type": str},
            "ipv6_virtual_router_addresses": {"type": Ipv6VirtualRouterAddresses},
            "ipv6_nd_ra_disabled": {"type": bool},
            "ipv6_nd_managed_config_flag": {"type": bool},
            "ipv6_nd_other_config_flag": {"type": bool},
            "ipv6_nd_cache": {"type": Ipv6NdCache},
            "ipv6_nd_prefixes": {"type": Ipv6NdPrefixes},
            "ipv6_dhcp_relay_destinations": {"type": Ipv6DhcpRelayDestinations},
            "ipv6_dhcp_relay_all_subnets": {"type": bool},
            "access_group_in": {"type": str},
            "access_group_out": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "ipv6_access_group_out": {"type": str},
            "multicast": {"type": Multicast},
            "ospf_network_point_to_point": {"type": bool},
            "ipv6_ospf_network_point_to_point": {"type": bool},
            "ospf_area": {"type": str},
            "ipv6_ospf_area": {"type": str},
            "ospf_cost": {"type": int},
            "ospf_authentication": {"type": str},
            "ospf_authentication_key": {"type": str},
            "ospf_message_digest_keys": {"type": OspfMessageDigestKeys},
            "pim": {"type": Pim},
            "isis_enable": {"type": str},
            "isis_bfd": {"type": bool},
            "isis_passive": {"type": bool},
            "isis_metric": {"type": int},
            "isis_network_point_to_point": {"type": bool},
            "isis_authentication": {"type": IsisAuthentication},
            "mtu": {"type": int},
            "no_autostate": {"type": bool},
            "vrrp_ids": {"type": VrrpIds},
            "ip_attached_host_route_export": {"type": IpAttachedHostRouteExport},
            "ipv6_attached_host_route_export": {"type": Ipv6AttachedHostRouteExport},
            "bfd": {"type": Bfd},
            "service_policy": {"type": ServicePolicy},
            "ntp_serve": {"type": bool},
            "pvlan_mapping": {"type": str},
            "tenant": {"type": str},
            "tags": {"type": Tags},
            "type": {"type": str},
            "eos_cli": {"type": str},
        }
        name: str
        """VLAN interface name like "Vlan123"."""
        description: str | None
        logging: Logging
        """Subclass of AvdModel."""
        shutdown: bool | None
        vrf: str | None
        """VRF name."""
        arp_aging_timeout: int | None
        """In seconds."""
        arp_cache_dynamic_capacity: int | None
        arp_gratuitous_accept: bool | None
        arp_monitor_mac_address: bool | None
        ip_proxy_arp: bool | None
        ip_directed_broadcast: bool | None
        ip_address: str | None
        """IPv4_address/Mask."""
        ip_address_secondaries: IpAddressSecondaries
        """Subclass of AvdList with `str` items."""
        ip_virtual_router_addresses: IpVirtualRouterAddresses
        """Subclass of AvdList with `str` items."""
        ip_address_virtual: str | None
        """IPv4_address/Mask."""
        ip_address_virtual_secondaries: IpAddressVirtualSecondaries
        """Subclass of AvdList with `str` items."""
        ip_verify_unicast_source_reachable_via: Literal["any", "rx"] | None
        ip_igmp: bool | None
        ip_igmp_version: int | None
        ip_igmp_querier_address_virtual: bool | None
        ip_igmp_host_proxy: IpIgmpHostProxy
        """Subclass of AvdModel."""
        ip_helpers: IpHelpers
        """
        List of DHCP servers.

        Subclass of AvdIndexedList with `IpHelpersItem` items. Primary key is
        `ip_helper` (`str`).
        """
        ip_dhcp_relay_all_subnets: bool | None
        """Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field."""
        ip_nat: IpNat
        """Subclass of AvdModel."""
        dhcp_server_ipv4: bool | None
        """Enable IPv4 DHCP server."""
        dhcp_server_ipv6: bool | None
        """Enable IPv6 DHCP server."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6_address/Mask."""
        ipv6_address_virtuals: Ipv6AddressVirtuals
        """
        The new "ipv6_address_virtuals" key support multiple virtual ipv6 addresses.

        Subclass of AvdList
        with `str` items.
        """
        ipv6_address_link_local: str | None
        """IPv6_address/Mask."""
        ipv6_virtual_router_addresses: Ipv6VirtualRouterAddresses
        """
        Improved "VARPv6" data model to support multiple VARPv6 addresses.

        Subclass of AvdList with `str`
        items.
        """
        ipv6_nd_ra_disabled: bool | None
        ipv6_nd_managed_config_flag: bool | None
        ipv6_nd_other_config_flag: bool | None
        """Set the "other stateful configuration" flag in IPv6 router advertisements."""
        ipv6_nd_cache: Ipv6NdCache
        """
        IPv6 neighbor cache options.

        Subclass of AvdModel.
        """
        ipv6_nd_prefixes: Ipv6NdPrefixes
        """Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`)."""
        ipv6_dhcp_relay_destinations: Ipv6DhcpRelayDestinations
        """
        Subclass of AvdIndexedList with `Ipv6DhcpRelayDestinationsItem` items. Primary key is `address`
        (`str`).
        """
        ipv6_dhcp_relay_all_subnets: bool | None
        """Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field."""
        access_group_in: str | None
        """IPv4 access-list name."""
        access_group_out: str | None
        """IPv4 access-list name."""
        ipv6_access_group_in: str | None
        """IPv6 access-list name."""
        ipv6_access_group_out: str | None
        """IPv6 access-list name."""
        multicast: Multicast
        """Subclass of AvdModel."""
        ospf_network_point_to_point: bool | None
        ipv6_ospf_network_point_to_point: bool | None
        ospf_area: str | None
        ipv6_ospf_area: str | None
        ospf_cost: int | None
        ospf_authentication: Literal["none", "simple", "message-digest"] | None
        ospf_authentication_key: str | None
        """Encrypted password used for simple authentication."""
        ospf_message_digest_keys: OspfMessageDigestKeys
        """
        Keys used for message-digest authentication.

        Subclass of AvdIndexedList with
        `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`).
        """
        pim: Pim
        """Subclass of AvdModel."""
        isis_enable: str | None
        """ISIS instance name."""
        isis_bfd: bool | None
        """Enable BFD for ISIS."""
        isis_passive: bool | None
        isis_metric: int | None
        isis_network_point_to_point: bool | None
        isis_authentication: IsisAuthentication
        """Subclass of AvdModel."""
        mtu: int | None
        no_autostate: bool | None
        vrrp_ids: VrrpIds
        """
        Improved "vrrp" data model to support multiple VRRP IDs.

        Subclass of AvdIndexedList with
        `VrrpIdsItem` items. Primary key is `id` (`int`).
        """
        ip_attached_host_route_export: IpAttachedHostRouteExport
        """Subclass of AvdModel."""
        ipv6_attached_host_route_export: Ipv6AttachedHostRouteExport
        """Subclass of AvdModel."""
        bfd: Bfd
        """Subclass of AvdModel."""
        service_policy: ServicePolicy
        """Subclass of AvdModel."""
        ntp_serve: bool | None
        """Enable/disable serving NTP to clients."""
        pvlan_mapping: str | None
        """List of VLANs as string."""
        tenant: str | None
        """Key only used for documentation or validation purposes."""
        tags: Tags
        """
        Key only used for documentation or validation purposes.

        Subclass of AvdList with `str` items.
        """
        type: str | None
        """Key only used for documentation or validation purposes."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the VLAN interface in the final EOS configuration."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                logging: Logging | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                arp_aging_timeout: int | None | UndefinedType = Undefined,
                arp_cache_dynamic_capacity: int | None | UndefinedType = Undefined,
                arp_gratuitous_accept: bool | None | UndefinedType = Undefined,
                arp_monitor_mac_address: bool | None | UndefinedType = Undefined,
                ip_proxy_arp: bool | None | UndefinedType = Undefined,
                ip_directed_broadcast: bool | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ip_address_secondaries: IpAddressSecondaries | UndefinedType = Undefined,
                ip_virtual_router_addresses: IpVirtualRouterAddresses | UndefinedType = Undefined,
                ip_address_virtual: str | None | UndefinedType = Undefined,
                ip_address_virtual_secondaries: IpAddressVirtualSecondaries | UndefinedType = Undefined,
                ip_verify_unicast_source_reachable_via: Literal["any", "rx"] | None | UndefinedType = Undefined,
                ip_igmp: bool | None | UndefinedType = Undefined,
                ip_igmp_version: int | None | UndefinedType = Undefined,
                ip_igmp_querier_address_virtual: bool | None | UndefinedType = Undefined,
                ip_igmp_host_proxy: IpIgmpHostProxy | UndefinedType = Undefined,
                ip_helpers: IpHelpers | UndefinedType = Undefined,
                ip_dhcp_relay_all_subnets: bool | None | UndefinedType = Undefined,
                ip_nat: IpNat | UndefinedType = Undefined,
                dhcp_server_ipv4: bool | None | UndefinedType = Undefined,
                dhcp_server_ipv6: bool | None | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                ipv6_address_virtuals: Ipv6AddressVirtuals | UndefinedType = Undefined,
                ipv6_address_link_local: str | None | UndefinedType = Undefined,
                ipv6_virtual_router_addresses: Ipv6VirtualRouterAddresses | UndefinedType = Undefined,
                ipv6_nd_ra_disabled: bool | None | UndefinedType = Undefined,
                ipv6_nd_managed_config_flag: bool | None | UndefinedType = Undefined,
                ipv6_nd_other_config_flag: bool | None | UndefinedType = Undefined,
                ipv6_nd_cache: Ipv6NdCache | UndefinedType = Undefined,
                ipv6_nd_prefixes: Ipv6NdPrefixes | UndefinedType = Undefined,
                ipv6_dhcp_relay_destinations: Ipv6DhcpRelayDestinations | UndefinedType = Undefined,
                ipv6_dhcp_relay_all_subnets: bool | None | UndefinedType = Undefined,
                access_group_in: str | None | UndefinedType = Undefined,
                access_group_out: str | None | UndefinedType = Undefined,
                ipv6_access_group_in: str | None | UndefinedType = Undefined,
                ipv6_access_group_out: str | None | UndefinedType = Undefined,
                multicast: Multicast | UndefinedType = Undefined,
                ospf_network_point_to_point: bool | None | UndefinedType = Undefined,
                ipv6_ospf_network_point_to_point: bool | None | UndefinedType = Undefined,
                ospf_area: str | None | UndefinedType = Undefined,
                ipv6_ospf_area: str | None | UndefinedType = Undefined,
                ospf_cost: int | None | UndefinedType = Undefined,
                ospf_authentication: Literal["none", "simple", "message-digest"] | None | UndefinedType = Undefined,
                ospf_authentication_key: str | None | UndefinedType = Undefined,
                ospf_message_digest_keys: OspfMessageDigestKeys | UndefinedType = Undefined,
                pim: Pim | UndefinedType = Undefined,
                isis_enable: str | None | UndefinedType = Undefined,
                isis_bfd: bool | None | UndefinedType = Undefined,
                isis_passive: bool | None | UndefinedType = Undefined,
                isis_metric: int | None | UndefinedType = Undefined,
                isis_network_point_to_point: bool | None | UndefinedType = Undefined,
                isis_authentication: IsisAuthentication | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                no_autostate: bool | None | UndefinedType = Undefined,
                vrrp_ids: VrrpIds | UndefinedType = Undefined,
                ip_attached_host_route_export: IpAttachedHostRouteExport | UndefinedType = Undefined,
                ipv6_attached_host_route_export: Ipv6AttachedHostRouteExport | UndefinedType = Undefined,
                bfd: Bfd | UndefinedType = Undefined,
                service_policy: ServicePolicy | UndefinedType = Undefined,
                ntp_serve: bool | None | UndefinedType = Undefined,
                pvlan_mapping: str | None | UndefinedType = Undefined,
                tenant: str | None | UndefinedType = Undefined,
                tags: Tags | UndefinedType = Undefined,
                type: str | None | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VlanInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: VLAN interface name like "Vlan123".
                    description: description
                    logging: Subclass of AvdModel.
                    shutdown: shutdown
                    vrf: VRF name.
                    arp_aging_timeout: In seconds.
                    arp_cache_dynamic_capacity: arp_cache_dynamic_capacity
                    arp_gratuitous_accept: arp_gratuitous_accept
                    arp_monitor_mac_address: arp_monitor_mac_address
                    ip_proxy_arp: ip_proxy_arp
                    ip_directed_broadcast: ip_directed_broadcast
                    ip_address: IPv4_address/Mask.
                    ip_address_secondaries: Subclass of AvdList with `str` items.
                    ip_virtual_router_addresses: Subclass of AvdList with `str` items.
                    ip_address_virtual: IPv4_address/Mask.
                    ip_address_virtual_secondaries: Subclass of AvdList with `str` items.
                    ip_verify_unicast_source_reachable_via: ip_verify_unicast_source_reachable_via
                    ip_igmp: ip_igmp
                    ip_igmp_version: ip_igmp_version
                    ip_igmp_querier_address_virtual: ip_igmp_querier_address_virtual
                    ip_igmp_host_proxy: Subclass of AvdModel.
                    ip_helpers:
                       List of DHCP servers.

                       Subclass of AvdIndexedList with `IpHelpersItem` items. Primary key is
                       `ip_helper` (`str`).
                    ip_dhcp_relay_all_subnets: Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field.
                    ip_nat: Subclass of AvdModel.
                    dhcp_server_ipv4: Enable IPv4 DHCP server.
                    dhcp_server_ipv6: Enable IPv6 DHCP server.
                    ipv6_enable: ipv6_enable
                    ipv6_address: IPv6_address/Mask.
                    ipv6_address_virtuals:
                       The new "ipv6_address_virtuals" key support multiple virtual ipv6 addresses.

                       Subclass of AvdList
                       with `str` items.
                    ipv6_address_link_local: IPv6_address/Mask.
                    ipv6_virtual_router_addresses:
                       Improved "VARPv6" data model to support multiple VARPv6 addresses.

                       Subclass of AvdList with `str`
                       items.
                    ipv6_nd_ra_disabled: ipv6_nd_ra_disabled
                    ipv6_nd_managed_config_flag: ipv6_nd_managed_config_flag
                    ipv6_nd_other_config_flag: Set the "other stateful configuration" flag in IPv6 router advertisements.
                    ipv6_nd_cache:
                       IPv6 neighbor cache options.

                       Subclass of AvdModel.
                    ipv6_nd_prefixes: Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`).
                    ipv6_dhcp_relay_destinations:
                       Subclass of AvdIndexedList with `Ipv6DhcpRelayDestinationsItem` items. Primary key is `address`
                       (`str`).
                    ipv6_dhcp_relay_all_subnets: Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field.
                    access_group_in: IPv4 access-list name.
                    access_group_out: IPv4 access-list name.
                    ipv6_access_group_in: IPv6 access-list name.
                    ipv6_access_group_out: IPv6 access-list name.
                    multicast: Subclass of AvdModel.
                    ospf_network_point_to_point: ospf_network_point_to_point
                    ipv6_ospf_network_point_to_point: ipv6_ospf_network_point_to_point
                    ospf_area: ospf_area
                    ipv6_ospf_area: ipv6_ospf_area
                    ospf_cost: ospf_cost
                    ospf_authentication: ospf_authentication
                    ospf_authentication_key: Encrypted password used for simple authentication.
                    ospf_message_digest_keys:
                       Keys used for message-digest authentication.

                       Subclass of AvdIndexedList with
                       `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`).
                    pim: Subclass of AvdModel.
                    isis_enable: ISIS instance name.
                    isis_bfd: Enable BFD for ISIS.
                    isis_passive: isis_passive
                    isis_metric: isis_metric
                    isis_network_point_to_point: isis_network_point_to_point
                    isis_authentication: Subclass of AvdModel.
                    mtu: mtu
                    no_autostate: no_autostate
                    vrrp_ids:
                       Improved "vrrp" data model to support multiple VRRP IDs.

                       Subclass of AvdIndexedList with
                       `VrrpIdsItem` items. Primary key is `id` (`int`).
                    ip_attached_host_route_export: Subclass of AvdModel.
                    ipv6_attached_host_route_export: Subclass of AvdModel.
                    bfd: Subclass of AvdModel.
                    service_policy: Subclass of AvdModel.
                    ntp_serve: Enable/disable serving NTP to clients.
                    pvlan_mapping: List of VLANs as string.
                    tenant: Key only used for documentation or validation purposes.
                    tags:
                       Key only used for documentation or validation purposes.

                       Subclass of AvdList with `str` items.
                    type: Key only used for documentation or validation purposes.
                    eos_cli: Multiline EOS CLI rendered directly on the VLAN interface in the final EOS configuration.

                """

    class VlanInterfaces(AvdIndexedList[str, VlanInterfacesItem]):
        """Subclass of AvdIndexedList with `VlanInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    VlanInterfaces._item_type = VlanInterfacesItem

    class VlanInternalOrder(AvdModel):
        """Subclass of AvdModel."""

        class Range(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"beginning": {"type": int}, "ending": {"type": int}}
            beginning: int
            """First VLAN ID."""
            ending: int
            """Last VLAN ID."""

            if TYPE_CHECKING:

                def __init__(self, *, beginning: int | UndefinedType = Undefined, ending: int | UndefinedType = Undefined) -> None:
                    """
                    Range.


                    Subclass of AvdModel.

                    Args:
                        beginning: First VLAN ID.
                        ending: Last VLAN ID.

                    """

        _fields: ClassVar[dict] = {"allocation": {"type": str}, "range": {"type": Range}}
        allocation: Literal["ascending", "descending"]
        range: Range
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, allocation: Literal["ascending", "descending"] | UndefinedType = Undefined, range: Range | UndefinedType = Undefined) -> None:
                """
                VlanInternalOrder.


                Subclass of AvdModel.

                Args:
                    allocation: allocation
                    range: Subclass of AvdModel.

                """

    class VlansItem(AvdModel):
        """Subclass of AvdModel."""

        class AddressLocking(AvdModel):
            """Subclass of AvdModel."""

            class AddressFamily(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4": {"type": bool}, "ipv6": {"type": bool}}
                ipv4: bool | None
                """Enable address locking for IPv4."""
                ipv6: bool | None
                """Enable address locking for IPv6."""

                if TYPE_CHECKING:

                    def __init__(self, *, ipv4: bool | None | UndefinedType = Undefined, ipv6: bool | None | UndefinedType = Undefined) -> None:
                        """
                        AddressFamily.


                        Subclass of AvdModel.

                        Args:
                            ipv4: Enable address locking for IPv4.
                            ipv6: Enable address locking for IPv6.

                        """

            _fields: ClassVar[dict] = {"address_family": {"type": AddressFamily}, "ipv4_enforcement_disabled": {"type": bool}}
            address_family: AddressFamily
            """Subclass of AvdModel."""
            ipv4_enforcement_disabled: bool | None
            """Disable enforcement for IPv4 locked addresses."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, address_family: AddressFamily | UndefinedType = Undefined, ipv4_enforcement_disabled: bool | None | UndefinedType = Undefined
                ) -> None:
                    """
                    AddressLocking.


                    Subclass of AvdModel.

                    Args:
                        address_family: Subclass of AvdModel.
                        ipv4_enforcement_disabled: Disable enforcement for IPv4 locked addresses.

                    """

        class TrunkGroups(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        TrunkGroups._item_type = str

        class ETree(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"leaf_role": {"type": bool}, "remote_leaf_host_drop": {"type": bool}}
            leaf_role: bool | None
            """Set the VLAN into the E-Tree leaf role. By default all VLANs are in root role."""
            remote_leaf_host_drop: bool | None
            """
            Enables remote leaf hosts to instead be installed as explicit drop routes in the local FDB. This is
            only applicable for VLANs operating in the 'Leaf' role.
            """

            if TYPE_CHECKING:

                def __init__(
                    self, *, leaf_role: bool | None | UndefinedType = Undefined, remote_leaf_host_drop: bool | None | UndefinedType = Undefined
                ) -> None:
                    """
                    ETree.


                    Subclass of AvdModel.

                    Args:
                        leaf_role: Set the VLAN into the E-Tree leaf role. By default all VLANs are in root role.
                        remote_leaf_host_drop:
                           Enables remote leaf hosts to instead be installed as explicit drop routes in the local FDB. This is
                           only applicable for VLANs operating in the 'Leaf' role.

                    """

        class PrivateVlan(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"type": {"type": str}, "primary_vlan": {"type": int}}
            type: Literal["community", "isolated"] | None
            primary_vlan: int | None
            """Primary VLAN ID."""

            if TYPE_CHECKING:

                def __init__(
                    self, *, type: Literal["community", "isolated"] | None | UndefinedType = Undefined, primary_vlan: int | None | UndefinedType = Undefined
                ) -> None:
                    """
                    PrivateVlan.


                    Subclass of AvdModel.

                    Args:
                        type: type
                        primary_vlan: Primary VLAN ID.

                    """

        _fields: ClassVar[dict] = {
            "id": {"type": int},
            "name": {"type": str},
            "state": {"type": str},
            "address_locking": {"type": AddressLocking},
            "trunk_groups": {"type": TrunkGroups},
            "e_tree": {"type": ETree},
            "private_vlan": {"type": PrivateVlan},
            "tenant": {"type": str},
        }
        id: int
        """VLAN ID."""
        name: str | None
        """VLAN Name."""
        state: Literal["active", "suspend"] | None
        address_locking: AddressLocking
        """Subclass of AvdModel."""
        trunk_groups: TrunkGroups
        """Subclass of AvdList with `str` items."""
        e_tree: ETree
        """Subclass of AvdModel."""
        private_vlan: PrivateVlan
        """Subclass of AvdModel."""
        tenant: str | None
        """Key only used for documentation or validation purposes."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                id: int | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                state: Literal["active", "suspend"] | None | UndefinedType = Undefined,
                address_locking: AddressLocking | UndefinedType = Undefined,
                trunk_groups: TrunkGroups | UndefinedType = Undefined,
                e_tree: ETree | UndefinedType = Undefined,
                private_vlan: PrivateVlan | UndefinedType = Undefined,
                tenant: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VlansItem.


                Subclass of AvdModel.

                Args:
                    id: VLAN ID.
                    name: VLAN Name.
                    state: state
                    address_locking: Subclass of AvdModel.
                    trunk_groups: Subclass of AvdList with `str` items.
                    e_tree: Subclass of AvdModel.
                    private_vlan: Subclass of AvdModel.
                    tenant: Key only used for documentation or validation purposes.

                """

    class Vlans(AvdIndexedList[int, VlansItem]):
        """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""

        _primary_key: ClassVar[str] = "id"

    Vlans._item_type = VlansItem

    class VmtracerSessionsItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "url": {"type": str},
            "username": {"type": str},
            "password": {"type": str},
            "autovlan_disable": {"type": bool},
            "vrf": {"type": str},
            "source_interface": {"type": str},
        }
        name: str
        """Vmtracer Session Name."""
        url: str | None
        username: str | None
        password: str | None
        """Type 7 Password Hash."""
        autovlan_disable: bool | None
        vrf: str | None
        source_interface: str | None

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                url: str | None | UndefinedType = Undefined,
                username: str | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                autovlan_disable: bool | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VmtracerSessionsItem.


                Subclass of AvdModel.

                Args:
                    name: Vmtracer Session Name.
                    url: url
                    username: username
                    password: Type 7 Password Hash.
                    autovlan_disable: autovlan_disable
                    vrf: vrf
                    source_interface: source_interface

                """

    class VmtracerSessions(AvdIndexedList[str, VmtracerSessionsItem]):
        """Subclass of AvdIndexedList with `VmtracerSessionsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    VmtracerSessions._item_type = VmtracerSessionsItem

    class VrfsItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "ip_routing": {"type": bool},
            "ipv6_routing": {"type": bool},
            "ip_routing_ipv6_interfaces": {"type": bool},
            "tenant": {"type": str},
        }
        name: str
        """VRF Name."""
        description: str | None
        ip_routing: bool | None
        ipv6_routing: bool | None
        ip_routing_ipv6_interfaces: bool | None
        tenant: str | None
        """Key only used for documentation or validation purposes."""

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                ip_routing: bool | None | UndefinedType = Undefined,
                ipv6_routing: bool | None | UndefinedType = Undefined,
                ip_routing_ipv6_interfaces: bool | None | UndefinedType = Undefined,
                tenant: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.


                Subclass of AvdModel.

                Args:
                    name: VRF Name.
                    description: description
                    ip_routing: ip_routing
                    ipv6_routing: ipv6_routing
                    ip_routing_ipv6_interfaces: ip_routing_ipv6_interfaces
                    tenant: Key only used for documentation or validation purposes.

                """

    class Vrfs(AvdIndexedList[str, VrfsItem]):
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Vrfs._item_type = VrfsItem

    class VxlanInterface(AvdModel):
        """Subclass of AvdModel."""

        class Vxlan1(AvdModel):
            """Subclass of AvdModel."""

            class Vxlan(AvdModel):
                """Subclass of AvdModel."""

                class Multicast(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"headend_replication": {"type": bool}}
                    headend_replication: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, headend_replication: bool | None | UndefinedType = Undefined) -> None:
                            """
                            Multicast.


                            Subclass of AvdModel.

                            Args:
                                headend_replication: headend_replication

                            """

                class ControllerClient(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}}
                    enabled: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | None | UndefinedType = Undefined) -> None:
                            """
                            ControllerClient.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled

                            """

                class Encapsulations(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ipv4": {"type": bool}, "ipv6": {"type": bool}}
                    ipv4: bool | None
                    """Use IPv4 for VXLAN Encapsulation."""
                    ipv6: bool | None
                    """Use IPv6 for VXLAN Encapsulation."""

                    if TYPE_CHECKING:

                        def __init__(self, *, ipv4: bool | None | UndefinedType = Undefined, ipv6: bool | None | UndefinedType = Undefined) -> None:
                            """
                            Encapsulations.


                            Subclass of AvdModel.

                            Args:
                                ipv4: Use IPv4 for VXLAN Encapsulation.
                                ipv6: Use IPv6 for VXLAN Encapsulation.

                            """

                class BfdVtepEvpn(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}, "prefix_list": {"type": str}}
                    interval: int | None
                    min_rx: int | None
                    multiplier: int | None
                    prefix_list: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            interval: int | None | UndefinedType = Undefined,
                            min_rx: int | None | UndefinedType = Undefined,
                            multiplier: int | None | UndefinedType = Undefined,
                            prefix_list: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BfdVtepEvpn.


                            Subclass of AvdModel.

                            Args:
                                interval: interval
                                min_rx: min_rx
                                multiplier: multiplier
                                prefix_list: prefix_list

                            """

                class Qos(AvdModel):
                    """Subclass of AvdModel."""

                    class DscpEcn(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"rewrite_bridged_enabled": {"type": bool}}
                        rewrite_bridged_enabled: bool | None
                        """Enable DSCP and ECN rewrite for VXLAN bridged packets."""

                        if TYPE_CHECKING:

                            def __init__(self, *, rewrite_bridged_enabled: bool | None | UndefinedType = Undefined) -> None:
                                """
                                DscpEcn.


                                Subclass of AvdModel.

                                Args:
                                    rewrite_bridged_enabled: Enable DSCP and ECN rewrite for VXLAN bridged packets.

                                """

                    _fields: ClassVar[dict] = {
                        "dscp_propagation_encapsulation": {"type": bool},
                        "ecn_propagation": {"type": bool},
                        "map_dscp_to_traffic_class_decapsulation": {"type": bool},
                        "dscp_ecn": {"type": DscpEcn},
                    }
                    dscp_propagation_encapsulation: bool | None
                    ecn_propagation: bool | None
                    """Enable copying the ECN marking to/from encapsulated packets."""
                    map_dscp_to_traffic_class_decapsulation: bool | None
                    dscp_ecn: DscpEcn
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            dscp_propagation_encapsulation: bool | None | UndefinedType = Undefined,
                            ecn_propagation: bool | None | UndefinedType = Undefined,
                            map_dscp_to_traffic_class_decapsulation: bool | None | UndefinedType = Undefined,
                            dscp_ecn: DscpEcn | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Qos.


                            Subclass of AvdModel.

                            Args:
                                dscp_propagation_encapsulation: dscp_propagation_encapsulation
                                ecn_propagation: Enable copying the ECN marking to/from encapsulated packets.
                                map_dscp_to_traffic_class_decapsulation: map_dscp_to_traffic_class_decapsulation
                                dscp_ecn: Subclass of AvdModel.

                            """

                class VlanRange(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"vlans": {"type": str}, "vnis": {"type": str}}
                    vlans: str
                    """e.g. "94,96,100-110"."""
                    vnis: str
                    """
                    Set `vnis` in the correct sequence as `vlans`.
                    e.g. "10094,10096,10100-10110".
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, vlans: str | UndefinedType = Undefined, vnis: str | UndefinedType = Undefined) -> None:
                            """
                            VlanRange.


                            Subclass of AvdModel.

                            Args:
                                vlans: e.g. "94,96,100-110".
                                vnis:
                                   Set `vnis` in the correct sequence as `vlans`.
                                   e.g. "10094,10096,10100-10110".

                            """

                class VlansItem(AvdModel):
                    """Subclass of AvdModel."""

                    class FloodVteps(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    FloodVteps._item_type = str

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "vni": {"type": int},
                        "multicast_group": {"type": str},
                        "flood_vteps": {"type": FloodVteps},
                        "flood_group": {"type": str},
                    }
                    id: int
                    """VLAN ID."""
                    vni: int | None
                    multicast_group: str | None
                    """IP Multicast Group Address."""
                    flood_vteps: FloodVteps
                    """Subclass of AvdList with `str` items."""
                    flood_group: str | None
                    """Flood multicast group address."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            vni: int | None | UndefinedType = Undefined,
                            multicast_group: str | None | UndefinedType = Undefined,
                            flood_vteps: FloodVteps | UndefinedType = Undefined,
                            flood_group: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VlansItem.


                            Subclass of AvdModel.

                            Args:
                                id: VLAN ID.
                                vni: vni
                                multicast_group: IP Multicast Group Address.
                                flood_vteps: Subclass of AvdList with `str` items.
                                flood_group: Flood multicast group address.

                            """

                class Vlans(AvdIndexedList[int, VlansItem]):
                    """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                Vlans._item_type = VlansItem

                class VrfsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class MulticastGroupsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"overlay_group": {"type": str}, "encap": {"type": str}}
                        overlay_group: str
                        """Overlay multicast group."""
                        encap: str
                        """Underlay multicast group."""

                        if TYPE_CHECKING:

                            def __init__(self, *, overlay_group: str | UndefinedType = Undefined, encap: str | UndefinedType = Undefined) -> None:
                                """
                                MulticastGroupsItem.


                                Subclass of AvdModel.

                                Args:
                                    overlay_group: Overlay multicast group.
                                    encap: Underlay multicast group.

                                """

                    class MulticastGroups(AvdIndexedList[str, MulticastGroupsItem]):
                        """Subclass of AvdIndexedList with `MulticastGroupsItem` items. Primary key is `overlay_group` (`str`)."""

                        _primary_key: ClassVar[str] = "overlay_group"

                    MulticastGroups._item_type = MulticastGroupsItem

                    _fields: ClassVar[dict] = {
                        "name": {"type": str},
                        "vni": {"type": int},
                        "multicast_group": {"type": str},
                        "multicast_group_encap_range": {"type": str},
                        "multicast_groups": {"type": MulticastGroups},
                    }
                    name: str
                    """VRF Name."""
                    vni: int | None
                    multicast_group: str | None
                    """Default IP Multicast Group Address for the VRF."""
                    multicast_group_encap_range: str | None
                    """
                    N:M mapping, the overlay groups in the VRF are mapped to one of
                    the underlay groups defined within
                    the encap range.
                    The format is X.X.X.X/YY (IPv4 multicast group with prefix length between 19 and
                    32).
                    Default multicast group `vxlan_interface.vxlan1.vxlan.vrfs.[].multicast_group` is required for
                    this feature to work.
                    See the TOI at
                    https://www.arista.com/en/support/toi/eos-4-29-1f/16546-multicast-evpn-irb-multiple-underlay-groups
                    """
                    multicast_groups: MulticastGroups
                    """
                    List of 1:1 mappings where each configured overlay multicast group is mapped
                    directly to the
                    specified underlay multicast group.

                    Subclass of AvdIndexedList with `MulticastGroupsItem` items.
                    Primary key is `overlay_group` (`str`).
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            vni: int | None | UndefinedType = Undefined,
                            multicast_group: str | None | UndefinedType = Undefined,
                            multicast_group_encap_range: str | None | UndefinedType = Undefined,
                            multicast_groups: MulticastGroups | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VrfsItem.


                            Subclass of AvdModel.

                            Args:
                                name: VRF Name.
                                vni: vni
                                multicast_group: Default IP Multicast Group Address for the VRF.
                                multicast_group_encap_range:
                                   N:M mapping, the overlay groups in the VRF are mapped to one of
                                   the underlay groups defined within
                                   the encap range.
                                   The format is X.X.X.X/YY (IPv4 multicast group with prefix length between 19 and
                                   32).
                                   Default multicast group `vxlan_interface.vxlan1.vxlan.vrfs.[].multicast_group` is required for
                                   this feature to work.
                                   See the TOI at
                                   https://www.arista.com/en/support/toi/eos-4-29-1f/16546-multicast-evpn-irb-multiple-underlay-groups
                                multicast_groups:
                                   List of 1:1 mappings where each configured overlay multicast group is mapped
                                   directly to the
                                   specified underlay multicast group.

                                   Subclass of AvdIndexedList with `MulticastGroupsItem` items.
                                   Primary key is `overlay_group` (`str`).

                            """

                class Vrfs(AvdIndexedList[str, VrfsItem]):
                    """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                Vrfs._item_type = VrfsItem

                class FloodVteps(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                FloodVteps._item_type = str

                _fields: ClassVar[dict] = {
                    "source_interface": {"type": str},
                    "multicast": {"type": Multicast},
                    "controller_client": {"type": ControllerClient},
                    "mlag_source_interface": {"type": str},
                    "udp_port": {"type": int},
                    "encapsulations": {"type": Encapsulations},
                    "vtep_to_vtep_bridging": {"type": bool},
                    "virtual_router_encapsulation_mac_address": {"type": str},
                    "bfd_vtep_evpn": {"type": BfdVtepEvpn},
                    "qos": {"type": Qos},
                    "vlan_range": {"type": VlanRange},
                    "vlans": {"type": Vlans},
                    "vrfs": {"type": Vrfs},
                    "flood_vteps": {"type": FloodVteps},
                    "flood_vtep_learned_data_plane": {"type": bool},
                }
                source_interface: str | None
                """Source Interface Name."""
                multicast: Multicast
                """Subclass of AvdModel."""
                controller_client: ControllerClient
                """
                Client to CVX Controllers.

                Subclass of AvdModel.
                """
                mlag_source_interface: str | None
                udp_port: int | None
                encapsulations: Encapsulations
                """Subclass of AvdModel."""
                vtep_to_vtep_bridging: bool | None
                """Enable bridging between different VTEPs in vxlan overlay."""
                virtual_router_encapsulation_mac_address: str | None
                """"mlag-system-id" or ethernet_address (H.H.H)."""
                bfd_vtep_evpn: BfdVtepEvpn
                """Subclass of AvdModel."""
                qos: Qos
                """
                For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                core ports must be in "DSCP Trust" mode.
                !!!Warning, only few hardware types with software version
                >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.


                Subclass of AvdModel.
                """
                vlan_range: VlanRange
                """
                Set VNI on range of VLANs. Number of VLANs must equal number of VNIs.
                If a VNI is set for a VLAN
                using `vlan_range`, VNI setting in `vxlan_interface.vxlan1.vxlan.vlans` is ignored for that VLAN.
                Subclass of AvdModel.
                """
                vlans: Vlans
                """
                Set VNI/multicast group/remote vtep on a vlan.
                If a VNI is set for a VLAN using `vlan_range`, VNI
                setting in `vxlan_interface.vxlan1.vxlan.vlans` is ignored for that VLAN.

                Subclass of
                AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`).
                """
                vrfs: Vrfs
                """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
                flood_vteps: FloodVteps
                """Subclass of AvdList with `str` items."""
                flood_vtep_learned_data_plane: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_interface: str | None | UndefinedType = Undefined,
                        multicast: Multicast | UndefinedType = Undefined,
                        controller_client: ControllerClient | UndefinedType = Undefined,
                        mlag_source_interface: str | None | UndefinedType = Undefined,
                        udp_port: int | None | UndefinedType = Undefined,
                        encapsulations: Encapsulations | UndefinedType = Undefined,
                        vtep_to_vtep_bridging: bool | None | UndefinedType = Undefined,
                        virtual_router_encapsulation_mac_address: str | None | UndefinedType = Undefined,
                        bfd_vtep_evpn: BfdVtepEvpn | UndefinedType = Undefined,
                        qos: Qos | UndefinedType = Undefined,
                        vlan_range: VlanRange | UndefinedType = Undefined,
                        vlans: Vlans | UndefinedType = Undefined,
                        vrfs: Vrfs | UndefinedType = Undefined,
                        flood_vteps: FloodVteps | UndefinedType = Undefined,
                        flood_vtep_learned_data_plane: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Vxlan.


                        Subclass of AvdModel.

                        Args:
                            source_interface: Source Interface Name.
                            multicast: Subclass of AvdModel.
                            controller_client:
                               Client to CVX Controllers.

                               Subclass of AvdModel.
                            mlag_source_interface: mlag_source_interface
                            udp_port: udp_port
                            encapsulations: Subclass of AvdModel.
                            vtep_to_vtep_bridging: Enable bridging between different VTEPs in vxlan overlay.
                            virtual_router_encapsulation_mac_address: "mlag-system-id" or ethernet_address (H.H.H).
                            bfd_vtep_evpn: Subclass of AvdModel.
                            qos:
                               For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                               core ports must be in "DSCP Trust" mode.
                               !!!Warning, only few hardware types with software version
                               >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.


                               Subclass of AvdModel.
                            vlan_range:
                               Set VNI on range of VLANs. Number of VLANs must equal number of VNIs.
                               If a VNI is set for a VLAN
                               using `vlan_range`, VNI setting in `vxlan_interface.vxlan1.vxlan.vlans` is ignored for that VLAN.
                               Subclass of AvdModel.
                            vlans:
                               Set VNI/multicast group/remote vtep on a vlan.
                               If a VNI is set for a VLAN using `vlan_range`, VNI
                               setting in `vxlan_interface.vxlan1.vxlan.vlans` is ignored for that VLAN.

                               Subclass of
                               AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`).
                            vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                            flood_vteps: Subclass of AvdList with `str` items.
                            flood_vtep_learned_data_plane: flood_vtep_learned_data_plane

                        """

            _fields: ClassVar[dict] = {"description": {"type": str}, "vxlan": {"type": Vxlan}, "eos_cli": {"type": str}}
            description: str | None
            vxlan: Vxlan
            """Subclass of AvdModel."""
            eos_cli: str | None
            """
            Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
            configuration.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    description: str | None | UndefinedType = Undefined,
                    vxlan: Vxlan | UndefinedType = Undefined,
                    eos_cli: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Vxlan1.


                    Subclass of AvdModel.

                    Args:
                        description: description
                        vxlan: Subclass of AvdModel.
                        eos_cli:
                           Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
                           configuration.

                    """

        class Vxlan1(AvdModel):
            """Subclass of AvdModel."""

            class Vxlan(AvdModel):
                """Subclass of AvdModel."""

                class Multicast(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"headend_replication": {"type": bool}}
                    headend_replication: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, headend_replication: bool | None | UndefinedType = Undefined) -> None:
                            """
                            Multicast.


                            Subclass of AvdModel.

                            Args:
                                headend_replication: headend_replication

                            """

                class ControllerClient(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}}
                    enabled: bool | None

                    if TYPE_CHECKING:

                        def __init__(self, *, enabled: bool | None | UndefinedType = Undefined) -> None:
                            """
                            ControllerClient.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled

                            """

                class Encapsulations(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ipv4": {"type": bool}, "ipv6": {"type": bool}}
                    ipv4: bool | None
                    """Use IPv4 for VXLAN Encapsulation."""
                    ipv6: bool | None
                    """Use IPv6 for VXLAN Encapsulation."""

                    if TYPE_CHECKING:

                        def __init__(self, *, ipv4: bool | None | UndefinedType = Undefined, ipv6: bool | None | UndefinedType = Undefined) -> None:
                            """
                            Encapsulations.


                            Subclass of AvdModel.

                            Args:
                                ipv4: Use IPv4 for VXLAN Encapsulation.
                                ipv6: Use IPv6 for VXLAN Encapsulation.

                            """

                class BfdVtepEvpn(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}, "prefix_list": {"type": str}}
                    interval: int | None
                    min_rx: int | None
                    multiplier: int | None
                    prefix_list: str | None

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            interval: int | None | UndefinedType = Undefined,
                            min_rx: int | None | UndefinedType = Undefined,
                            multiplier: int | None | UndefinedType = Undefined,
                            prefix_list: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BfdVtepEvpn.


                            Subclass of AvdModel.

                            Args:
                                interval: interval
                                min_rx: min_rx
                                multiplier: multiplier
                                prefix_list: prefix_list

                            """

                class Qos(AvdModel):
                    """Subclass of AvdModel."""

                    class DscpEcn(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"rewrite_bridged_enabled": {"type": bool}}
                        rewrite_bridged_enabled: bool | None
                        """Enable DSCP and ECN rewrite for VXLAN bridged packets."""

                        if TYPE_CHECKING:

                            def __init__(self, *, rewrite_bridged_enabled: bool | None | UndefinedType = Undefined) -> None:
                                """
                                DscpEcn.


                                Subclass of AvdModel.

                                Args:
                                    rewrite_bridged_enabled: Enable DSCP and ECN rewrite for VXLAN bridged packets.

                                """

                    _fields: ClassVar[dict] = {
                        "dscp_propagation_encapsulation": {"type": bool},
                        "ecn_propagation": {"type": bool},
                        "map_dscp_to_traffic_class_decapsulation": {"type": bool},
                        "dscp_ecn": {"type": DscpEcn},
                    }
                    dscp_propagation_encapsulation: bool | None
                    ecn_propagation: bool | None
                    """Enable copying the ECN marking to/from encapsulated packets."""
                    map_dscp_to_traffic_class_decapsulation: bool | None
                    dscp_ecn: DscpEcn
                    """Subclass of AvdModel."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            dscp_propagation_encapsulation: bool | None | UndefinedType = Undefined,
                            ecn_propagation: bool | None | UndefinedType = Undefined,
                            map_dscp_to_traffic_class_decapsulation: bool | None | UndefinedType = Undefined,
                            dscp_ecn: DscpEcn | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Qos.


                            Subclass of AvdModel.

                            Args:
                                dscp_propagation_encapsulation: dscp_propagation_encapsulation
                                ecn_propagation: Enable copying the ECN marking to/from encapsulated packets.
                                map_dscp_to_traffic_class_decapsulation: map_dscp_to_traffic_class_decapsulation
                                dscp_ecn: Subclass of AvdModel.

                            """

                class VlanRange(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"vlans": {"type": str}, "vnis": {"type": str}}
                    vlans: str
                    """e.g. "94,96,100-110"."""
                    vnis: str
                    """
                    Set `vnis` in the correct sequence as `vlans`.
                    e.g. "10094,10096,10100-10110".
                    """

                    if TYPE_CHECKING:

                        def __init__(self, *, vlans: str | UndefinedType = Undefined, vnis: str | UndefinedType = Undefined) -> None:
                            """
                            VlanRange.


                            Subclass of AvdModel.

                            Args:
                                vlans: e.g. "94,96,100-110".
                                vnis:
                                   Set `vnis` in the correct sequence as `vlans`.
                                   e.g. "10094,10096,10100-10110".

                            """

                class VlansItem(AvdModel):
                    """Subclass of AvdModel."""

                    class FloodVteps(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    FloodVteps._item_type = str

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "vni": {"type": int},
                        "multicast_group": {"type": str},
                        "flood_vteps": {"type": FloodVteps},
                        "flood_group": {"type": str},
                    }
                    id: int
                    """VLAN ID."""
                    vni: int | None
                    multicast_group: str | None
                    """IP Multicast Group Address."""
                    flood_vteps: FloodVteps
                    """Subclass of AvdList with `str` items."""
                    flood_group: str | None
                    """Flood multicast group address."""

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            vni: int | None | UndefinedType = Undefined,
                            multicast_group: str | None | UndefinedType = Undefined,
                            flood_vteps: FloodVteps | UndefinedType = Undefined,
                            flood_group: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VlansItem.


                            Subclass of AvdModel.

                            Args:
                                id: VLAN ID.
                                vni: vni
                                multicast_group: IP Multicast Group Address.
                                flood_vteps: Subclass of AvdList with `str` items.
                                flood_group: Flood multicast group address.

                            """

                class Vlans(AvdIndexedList[int, VlansItem]):
                    """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                Vlans._item_type = VlansItem

                class VrfsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class MulticastGroupsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"overlay_group": {"type": str}, "encap": {"type": str}}
                        overlay_group: str
                        """Overlay multicast group."""
                        encap: str
                        """Underlay multicast group."""

                        if TYPE_CHECKING:

                            def __init__(self, *, overlay_group: str | UndefinedType = Undefined, encap: str | UndefinedType = Undefined) -> None:
                                """
                                MulticastGroupsItem.


                                Subclass of AvdModel.

                                Args:
                                    overlay_group: Overlay multicast group.
                                    encap: Underlay multicast group.

                                """

                    class MulticastGroups(AvdIndexedList[str, MulticastGroupsItem]):
                        """Subclass of AvdIndexedList with `MulticastGroupsItem` items. Primary key is `overlay_group` (`str`)."""

                        _primary_key: ClassVar[str] = "overlay_group"

                    MulticastGroups._item_type = MulticastGroupsItem

                    _fields: ClassVar[dict] = {
                        "name": {"type": str},
                        "vni": {"type": int},
                        "multicast_group": {"type": str},
                        "multicast_group_encap_range": {"type": str},
                        "multicast_groups": {"type": MulticastGroups},
                    }
                    name: str
                    """VRF Name."""
                    vni: int | None
                    multicast_group: str | None
                    """Default IP Multicast Group Address for the VRF."""
                    multicast_group_encap_range: str | None
                    """
                    N:M mapping, the overlay groups in the VRF are mapped to one of
                    the underlay groups defined within
                    the encap range.
                    The format is X.X.X.X/YY (IPv4 multicast group with prefix length between 19 and
                    32).
                    Default multicast group `vxlan_interface.vxlan1.vxlan.vrfs.[].multicast_group` is required for
                    this feature to work.
                    See the TOI at
                    https://www.arista.com/en/support/toi/eos-4-29-1f/16546-multicast-evpn-irb-multiple-underlay-groups
                    """
                    multicast_groups: MulticastGroups
                    """
                    List of 1:1 mappings where each configured overlay multicast group is mapped
                    directly to the
                    specified underlay multicast group.

                    Subclass of AvdIndexedList with `MulticastGroupsItem` items.
                    Primary key is `overlay_group` (`str`).
                    """

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            vni: int | None | UndefinedType = Undefined,
                            multicast_group: str | None | UndefinedType = Undefined,
                            multicast_group_encap_range: str | None | UndefinedType = Undefined,
                            multicast_groups: MulticastGroups | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VrfsItem.


                            Subclass of AvdModel.

                            Args:
                                name: VRF Name.
                                vni: vni
                                multicast_group: Default IP Multicast Group Address for the VRF.
                                multicast_group_encap_range:
                                   N:M mapping, the overlay groups in the VRF are mapped to one of
                                   the underlay groups defined within
                                   the encap range.
                                   The format is X.X.X.X/YY (IPv4 multicast group with prefix length between 19 and
                                   32).
                                   Default multicast group `vxlan_interface.vxlan1.vxlan.vrfs.[].multicast_group` is required for
                                   this feature to work.
                                   See the TOI at
                                   https://www.arista.com/en/support/toi/eos-4-29-1f/16546-multicast-evpn-irb-multiple-underlay-groups
                                multicast_groups:
                                   List of 1:1 mappings where each configured overlay multicast group is mapped
                                   directly to the
                                   specified underlay multicast group.

                                   Subclass of AvdIndexedList with `MulticastGroupsItem` items.
                                   Primary key is `overlay_group` (`str`).

                            """

                class Vrfs(AvdIndexedList[str, VrfsItem]):
                    """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                Vrfs._item_type = VrfsItem

                class FloodVteps(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                FloodVteps._item_type = str

                _fields: ClassVar[dict] = {
                    "source_interface": {"type": str},
                    "multicast": {"type": Multicast},
                    "controller_client": {"type": ControllerClient},
                    "mlag_source_interface": {"type": str},
                    "udp_port": {"type": int},
                    "encapsulations": {"type": Encapsulations},
                    "vtep_to_vtep_bridging": {"type": bool},
                    "virtual_router_encapsulation_mac_address": {"type": str},
                    "bfd_vtep_evpn": {"type": BfdVtepEvpn},
                    "qos": {"type": Qos},
                    "vlan_range": {"type": VlanRange},
                    "vlans": {"type": Vlans},
                    "vrfs": {"type": Vrfs},
                    "flood_vteps": {"type": FloodVteps},
                    "flood_vtep_learned_data_plane": {"type": bool},
                }
                source_interface: str | None
                """Source Interface Name."""
                multicast: Multicast
                """Subclass of AvdModel."""
                controller_client: ControllerClient
                """
                Client to CVX Controllers.

                Subclass of AvdModel.
                """
                mlag_source_interface: str | None
                udp_port: int | None
                encapsulations: Encapsulations
                """Subclass of AvdModel."""
                vtep_to_vtep_bridging: bool | None
                """Enable bridging between different VTEPs in vxlan overlay."""
                virtual_router_encapsulation_mac_address: str | None
                """"mlag-system-id" or ethernet_address (H.H.H)."""
                bfd_vtep_evpn: BfdVtepEvpn
                """Subclass of AvdModel."""
                qos: Qos
                """
                For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                core ports must be in "DSCP Trust" mode.
                !!!Warning, only few hardware types with software version
                >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.


                Subclass of AvdModel.
                """
                vlan_range: VlanRange
                """
                Set VNI on range of VLANs. Number of VLANs must equal number of VNIs.
                If a VNI is set for a VLAN
                using `vlan_range`, VNI setting in `vxlan_interface.vxlan1.vxlan.vlans` is ignored for that VLAN.
                Subclass of AvdModel.
                """
                vlans: Vlans
                """
                Set VNI/multicast group/remote vtep on a vlan.
                If a VNI is set for a VLAN using `vlan_range`, VNI
                setting in `vxlan_interface.vxlan1.vxlan.vlans` is ignored for that VLAN.

                Subclass of
                AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`).
                """
                vrfs: Vrfs
                """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
                flood_vteps: FloodVteps
                """Subclass of AvdList with `str` items."""
                flood_vtep_learned_data_plane: bool | None

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_interface: str | None | UndefinedType = Undefined,
                        multicast: Multicast | UndefinedType = Undefined,
                        controller_client: ControllerClient | UndefinedType = Undefined,
                        mlag_source_interface: str | None | UndefinedType = Undefined,
                        udp_port: int | None | UndefinedType = Undefined,
                        encapsulations: Encapsulations | UndefinedType = Undefined,
                        vtep_to_vtep_bridging: bool | None | UndefinedType = Undefined,
                        virtual_router_encapsulation_mac_address: str | None | UndefinedType = Undefined,
                        bfd_vtep_evpn: BfdVtepEvpn | UndefinedType = Undefined,
                        qos: Qos | UndefinedType = Undefined,
                        vlan_range: VlanRange | UndefinedType = Undefined,
                        vlans: Vlans | UndefinedType = Undefined,
                        vrfs: Vrfs | UndefinedType = Undefined,
                        flood_vteps: FloodVteps | UndefinedType = Undefined,
                        flood_vtep_learned_data_plane: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Vxlan.


                        Subclass of AvdModel.

                        Args:
                            source_interface: Source Interface Name.
                            multicast: Subclass of AvdModel.
                            controller_client:
                               Client to CVX Controllers.

                               Subclass of AvdModel.
                            mlag_source_interface: mlag_source_interface
                            udp_port: udp_port
                            encapsulations: Subclass of AvdModel.
                            vtep_to_vtep_bridging: Enable bridging between different VTEPs in vxlan overlay.
                            virtual_router_encapsulation_mac_address: "mlag-system-id" or ethernet_address (H.H.H).
                            bfd_vtep_evpn: Subclass of AvdModel.
                            qos:
                               For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                               core ports must be in "DSCP Trust" mode.
                               !!!Warning, only few hardware types with software version
                               >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.


                               Subclass of AvdModel.
                            vlan_range:
                               Set VNI on range of VLANs. Number of VLANs must equal number of VNIs.
                               If a VNI is set for a VLAN
                               using `vlan_range`, VNI setting in `vxlan_interface.vxlan1.vxlan.vlans` is ignored for that VLAN.
                               Subclass of AvdModel.
                            vlans:
                               Set VNI/multicast group/remote vtep on a vlan.
                               If a VNI is set for a VLAN using `vlan_range`, VNI
                               setting in `vxlan_interface.vxlan1.vxlan.vlans` is ignored for that VLAN.

                               Subclass of
                               AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`).
                            vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                            flood_vteps: Subclass of AvdList with `str` items.
                            flood_vtep_learned_data_plane: flood_vtep_learned_data_plane

                        """

            _fields: ClassVar[dict] = {"description": {"type": str}, "vxlan": {"type": Vxlan}, "eos_cli": {"type": str}}
            description: str | None
            vxlan: Vxlan
            """Subclass of AvdModel."""
            eos_cli: str | None
            """
            Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
            configuration.
            """

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    description: str | None | UndefinedType = Undefined,
                    vxlan: Vxlan | UndefinedType = Undefined,
                    eos_cli: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Vxlan1.


                    Subclass of AvdModel.

                    Args:
                        description: description
                        vxlan: Subclass of AvdModel.
                        eos_cli:
                           Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
                           configuration.

                    """

        _fields: ClassVar[dict] = {"vxlan1": {"type": Vxlan1}, "field_Vxlan1": {"type": Vxlan1}}
        _field_to_key_map: ClassVar[dict] = {"field_Vxlan1": "Vxlan1"}
        _key_to_field_map: ClassVar[dict] = {"Vxlan1": "field_Vxlan1"}
        vxlan1: Vxlan1
        """Subclass of AvdModel."""
        field_Vxlan1: Vxlan1
        """Subclass of AvdModel."""

        if TYPE_CHECKING:

            def __init__(self, *, vxlan1: Vxlan1 | UndefinedType = Undefined, field_Vxlan1: Vxlan1 | UndefinedType = Undefined) -> None:
                """
                VxlanInterface.


                Subclass of AvdModel.

                Args:
                    vxlan1: Subclass of AvdModel.
                    field_Vxlan1: Subclass of AvdModel.

                """

    _fields: ClassVar[dict] = {
        "aaa_accounting": {"type": AaaAccounting},
        "aaa_authentication": {"type": AaaAuthentication},
        "aaa_authorization": {"type": AaaAuthorization},
        "aaa_root": {"type": AaaRoot},
        "aaa_server_groups": {"type": AaaServerGroups},
        "access_lists": {"type": AccessLists},
        "address_locking": {"type": AddressLocking},
        "agents": {"type": Agents},
        "aliases": {"type": str},
        "application_traffic_recognition": {"type": ApplicationTrafficRecognition},
        "arp": {"type": Arp},
        "as_path": {"type": AsPath},
        "avd_data_validation_mode": {"type": str, "default": "error"},
        "banners": {"type": Banners},
        "bgp_groups": {"type": BgpGroups},
        "boot": {"type": Boot},
        "cfm": {"type": Cfm},
        "class_maps": {"type": ClassMaps},
        "clock": {"type": Clock},
        "community_lists": {"type": CommunityLists},
        "config_comment": {"type": str},
        "config_end": {"type": bool, "default": False},
        "custom_templates": {"type": CustomTemplates},
        "cvx": {"type": Cvx},
        "daemon_terminattr": {"type": DaemonTerminattr},
        "daemons": {"type": Daemons},
        "dhcp_relay": {"type": DhcpRelay},
        "dhcp_servers": {"type": DhcpServers},
        "dns_domain": {"type": str},
        "domain_list": {"type": DomainList},
        "dot1x": {"type": Dot1x},
        "dps_interfaces": {"type": DpsInterfaces},
        "dynamic_prefix_lists": {"type": DynamicPrefixLists},
        "enable_password": {"type": EnablePassword},
        "eos_cli": {"type": str},
        "eos_cli_config_gen_configuration": {"type": EosCliConfigGenConfiguration},
        "eos_cli_config_gen_documentation": {"type": EosCliConfigGenDocumentation},
        "errdisable": {"type": Errdisable},
        "ethernet_interfaces": {"type": EthernetInterfaces},
        "event_handlers": {"type": EventHandlers},
        "event_monitor": {"type": EventMonitor},
        "flow_tracking": {"type": FlowTracking},
        "generate_default_config": {"type": bool, "default": False},
        "generate_device_documentation": {"type": bool, "default": True},
        "hardware": {"type": Hardware},
        "hardware_counters": {"type": HardwareCounters},
        "hostname": {"type": str},
        "interface_defaults": {"type": InterfaceDefaults},
        "interface_groups": {"type": InterfaceGroups},
        "interface_profiles": {"type": InterfaceProfiles},
        "ip_access_lists": {"type": IpAccessLists},
        "ip_access_lists_max_entries": {"type": int},
        "ip_community_lists": {"type": IpCommunityLists},
        "ip_dhcp_relay": {"type": IpDhcpRelay},
        "ip_dhcp_snooping": {"type": IpDhcpSnooping},
        "ip_domain_lookup": {"type": IpDomainLookup},
        "ip_extcommunity_lists": {"type": IpExtcommunityLists},
        "ip_extcommunity_lists_regexp": {"type": IpExtcommunityListsRegexp},
        "ip_ftp_client_source_interfaces": {"type": IpFtpClientSourceInterfaces},
        "ip_hardware": {"type": IpHardware},
        "ip_http_client_source_interfaces": {"type": IpHttpClientSourceInterfaces},
        "ip_icmp_redirect": {"type": bool},
        "ip_igmp_snooping": {"type": IpIgmpSnooping},
        "ip_name_server_groups": {"type": IpNameServerGroups},
        "ip_name_servers": {"type": IpNameServers},
        "ip_nat": {"type": IpNat},
        "ip_ospf_router_id_output_format_hostnames": {"type": bool},
        "ip_radius_source_interfaces": {"type": IpRadiusSourceInterfaces},
        "ip_routing": {"type": bool},
        "ip_routing_ipv6_interfaces": {"type": bool},
        "ip_security": {"type": IpSecurity},
        "ip_ssh_client_source_interfaces": {"type": IpSshClientSourceInterfaces},
        "ip_tacacs_source_interfaces": {"type": IpTacacsSourceInterfaces},
        "ip_telnet_client_source_interfaces": {"type": IpTelnetClientSourceInterfaces},
        "ip_tftp_client_source_interfaces": {"type": IpTftpClientSourceInterfaces},
        "ip_virtual_router_mac_address": {"type": str},
        "ip_virtual_router_mac_address_advertisement_interval": {"type": int},
        "ip_virtual_router_mac_address_mlag_peer": {"type": bool},
        "ipv6_access_lists": {"type": Ipv6AccessLists},
        "ipv6_dhcp_relay": {"type": Ipv6DhcpRelay},
        "ipv6_hardware": {"type": Ipv6Hardware},
        "ipv6_icmp_redirect": {"type": bool},
        "ipv6_neighbor": {"type": Ipv6Neighbor},
        "ipv6_prefix_lists": {"type": Ipv6PrefixLists},
        "ipv6_router_ospf": {"type": Ipv6RouterOspf},
        "ipv6_standard_access_lists": {"type": Ipv6StandardAccessLists},
        "ipv6_static_routes": {"type": Ipv6StaticRoutes},
        "ipv6_unicast_routing": {"type": bool},
        "is_deployed": {"type": bool},
        "kernel": {"type": Kernel},
        "l2_protocol": {"type": L2Protocol},
        "lacp": {"type": Lacp},
        "link_tracking_groups": {"type": LinkTrackingGroups},
        "lldp": {"type": Lldp},
        "load_balance": {"type": LoadBalance},
        "load_interval": {"type": LoadInterval},
        "local_users": {"type": LocalUsers},
        "logging": {"type": Logging},
        "loopback_interfaces": {"type": LoopbackInterfaces},
        "mac_access_lists": {"type": MacAccessLists},
        "mac_address_table": {"type": MacAddressTable},
        "mac_security": {"type": MacSecurity},
        "maintenance": {"type": Maintenance},
        "management_accounts": {"type": ManagementAccounts},
        "management_api_gnmi": {"type": ManagementApiGnmi},
        "management_api_http": {"type": ManagementApiHttp},
        "management_api_models": {"type": ManagementApiModels},
        "management_console": {"type": ManagementConsole},
        "management_cvx": {"type": ManagementCvx},
        "management_defaults": {"type": ManagementDefaults},
        "management_interfaces": {"type": ManagementInterfaces},
        "management_security": {"type": ManagementSecurity},
        "management_ssh": {"type": ManagementSsh},
        "management_tech_support": {"type": ManagementTechSupport},
        "match_list_input": {"type": MatchListInput},
        "mcs_client": {"type": McsClient},
        "metadata": {"type": Metadata},
        "mlag_configuration": {"type": MlagConfiguration},
        "monitor_connectivity": {"type": MonitorConnectivity},
        "monitor_layer1": {"type": MonitorLayer1},
        "monitor_server_radius": {"type": MonitorServerRadius},
        "monitor_session_default_encapsulation_gre": {"type": MonitorSessionDefaultEncapsulationGre},
        "monitor_sessions": {"type": MonitorSessions},
        "monitor_telemetry_influx": {"type": MonitorTelemetryInflux},
        "monitor_telemetry_postcard_policy": {"type": MonitorTelemetryPostcardPolicy},
        "monitor_twamp": {"type": MonitorTwamp},
        "mpls": {"type": Mpls},
        "ntp": {"type": Ntp},
        "patch_panel": {"type": PatchPanel},
        "peer_filters": {"type": PeerFilters},
        "platform": {"type": Platform},
        "poe": {"type": Poe},
        "policy_maps": {"type": PolicyMaps},
        "port_channel": {"type": PortChannel},
        "port_channel_interfaces": {"type": PortChannelInterfaces},
        "prefix_lists": {"type": PrefixLists},
        "priority_flow_control": {"type": PriorityFlowControl},
        "prompt": {"type": str},
        "ptp": {"type": Ptp},
        "qos": {"type": Qos},
        "qos_profiles": {"type": QosProfiles},
        "queue_monitor_length": {"type": QueueMonitorLength},
        "queue_monitor_streaming": {"type": QueueMonitorStreaming},
        "radius_proxy": {"type": RadiusProxy},
        "radius_server": {"type": RadiusServer},
        "redundancy": {"type": Redundancy},
        "roles": {"type": Roles},
        "route_maps": {"type": RouteMaps},
        "router_adaptive_virtual_topology": {"type": RouterAdaptiveVirtualTopology},
        "router_bfd": {"type": RouterBfd},
        "router_bgp": {"type": RouterBgp},
        "router_general": {"type": RouterGeneral},
        "router_igmp": {"type": RouterIgmp},
        "router_internet_exit": {"type": RouterInternetExit},
        "router_isis": {"type": RouterIsis},
        "router_l2_vpn": {"type": RouterL2Vpn},
        "router_msdp": {"type": RouterMsdp},
        "router_multicast": {"type": RouterMulticast},
        "router_ospf": {"type": RouterOspf},
        "router_path_selection": {"type": RouterPathSelection},
        "router_pim_sparse_mode": {"type": RouterPimSparseMode},
        "router_rip": {"type": RouterRip},
        "router_segment_security": {"type": RouterSegmentSecurity},
        "router_service_insertion": {"type": RouterServiceInsertion},
        "router_traffic_engineering": {"type": RouterTrafficEngineering},
        "serial_number": {"type": str},
        "service_routing_configuration_bgp": {"type": ServiceRoutingConfigurationBgp},
        "service_routing_protocols_model": {"type": str},
        "service_unsupported_transceiver": {"type": ServiceUnsupportedTransceiver},
        "sflow": {"type": Sflow},
        "snmp_server": {"type": SnmpServer},
        "spanning_tree": {"type": SpanningTree},
        "standard_access_lists": {"type": StandardAccessLists},
        "static_routes": {"type": StaticRoutes},
        "stun": {"type": Stun},
        "switchport_default": {"type": SwitchportDefault},
        "switchport_port_security": {"type": SwitchportPortSecurity},
        "sync_e": {"type": SyncE},
        "system": {"type": System},
        "tacacs_servers": {"type": TacacsServers},
        "tap_aggregation": {"type": TapAggregation},
        "tcam_profile": {"type": TcamProfile},
        "terminal": {"type": Terminal},
        "trackers": {"type": Trackers},
        "traffic_policies": {"type": TrafficPolicies},
        "transceiver": {"type": Transceiver},
        "transceiver_qsfp_default_mode_4x10": {"type": bool, "default": True},
        "tunnel_interfaces": {"type": TunnelInterfaces},
        "virtual_source_nat_vrfs": {"type": VirtualSourceNatVrfs},
        "vlan_interfaces": {"type": VlanInterfaces},
        "vlan_internal_order": {"type": VlanInternalOrder},
        "vlans": {"type": Vlans},
        "vmtracer_sessions": {"type": VmtracerSessions},
        "vrfs": {"type": Vrfs},
        "vxlan_interface": {"type": VxlanInterface},
    }
    _allow_other_keys: ClassVar[bool] = True
    aaa_accounting: AaaAccounting
    """Subclass of AvdModel."""
    aaa_authentication: AaaAuthentication
    """Subclass of AvdModel."""
    aaa_authorization: AaaAuthorization
    """Subclass of AvdModel."""
    aaa_root: AaaRoot
    """Subclass of AvdModel."""
    aaa_server_groups: AaaServerGroups
    """Subclass of AvdIndexedList with `AaaServerGroupsItem` items. Primary key is `name` (`str`)."""
    access_lists: AccessLists
    """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""
    address_locking: AddressLocking
    """Subclass of AvdModel."""
    agents: Agents
    """Subclass of AvdIndexedList with `AgentsItem` items. Primary key is `name` (`str`)."""
    aliases: str | None
    """
    Multi-line string with one or more alias commands.

    Example:

    ```yaml
    aliases: |
      alias wr copy
    running-config startup-config
      alias siib show ip interface brief
    ```
    """
    application_traffic_recognition: ApplicationTrafficRecognition
    """
    Application traffic recognition configuration.

    Subclass of AvdModel.
    """
    arp: Arp
    """Subclass of AvdModel."""
    as_path: AsPath
    """Subclass of AvdModel."""
    avd_data_validation_mode: Literal["error", "warning"]
    """
    Validation Mode for AVD input data validation.
    Input data validation will validate the input
    variables according to the schema.
    During validation, messages will generated with information about
    the host(s) and key(s) which failed validation.
    "error" will produce error messages and fail the
    task.
    "warning" will produce warning messages.

    Default value: `"error"`
    """
    banners: Banners
    """Subclass of AvdModel."""
    bgp_groups: BgpGroups
    """Subclass of AvdIndexedList with `BgpGroupsItem` items. Primary key is `name` (`str`)."""
    boot: Boot
    """
    Set the Aboot password.


    Subclass of AvdModel.
    """
    cfm: Cfm
    """
    Configure connectivity fault management (CFM).
    CFM is a network protocol for monitoring and
    troubleshooting Ethernet networks.

    Subclass of AvdModel.
    """
    class_maps: ClassMaps
    """Subclass of AvdModel."""
    clock: Clock
    """Subclass of AvdModel."""
    community_lists: CommunityLists
    """Subclass of AvdIndexedList with `CommunityListsItem` items. Primary key is `name` (`str`)."""
    config_comment: str | None
    """
    Add a comment to provide information about the configuration.
    This comment will be rendered at the
    top of the generated configuration.
    """
    config_end: bool
    """
    Render `end` at the end of the configuration.

    Default value: `False`
    """
    custom_templates: CustomTemplates
    """
    - Custom templates can be added below the playbook directory.
    - If a location above the directory is
    desired, a symbolic link can be used.
    - Example under the `playbooks` directory create symbolic link
    with the following command:

      ```bash
      ln -s ../../shared_repo/custom_avd_templates/
    ./custom_avd_templates
      ```

    - The output will be rendered at the end of the configuration.
    - The
    order of custom templates in the list can be important if they overlap.
    - It is recommended to use a
    `!` delimiter at the top of each custom template.

    Add `custom_templates` to group/host variables:
    Subclass of AvdList with `str` items.
    """
    cvx: Cvx
    """
    CVX server features are not supported on physical switches. See `management_cvx` for client
    configurations.

    Subclass of AvdModel.
    """
    daemon_terminattr: DaemonTerminattr
    """
    You can either provide a list of IPs/FQDNs to target on-premise Cloudvision cluster or use DNS name
    for your Cloudvision as a Service instance.
    Streaming to multiple clusters both on-prem and cloud
    service is supported.

    !!! note
        For TerminAttr version recommendation and EOS compatibility
    matrix, please refer to the latest TerminAttr Release Notes
        which always contain the latest
    recommended versions and minimum required versions per EOS release.


    Subclass of AvdModel.
    """
    daemons: Daemons
    """
    This will add a daemon to the eos configuration that is most useful when trying to run OpenConfig
    clients like ocprometheus.

    Subclass of AvdIndexedList with `DaemonsItem` items. Primary key is
    `name` (`str`).
    """
    dhcp_relay: DhcpRelay
    """Subclass of AvdModel."""
    dhcp_servers: DhcpServers
    """Subclass of AvdIndexedList with `DhcpServersItem` items. Primary key is `vrf` (`str`)."""
    dns_domain: str | None
    """Domain Name."""
    domain_list: DomainList
    """
    Search list of DNS domains.

    Subclass of AvdList with `str` items.
    """
    dot1x: Dot1x
    """Subclass of AvdModel."""
    dps_interfaces: DpsInterfaces
    """Subclass of AvdIndexedList with `DpsInterfacesItem` items. Primary key is `name` (`str`)."""
    dynamic_prefix_lists: DynamicPrefixLists
    """Subclass of AvdList with `DynamicPrefixListsItem` items."""
    enable_password: EnablePassword
    """Subclass of AvdModel."""
    eos_cli: str | None
    """Multiline string with EOS CLI rendered directly on the root level of the final EOS configuration."""
    eos_cli_config_gen_configuration: EosCliConfigGenConfiguration
    """Subclass of AvdModel."""
    eos_cli_config_gen_documentation: EosCliConfigGenDocumentation
    """Subclass of AvdModel."""
    errdisable: Errdisable
    """Subclass of AvdModel."""
    ethernet_interfaces: EthernetInterfaces
    """Subclass of AvdIndexedList with `EthernetInterfacesItem` items. Primary key is `name` (`str`)."""
    event_handlers: EventHandlers
    """
    Gives the ability to monitor and react to Syslog messages.
    Event Handlers provide a powerful and
    flexible tool that can be used to apply self-healing actions,
    customize the system behavior, and
    implement workarounds to problems discovered in the field.


    Subclass of AvdIndexedList with
    `EventHandlersItem` items. Primary key is `name` (`str`).
    """
    event_monitor: EventMonitor
    """Subclass of AvdModel."""
    flow_tracking: FlowTracking
    """Subclass of AvdModel."""
    generate_default_config: bool
    """
    The `generate_default_config` knob allows to omit default EOS configuration.
    This can be useful when
    leveraging `eos_cli_config_gen` to generate configlets with CloudVision.

    The following commands
    will be omitted when `generate_default_config` is set to `false`:

    - RANCID Content Type
    - Hostname
    (even if `hostname` variable is not set. Then the hostname is picked up from `inventory_hostname`)
    -
    Default configuration for `aaa`
    - Default configuration for `enable password`
    - Transceiver qsfp
    default mode
    - End of configuration delimiter

    Default value: `False`
    """
    generate_device_documentation: bool
    """Default value: `True`"""
    hardware: Hardware
    """Subclass of AvdModel."""
    hardware_counters: HardwareCounters
    """Subclass of AvdModel."""
    hostname: str | None
    interface_defaults: InterfaceDefaults
    """Subclass of AvdModel."""
    interface_groups: InterfaceGroups
    """Subclass of AvdIndexedList with `InterfaceGroupsItem` items. Primary key is `name` (`str`)."""
    interface_profiles: InterfaceProfiles
    """Subclass of AvdIndexedList with `InterfaceProfilesItem` items. Primary key is `name` (`str`)."""
    ip_access_lists: IpAccessLists
    """Subclass of AvdIndexedList with `IpAccessListsItem` items. Primary key is `name` (`str`)."""
    ip_access_lists_max_entries: int | None
    """Limit ACL entries defined under the `ip_access_lists`."""
    ip_community_lists: IpCommunityLists
    """
    Communities and regexp entries MUST not be configured in the same community-list.


    Subclass of
    AvdIndexedList with `IpCommunityListsItem` items. Primary key is `name` (`str`).
    """
    ip_dhcp_relay: IpDhcpRelay
    """Subclass of AvdModel."""
    ip_dhcp_snooping: IpDhcpSnooping
    """Subclass of AvdModel."""
    ip_domain_lookup: IpDomainLookup
    """Subclass of AvdModel."""
    ip_extcommunity_lists: IpExtcommunityLists
    """Subclass of AvdIndexedList with `IpExtcommunityListsItem` items. Primary key is `name` (`str`)."""
    ip_extcommunity_lists_regexp: IpExtcommunityListsRegexp
    """
    Subclass of AvdIndexedList with `IpExtcommunityListsRegexpItem` items. Primary key is `name`
    (`str`).
    """
    ip_ftp_client_source_interfaces: IpFtpClientSourceInterfaces
    """Subclass of AvdList with `IpFtpClientSourceInterfacesItem` items."""
    ip_hardware: IpHardware
    """Subclass of AvdModel."""
    ip_http_client_source_interfaces: IpHttpClientSourceInterfaces
    """Subclass of AvdList with `IpHttpClientSourceInterfacesItem` items."""
    ip_icmp_redirect: bool | None
    ip_igmp_snooping: IpIgmpSnooping
    """Subclass of AvdModel."""
    ip_name_server_groups: IpNameServerGroups
    """Subclass of AvdIndexedList with `IpNameServerGroupsItem` items. Primary key is `name` (`str`)."""
    ip_name_servers: IpNameServers
    """Subclass of AvdList with `IpNameServersItem` items."""
    ip_nat: IpNat
    """Subclass of AvdModel."""
    ip_ospf_router_id_output_format_hostnames: bool | None
    """Display DNS-resolved router names for OSPF router IDs."""
    ip_radius_source_interfaces: IpRadiusSourceInterfaces
    """Subclass of AvdList with `IpRadiusSourceInterfacesItem` items."""
    ip_routing: bool | None
    ip_routing_ipv6_interfaces: bool | None
    ip_security: IpSecurity
    """Subclass of AvdModel."""
    ip_ssh_client_source_interfaces: IpSshClientSourceInterfaces
    """Subclass of AvdList with `IpSshClientSourceInterfacesItem` items."""
    ip_tacacs_source_interfaces: IpTacacsSourceInterfaces
    """Subclass of AvdList with `IpTacacsSourceInterfacesItem` items."""
    ip_telnet_client_source_interfaces: IpTelnetClientSourceInterfaces
    """Subclass of AvdList with `IpTelnetClientSourceInterfacesItem` items."""
    ip_tftp_client_source_interfaces: IpTftpClientSourceInterfaces
    """Subclass of AvdList with `IpTftpClientSourceInterfacesItem` items."""
    ip_virtual_router_mac_address: str | None
    """MAC address (hh:hh:hh:hh:hh:hh)."""
    ip_virtual_router_mac_address_advertisement_interval: int | None
    """Advertisement interval in seconds."""
    ip_virtual_router_mac_address_mlag_peer: bool | None
    """Enable MLAG peer gateway."""
    ipv6_access_lists: Ipv6AccessLists
    """Subclass of AvdIndexedList with `Ipv6AccessListsItem` items. Primary key is `name` (`str`)."""
    ipv6_dhcp_relay: Ipv6DhcpRelay
    """Subclass of AvdModel."""
    ipv6_hardware: Ipv6Hardware
    """Subclass of AvdModel."""
    ipv6_icmp_redirect: bool | None
    ipv6_neighbor: Ipv6Neighbor
    """Subclass of AvdModel."""
    ipv6_prefix_lists: Ipv6PrefixLists
    """Subclass of AvdIndexedList with `Ipv6PrefixListsItem` items. Primary key is `name` (`str`)."""
    ipv6_router_ospf: Ipv6RouterOspf
    """Subclass of AvdModel."""
    ipv6_standard_access_lists: Ipv6StandardAccessLists
    """Subclass of AvdIndexedList with `Ipv6StandardAccessListsItem` items. Primary key is `name` (`str`)."""
    ipv6_static_routes: Ipv6StaticRoutes
    """Subclass of AvdList with `Ipv6StaticRoutesItem` items."""
    ipv6_unicast_routing: bool | None
    is_deployed: bool | None
    """
    Key only used for documentation or validation purposes.
    This key is deprecated and new key is
    metadata.is_deployed.
    """
    kernel: Kernel
    """Subclass of AvdModel."""
    l2_protocol: L2Protocol
    """Subclass of AvdModel."""
    lacp: Lacp
    """
    Set Link Aggregation Control Protocol (LACP) parameters.

    Subclass of AvdModel.
    """
    link_tracking_groups: LinkTrackingGroups
    """Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`)."""
    lldp: Lldp
    """Subclass of AvdModel."""
    load_balance: LoadBalance
    """
    Configuration for load balancing behavior across port-channels and ECMP paths.

    Subclass of
    AvdModel.
    """
    load_interval: LoadInterval
    """Subclass of AvdModel."""
    local_users: LocalUsers
    """Subclass of AvdIndexedList with `LocalUsersItem` items. Primary key is `name` (`str`)."""
    logging: Logging
    """Subclass of AvdModel."""
    loopback_interfaces: LoopbackInterfaces
    """Subclass of AvdIndexedList with `LoopbackInterfacesItem` items. Primary key is `name` (`str`)."""
    mac_access_lists: MacAccessLists
    """Subclass of AvdIndexedList with `MacAccessListsItem` items. Primary key is `name` (`str`)."""
    mac_address_table: MacAddressTable
    """Subclass of AvdModel."""
    mac_security: MacSecurity
    """Subclass of AvdModel."""
    maintenance: Maintenance
    """Subclass of AvdModel."""
    management_accounts: ManagementAccounts
    """Subclass of AvdModel."""
    management_api_gnmi: ManagementApiGnmi
    """Subclass of AvdModel."""
    management_api_http: ManagementApiHttp
    """Subclass of AvdModel."""
    management_api_models: ManagementApiModels
    """Subclass of AvdModel."""
    management_console: ManagementConsole
    """Subclass of AvdModel."""
    management_cvx: ManagementCvx
    """Subclass of AvdModel."""
    management_defaults: ManagementDefaults
    """Subclass of AvdModel."""
    management_interfaces: ManagementInterfaces
    """Subclass of AvdIndexedList with `ManagementInterfacesItem` items. Primary key is `name` (`str`)."""
    management_security: ManagementSecurity
    """Subclass of AvdModel."""
    management_ssh: ManagementSsh
    """Subclass of AvdModel."""
    management_tech_support: ManagementTechSupport
    """Subclass of AvdModel."""
    match_list_input: MatchListInput
    """Subclass of AvdModel."""
    mcs_client: McsClient
    """Subclass of AvdModel."""
    metadata: Metadata
    """
    The data under `metadata` is used for documentation, validation or integration purposes.
    It will not
    affect the generated EOS configuration.

    Subclass of AvdModel.
    """
    mlag_configuration: MlagConfiguration
    """Subclass of AvdModel."""
    monitor_connectivity: MonitorConnectivity
    """Subclass of AvdModel."""
    monitor_layer1: MonitorLayer1
    """
    Enable SYSLOG messages on transceiver SMBus communication failures.

    Subclass of AvdModel.
    """
    monitor_server_radius: MonitorServerRadius
    """
    Settings to monitor radius servers.

    Subclass of AvdModel.
    """
    monitor_session_default_encapsulation_gre: MonitorSessionDefaultEncapsulationGre
    """Subclass of AvdModel."""
    monitor_sessions: MonitorSessions
    """Subclass of AvdIndexedList with `MonitorSessionsItem` items. Primary key is `name` (`str`)."""
    monitor_telemetry_influx: MonitorTelemetryInflux
    """Subclass of AvdModel."""
    monitor_telemetry_postcard_policy: MonitorTelemetryPostcardPolicy
    """Subclass of AvdModel."""
    monitor_twamp: MonitorTwamp
    """Subclass of AvdModel."""
    mpls: Mpls
    """Subclass of AvdModel."""
    ntp: Ntp
    """Subclass of AvdModel."""
    patch_panel: PatchPanel
    """Subclass of AvdModel."""
    peer_filters: PeerFilters
    """Subclass of AvdIndexedList with `PeerFiltersItem` items. Primary key is `name` (`str`)."""
    platform: Platform
    """
    Every key below this point is platform dependent.

    Subclass of AvdModel.
    """
    poe: Poe
    """Subclass of AvdModel."""
    policy_maps: PolicyMaps
    """Subclass of AvdModel."""
    port_channel: PortChannel
    """Subclass of AvdModel."""
    port_channel_interfaces: PortChannelInterfaces
    """Subclass of AvdIndexedList with `PortChannelInterfacesItem` items. Primary key is `name` (`str`)."""
    prefix_lists: PrefixLists
    """Subclass of AvdIndexedList with `PrefixListsItem` items. Primary key is `name` (`str`)."""
    priority_flow_control: PriorityFlowControl
    """
    Global Priority Flow Control settings.


    Subclass of AvdModel.
    """
    prompt: str | None
    ptp: Ptp
    """Subclass of AvdModel."""
    qos: Qos
    """Subclass of AvdModel."""
    qos_profiles: QosProfiles
    """Subclass of AvdIndexedList with `QosProfilesItem` items. Primary key is `name` (`str`)."""
    queue_monitor_length: QueueMonitorLength
    """Subclass of AvdModel."""
    queue_monitor_streaming: QueueMonitorStreaming
    """Subclass of AvdModel."""
    radius_proxy: RadiusProxy
    """
    Configure RADIUS proxy parameters.

    Subclass of AvdModel.
    """
    radius_server: RadiusServer
    """Subclass of AvdModel."""
    redundancy: Redundancy
    """Subclass of AvdModel."""
    roles: Roles
    """Subclass of AvdIndexedList with `RolesItem` items. Primary key is `name` (`str`)."""
    route_maps: RouteMaps
    """Subclass of AvdIndexedList with `RouteMapsItem` items. Primary key is `name` (`str`)."""
    router_adaptive_virtual_topology: RouterAdaptiveVirtualTopology
    """Subclass of AvdModel."""
    router_bfd: RouterBfd
    """Subclass of AvdModel."""
    router_bgp: RouterBgp
    """Subclass of AvdModel."""
    router_general: RouterGeneral
    """Subclass of AvdModel."""
    router_igmp: RouterIgmp
    """Subclass of AvdModel."""
    router_internet_exit: RouterInternetExit
    """
    Internet-exit feature to configure internet bound service for virtual topologies.

    Subclass of
    AvdModel.
    """
    router_isis: RouterIsis
    """Subclass of AvdModel."""
    router_l2_vpn: RouterL2Vpn
    """Subclass of AvdModel."""
    router_msdp: RouterMsdp
    """Subclass of AvdModel."""
    router_multicast: RouterMulticast
    """Subclass of AvdModel."""
    router_ospf: RouterOspf
    """Subclass of AvdModel."""
    router_path_selection: RouterPathSelection
    """
    Dynamic path selection configuration.

    Subclass of AvdModel.
    """
    router_pim_sparse_mode: RouterPimSparseMode
    """Subclass of AvdModel."""
    router_rip: RouterRip
    """
    Routing Information Protocol settings.

    Subclass of AvdModel.
    """
    router_segment_security: RouterSegmentSecurity
    """Subclass of AvdModel."""
    router_service_insertion: RouterServiceInsertion
    """
    Configure network services inserted to data forwarding.

    Subclass of AvdModel.
    """
    router_traffic_engineering: RouterTrafficEngineering
    """Subclass of AvdModel."""
    serial_number: str | None
    """
    Serial Number of the device.
    Used only for documentation and deployment purposes. It is used by the
    'eos_config_deploy_cvp' and 'cv_deploy' roles.
    """
    service_routing_configuration_bgp: ServiceRoutingConfigurationBgp
    """Subclass of AvdModel."""
    service_routing_protocols_model: Literal["multi-agent", "ribd"] | None
    service_unsupported_transceiver: ServiceUnsupportedTransceiver
    """Subclass of AvdModel."""
    sflow: Sflow
    """Subclass of AvdModel."""
    snmp_server: SnmpServer
    """
    SNMP settings.

    Subclass of AvdModel.
    """
    spanning_tree: SpanningTree
    """Subclass of AvdModel."""
    standard_access_lists: StandardAccessLists
    """Subclass of AvdIndexedList with `StandardAccessListsItem` items. Primary key is `name` (`str`)."""
    static_routes: StaticRoutes
    """Subclass of AvdList with `StaticRoutesItem` items."""
    stun: Stun
    """
    STUN configuration.

    Subclass of AvdModel.
    """
    switchport_default: SwitchportDefault
    """Subclass of AvdModel."""
    switchport_port_security: SwitchportPortSecurity
    """Subclass of AvdModel."""
    sync_e: SyncE
    """Subclass of AvdModel."""
    system: System
    """Subclass of AvdModel."""
    tacacs_servers: TacacsServers
    """Subclass of AvdModel."""
    tap_aggregation: TapAggregation
    """Subclass of AvdModel."""
    tcam_profile: TcamProfile
    """Subclass of AvdModel."""
    terminal: Terminal
    """Subclass of AvdModel."""
    trackers: Trackers
    """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""
    traffic_policies: TrafficPolicies
    """Subclass of AvdModel."""
    transceiver: Transceiver
    """Subclass of AvdModel."""
    transceiver_qsfp_default_mode_4x10: bool
    """
    On all front panel ports which support this feature, the following global configuration command
    changes the QSFP mode from 40G to 4x10G (default). When set to false the command reverts the default
    QSFP mode back to 40G.

    Default value: `True`
    """
    tunnel_interfaces: TunnelInterfaces
    """Subclass of AvdIndexedList with `TunnelInterfacesItem` items. Primary key is `name` (`str`)."""
    virtual_source_nat_vrfs: VirtualSourceNatVrfs
    """Subclass of AvdIndexedList with `VirtualSourceNatVrfsItem` items. Primary key is `name` (`str`)."""
    vlan_interfaces: VlanInterfaces
    """Subclass of AvdIndexedList with `VlanInterfacesItem` items. Primary key is `name` (`str`)."""
    vlan_internal_order: VlanInternalOrder
    """Subclass of AvdModel."""
    vlans: Vlans
    """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""
    vmtracer_sessions: VmtracerSessions
    """Subclass of AvdIndexedList with `VmtracerSessionsItem` items. Primary key is `name` (`str`)."""
    vrfs: Vrfs
    """
    These keys are ignored if the name of the vrf is 'default'.


    Subclass of AvdIndexedList with
    `VrfsItem` items. Primary key is `name` (`str`).
    """
    vxlan_interface: VxlanInterface
    """Subclass of AvdModel."""

    if TYPE_CHECKING:

        def __init__(
            self,
            *,
            aaa_accounting: AaaAccounting | UndefinedType = Undefined,
            aaa_authentication: AaaAuthentication | UndefinedType = Undefined,
            aaa_authorization: AaaAuthorization | UndefinedType = Undefined,
            aaa_root: AaaRoot | UndefinedType = Undefined,
            aaa_server_groups: AaaServerGroups | UndefinedType = Undefined,
            access_lists: AccessLists | UndefinedType = Undefined,
            address_locking: AddressLocking | UndefinedType = Undefined,
            agents: Agents | UndefinedType = Undefined,
            aliases: str | None | UndefinedType = Undefined,
            application_traffic_recognition: ApplicationTrafficRecognition | UndefinedType = Undefined,
            arp: Arp | UndefinedType = Undefined,
            as_path: AsPath | UndefinedType = Undefined,
            avd_data_validation_mode: Literal["error", "warning"] | UndefinedType = Undefined,
            banners: Banners | UndefinedType = Undefined,
            bgp_groups: BgpGroups | UndefinedType = Undefined,
            boot: Boot | UndefinedType = Undefined,
            cfm: Cfm | UndefinedType = Undefined,
            class_maps: ClassMaps | UndefinedType = Undefined,
            clock: Clock | UndefinedType = Undefined,
            community_lists: CommunityLists | UndefinedType = Undefined,
            config_comment: str | None | UndefinedType = Undefined,
            config_end: bool | UndefinedType = Undefined,
            custom_templates: CustomTemplates | UndefinedType = Undefined,
            cvx: Cvx | UndefinedType = Undefined,
            daemon_terminattr: DaemonTerminattr | UndefinedType = Undefined,
            daemons: Daemons | UndefinedType = Undefined,
            dhcp_relay: DhcpRelay | UndefinedType = Undefined,
            dhcp_servers: DhcpServers | UndefinedType = Undefined,
            dns_domain: str | None | UndefinedType = Undefined,
            domain_list: DomainList | UndefinedType = Undefined,
            dot1x: Dot1x | UndefinedType = Undefined,
            dps_interfaces: DpsInterfaces | UndefinedType = Undefined,
            dynamic_prefix_lists: DynamicPrefixLists | UndefinedType = Undefined,
            enable_password: EnablePassword | UndefinedType = Undefined,
            eos_cli: str | None | UndefinedType = Undefined,
            eos_cli_config_gen_configuration: EosCliConfigGenConfiguration | UndefinedType = Undefined,
            eos_cli_config_gen_documentation: EosCliConfigGenDocumentation | UndefinedType = Undefined,
            errdisable: Errdisable | UndefinedType = Undefined,
            ethernet_interfaces: EthernetInterfaces | UndefinedType = Undefined,
            event_handlers: EventHandlers | UndefinedType = Undefined,
            event_monitor: EventMonitor | UndefinedType = Undefined,
            flow_tracking: FlowTracking | UndefinedType = Undefined,
            generate_default_config: bool | UndefinedType = Undefined,
            generate_device_documentation: bool | UndefinedType = Undefined,
            hardware: Hardware | UndefinedType = Undefined,
            hardware_counters: HardwareCounters | UndefinedType = Undefined,
            hostname: str | None | UndefinedType = Undefined,
            interface_defaults: InterfaceDefaults | UndefinedType = Undefined,
            interface_groups: InterfaceGroups | UndefinedType = Undefined,
            interface_profiles: InterfaceProfiles | UndefinedType = Undefined,
            ip_access_lists: IpAccessLists | UndefinedType = Undefined,
            ip_access_lists_max_entries: int | None | UndefinedType = Undefined,
            ip_community_lists: IpCommunityLists | UndefinedType = Undefined,
            ip_dhcp_relay: IpDhcpRelay | UndefinedType = Undefined,
            ip_dhcp_snooping: IpDhcpSnooping | UndefinedType = Undefined,
            ip_domain_lookup: IpDomainLookup | UndefinedType = Undefined,
            ip_extcommunity_lists: IpExtcommunityLists | UndefinedType = Undefined,
            ip_extcommunity_lists_regexp: IpExtcommunityListsRegexp | UndefinedType = Undefined,
            ip_ftp_client_source_interfaces: IpFtpClientSourceInterfaces | UndefinedType = Undefined,
            ip_hardware: IpHardware | UndefinedType = Undefined,
            ip_http_client_source_interfaces: IpHttpClientSourceInterfaces | UndefinedType = Undefined,
            ip_icmp_redirect: bool | None | UndefinedType = Undefined,
            ip_igmp_snooping: IpIgmpSnooping | UndefinedType = Undefined,
            ip_name_server_groups: IpNameServerGroups | UndefinedType = Undefined,
            ip_name_servers: IpNameServers | UndefinedType = Undefined,
            ip_nat: IpNat | UndefinedType = Undefined,
            ip_ospf_router_id_output_format_hostnames: bool | None | UndefinedType = Undefined,
            ip_radius_source_interfaces: IpRadiusSourceInterfaces | UndefinedType = Undefined,
            ip_routing: bool | None | UndefinedType = Undefined,
            ip_routing_ipv6_interfaces: bool | None | UndefinedType = Undefined,
            ip_security: IpSecurity | UndefinedType = Undefined,
            ip_ssh_client_source_interfaces: IpSshClientSourceInterfaces | UndefinedType = Undefined,
            ip_tacacs_source_interfaces: IpTacacsSourceInterfaces | UndefinedType = Undefined,
            ip_telnet_client_source_interfaces: IpTelnetClientSourceInterfaces | UndefinedType = Undefined,
            ip_tftp_client_source_interfaces: IpTftpClientSourceInterfaces | UndefinedType = Undefined,
            ip_virtual_router_mac_address: str | None | UndefinedType = Undefined,
            ip_virtual_router_mac_address_advertisement_interval: int | None | UndefinedType = Undefined,
            ip_virtual_router_mac_address_mlag_peer: bool | None | UndefinedType = Undefined,
            ipv6_access_lists: Ipv6AccessLists | UndefinedType = Undefined,
            ipv6_dhcp_relay: Ipv6DhcpRelay | UndefinedType = Undefined,
            ipv6_hardware: Ipv6Hardware | UndefinedType = Undefined,
            ipv6_icmp_redirect: bool | None | UndefinedType = Undefined,
            ipv6_neighbor: Ipv6Neighbor | UndefinedType = Undefined,
            ipv6_prefix_lists: Ipv6PrefixLists | UndefinedType = Undefined,
            ipv6_router_ospf: Ipv6RouterOspf | UndefinedType = Undefined,
            ipv6_standard_access_lists: Ipv6StandardAccessLists | UndefinedType = Undefined,
            ipv6_static_routes: Ipv6StaticRoutes | UndefinedType = Undefined,
            ipv6_unicast_routing: bool | None | UndefinedType = Undefined,
            is_deployed: bool | None | UndefinedType = Undefined,
            kernel: Kernel | UndefinedType = Undefined,
            l2_protocol: L2Protocol | UndefinedType = Undefined,
            lacp: Lacp | UndefinedType = Undefined,
            link_tracking_groups: LinkTrackingGroups | UndefinedType = Undefined,
            lldp: Lldp | UndefinedType = Undefined,
            load_balance: LoadBalance | UndefinedType = Undefined,
            load_interval: LoadInterval | UndefinedType = Undefined,
            local_users: LocalUsers | UndefinedType = Undefined,
            logging: Logging | UndefinedType = Undefined,
            loopback_interfaces: LoopbackInterfaces | UndefinedType = Undefined,
            mac_access_lists: MacAccessLists | UndefinedType = Undefined,
            mac_address_table: MacAddressTable | UndefinedType = Undefined,
            mac_security: MacSecurity | UndefinedType = Undefined,
            maintenance: Maintenance | UndefinedType = Undefined,
            management_accounts: ManagementAccounts | UndefinedType = Undefined,
            management_api_gnmi: ManagementApiGnmi | UndefinedType = Undefined,
            management_api_http: ManagementApiHttp | UndefinedType = Undefined,
            management_api_models: ManagementApiModels | UndefinedType = Undefined,
            management_console: ManagementConsole | UndefinedType = Undefined,
            management_cvx: ManagementCvx | UndefinedType = Undefined,
            management_defaults: ManagementDefaults | UndefinedType = Undefined,
            management_interfaces: ManagementInterfaces | UndefinedType = Undefined,
            management_security: ManagementSecurity | UndefinedType = Undefined,
            management_ssh: ManagementSsh | UndefinedType = Undefined,
            management_tech_support: ManagementTechSupport | UndefinedType = Undefined,
            match_list_input: MatchListInput | UndefinedType = Undefined,
            mcs_client: McsClient | UndefinedType = Undefined,
            metadata: Metadata | UndefinedType = Undefined,
            mlag_configuration: MlagConfiguration | UndefinedType = Undefined,
            monitor_connectivity: MonitorConnectivity | UndefinedType = Undefined,
            monitor_layer1: MonitorLayer1 | UndefinedType = Undefined,
            monitor_server_radius: MonitorServerRadius | UndefinedType = Undefined,
            monitor_session_default_encapsulation_gre: MonitorSessionDefaultEncapsulationGre | UndefinedType = Undefined,
            monitor_sessions: MonitorSessions | UndefinedType = Undefined,
            monitor_telemetry_influx: MonitorTelemetryInflux | UndefinedType = Undefined,
            monitor_telemetry_postcard_policy: MonitorTelemetryPostcardPolicy | UndefinedType = Undefined,
            monitor_twamp: MonitorTwamp | UndefinedType = Undefined,
            mpls: Mpls | UndefinedType = Undefined,
            ntp: Ntp | UndefinedType = Undefined,
            patch_panel: PatchPanel | UndefinedType = Undefined,
            peer_filters: PeerFilters | UndefinedType = Undefined,
            platform: Platform | UndefinedType = Undefined,
            poe: Poe | UndefinedType = Undefined,
            policy_maps: PolicyMaps | UndefinedType = Undefined,
            port_channel: PortChannel | UndefinedType = Undefined,
            port_channel_interfaces: PortChannelInterfaces | UndefinedType = Undefined,
            prefix_lists: PrefixLists | UndefinedType = Undefined,
            priority_flow_control: PriorityFlowControl | UndefinedType = Undefined,
            prompt: str | None | UndefinedType = Undefined,
            ptp: Ptp | UndefinedType = Undefined,
            qos: Qos | UndefinedType = Undefined,
            qos_profiles: QosProfiles | UndefinedType = Undefined,
            queue_monitor_length: QueueMonitorLength | UndefinedType = Undefined,
            queue_monitor_streaming: QueueMonitorStreaming | UndefinedType = Undefined,
            radius_proxy: RadiusProxy | UndefinedType = Undefined,
            radius_server: RadiusServer | UndefinedType = Undefined,
            redundancy: Redundancy | UndefinedType = Undefined,
            roles: Roles | UndefinedType = Undefined,
            route_maps: RouteMaps | UndefinedType = Undefined,
            router_adaptive_virtual_topology: RouterAdaptiveVirtualTopology | UndefinedType = Undefined,
            router_bfd: RouterBfd | UndefinedType = Undefined,
            router_bgp: RouterBgp | UndefinedType = Undefined,
            router_general: RouterGeneral | UndefinedType = Undefined,
            router_igmp: RouterIgmp | UndefinedType = Undefined,
            router_internet_exit: RouterInternetExit | UndefinedType = Undefined,
            router_isis: RouterIsis | UndefinedType = Undefined,
            router_l2_vpn: RouterL2Vpn | UndefinedType = Undefined,
            router_msdp: RouterMsdp | UndefinedType = Undefined,
            router_multicast: RouterMulticast | UndefinedType = Undefined,
            router_ospf: RouterOspf | UndefinedType = Undefined,
            router_path_selection: RouterPathSelection | UndefinedType = Undefined,
            router_pim_sparse_mode: RouterPimSparseMode | UndefinedType = Undefined,
            router_rip: RouterRip | UndefinedType = Undefined,
            router_segment_security: RouterSegmentSecurity | UndefinedType = Undefined,
            router_service_insertion: RouterServiceInsertion | UndefinedType = Undefined,
            router_traffic_engineering: RouterTrafficEngineering | UndefinedType = Undefined,
            serial_number: str | None | UndefinedType = Undefined,
            service_routing_configuration_bgp: ServiceRoutingConfigurationBgp | UndefinedType = Undefined,
            service_routing_protocols_model: Literal["multi-agent", "ribd"] | None | UndefinedType = Undefined,
            service_unsupported_transceiver: ServiceUnsupportedTransceiver | UndefinedType = Undefined,
            sflow: Sflow | UndefinedType = Undefined,
            snmp_server: SnmpServer | UndefinedType = Undefined,
            spanning_tree: SpanningTree | UndefinedType = Undefined,
            standard_access_lists: StandardAccessLists | UndefinedType = Undefined,
            static_routes: StaticRoutes | UndefinedType = Undefined,
            stun: Stun | UndefinedType = Undefined,
            switchport_default: SwitchportDefault | UndefinedType = Undefined,
            switchport_port_security: SwitchportPortSecurity | UndefinedType = Undefined,
            sync_e: SyncE | UndefinedType = Undefined,
            system: System | UndefinedType = Undefined,
            tacacs_servers: TacacsServers | UndefinedType = Undefined,
            tap_aggregation: TapAggregation | UndefinedType = Undefined,
            tcam_profile: TcamProfile | UndefinedType = Undefined,
            terminal: Terminal | UndefinedType = Undefined,
            trackers: Trackers | UndefinedType = Undefined,
            traffic_policies: TrafficPolicies | UndefinedType = Undefined,
            transceiver: Transceiver | UndefinedType = Undefined,
            transceiver_qsfp_default_mode_4x10: bool | UndefinedType = Undefined,
            tunnel_interfaces: TunnelInterfaces | UndefinedType = Undefined,
            virtual_source_nat_vrfs: VirtualSourceNatVrfs | UndefinedType = Undefined,
            vlan_interfaces: VlanInterfaces | UndefinedType = Undefined,
            vlan_internal_order: VlanInternalOrder | UndefinedType = Undefined,
            vlans: Vlans | UndefinedType = Undefined,
            vmtracer_sessions: VmtracerSessions | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
            vxlan_interface: VxlanInterface | UndefinedType = Undefined,
        ) -> None:
            """
            EosCliConfigGen.


            Subclass of EosCliConfigGenRootModel.

            Args:
                aaa_accounting: Subclass of AvdModel.
                aaa_authentication: Subclass of AvdModel.
                aaa_authorization: Subclass of AvdModel.
                aaa_root: Subclass of AvdModel.
                aaa_server_groups: Subclass of AvdIndexedList with `AaaServerGroupsItem` items. Primary key is `name` (`str`).
                access_lists: Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`).
                address_locking: Subclass of AvdModel.
                agents: Subclass of AvdIndexedList with `AgentsItem` items. Primary key is `name` (`str`).
                aliases:
                   Multi-line string with one or more alias commands.

                   Example:  # fmt: skip

                   ```yaml
                   aliases: |
                     alias wr copy
                   running-config startup-config
                     alias siib show ip interface brief
                   ```
                application_traffic_recognition:
                   Application traffic recognition configuration.

                   Subclass of AvdModel.
                arp: Subclass of AvdModel.
                as_path: Subclass of AvdModel.
                avd_data_validation_mode:
                   Validation Mode for AVD input data validation.
                   Input data validation will validate the input
                   variables according to the schema.
                   During validation, messages will generated with information about
                   the host(s) and key(s) which failed validation.
                   "error" will produce error messages and fail the
                   task.
                   "warning" will produce warning messages.
                banners: Subclass of AvdModel.
                bgp_groups: Subclass of AvdIndexedList with `BgpGroupsItem` items. Primary key is `name` (`str`).
                boot:
                   Set the Aboot password.


                   Subclass of AvdModel.
                cfm:
                   Configure connectivity fault management (CFM).
                   CFM is a network protocol for monitoring and
                   troubleshooting Ethernet networks.

                   Subclass of AvdModel.
                class_maps: Subclass of AvdModel.
                clock: Subclass of AvdModel.
                community_lists: Subclass of AvdIndexedList with `CommunityListsItem` items. Primary key is `name` (`str`).
                config_comment:
                   Add a comment to provide information about the configuration.
                   This comment will be rendered at the
                   top of the generated configuration.
                config_end: Render `end` at the end of the configuration.
                custom_templates:
                   - Custom templates can be added below the playbook directory.
                   - If a location above the directory is
                   desired, a symbolic link can be used.
                   - Example under the `playbooks` directory create symbolic link
                   with the following command:

                     ```bash
                     ln -s ../../shared_repo/custom_avd_templates/
                   ./custom_avd_templates
                     ```

                   - The output will be rendered at the end of the configuration.
                   - The
                   order of custom templates in the list can be important if they overlap.
                   - It is recommended to use a
                   `!` delimiter at the top of each custom template.

                   Add `custom_templates` to group/host variables:
                   Subclass of AvdList with `str` items.
                cvx:
                   CVX server features are not supported on physical switches. See `management_cvx` for client
                   configurations.

                   Subclass of AvdModel.
                daemon_terminattr:
                   You can either provide a list of IPs/FQDNs to target on-premise Cloudvision cluster or use DNS name
                   for your Cloudvision as a Service instance.
                   Streaming to multiple clusters both on-prem and cloud
                   service is supported.

                   !!! note
                       For TerminAttr version recommendation and EOS compatibility
                   matrix, please refer to the latest TerminAttr Release Notes
                       which always contain the latest
                   recommended versions and minimum required versions per EOS release.


                   Subclass of AvdModel.
                daemons:
                   This will add a daemon to the eos configuration that is most useful when trying to run OpenConfig
                   clients like ocprometheus.

                   Subclass of AvdIndexedList with `DaemonsItem` items. Primary key is
                   `name` (`str`).
                dhcp_relay: Subclass of AvdModel.
                dhcp_servers: Subclass of AvdIndexedList with `DhcpServersItem` items. Primary key is `vrf` (`str`).
                dns_domain: Domain Name.
                domain_list:
                   Search list of DNS domains.

                   Subclass of AvdList with `str` items.
                dot1x: Subclass of AvdModel.
                dps_interfaces: Subclass of AvdIndexedList with `DpsInterfacesItem` items. Primary key is `name` (`str`).
                dynamic_prefix_lists: Subclass of AvdList with `DynamicPrefixListsItem` items.
                enable_password: Subclass of AvdModel.
                eos_cli: Multiline string with EOS CLI rendered directly on the root level of the final EOS configuration.
                eos_cli_config_gen_configuration: Subclass of AvdModel.
                eos_cli_config_gen_documentation: Subclass of AvdModel.
                errdisable: Subclass of AvdModel.
                ethernet_interfaces: Subclass of AvdIndexedList with `EthernetInterfacesItem` items. Primary key is `name` (`str`).
                event_handlers:
                   Gives the ability to monitor and react to Syslog messages.
                   Event Handlers provide a powerful and
                   flexible tool that can be used to apply self-healing actions,
                   customize the system behavior, and
                   implement workarounds to problems discovered in the field.


                   Subclass of AvdIndexedList with
                   `EventHandlersItem` items. Primary key is `name` (`str`).
                event_monitor: Subclass of AvdModel.
                flow_tracking: Subclass of AvdModel.
                generate_default_config:
                   The `generate_default_config` knob allows to omit default EOS configuration.
                   This can be useful when
                   leveraging `eos_cli_config_gen` to generate configlets with CloudVision.

                   The following commands
                   will be omitted when `generate_default_config` is set to `false`:

                   - RANCID Content Type
                   - Hostname
                   (even if `hostname` variable is not set. Then the hostname is picked up from `inventory_hostname`)
                   -
                   Default configuration for `aaa`
                   - Default configuration for `enable password`
                   - Transceiver qsfp
                   default mode
                   - End of configuration delimiter
                generate_device_documentation: generate_device_documentation
                hardware: Subclass of AvdModel.
                hardware_counters: Subclass of AvdModel.
                hostname: hostname
                interface_defaults: Subclass of AvdModel.
                interface_groups: Subclass of AvdIndexedList with `InterfaceGroupsItem` items. Primary key is `name` (`str`).
                interface_profiles: Subclass of AvdIndexedList with `InterfaceProfilesItem` items. Primary key is `name` (`str`).
                ip_access_lists: Subclass of AvdIndexedList with `IpAccessListsItem` items. Primary key is `name` (`str`).
                ip_access_lists_max_entries: Limit ACL entries defined under the `ip_access_lists`.
                ip_community_lists:
                   Communities and regexp entries MUST not be configured in the same community-list.


                   Subclass of
                   AvdIndexedList with `IpCommunityListsItem` items. Primary key is `name` (`str`).
                ip_dhcp_relay: Subclass of AvdModel.
                ip_dhcp_snooping: Subclass of AvdModel.
                ip_domain_lookup: Subclass of AvdModel.
                ip_extcommunity_lists: Subclass of AvdIndexedList with `IpExtcommunityListsItem` items. Primary key is `name` (`str`).
                ip_extcommunity_lists_regexp:
                   Subclass of AvdIndexedList with `IpExtcommunityListsRegexpItem` items. Primary key is `name`
                   (`str`).
                ip_ftp_client_source_interfaces: Subclass of AvdList with `IpFtpClientSourceInterfacesItem` items.
                ip_hardware: Subclass of AvdModel.
                ip_http_client_source_interfaces: Subclass of AvdList with `IpHttpClientSourceInterfacesItem` items.
                ip_icmp_redirect: ip_icmp_redirect
                ip_igmp_snooping: Subclass of AvdModel.
                ip_name_server_groups: Subclass of AvdIndexedList with `IpNameServerGroupsItem` items. Primary key is `name` (`str`).
                ip_name_servers: Subclass of AvdList with `IpNameServersItem` items.
                ip_nat: Subclass of AvdModel.
                ip_ospf_router_id_output_format_hostnames: Display DNS-resolved router names for OSPF router IDs.
                ip_radius_source_interfaces: Subclass of AvdList with `IpRadiusSourceInterfacesItem` items.
                ip_routing: ip_routing
                ip_routing_ipv6_interfaces: ip_routing_ipv6_interfaces
                ip_security: Subclass of AvdModel.
                ip_ssh_client_source_interfaces: Subclass of AvdList with `IpSshClientSourceInterfacesItem` items.
                ip_tacacs_source_interfaces: Subclass of AvdList with `IpTacacsSourceInterfacesItem` items.
                ip_telnet_client_source_interfaces: Subclass of AvdList with `IpTelnetClientSourceInterfacesItem` items.
                ip_tftp_client_source_interfaces: Subclass of AvdList with `IpTftpClientSourceInterfacesItem` items.
                ip_virtual_router_mac_address: MAC address (hh:hh:hh:hh:hh:hh).
                ip_virtual_router_mac_address_advertisement_interval: Advertisement interval in seconds.
                ip_virtual_router_mac_address_mlag_peer: Enable MLAG peer gateway.
                ipv6_access_lists: Subclass of AvdIndexedList with `Ipv6AccessListsItem` items. Primary key is `name` (`str`).
                ipv6_dhcp_relay: Subclass of AvdModel.
                ipv6_hardware: Subclass of AvdModel.
                ipv6_icmp_redirect: ipv6_icmp_redirect
                ipv6_neighbor: Subclass of AvdModel.
                ipv6_prefix_lists: Subclass of AvdIndexedList with `Ipv6PrefixListsItem` items. Primary key is `name` (`str`).
                ipv6_router_ospf: Subclass of AvdModel.
                ipv6_standard_access_lists: Subclass of AvdIndexedList with `Ipv6StandardAccessListsItem` items. Primary key is `name` (`str`).
                ipv6_static_routes: Subclass of AvdList with `Ipv6StaticRoutesItem` items.
                ipv6_unicast_routing: ipv6_unicast_routing
                is_deployed:
                   Key only used for documentation or validation purposes.
                   This key is deprecated and new key is
                   metadata.is_deployed.
                kernel: Subclass of AvdModel.
                l2_protocol: Subclass of AvdModel.
                lacp:
                   Set Link Aggregation Control Protocol (LACP) parameters.

                   Subclass of AvdModel.
                link_tracking_groups: Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`).
                lldp: Subclass of AvdModel.
                load_balance:
                   Configuration for load balancing behavior across port-channels and ECMP paths.

                   Subclass of
                   AvdModel.
                load_interval: Subclass of AvdModel.
                local_users: Subclass of AvdIndexedList with `LocalUsersItem` items. Primary key is `name` (`str`).
                logging: Subclass of AvdModel.
                loopback_interfaces: Subclass of AvdIndexedList with `LoopbackInterfacesItem` items. Primary key is `name` (`str`).
                mac_access_lists: Subclass of AvdIndexedList with `MacAccessListsItem` items. Primary key is `name` (`str`).
                mac_address_table: Subclass of AvdModel.
                mac_security: Subclass of AvdModel.
                maintenance: Subclass of AvdModel.
                management_accounts: Subclass of AvdModel.
                management_api_gnmi: Subclass of AvdModel.
                management_api_http: Subclass of AvdModel.
                management_api_models: Subclass of AvdModel.
                management_console: Subclass of AvdModel.
                management_cvx: Subclass of AvdModel.
                management_defaults: Subclass of AvdModel.
                management_interfaces: Subclass of AvdIndexedList with `ManagementInterfacesItem` items. Primary key is `name` (`str`).
                management_security: Subclass of AvdModel.
                management_ssh: Subclass of AvdModel.
                management_tech_support: Subclass of AvdModel.
                match_list_input: Subclass of AvdModel.
                mcs_client: Subclass of AvdModel.
                metadata:
                   The data under `metadata` is used for documentation, validation or integration purposes.
                   It will not
                   affect the generated EOS configuration.

                   Subclass of AvdModel.
                mlag_configuration: Subclass of AvdModel.
                monitor_connectivity: Subclass of AvdModel.
                monitor_layer1:
                   Enable SYSLOG messages on transceiver SMBus communication failures.

                   Subclass of AvdModel.
                monitor_server_radius:
                   Settings to monitor radius servers.

                   Subclass of AvdModel.
                monitor_session_default_encapsulation_gre: Subclass of AvdModel.
                monitor_sessions: Subclass of AvdIndexedList with `MonitorSessionsItem` items. Primary key is `name` (`str`).
                monitor_telemetry_influx: Subclass of AvdModel.
                monitor_telemetry_postcard_policy: Subclass of AvdModel.
                monitor_twamp: Subclass of AvdModel.
                mpls: Subclass of AvdModel.
                ntp: Subclass of AvdModel.
                patch_panel: Subclass of AvdModel.
                peer_filters: Subclass of AvdIndexedList with `PeerFiltersItem` items. Primary key is `name` (`str`).
                platform:
                   Every key below this point is platform dependent.

                   Subclass of AvdModel.
                poe: Subclass of AvdModel.
                policy_maps: Subclass of AvdModel.
                port_channel: Subclass of AvdModel.
                port_channel_interfaces: Subclass of AvdIndexedList with `PortChannelInterfacesItem` items. Primary key is `name` (`str`).
                prefix_lists: Subclass of AvdIndexedList with `PrefixListsItem` items. Primary key is `name` (`str`).
                priority_flow_control:
                   Global Priority Flow Control settings.


                   Subclass of AvdModel.
                prompt: prompt
                ptp: Subclass of AvdModel.
                qos: Subclass of AvdModel.
                qos_profiles: Subclass of AvdIndexedList with `QosProfilesItem` items. Primary key is `name` (`str`).
                queue_monitor_length: Subclass of AvdModel.
                queue_monitor_streaming: Subclass of AvdModel.
                radius_proxy:
                   Configure RADIUS proxy parameters.

                   Subclass of AvdModel.
                radius_server: Subclass of AvdModel.
                redundancy: Subclass of AvdModel.
                roles: Subclass of AvdIndexedList with `RolesItem` items. Primary key is `name` (`str`).
                route_maps: Subclass of AvdIndexedList with `RouteMapsItem` items. Primary key is `name` (`str`).
                router_adaptive_virtual_topology: Subclass of AvdModel.
                router_bfd: Subclass of AvdModel.
                router_bgp: Subclass of AvdModel.
                router_general: Subclass of AvdModel.
                router_igmp: Subclass of AvdModel.
                router_internet_exit:
                   Internet-exit feature to configure internet bound service for virtual topologies.

                   Subclass of
                   AvdModel.
                router_isis: Subclass of AvdModel.
                router_l2_vpn: Subclass of AvdModel.
                router_msdp: Subclass of AvdModel.
                router_multicast: Subclass of AvdModel.
                router_ospf: Subclass of AvdModel.
                router_path_selection:
                   Dynamic path selection configuration.

                   Subclass of AvdModel.
                router_pim_sparse_mode: Subclass of AvdModel.
                router_rip:
                   Routing Information Protocol settings.

                   Subclass of AvdModel.
                router_segment_security: Subclass of AvdModel.
                router_service_insertion:
                   Configure network services inserted to data forwarding.

                   Subclass of AvdModel.
                router_traffic_engineering: Subclass of AvdModel.
                serial_number:
                   Serial Number of the device.
                   Used only for documentation and deployment purposes. It is used by the
                   'eos_config_deploy_cvp' and 'cv_deploy' roles.
                service_routing_configuration_bgp: Subclass of AvdModel.
                service_routing_protocols_model: service_routing_protocols_model
                service_unsupported_transceiver: Subclass of AvdModel.
                sflow: Subclass of AvdModel.
                snmp_server:
                   SNMP settings.

                   Subclass of AvdModel.
                spanning_tree: Subclass of AvdModel.
                standard_access_lists: Subclass of AvdIndexedList with `StandardAccessListsItem` items. Primary key is `name` (`str`).
                static_routes: Subclass of AvdList with `StaticRoutesItem` items.
                stun:
                   STUN configuration.

                   Subclass of AvdModel.
                switchport_default: Subclass of AvdModel.
                switchport_port_security: Subclass of AvdModel.
                sync_e: Subclass of AvdModel.
                system: Subclass of AvdModel.
                tacacs_servers: Subclass of AvdModel.
                tap_aggregation: Subclass of AvdModel.
                tcam_profile: Subclass of AvdModel.
                terminal: Subclass of AvdModel.
                trackers: Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`).
                traffic_policies: Subclass of AvdModel.
                transceiver: Subclass of AvdModel.
                transceiver_qsfp_default_mode_4x10:
                   On all front panel ports which support this feature, the following global configuration command
                   changes the QSFP mode from 40G to 4x10G (default). When set to false the command reverts the default
                   QSFP mode back to 40G.
                tunnel_interfaces: Subclass of AvdIndexedList with `TunnelInterfacesItem` items. Primary key is `name` (`str`).
                virtual_source_nat_vrfs: Subclass of AvdIndexedList with `VirtualSourceNatVrfsItem` items. Primary key is `name` (`str`).
                vlan_interfaces: Subclass of AvdIndexedList with `VlanInterfacesItem` items. Primary key is `name` (`str`).
                vlan_internal_order: Subclass of AvdModel.
                vlans: Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`).
                vmtracer_sessions: Subclass of AvdIndexedList with `VmtracerSessionsItem` items. Primary key is `name` (`str`).
                vrfs:
                   These keys are ignored if the name of the vrf is 'default'.


                   Subclass of AvdIndexedList with
                   `VrfsItem` items. Primary key is `name` (`str`).
                vxlan_interface: Subclass of AvdModel.

            """
