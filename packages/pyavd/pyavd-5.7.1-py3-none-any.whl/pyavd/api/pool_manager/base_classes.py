# Copyright (c) 2023-2025 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from itertools import filterfalse
from typing import TYPE_CHECKING, Generic, TypeVar, cast

from yaml import CSafeDumper, CSafeLoader, dump, load

from pyavd.j2filters import natural_sort

if TYPE_CHECKING:
    from pathlib import Path
    from typing import Any

    from pyavd._eos_designs.shared_utils import SharedUtilsProtocol

T_ValueType = TypeVar("T_ValueType", int, str)

FILE_HEADER = """\
# This file is auto-generated by AVD eos_designs.
# When there is a merge conflict for this file, rebase the branch, accept all current changes for this file, and re-run AVD.
"""


@dataclass
class PoolAssignment(Generic[T_ValueType]):
    key: str
    value: T_ValueType
    accessed: bool = False


@dataclass
class Pool(Generic[T_ValueType]):
    """One Pool of resources indexed by str. Currently only supporting a pool of Integers."""

    collection: PoolCollection[T_ValueType]
    pool_key: str
    assignments: dict[str, PoolAssignment[T_ValueType]]

    def _is_value_available(self, value: T_ValueType) -> bool:
        if self.collection.value_type is int and isinstance(value, int):
            existing_ids = {assignment.value for assignment in self.assignments.values()}
            return not (
                value in existing_ids or value < self.collection.min_value or (self.collection.max_value is not None and value > self.collection.max_value)
            )

        # currently we only support int pools
        return False

    def _next_available(self) -> T_ValueType:
        if self.collection.value_type is int:
            collection = cast("PoolCollection[int]", self.collection)
            assignments = cast("dict[str, PoolAssignment[int]]", self.assignments)
            existing_ids = {assignment.value for assignment in assignments.values()}
            # Create a filterfalse generator from a range starting from the min_value, excluding the values that are already assigned.
            # Nothing will be iterated at this point, but the next(iter()) below will ask the generator for the first item.
            available_ids = filterfalse(
                existing_ids.__contains__,
                range(collection.min_value, collection.min_value + len(existing_ids) + 2),
            )
            next_available = next(iter(available_ids))
            if collection.max_value is not None and next_available > collection.max_value:
                msg = (
                    f"No available values found within '{self.collection.pools_key}' with key '{self.pool_key}' "
                    f"and range {collection.min_value}-{collection.max_value}."
                )
                raise ValueError(msg)
            return cast("T_ValueType", next_available)

        msg = f"Currently we only support pools of Integers. Got {self.collection.value_type}."
        raise NotImplementedError(msg)

    def get_assignment(self, key: str, requested_value: T_ValueType | None = None) -> PoolAssignment[T_ValueType]:
        """
        Returns the assignment for the key if found in the pool.

        Otherwise a new entry is inserted into the pool and returned.

        If 'requested_value' is given and available in the pool, any existing assignment will be updated and returned.
        For new assignments this value will be used.
        """
        if key not in self.assignments:
            # No existing assignment. Use the requested value if given and available. Otherwise use next available.
            new_assignment_value = requested_value if requested_value is not None and self._is_value_available(requested_value) else self._next_available()
            self.assignments[key] = self.collection.assignment_cls(key=key, value=new_assignment_value, accessed=True)
            self.collection.changed = True
        elif requested_value is not None and requested_value != self.assignments[key].value and self._is_value_available(requested_value):
            # Existing assignment but not with the requested value. Change the existing assignment to the requested_value.
            self.assignments[key] = self.collection.assignment_cls(key=key, value=requested_value, accessed=True)
            self.collection.changed = True
        else:
            # Existing item
            self.assignments[key].accessed = True

        return self.assignments[key]

    def get_assignment_by_value(self, value: T_ValueType) -> PoolAssignment[T_ValueType] | None:
        """Returns the assignment with the given value if found in the pool."""
        for assignment in self.assignments.values():
            if assignment.value == value:
                return assignment

        return None

    def _remove_stale_assignments(self) -> None:
        """
        Remove stale assignments. An assignment is deemed stale if "accessed" is not True. Sets parent .changed if it removed anything.

        Note: This method is called from the parent collection and should _not_ be called manually.
        """
        len_before = len(self.assignments)
        self.assignments = {key: assignment for key, assignment in self.assignments.items() if assignment.accessed}
        self.collection.changed = self.collection.changed or len_before != len(self.assignments)

    def assignments_as_dict(self) -> dict[str, T_ValueType]:
        """Returns a dict sorted on assignment value representing the assignments."""
        # Convert assignments to a list of dicts with value key to make it sortable by our natural_sort.
        assignments_as_list_of_dicts = [{"value": assignment.value, "assignment": assignment} for assignment in self.assignments.values()]
        return {
            assignment_dict["assignment"].key: assignment_dict["assignment"].value
            for assignment_dict in natural_sort(assignments_as_list_of_dicts, sort_key="value")
        }

    @classmethod
    def load(
        cls,
        pool_key: Any,
        pool_assignments: Any,
        collection: PoolCollection[T_ValueType],
    ) -> Pool[T_ValueType]:
        """Returns pool from file data."""
        if not isinstance(pool_key, str):
            msg = f"Invalid type for pool key '{type(pool_key)}'. Expected a str."
            raise TypeError(msg)

        if not isinstance(pool_assignments, dict):
            msg = f"Invalid type for pool assignments '{type(pool_assignments)}'. Expected a dict."
            raise TypeError(msg)

        assignments: dict[str, PoolAssignment[T_ValueType]] = {}
        for assignment_key, assignment_value in pool_assignments.items():
            if not isinstance(assignment_key, str):
                msg = f"Invalid type for assignment key '{type(assignment_key)}'. Expected a str."
                raise TypeError(msg)

            if not isinstance(assignment_value, collection.value_type):
                msg = f"Invalid type for assignment 'value' '{type(assignment_value)}'. Expected a {collection.value_type.__name__}."
                raise TypeError(msg)

            assignment = collection.assignment_cls(assignment_key, value=assignment_value)
            assignments[assignment.key] = assignment

        return cls(
            collection=collection,
            pool_key=pool_key,
            assignments=assignments,
        )

    @classmethod
    def load_old_format(
        cls,
        data: Any,
        collection: PoolCollection[T_ValueType],
    ) -> Pool[T_ValueType]:
        """Returns one pool from file data using the older AVD <5.5.0 format."""
        if not isinstance(data, dict):
            msg = f"Invalid type for 'pool' '{type(data)}'. Expected a dict."
            raise TypeError(msg)

        if not isinstance(pool_key_dict := data["pool_key"], dict):
            msg = f"Invalid type for 'pool_key' '{type(pool_key_dict)}'. Expected a dict."
            raise TypeError(msg)

        pool_key = collection._pool_key_from_dict(pool_key_dict)

        if not isinstance(pool_assignments := data["assignments"], list):
            msg = f"Invalid type for 'assignments' '{type(pool_assignments)}'. Expected a list."
            raise TypeError(msg)

        assignments = {}
        for assignment_dict in pool_assignments:
            if not isinstance(assignment_dict, dict):
                msg = f"Invalid assignment type '{type(assignment_dict)}'. Expected a dict."
                raise TypeError(msg)

            if not isinstance(assignment_key_dict := assignment_dict["key"], dict):
                msg = f"Invalid type for assignment 'key' '{type(assignment_key_dict)}'. Expected a dict."
                raise TypeError(msg)

            if not isinstance(assignment_value := assignment_dict["value"], collection.value_type):
                msg = f"Invalid type for assignment 'value' '{type(assignment_value)}'. Expected a {collection.value_type.__name__}."
                raise TypeError(msg)

            assignment = collection.assignment_cls(
                key=f"hostname={assignment_key_dict['hostname']}",
                value=assignment_value,
            )
            assignments[assignment.key] = assignment

        # Since we read the old format, we mark the collection as 'changed' to trigger a save with the new format, even though nothing really changed.
        collection.changed = True

        return cls(
            collection=collection,
            pool_key=pool_key,
            assignments=assignments,
        )


@dataclass
class PoolCollection(ABC, Generic[T_ValueType]):
    """
    Collection of similar Pool instances indexed by a str.

    We will maintain a collection of pools per file.
    """

    pools_file: Path
    # Using field(init=False) on fields that are expected to have a default value set on the subclass.
    pools_key: str = field(init=False)
    _pools: dict[str, Pool[T_ValueType]] = field(init=False)
    pool_cls: type[Pool[T_ValueType]] = field(init=False)
    assignment_cls: type[PoolAssignment[T_ValueType]] = field(init=False)
    value_type: type[T_ValueType] = field(init=False)
    min_value: T_ValueType = field(init=False)
    max_value: T_ValueType | None = None
    changed: bool = False

    def __post_init__(self) -> None:
        """Try to load data from the pools_file into _pools. If the file is missing, we just set a blank pools."""
        if not self.pools_file.exists():
            self._pools = {}
            return

        file_data = load(self.pools_file.read_text(encoding="UTF-8"), Loader=CSafeLoader)
        if not isinstance(file_data, dict) or self.pools_key not in file_data:
            self._pools = {}
            return

        try:
            self._pools = self.load(file_data[self.pools_key])
        except (TypeError, KeyError, ValueError) as e:
            msg = f"An error occurred during parsing of '{self.pools_file}': {e.__class__.__name__}: {e}"
            raise TypeError(msg) from e

    def load(self, data: Any) -> dict[str, Pool[T_ValueType]]:
        """Returns pools from file data."""
        if not isinstance(data, dict):
            if not isinstance(data, list):
                msg = f"Invalid type '{type(data)}'. Expected a dict."
                raise TypeError(msg)

            # This is possibly an older variant of the file from AVD <5.5.0. Try to read it as the old type.
            return {pool.pool_key: pool for data_item in data if (pool := self.pool_cls.load_old_format(data_item, collection=self))}

        return {pool.pool_key: pool for pool_key, pool_assignments in data.items() if (pool := self.pool_cls.load(pool_key, pool_assignments, collection=self))}

    def get_pool(self, pool_key: str) -> Pool[T_ValueType]:
        """
        Returns the pool for the given key if found in the collection.

        Otherwise a new pool is inserted into the collection and returned.
        """
        if pool_key not in self._pools:
            self._pools[pool_key] = self.pool_cls(collection=self, pool_key=pool_key, assignments={})
            self.changed = True

        return self._pools[pool_key]

    def __remove_stale_assignments(self) -> None:
        """Remove stale assignments from all pools in the collection and remove empty pools afterwards."""
        len_before = len(self._pools)
        non_empty_pools: dict[str, Pool] = {}
        for pool_key, pool in self._pools.items():
            pool._remove_stale_assignments()
            if pool.assignments:
                non_empty_pools[pool_key] = pool
        self._pools = non_empty_pools
        self.changed = self.changed or len_before != len(self._pools)

    def as_dict(self) -> dict[str, dict[str, T_ValueType]]:
        """Returns a dicts representing the pools."""
        return {pool_key: self._pools[pool_key].assignments_as_dict() for pool_key in natural_sort(self._pools)}

    def save_updates(self, dumper_cls: type = CSafeDumper) -> bool:
        """
        Save data if anything changed. Returns a boolean telling if anything was changed.

        Calls self._remove_stale_assignments first to ensure we save the cleaned data.

        Data is sorted to ensure a consistent layout.
        """
        self.__remove_stale_assignments()
        if not self.changed:
            return False

        if not self.pools_file.exists():
            # Try to create the dir and file.
            self.pools_file.parent.mkdir(mode=0o775, parents=True, exist_ok=True)
            self.pools_file.touch(mode=0o664)

        try:
            self.pools_file.write_text(FILE_HEADER + dump({self.pools_key: self.as_dict()}, Dumper=dumper_cls, sort_keys=False))
        except OSError as e:
            msg = f"An error occurred during writing of the AVD Pool Manager file '{self.pools_file}': {e}"
            raise type(e)(msg) from e

        self.changed = False
        return True

    @staticmethod
    @abstractmethod
    def _pool_key_from_shared_utils(shared_utils: SharedUtilsProtocol) -> str:
        """Returns the pool key to use for this device."""

    @staticmethod
    @abstractmethod
    def _pool_key_from_dict(pool_key_dict: dict) -> str:
        """
        Returns the formatted pool key generated from legacy pool key dict format.

        Caveat: This will always use the default template string to generate the pool names.

        Raises:
            KeyError: If any of the legacy fields are missing. Caught by the caller.
        """

    @staticmethod
    @abstractmethod
    def _pools_file_from_shared_utils(output_dir: Path, shared_utils: SharedUtilsProtocol) -> Path:
        """Returns the file to use for this device."""

    @staticmethod
    @abstractmethod
    def _assignment_key_from_shared_utils(shared_utils: SharedUtilsProtocol) -> str:
        """Returns the assignment key to use for this device."""
