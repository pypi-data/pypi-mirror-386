"""Base classes, types, and protocols for Tailwind CSS abstractions"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/base.ipynb.

# %% auto 0
__all__ = ['TailwindScale', 'TailwindFraction', 'TailwindArbitrary', 'TailwindCustomProperty', 'TailwindValue',
           'PSEUDO_CLASS_MODIFIERS', 'PSEUDO_ELEMENT_MODIFIERS', 'RESPONSIVE_MODIFIERS', 'THEME_MODIFIERS',
           'MOTION_MODIFIERS', 'PRINT_MODIFIERS', 'ORIENTATION_MODIFIERS', 'CONTRAST_MODIFIERS', 'DIRECTION_MODIFIERS',
           'STATE_MODIFIERS', 'CHILD_MODIFIERS', 'ALL_MODIFIER_GROUPS', 'CONTAINER_SCALES', 'BREAKPOINTS', 'T',
           'DIRECTIONS', 'is_numeric_scale', 'is_fraction', 'is_custom_property', 'is_arbitrary_value',
           'TailwindBuilder', 'BaseUtility', 'ModifierMixin', 'ModifierGroup', 'StandardUtility', 'NamedScale',
           'Breakpoint', 'BaseFactory', 'UtilityFactory', 'combine_classes', 'SingleValueUtility', 'SingleValueFactory',
           'Direction', 'DirectionalUtility', 'NegativeableUtility']

# %% ../../nbs/core/base.ipynb 3
from typing import Union, Optional, Literal, Protocol, runtime_checkable, TypeVar, Generic, Callable, Any, Dict, List, Tuple
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
import re

# %% ../../nbs/core/base.ipynb 5
# Type aliases for Tailwind values
TailwindScale = Union[int, float, str]  # Numeric scales like 1, 2.5, "px"
TailwindFraction = str  # Fractions like "1/2", "2/3"
TailwindArbitrary = str  # Arbitrary values like "123px", "10rem"
TailwindCustomProperty = str  # CSS custom properties like "--spacing-lg"
TailwindValue = Union[TailwindScale, TailwindFraction, TailwindArbitrary, TailwindCustomProperty] # Union of all possible value types

# %% ../../nbs/core/base.ipynb 7
def is_numeric_scale(
    value: Any  # The value to check - can be int, float, or string
) -> bool:  # True if the value is a valid numeric scale, False otherwise
    """Check if value is a valid numeric scale (int, float, or 'px')."""
    if isinstance(value, (int, float)):
        return True
    if isinstance(value, str) and value == "px":
        return True
    return False

# %% ../../nbs/core/base.ipynb 8
def is_fraction(
    value: Any  # The value to check for fraction format
) -> bool:  # True if the value is a valid fraction string, False otherwise
    """Check if value is a valid fraction string (e.g., '1/2', '3/4')."""
    if not isinstance(value, str):
        return False
    pattern = r'^\d+/\d+$'
    return bool(re.match(pattern, value))

# %% ../../nbs/core/base.ipynb 9
def is_custom_property(
    value: Any  # The value to check for CSS custom property format
) -> bool:  # True if the value is a CSS custom property, False otherwise
    """Check if value is a CSS custom property (starts with --)."""
    if not isinstance(value, str):
        return False
    return value.startswith("--")

# %% ../../nbs/core/base.ipynb 10
def is_arbitrary_value(
    value: Any  # The value to check for arbitrary CSS value format
) -> bool:  # True if the value contains CSS units or calc(), False otherwise
    """Check if value is an arbitrary value (contains units or special chars)."""
    if not isinstance(value, str):
        return False
    # Check for common CSS units
    units = r'(px|em|rem|vh|vw|%|deg|s|ms)$'
    return bool(re.search(units, value)) or value.startswith("calc(")

# %% ../../nbs/core/base.ipynb 12
@runtime_checkable
class TailwindBuilder(Protocol):
    """Protocol for all Tailwind utility builders."""
    
    def build(
        self,
        *args,
        **kwargs
    ) -> str:  # The built CSS class string
        """Build and return the CSS class string."""
        ...
    
    def __str__(
        self
    ) -> str:  # The built CSS class string
        """Return the built CSS class string."""
        ...

# %% ../../nbs/core/base.ipynb 14
class BaseUtility(ABC):
    """Base class for all Tailwind utility builders."""
    
    def __init__(
        self,
        prefix: str  # The utility prefix (e.g., 'w' for width, 'p' for padding)
    ):
        """
        Initialize with a utility prefix.
        """
        self.prefix = prefix
        self._value: Optional[str] = None
        self._modifiers: List[str] = []
    
    @abstractmethod
    def _format_value(
        self,
        value: TailwindValue  # The value to format (numeric, fraction, arbitrary, etc.)
    ) -> str:  # The formatted value string ready for class construction
        """Format the value according to Tailwind conventions."""
        pass
    
    def _build_class(
        self,
        value: Optional[TailwindValue] = None  # Optional value to use for building the class
    ) -> str:  # The complete CSS class string with modifiers applied
        """Build the complete CSS class string."""
        if value is not None:
            formatted_value = self._format_value(value)
        elif self._value is not None:
            formatted_value = self._value
        else:
            return self.prefix
        
        # Join prefix and value
        base_class = f"{self.prefix}-{formatted_value}"
        
        # Apply modifiers
        if self._modifiers:
            return ":".join(self._modifiers + [base_class])
        
        return base_class
    
    def build(
        self,
        value: Optional[TailwindValue] = None  # Optional value to override the stored value
    ) -> str:  # The built CSS class string
        """Build and return the CSS class string."""
        return self._build_class(value)
    
    def __str__(
        self
    ) -> str:  # The built CSS class string
        """Return the built CSS class string."""
        return self._build_class()
    
    def with_modifiers(
        self,
        *modifiers: str  # Modifier strings to apply (e.g., 'hover', 'focus', 'dark')
    ) -> 'BaseUtility':  # A new instance with the modifiers applied
        """
        Create a new instance with additional modifiers.
        Modifiers are applied in the order they are passed.
        """
        # Create a shallow copy to avoid modifying the original
        import copy
        new_instance = copy.copy(self)
        new_instance._modifiers = list(modifiers) + self._modifiers
        return new_instance

# %% ../../nbs/core/base.ipynb 16
class ModifierMixin:
    """Mixin to add modifier support to any utility with convenient property access."""
    
    # Pseudo-class modifiers
    @property
    def hover(
        self
    ) -> 'BaseUtility':  # Utility with hover state modifier applied
        """Apply hover modifier."""
        return self.with_modifiers("hover")
    
    @property
    def focus(
        self
    ) -> 'BaseUtility':  # Utility with focus state modifier applied
        """Apply focus modifier."""
        return self.with_modifiers("focus")
    
    @property
    def active(
        self
    ) -> 'BaseUtility':  # Utility with active state modifier applied
        """Apply active modifier."""
        return self.with_modifiers("active")
    
    @property
    def visited(
        self
    ) -> 'BaseUtility':  # Utility with visited state modifier applied
        """Apply visited modifier."""
        return self.with_modifiers("visited")
    
    @property
    def disabled(
        self
    ) -> 'BaseUtility':  # Utility with disabled state modifier applied
        """Apply disabled modifier."""
        return self.with_modifiers("disabled")
    
    @property
    def checked(
        self
    ) -> 'BaseUtility':  # Utility with checked state modifier applied
        """Apply checked modifier."""
        return self.with_modifiers("checked")
    
    @property
    def required(
        self
    ) -> 'BaseUtility':  # Utility with required state modifier applied
        """Apply required modifier."""
        return self.with_modifiers("required")
    
    @property
    def invalid(
        self
    ) -> 'BaseUtility':  # Utility with invalid state modifier applied
        """Apply invalid modifier."""
        return self.with_modifiers("invalid")
    
    @property
    def valid(
        self
    ) -> 'BaseUtility':  # Utility with valid state modifier applied
        """Apply valid modifier."""
        return self.with_modifiers("valid")
    
    # Pseudo-element modifiers
    @property
    def before(
        self
    ) -> 'BaseUtility':  # Utility with before pseudo-element modifier applied
        """Apply before pseudo-element modifier."""
        return self.with_modifiers("before")
    
    @property
    def after(
        self
    ) -> 'BaseUtility':  # Utility with after pseudo-element modifier applied
        """Apply after pseudo-element modifier."""
        return self.with_modifiers("after")
    
    @property
    def placeholder(
        self
    ) -> 'BaseUtility':  # Utility with placeholder modifier applied
        """Apply placeholder modifier."""
        return self.with_modifiers("placeholder")
    
    @property
    def selection(
        self
    ) -> 'BaseUtility':  # Utility with selection modifier applied
        """Apply selection modifier."""
        return self.with_modifiers("selection")
    
    # Responsive modifiers
    @property
    def sm(
        self
    ) -> 'BaseUtility':  # Utility with small breakpoint modifier applied
        """Apply small breakpoint modifier."""
        return self.with_modifiers("sm")

    @property
    def max_sm(
        self
    ) -> 'BaseUtility':  # Utility with max-sm breakpoint modifier applied
        """Apply max small breakpoint modifier variant."""
        return self.with_modifiers("max-sm")
    
    @property
    def md(
        self
    ) -> 'BaseUtility':  # Utility with medium breakpoint modifier applied
        """Apply medium breakpoint modifier."""
        return self.with_modifiers("md")

    @property
    def max_md(
        self
    ) -> 'BaseUtility':  # Utility with max-md breakpoint modifier applied
        """Apply max medium breakpoint modifier variant."""
        return self.with_modifiers("max-md")
    
    @property
    def lg(
        self
    ) -> 'BaseUtility':  # Utility with large breakpoint modifier applied
        """Apply large breakpoint modifier."""
        return self.with_modifiers("lg")
    
    @property
    def xl(
        self
    ) -> 'BaseUtility':  # Utility with extra large breakpoint modifier applied
        """Apply extra large breakpoint modifier."""
        return self.with_modifiers("xl")
    
    @property
    def _2xl(
        self
    ) -> 'BaseUtility':  # Utility with 2xl breakpoint modifier applied
        """Apply 2xl breakpoint modifier."""
        return self.with_modifiers("2xl")
    
    # Theme modifiers
    @property
    def dark(
        self
    ) -> 'BaseUtility':  # Utility with dark mode modifier applied
        """Apply dark mode modifier."""
        return self.with_modifiers("dark")
    
    # Motion modifiers
    @property
    def motion_reduce(
        self
    ) -> 'BaseUtility':  # Utility with reduced motion modifier applied
        """Apply reduced motion modifier."""
        return self.with_modifiers("motion-reduce")
    
    @property
    def motion_safe(
        self
    ) -> 'BaseUtility':  # Utility with safe motion modifier applied
        """Apply safe motion modifier."""
        return self.with_modifiers("motion-safe")
    
    # Structural modifiers
    @property
    def first(
        self
    ) -> 'BaseUtility':  # Utility with first child modifier applied
        """Apply first child modifier."""
        return self.with_modifiers("first")
    
    @property
    def last(
        self
    ) -> 'BaseUtility':  # Utility with last child modifier applied
        """Apply last child modifier."""
        return self.with_modifiers("last")
    
    @property
    def odd(
        self
    ) -> 'BaseUtility':  # Utility with odd child modifier applied
        """Apply odd child modifier."""
        return self.with_modifiers("odd")
    
    @property
    def even(
        self
    ) -> 'BaseUtility':  # Utility with even child modifier applied
        """Apply even child modifier."""
        return self.with_modifiers("even")
    
    # Group and peer modifiers
    def group(
        self, 
        state: Optional[str] = None,  # Optional state like 'hover', 'focus'
        name: Optional[str] = None    # Optional group name for nested groups
    ) -> 'BaseUtility':  # The utility with group modifier applied
        """Apply group modifier with optional state and name."""
        modifier = "group"
        if name:
            modifier = f"group/{name}"
        if state:
            modifier = f"{modifier}-{state}"
        return self.with_modifiers(modifier)
    
    def peer(
        self, 
        state: Optional[str] = None,  # Optional state like 'hover', 'focus'
        name: Optional[str] = None    # Optional peer name for multiple peers
    ) -> 'BaseUtility':  # The utility with peer modifier applied
        """Apply peer modifier with optional state and name."""
        modifier = "peer"
        if name:
            modifier = f"peer/{name}"
        if state:
            modifier = f"{modifier}-{state}"
        return self.with_modifiers(modifier)
    
    # Arbitrary modifiers
    def has(
        self,
        selector: str  # CSS selector for :has() pseudo-class
    ) -> 'BaseUtility':  # The utility with has modifier applied
        """Apply has modifier with a selector."""
        return self.with_modifiers(f"has-[{selector}]")
    
    def aria(
        self,
        attribute: str,  # ARIA attribute name
        value: Optional[str] = None  # Optional value for the attribute
    ) -> 'BaseUtility':  # The utility with aria modifier applied
        """Apply aria modifier with attribute and optional value."""
        if value:
            return self.with_modifiers(f"aria-[{attribute}={value}]")
        return self.with_modifiers(f"aria-{attribute}")
    
    def data(
        self,
        attribute: str,  # Data attribute name
        value: Optional[str] = None  # Optional value for the attribute
    ) -> 'BaseUtility':  # The utility with data modifier applied
        """Apply data modifier with attribute and optional value."""
        if value:
            return self.with_modifiers(f"data-[{attribute}={value}]")
        return self.with_modifiers(f"data-[{attribute}]")
    
    def arbitrary(
        self,
        selector: str  # Arbitrary CSS selector
    ) -> 'BaseUtility':  # The utility with arbitrary modifier applied
        """Apply arbitrary modifier with custom selector."""
        return self.with_modifiers(f"[{selector}]")

# %% ../../nbs/core/base.ipynb 18
@dataclass
class ModifierGroup:
    """Group of related modifiers with descriptions."""
    name: str
    description: str
    modifiers: Dict[str, str]  # modifier_name -> tailwind_variant

# Pseudo-class modifiers
PSEUDO_CLASS_MODIFIERS = ModifierGroup(
    "Pseudo Classes",
    "Style elements based on pseudo-class states",
    {
        # Interactive states
        "hover": "hover",
        "focus": "focus",
        "focus_within": "focus-within",
        "focus_visible": "focus-visible",
        "active": "active",
        "visited": "visited",
        "target": "target",
        
        # Form states
        "disabled": "disabled",
        "enabled": "enabled",
        "checked": "checked",
        "indeterminate": "indeterminate",
        "default": "default",
        "required": "required",
        "valid": "valid",
        "invalid": "invalid",
        "in_range": "in-range",
        "out_of_range": "out-of-range",
        "placeholder_shown": "placeholder-shown",
        "autofill": "autofill",
        "read_only": "read-only",
        
        # Structural states
        "first": "first",
        "last": "last",
        "only": "only",
        "odd": "odd",
        "even": "even",
        "first_of_type": "first-of-type",
        "last_of_type": "last-of-type",
        "only_of_type": "only-of-type",
        "empty": "empty",
    }
)

# Pseudo-element modifiers
PSEUDO_ELEMENT_MODIFIERS = ModifierGroup(
    "Pseudo Elements",
    "Style pseudo-elements of an element",
    {
        "before": "before",
        "after": "after",
        "first_letter": "first-letter",
        "first_line": "first-line",
        "marker": "marker",
        "selection": "selection",
        "file": "file",
        "backdrop": "backdrop",
        "placeholder": "placeholder",
    }
)

# Responsive modifiers
RESPONSIVE_MODIFIERS = ModifierGroup(
    "Responsive",
    "Apply styles at specific breakpoints",
    {
        "sm": "sm",      # >= 640px
        "md": "md",      # >= 768px
        "lg": "lg",      # >= 1024px
        "xl": "xl",      # >= 1280px
        "2xl": "2xl",    # >= 1536px
    }
)

# Dark mode and theme modifiers
THEME_MODIFIERS = ModifierGroup(
    "Theme",
    "Apply styles based on color scheme preference",
    {
        "dark": "dark",
        "light": "light",  # For explicit light mode styling
    }
)

# Motion modifiers
MOTION_MODIFIERS = ModifierGroup(
    "Motion",
    "Apply styles based on motion preferences",
    {
        "motion_safe": "motion-safe",
        "motion_reduce": "motion-reduce",
    }
)

# Print modifier
PRINT_MODIFIERS = ModifierGroup(
    "Print",
    "Apply styles for print media",
    {
        "print": "print",
    }
)

# Orientation modifiers
ORIENTATION_MODIFIERS = ModifierGroup(
    "Orientation",
    "Apply styles based on viewport orientation",
    {
        "portrait": "portrait",
        "landscape": "landscape",
    }
)

# Contrast modifiers
CONTRAST_MODIFIERS = ModifierGroup(
    "Contrast",
    "Apply styles based on contrast preference",
    {
        "contrast_more": "contrast-more",
        "contrast_less": "contrast-less",
    }
)

# Direction modifiers
DIRECTION_MODIFIERS = ModifierGroup(
    "Direction",
    "Apply styles based on text direction",
    {
        "rtl": "rtl",
        "ltr": "ltr",
    }
)

# Open/closed state modifiers
STATE_MODIFIERS = ModifierGroup(
    "State",
    "Apply styles based on open/closed states",
    {
        "open": "open",
        "closed": "closed",
    }
)

# Child selector modifiers
CHILD_MODIFIERS = ModifierGroup(
    "Children",
    "Apply styles to child elements",
    {
        "children": "*",      # Direct children
        "descendants": "**",  # All descendants
    }
)

# All modifier groups
ALL_MODIFIER_GROUPS = [
    PSEUDO_CLASS_MODIFIERS,
    PSEUDO_ELEMENT_MODIFIERS,
    RESPONSIVE_MODIFIERS,
    THEME_MODIFIERS,
    MOTION_MODIFIERS,
    PRINT_MODIFIERS,
    ORIENTATION_MODIFIERS,
    CONTRAST_MODIFIERS,
    DIRECTION_MODIFIERS,
    STATE_MODIFIERS,
    CHILD_MODIFIERS,
]

# %% ../../nbs/core/base.ipynb 19
class StandardUtility(BaseUtility, ModifierMixin):
    """Standard utility class with common value formatting and modifier support."""
    
    def _format_value(
        self,
        value: TailwindValue  # The value to format according to Tailwind conventions
    ) -> str:  # The formatted value string (e.g., "4", "[10px]", "(--custom)")
        """
        Format value according to Tailwind conventions:
        - Numeric scales: used as-is (e.g., 4 -> "4")
        - Fractions: used as-is (e.g., "1/2" -> "1/2")
        - Custom properties: wrapped in parentheses (e.g., "--spacing" -> "(--spacing)")
        - Arbitrary values: wrapped in brackets (e.g., "10px" -> "[10px]")
        """
        if is_numeric_scale(value):
            return str(value)
        elif is_fraction(value):
            return value
        elif is_custom_property(value):
            return f"({value})"
        elif is_arbitrary_value(value):
            return f"[{value}]"
        else:
            # Named values (like 'auto', 'full', etc.)
            return str(value)

# %% ../../nbs/core/base.ipynb 21
@dataclass
class NamedScale:
    """Represents a named scale with optional CSS variable."""
    name: str
    var: Optional[str] = None
    comment: Optional[str] = None
    
    def format(
        self
    ) -> str:  # The name of the scale for use in CSS classes
        """Format as Tailwind class suffix."""
        return self.name

# %% ../../nbs/core/base.ipynb 22
CONTAINER_SCALES = [ # Common named scales used across utilities
    NamedScale("3xs", "--container-3xs", "16rem (256px)"),
    NamedScale("2xs", "--container-2xs", "18rem (288px)"),
    NamedScale("xs", "--container-xs", "20rem (320px)"),
    NamedScale("sm", "--container-sm", "24rem (384px)"),
    NamedScale("md", "--container-md", "28rem (448px)"),
    NamedScale("lg", "--container-lg", "32rem (512px)"),
    NamedScale("xl", "--container-xl", "36rem (576px)"),
    NamedScale("2xl", "--container-2xl", "42rem (672px)"),
    NamedScale("3xl", "--container-3xl", "48rem (768px)"),
    NamedScale("4xl", "--container-4xl", "56rem (896px)"),
    NamedScale("5xl", "--container-5xl", "64rem (1024px)"),
    NamedScale("6xl", "--container-6xl", "72rem (1152px)"),
    NamedScale("7xl", "--container-7xl", "80rem (1280px)"),
]

# %% ../../nbs/core/base.ipynb 24
@dataclass
class Breakpoint:
    """Responsive breakpoint definition."""
    name: str
    min_width: Optional[str] = None

# %% ../../nbs/core/base.ipynb 25
BREAKPOINTS = { # Common breakpoints
    "sm": Breakpoint("sm", "640px"),
    "md": Breakpoint("md", "768px"),
    "lg": Breakpoint("lg", "1024px"),
    "xl": Breakpoint("xl", "1280px"),
    "2xl": Breakpoint("2xl", "1536px"),
}

# %% ../../nbs/core/base.ipynb 26
STATE_MODIFIERS = [ # Common state modifiers
    "hover", "focus", "active", "visited", "target",
    "focus-within", "focus-visible", "disabled", "enabled",
    "checked", "indeterminate", "default", "required",
    "valid", "invalid", "in-range", "out-of-range",
    "placeholder-shown", "autofill", "read-only",
    "first", "last", "odd", "even", "first-of-type",
    "last-of-type", "only-child", "empty",
    "before", "after", "first-letter", "first-line",
    "marker", "selection", "file", "backdrop",
    "placeholder", "open", "closed",
]

# %% ../../nbs/core/base.ipynb 28
class BaseFactory(ABC):
    """Base factory class with documentation support."""
    
    def __init__(
        self,
        doc: str  # Documentation string describing what this factory creates
    ):
        """Initialize with documentation string."""
        self._doc = doc
    
    @property
    def __doc__(
        self
    ) -> str:  # The documentation string
        """Return the documentation for this factory."""
        return self._doc
    
    def describe(
        self
    ) -> str:  # A formatted description of the factory
        """Return a formatted description of this factory."""
        return self._doc
    
    @abstractmethod
    def get_info(
        self
    ) -> Dict[str, Any]:  # Dictionary with factory information
        """
        Get detailed information about this factory's options and valid inputs.
        
        Should return a dictionary with keys like:
        - 'description': Factory description
        - 'valid_inputs': List/description of valid input values
        - 'options': Available options or methods
        """
        pass

# %% ../../nbs/core/base.ipynb 30
T = TypeVar('T', bound=BaseUtility)

# %% ../../nbs/core/base.ipynb 31
class UtilityFactory(BaseFactory, Generic[T]):
    """Factory for creating utility instances with fluent API."""
    
    def __init__(
        self,
        utility_class: type[T],  # The utility class to instantiate
        prefix: str,  # The prefix to use for the utilities
        doc: Optional[str] = None  # Optional documentation string
    ):
        "Initialize factory with a utility class and prefix."
        doc = doc or f"Factory for {prefix} utilities"
        super().__init__(doc)
        self.utility_class = utility_class
        self.prefix = prefix
    
    def __call__(
        self,
        value: Optional[TailwindValue] = None  # Initial value for the utility
    ) -> T:  # A new instance of the utility class
        """Create a utility instance with optional value."""
        instance = self.utility_class(self.prefix)
        if value is not None:
            instance._value = instance._format_value(value)
        return instance
    
    def __getattr__(
        self,
        name: str  # Attribute name to convert to a utility value
    ) -> T:  # A new utility instance with the attribute as its value
        """Handle named values (e.g., w.full, h.screen)."""
        instance = self.utility_class(self.prefix)
        instance._value = name.replace("_", "-")
        return instance
    
    def get_info(
        self
    ) -> Dict[str, Any]:  # Dictionary with factory information
        """Get information about this utility factory."""
        return {
            'description': self._doc,
            'valid_inputs': 'Various Tailwind values (implementation specific)',
            'options': {
                'prefix': self.prefix,
                'utility_class': self.utility_class.__name__
            }
        }

# %% ../../nbs/core/base.ipynb 43
def combine_classes(
    *args: Union[str, BaseUtility, TailwindBuilder, BaseFactory, None]
) -> str:  # Space-separated class string
    "Combine multiple class builders or strings into a single class string."
    classes = []
    for arg in args:
        if arg is None:
            continue
        elif isinstance(arg, str):
            if arg.strip():  # Only add non-empty strings
                classes.append(arg.strip())
        elif isinstance(arg, BaseUtility):
            classes.append(str(arg))
        elif isinstance(arg, SingleValueFactory):
            classes.append(str(arg))
        elif hasattr(arg, 'build'):
            classes.append(arg.build())
        elif hasattr(arg, '__str__'):
            result = str(arg)
            if result.strip():
                classes.append(result)
    
    return " ".join(classes)

# %% ../../nbs/core/base.ipynb 51
class SingleValueUtility(BaseUtility, ModifierMixin):
    """A utility that represents a single fixed value."""
    
    def __init__(
        self,
        value: str  # The complete utility class string (e.g., "container", "sr-only")
    ):
        """Initialize with a complete utility value."""
        # For single values, the entire value is the prefix
        super().__init__(value)
        # No additional value needed
        self._value = None
    
    def _format_value(
        self,
        value: TailwindValue  # Not used for single value utilities
    ) -> str:  # Empty string since value is in prefix
        """Single value utilities don't format values."""
        return ""
    
    def _build_class(
        self,
        value: Optional[TailwindValue] = None  # Ignored for single value utilities
    ) -> str:  # The complete CSS class string with modifiers
        """Build the complete CSS class string."""
        # For single values, the prefix IS the class
        base_class = self.prefix
        
        # Apply modifiers
        if self._modifiers:
            return ":".join(self._modifiers + [base_class])
        
        return base_class

# %% ../../nbs/core/base.ipynb 52
class SingleValueFactory(BaseFactory):
    """Factory for a single utility class with modifier support."""
    
    def __init__(
        self,
        value: str,  # The utility class string (e.g., "container")
        doc: str  # Documentation describing what this utility does
    ):
        """Initialize with a value and documentation."""
        super().__init__(doc)
        self._value = value
        # Create a cached instance for property access
        self._instance = SingleValueUtility(value)
    
    def __str__(
        self
    ) -> str:  # The utility class string
        """Return the utility class string."""
        return self._value
    
    def __call__(
        self
    ) -> SingleValueUtility:  # A SingleValueUtility instance
        """Return a new SingleValueUtility instance when called."""
        return SingleValueUtility(self._value)
    
    def build(
        self
    ) -> str:  # The utility class string
        """Build and return the utility class string."""
        return self._value
    
    # Delegate modifier properties to the cached instance
    def __getattr__(
        self,
        name: str  # Attribute name to delegate
    ) -> Any:  # The result from the cached instance
        """Delegate modifier access to the cached instance."""
        # Check if it's a modifier property
        if hasattr(self._instance, name):
            attr = getattr(self._instance, name)
            # If it's a property or method that returns a utility, we need to handle it
            if callable(attr) or isinstance(attr, property):
                # Get the actual value
                result = getattr(self._instance, name)
                if isinstance(result, BaseUtility):
                    return result
            return attr
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")
    
    def get_info(
        self
    ) -> Dict[str, Any]:  # Dictionary with factory information
        """Get information about this single-value factory."""
        return {
            'description': self._doc,
            'valid_inputs': 'No inputs - returns a fixed value with modifier support',
            'options': {
                'value': self._value,
                'supports_modifiers': True
            }
        }

# %% ../../nbs/core/base.ipynb 55
@dataclass
class Direction:
    """Represents a directional variant."""
    suffix: str
    css_suffix: str

# %% ../../nbs/core/base.ipynb 56
DIRECTIONS = { # Common directions
    "t": Direction("t", "top"),      # top
    "r": Direction("r", "right"),    # right
    "b": Direction("b", "bottom"),   # bottom
    "l": Direction("l", "left"),     # left
    "x": Direction("x", "inline"),   # horizontal
    "y": Direction("y", "block"),    # vertical
}

# %% ../../nbs/core/base.ipynb 57
class DirectionalUtility(StandardUtility):
    """Base class for utilities with directional variants."""
    
    def __init__(
        self,
        prefix: str,  # Base prefix (e.g., 'p' for padding)
        direction: Optional[str] = None  # Optional direction ('t', 'r', 'b', 'l', 'x', 'y')
    ):
        """Initialize with prefix and optional direction."""
        if direction and direction in DIRECTIONS:
            full_prefix = f"{prefix}{direction}"
        else:
            full_prefix = prefix
        super().__init__(full_prefix)

# %% ../../nbs/core/base.ipynb 60
class NegativeableUtility(StandardUtility):
    """Utility class that supports negative values."""
    
    def __init__(
        self,
        prefix: str,  # Base prefix
        negative: bool = False  # Whether this is a negative variant
    ):
        """Initialize with prefix and negative flag."""
        self.negative = negative
        full_prefix = f"-{prefix}" if negative else prefix
        super().__init__(full_prefix)
