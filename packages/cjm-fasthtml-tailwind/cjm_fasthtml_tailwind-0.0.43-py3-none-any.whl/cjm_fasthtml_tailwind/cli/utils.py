"""Utility functions for CLI tools"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/cli/utils.ipynb.

# %% auto 0
__all__ = ['SearchResult', 'print_header', 'print_not_found', 'print_total', 'print_helpful_instructions',
           'display_items_generic', 'handle_module_not_found', 'simple_item_formatter', 'indented_item_formatter',
           'extract_match_context', 'extract_source_line_context', 'create_search_result', 'search_in_text',
           'search_in_name_and_text', 'check_factory_usage_patterns', 'search_in_fields', 'search_in_source_code',
           'find_variable_usages', 'find_usage_in_items', 'get_view_command', 'format_usage_examples',
           'discover_utility_modules', 'iterate_all_modules_with_items', 'extract_helper_names_from_test',
           'load_code_from_file', 'list_utility_modules']

# %% ../../nbs/cli/utils.ipynb 3
import ast
import inspect
from typing import List, Tuple, Optional, Dict, Any, Callable, Union
from dataclasses import dataclass
import re
from pathlib import Path
from .cli_config import LibraryConfig, get_active_config

# %% ../../nbs/cli/utils.ipynb 5
@dataclass
class SearchResult:
    """Represents a single search result."""
    content_type: str  # 'factory', 'example', 'helper', 'module'
    module_name: str  # Module where found
    item_name: str  # Name of the item (factory name, function name, etc.)
    match_context: str  # The context where the match was found
    match_location: str  # Where the match was found (name, doc, source)
    score: float = 1.0  # Relevance score for fuzzy matching

# %% ../../nbs/cli/utils.ipynb 7
def print_header(
    title: str,  # Header title to display
    width: int = 60  # Width of separator line in characters
) -> None:  # No return value
    """Print a formatted header with title and separator."""
    print(title)
    print("=" * width)
    if title.endswith(":"):
        print()  # Add extra line after colon headers

# %% ../../nbs/cli/utils.ipynb 8
def print_not_found(
    item_type: str,  # Type of item that wasn't found (e.g., 'factory', 'example')
    item_name: str,  # Name of the item that wasn't found
    module_name: Optional[str] = None,  # Optional module name where search was performed
    config: Optional[LibraryConfig] = None  # Optional configuration
) -> None:  # No return value
    """Print a standardized not found message."""
    if config is None:
        config = get_active_config()
    
    if module_name:
        print(f"No {item_type} '{item_name}' found in module '{module_name}' or module doesn't exist.")
        print(f"\nTry running '{config.cli_command} modules' to see available modules.")
    else:
        print(f"No {item_type} found in any utility modules.")

# %% ../../nbs/cli/utils.ipynb 9
def print_total(
    item_type: str,  # Type of items being counted (e.g., 'factories', 'examples')
    count: int,  # Number of items found
    across_modules: bool = False  # Whether count spans multiple modules
) -> None:  # No return value
    """Print a standardized total count message."""
    if across_modules:
        print(f"\nTotal {item_type} across all modules: {count}")
    else:
        print(f"\nTotal {item_type}: {count}")

# %% ../../nbs/cli/utils.ipynb 10
def print_helpful_instructions(
    instructions: List[Tuple[str, Optional[str]]]  # List of (description, example) tuples
):
    "Print helpful instructions section."
    print("\nTo explore further:")
    for desc, example in instructions:
        print(f"  {desc}")
        if example:
            print(f"    {example}")

# %% ../../nbs/cli/utils.ipynb 11
def display_items_generic(
    items: Union[Dict, List],  # Items to display (dict of lists or list)
    title: str,  # Title for the display
    item_formatter: Callable[[Any], str],  # Function to format each item
    item_type: str,  # Type of items for the total message
    instructions: Optional[List[Tuple[str, Optional[str]]]] = None,  # Help instructions
    not_found_message: Optional[str] = None  # Custom not found message
):
    """Generic function to display a collection of items with consistent formatting."""
    if not items:
        print(not_found_message or f"No {item_type} found.")
        return
    
    print_header(title, 60)
    
    total = 0
    if isinstance(items, dict):
        for key, values in items.items():
            if values:  # Only show if there are items
                print(f"\n{key} ({len(values)} {item_type})")
                print("-" * (len(key) + len(f" ({len(values)} {item_type})")))
                for item in values:
                    print(item_formatter(item))
                total += len(values)
    else:
        for item in items:
            print(item_formatter(item))
        total = len(items)
    
    print_total(item_type, total, across_modules=isinstance(items, dict))
    
    if instructions:
        print_helpful_instructions(instructions)

# %% ../../nbs/cli/utils.ipynb 13
def handle_module_not_found(
    item_type: str,  # Type of items not found (e.g., 'factories', 'examples')
    module_name: str,  # Name of the module that wasn't found
    config: Optional[LibraryConfig] = None  # Optional configuration
):
    """Print standardized error message for module not found."""
    if config is None:
        config = get_active_config()
    print(f"No {item_type} found in module '{module_name}' or module doesn't exist.")
    print(f"\nTry running '{config.cli_command} modules' to see available modules.")

# %% ../../nbs/cli/utils.ipynb 14
def simple_item_formatter(
    name_field: str,  # Name of the field containing the item name
    doc_field: str  # Name of the field containing the documentation
) -> Callable[[Any], str]:  # Formatter function
    """Create a simple formatter for items with name and documentation fields."""
    def formatter(
        item: Any  # Item to format
    ) -> str:  # Formatted string
        """Format item as 'name: documentation'."""
        name = getattr(item, name_field, "Unknown")
        doc = getattr(item, doc_field, "No documentation available")
        return f"{name}: {doc}"
    return formatter

# %% ../../nbs/cli/utils.ipynb 15
def indented_item_formatter(
    prefix: str = "  "  # Indentation prefix
) -> Callable[[Any], Callable[[Any], str]]:  # Returns a formatter factory
    """Create a formatter that indents items with a prefix."""
    def make_formatter(
        inner_formatter: Callable[[Any], str]  # Formatter to wrap with indentation
    ) -> Callable[[Any], str]:  # Formatter that adds indentation
        """Create indented formatter from inner formatter."""
        def formatter(
            item: Any  # Item to format
        ) -> str:  # Indented formatted string
            """Format item with indentation prefix."""
            return prefix + inner_formatter(item)
        return formatter
    return make_formatter

# %% ../../nbs/cli/utils.ipynb 16
def extract_match_context(
    text: str,  # Text to extract context from
    query: str,  # Query string to find
    case_sensitive: bool = False,  # Whether to perform case-sensitive search
    context_size: int = 30  # Number of characters to show before and after match
) -> str:  # Context string with match highlighted
    """Extract context around a match in text."""
    text_search = text if case_sensitive else text.lower()
    query_search = query if case_sensitive else query.lower()
    
    idx = text_search.find(query_search)
    if idx == -1:
        return text[:60] + "..."
    
    start = max(0, idx - context_size)
    end = min(len(text), idx + len(query) + context_size)
    
    prefix = "..." if start > 0 else ""
    suffix = "..." if end < len(text) else ""
    
    return prefix + text[start:end] + suffix

# %% ../../nbs/cli/utils.ipynb 17
def extract_source_line_context(
    source: str,  # Source code to search
    query: str,  # Query string to find
    case_sensitive: bool = False  # Whether to perform case-sensitive search
) -> str:  # Line context showing where match was found
    """Extract line context for a match in source code."""
    source_search = source if case_sensitive else source.lower()
    query_search = query if case_sensitive else query.lower()
    
    idx = source_search.find(query_search)
    if idx == -1:
        return extract_match_context(source, query, case_sensitive)
    
    # Find line containing the match
    lines = source.split('\n')
    current_pos = 0
    
    for line_num, line in enumerate(lines):
        if current_pos <= idx < current_pos + len(line) + 1:
            return f"Line {line_num + 1}: {line.strip()}"
        current_pos += len(line) + 1
    
    # Fallback to context extraction
    return extract_match_context(source, query, case_sensitive)

# %% ../../nbs/cli/utils.ipynb 18
def create_search_result(
    content_type: str,  # Type of content ('factory', 'example', 'helper', 'module')
    module_name: str,  # Module where match was found
    item_name: str,  # Name of the item that matched
    match_context: str,  # Context showing the match
    match_location: str  # Where in the item the match was found ('name', 'doc', 'source')
) -> SearchResult:  # SearchResult instance with provided fields
    """Create a SearchResult with standard fields."""
    return SearchResult(
        content_type=content_type,
        module_name=module_name,
        item_name=item_name,
        match_context=match_context,
        match_location=match_location
    )

# %% ../../nbs/cli/utils.ipynb 19
def search_in_text(
    query: str,  # Search query
    text: str,  # Text to search in
    case_sensitive: bool = False  # Whether to perform case-sensitive search
) -> bool:  # True if match found
    """Check if query exists in text."""
    if not case_sensitive:
        return query.lower() in text.lower()
    return query in text

# %% ../../nbs/cli/utils.ipynb 20
def search_in_name_and_text(
    query: str,  # Search query to find
    item_name: str,  # Item name to search in
    text: str,  # Text (documentation, docstring) to search in
    content_type: str,  # Type of content being searched
    module_name: str,  # Module containing the item
    text_location: str,  # Description of text field (e.g., 'documentation', 'docstring')
    case_sensitive: bool = False  # Whether to perform case-sensitive search
) -> List[SearchResult]:  # List of search results for matches found
    """Search in both name and text fields, returning search results."""
    results = []
    
    # Search in name
    if search_in_text(query, item_name, case_sensitive):
        results.append(create_search_result(
            content_type=content_type,
            module_name=module_name,
            item_name=item_name,
            match_context=item_name,
            match_location='name'
        ))
    
    # Search in text (documentation, docstring, etc.)
    if search_in_text(query, text, case_sensitive):
        context = extract_match_context(text, query, case_sensitive)
        results.append(create_search_result(
            content_type=content_type,
            module_name=module_name,
            item_name=item_name,
            match_context=context,
            match_location=text_location
        ))
    
    return results

# %% ../../nbs/cli/utils.ipynb 21
def check_factory_usage_patterns(
    factory_name: str  # Name of factory to create patterns for
) -> List[str]:  # List of regex patterns matching factory usage
    """Get regex patterns to match common factory usage patterns."""
    import re
    
    # Patterns to match factory usage
    patterns = [
        rf'\b{factory_name}\(',           # factory_name(
        rf'\b{factory_name}\.',           # factory_name.
        rf'\bstr\({factory_name}\b',      # str(factory_name
        rf'\b{factory_name}\[',           # factory_name[
        rf'\({factory_name}\)',           # (factory_name)
        rf'\b{factory_name}\s*=',        # factory_name =
    ]
    
    return patterns

# %% ../../nbs/cli/utils.ipynb 23
def search_in_fields(
    item: Any,  # The item to search in
    query: str,  # Search query
    fields: Dict[str, Callable[[Any], str]],  # field_name -> getter function
    content_type: str,  # Type of content being searched
    module_name: str,  # Module containing the item
    item_name: str,  # Name of the item
    case_sensitive: bool = False  # Whether to perform case-sensitive search
) -> List[SearchResult]:  # List of search results
    """Search for query in multiple fields of an item."""
    results = []
    
    for field_name, getter in fields.items():
        try:
            value = getter(item)
            if value and search_in_text(query, value, case_sensitive):
                context = extract_match_context(value, query, case_sensitive)
                results.append(create_search_result(
                    content_type=content_type,
                    module_name=module_name,
                    item_name=item_name,
                    match_context=context,
                    match_location=field_name
                ))
        except (AttributeError, TypeError):
            # Skip fields that can't be accessed
            pass
    
    return results

# %% ../../nbs/cli/utils.ipynb 24
def search_in_source_code(
    source: str,  # Source code to search in
    query: str,  # Search query
    content_type: str,  # Type of content being searched
    module_name: str,  # Module containing the source
    item_name: str,  # Name of the item
    case_sensitive: bool = False  # Whether to perform case-sensitive search
) -> Optional[SearchResult]:  # Search result or None
    """Search in source code and return result with line context."""
    if not source or not search_in_text(query, source, case_sensitive):
        return None
    
    context = extract_source_line_context(source, query, case_sensitive)
    return create_search_result(
        content_type=content_type,
        module_name=module_name,
        item_name=item_name,
        match_context=context,
        match_location='source'
    )

# %% ../../nbs/cli/utils.ipynb 25
def find_variable_usages(
    func_src: str,  # Source code to search
    var_name: str  # Variable name to find
) -> List[Tuple[int, int, str]]:  # List of (line_number, column, context_type) tuples
    """Find variable usages by parsing function into an AST."""
    # Parse into an AST
    tree = ast.parse(func_src)

    matches = []

    class VarVisitor(ast.NodeVisitor):
        """AST visitor to find variable name references."""
        def visit_Name(
            self,
            node: ast.Name  # AST Name node to visit
        ) -> None:  # No return value
            """Visit Name nodes and record matches."""
            if node.id == var_name:
                matches.append((node.lineno, node.col_offset, type(node.ctx).__name__))
            self.generic_visit(node)

    VarVisitor().visit(tree)
    return matches

# %% ../../nbs/cli/utils.ipynb 26
def find_usage_in_items(
    target_name: str,  # Name of the target (factory/helper) to find usage for
    items: Dict[str, List[Any]],  # Dictionary of module_name -> list of items
    source_getter: Callable[[Any], str],  # Function to get source code from item
    item_type: str  # Type of items being searched (for display)
) -> List[Tuple[str, Any]]:  # List of (module_name, item) tuples
    """Find items that use a specific target (factory/helper)."""
    usage_items = []

    for module_name, module_items in items.items():
        for item in module_items:
            try:
                matches = find_variable_usages(source_getter(item), target_name)
                if matches:
                    usage_items.append((module_name, item))
            except (AttributeError, TypeError):
                # Skip items where source can't be extracted
                pass
    
    return usage_items

# %% ../../nbs/cli/utils.ipynb 29
def get_view_command(
    content_type: str,  # Type of content ('factory', 'example', 'helper', 'module')
    module_name: str,  # Module name
    item_name: str,  # Item name (or feature name for examples)
    config: Optional[LibraryConfig] = None  # Optional configuration
) -> str:  # CLI command to view the item
    """Get the CLI command to view a specific item."""
    if config is None:
        config = get_active_config()
        
    cli_cmd = config.cli_command
    
    commands = {
        'factory': f"{cli_cmd} factory {module_name} {item_name}",
        'example': f"{cli_cmd} example {module_name} {item_name}",
        'helper': f"{cli_cmd} helper {module_name} {item_name}",
        'module': f"{cli_cmd} factories --module {module_name}"
    }
    return commands.get(content_type, "")

# %% ../../nbs/cli/utils.ipynb 30
def format_usage_examples(
    usage_items: List[Tuple[str, Any]],  # List of (module_name, item) tuples
    item_name_getter: Callable[[Any], str],  # Function to get item name
    item_type: str,  # Type of items ('examples' or 'helpers')
    view_command_type: str  # Type for get_view_command ('example' or 'helper')
) -> List[str]:  # List of formatted strings
    """Format usage examples for display."""
    formatted = []
    
    for module_name, item in usage_items:
        item_name = item_name_getter(item)
        # Extract feature name for examples
        if view_command_type == 'example' and hasattr(item, 'feature'):
            view_name = item.feature
        else:
            view_name = item_name
            
        formatted.append(f"  - {item_name} ({module_name} module)")
        formatted.append(f"    View with: {get_view_command(view_command_type, module_name, view_name)}\n")
    
    return formatted

# %% ../../nbs/cli/utils.ipynb 31
import importlib
import pkgutil

def discover_utility_modules(
    config: Optional[LibraryConfig] = None,  # Optional configuration, uses active if not provided
    include_submodules: bool = True  # Whether to include submodules
) -> List[Tuple[str, Any]]:  # List of (module_name, module) tuples
    """Discover all utility modules based on configuration, including submodules."""
    if config is None:
        config = get_active_config()
    
    modules = []
    
    def discover_modules_recursive(
        package_path: str,  # Full package path to discover (e.g., 'pkg.subpkg')
        base_name: str = ""  # Base discovery path for relative naming
    ) -> List[Tuple[str, Any]]:  # List of (module_name, module) tuples
        """Recursively discover modules and submodules."""
        try:
            # Import the package
            package = importlib.import_module(package_path)
            
            # Get the package path
            if hasattr(package, '__path__'):
                # Iterate through all modules in the package
                for importer, modname, ispkg in pkgutil.iter_modules(package.__path__, 
                                                                     prefix=f'{package_path}.'):
                    try:
                        module = importlib.import_module(modname)
                        # Extract the relative name from the base discovery path
                        if base_name:
                            short_name = modname.replace(f"{config.package_name}.{base_name}.", "")
                        else:
                            short_name = modname.split('.')[-1]
                        
                        if ispkg and include_submodules:
                            # If it's a package, recursively discover its modules
                            submodules = discover_modules_recursive(modname, base_name or discovery_path)
                            modules.extend(submodules)
                        else:
                            # Add the module itself
                            modules.append((short_name, module))
                    except ImportError:
                        pass  # Skip modules that can't be imported
        except ImportError:
            pass  # Package not found
        
        return modules
    
    # Iterate through all configured discovery paths
    for discovery_path in config.module_discovery_paths:
        package_path = f"{config.package_name}.{discovery_path}"
        discovered = discover_modules_recursive(package_path, discovery_path)
        modules.extend(discovered)
    
    # Remove duplicates while preserving order
    seen = set()
    unique_modules = []
    for name, module in modules:
        if name not in seen:
            seen.add(name)
            unique_modules.append((name, module))
    
    return sorted(unique_modules, key=lambda x: x[0])  # Sort by module name

# %% ../../nbs/cli/utils.ipynb 32
def iterate_all_modules_with_items(
    extractor_func: Callable[[Any, str], List[Any]],  # Function to extract items from a module
    module_filter: Optional[str] = None,  # Optional specific module to filter for
    config: Optional[LibraryConfig] = None  # Optional configuration
) -> Dict[str, List[Any]]:  # Dictionary mapping module names to their items
    """Generic iterator for extracting items from all modules."""
    if config is None:
        config = get_active_config()
        
    all_items = {}
    
    for module_name, module in discover_utility_modules(config):
        if module_filter and module_name != module_filter:
            continue
            
        items = extractor_func(module, module_name)
        if items:  # Only include modules that have items
            all_items[module_name] = items
    
    return all_items

# %% ../../nbs/cli/utils.ipynb 35
def extract_helper_names_from_test(
    source: str  # Source code of the test_<module>_helper_examples function
) -> List[str]:  # List of helper function names
    """Extract helper function names from test source code."""
    helper_names = set()
    
    # Pattern to match function calls (simple pattern for common cases)
    # Matches: function_name( or function_name (
    import_pattern = re.compile(r'from\s+[\w.]+\s+import\s+([\w\s,]+)')
    call_pattern = re.compile(r'\b(\w+)\s*\(')
    
    # First, check for explicit imports in the test
    imported_names = set()
    for match in import_pattern.finditer(source):
        imports = match.group(1)
        # Split by comma and clean up
        for name in imports.split(','):
            name = name.strip()
            if name and not name.startswith('test_'):
                imported_names.add(name)
    
    # Find all function calls
    for match in call_pattern.finditer(source):
        func_name = match.group(1)
        # Skip common built-ins and test functions
        if (func_name not in ['assert', 'print', 'str', 'int', 'float', 'list', 'dict', 
                              'tuple', 'set', 'len', 'range', 'enumerate', 'zip',
                              'isinstance', 'hasattr', 'getattr', 'setattr'] and
            not func_name.startswith('test_') and
            not func_name.startswith('_')):
            # If we have imports, only include explicitly imported names
            if imported_names:
                if func_name in imported_names:
                    helper_names.add(func_name)
            else:
                # Otherwise include all non-builtin function calls
                helper_names.add(func_name)
    
    return sorted(list(helper_names))

# %% ../../nbs/cli/utils.ipynb 38
def load_code_from_file(
    filepath: str  # Path to file to load
) -> Optional[str]:  # File contents as string, or None if error
    """Load code from a file."""
    try:
        path = Path(filepath).expanduser().resolve()
        if not path.exists():
            print(f"Error: File '{filepath}' not found.")
            return None
        
        if not path.is_file():
            print(f"Error: '{filepath}' is not a file.")
            return None
            
        with open(path, 'r') as f:
            return f.read()
    except Exception as e:
        print(f"Error reading file: {str(e)}")
        return None

# %% ../../nbs/cli/utils.ipynb 40
def list_utility_modules(
    config: Optional[LibraryConfig] = None  # Optional configuration
) -> Dict[str, str]:  # Dictionary mapping module names to their docstrings
    """List all available utility modules with their docstrings."""
    if config is None:
        config = get_active_config()
        
    modules_info = {}
    
    for module_name, module in discover_utility_modules(config):
        # Get module docstring
        doc = inspect.getdoc(module) or "No documentation available"
        modules_info[module_name] = doc
    
    return modules_info
