"""Functions to test code snippets using the library:"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/cli/test_code.ipynb.

# %% auto 0
__all__ = ['create_test_script', 'execute_test_code']

# %% ../../nbs/cli/test_code.ipynb 3
import tempfile
import subprocess
import sys
import os
from pathlib import Path
from typing import Dict, List, Tuple, Any, Optional

from .utils import discover_utility_modules
from .factory_extraction import extract_factories_from_module
from .helper_discovery import get_module_helpers
from .cli_config import LibraryConfig, get_active_config

# %% ../../nbs/cli/test_code.ipynb 4
def create_test_script(
    code: str, # The Python code snippet to wrap in a test script
    config: Optional[LibraryConfig] = None  # Optional configuration
) -> str: # A complete Python script with imports and the provided code
    """Create a test script with necessary imports and the provided code."""
    if config is None:
        config = get_active_config()
        
    # Build the import statements dynamically based on discovered modules
    imports = []
    
    # Add base imports from configuration
    imports.extend(config.base_imports)
    
    # Add imports for factories from each utility module
    for module_name, module in discover_utility_modules(config):
        # Get the factory names from this module
        factories = extract_factories_from_module(module, module_name)
        if factories:
            # Import only the actual factory names
            factory_names = [f.name for f in factories]
            import_list = ", ".join(factory_names)
            imports.append(f"from {module.__name__} import {import_list}")
        
        # Also check for helper functions and import them
        helpers = get_module_helpers(module_name)
        if helpers:
            helper_names = [h.name for h in helpers]
            # Check if we already have factories to import
            if factories:
                # Combine with existing import
                all_names = factory_names + helper_names
                import_list = ", ".join(all_names)
                # Replace the last import for this module
                imports[-1] = f"from {module.__name__} import {import_list}"
            else:
                # Just import helpers
                import_list = ", ".join(helper_names)
                imports.append(f"from {module.__name__} import {import_list}")
    
    # Add core utilities from configuration
    for util_name, module_path in config.core_utilities:
        imports.append(f"from {module_path} import {util_name}")
    
    # Create the full script
    script = "\n".join(imports) + "\n\n"
    script += "# User code starts here\n"
    script += code + "\n"
    
    return script

# %% ../../nbs/cli/test_code.ipynb 5
def execute_test_code(
    code: str,  # The code to test
    show_imports: bool = False,  # Whether to show the generated imports
    timeout: int = 10  # Timeout in seconds
) -> Tuple[bool, str, str]:  # (success, stdout, stderr)
    """Execute test code in a safe environment."""
    # Create the test script
    script = create_test_script(code)
    
    if show_imports:
        print("Generated script:")
        print("=" * 60)
        print(script)
        print("=" * 60)
        print()
    
    # Create a temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write(script)
        temp_file = f.name
    
    try:
        # Execute the script
        result = subprocess.run(
            [sys.executable, temp_file],
            capture_output=True,
            text=True,
            timeout=timeout
        )
        
        success = result.returncode == 0
        return success, result.stdout, result.stderr
        
    except subprocess.TimeoutExpired:
        return False, "", f"Code execution timed out after {timeout} seconds"
    except Exception as e:
        return False, "", f"Error executing code: {str(e)}"
    finally:
        # Clean up the temporary file
        try:
            os.unlink(temp_file)
        except:
            pass
