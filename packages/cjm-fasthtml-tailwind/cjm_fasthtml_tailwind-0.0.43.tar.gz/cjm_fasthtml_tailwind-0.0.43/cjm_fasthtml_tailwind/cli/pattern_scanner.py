"""Scan Python code for replaceable CSS class patterns"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/cli/pattern_scanner.ipynb.

# %% auto 0
__all__ = ['ClsPattern', 'ClsPatternVisitor', 'scan_python_code', 'extract_css_classes_from_node', 'display_patterns',
           'get_unique_css_classes', 'AssertionPattern', 'get_available_css_classes', 'extract_assertion_patterns',
           'collect_all_assertion_patterns', 'MatchType', 'CSSClassMatch', 'tokenize_css_class', 'find_pattern_matches',
           'match_css_class', 'match_css_classes', 'display_match_results', 'analyze_code_patterns',
           'display_code_analysis', 'find_assertion_for_class', 'find_pattern_examples', 'get_migration_suggestions',
           'display_migration_suggestions', 'analyze_and_suggest', 'scan_python_file', 'scan_jupyter_notebook',
           'InputType', 'detect_input_type', 'scan_input', 'analyze_input', 'display_input_analysis',
           'analyze_and_suggest_input']

# %% ../../nbs/cli/pattern_scanner.ipynb 3
import ast
import re
from typing import List, Dict, Tuple, Optional, Set, Any
from dataclasses import dataclass

from .cli_config import LibraryConfig, get_active_config
from .example_discovery import get_example_pattern

# %% ../../nbs/cli/pattern_scanner.ipynb 5
@dataclass
class ClsPattern:
    """Represents a cls= pattern found in code."""
    line_number: int  # Line number where pattern was found
    full_expression: str  # The full cls=... expression
    css_classes: List[str]  # Individual CSS classes extracted
    context: str  # Code context around the pattern
    uses_combine_classes: bool  # Whether combine_classes is used

# %% ../../nbs/cli/pattern_scanner.ipynb 7
class ClsPatternVisitor(ast.NodeVisitor):
    """AST visitor to find cls= patterns in Python code."""
    
    def __init__(
        self,
        source_lines: List[str]  # Source code lines for extracting context around patterns
    ):
        """Initialize with source code lines for context extraction."""
        self.patterns: List[ClsPattern] = []
        self.source_lines = source_lines
    
    def visit_Call(
        self,
        node: ast.Call  # AST Call node to examine for cls= keyword arguments
    ):  # Visits the node and updates self.patterns
        """Visit function calls to find cls= keyword arguments."""
        # Check if this call has a cls keyword argument
        for keyword in node.keywords:
            if keyword.arg == 'cls':
                pattern = self._extract_pattern(keyword.value, node)
                if pattern:
                    self.patterns.append(pattern)
        
        # Continue visiting child nodes
        self.generic_visit(node)
    
    def _extract_pattern(
        self,
        value_node: ast.AST,  # AST node representing the cls= value
        call_node: ast.Call  # AST Call node containing the cls= keyword argument
    ) -> Optional[ClsPattern]:  # ClsPattern object if extraction succeeds, None otherwise
        """Extract a ClsPattern from the cls= value node."""
        try:
            line_number = value_node.lineno
            
            # Get the full expression as a string
            full_expression = ast.unparse(value_node)
            
            # Check if combine_classes is used
            uses_combine_classes = isinstance(value_node, ast.Call) and \
                                 getattr(value_node.func, 'id', None) == 'combine_classes'
            
            # Extract CSS classes using the enhanced function
            css_classes = extract_css_classes_from_node(value_node)
            
            # Get context (the line containing the pattern)
            context_line = line_number - 1  # Convert to 0-based index
            if 0 <= context_line < len(self.source_lines):
                context = self.source_lines[context_line].strip()
            else:
                context = full_expression
            
            return ClsPattern(
                line_number=line_number,
                full_expression=full_expression,
                css_classes=css_classes,
                context=context,
                uses_combine_classes=uses_combine_classes
            )
        except Exception:
            # If we can't parse it, skip it
            return None

# %% ../../nbs/cli/pattern_scanner.ipynb 9
def scan_python_code(
    code: str  # Python source code as a string
) -> List[ClsPattern]:  # List of ClsPattern objects found in the code
    "Scan Python code for cls= patterns."
    try:
        # Parse the code into an AST
        tree = ast.parse(code)
        
        # Split code into lines for context extraction
        source_lines = code.splitlines()
        
        # Create and run the visitor
        visitor = ClsPatternVisitor(source_lines)
        visitor.visit(tree)
        
        return visitor.patterns
    except SyntaxError as e:
        print(f"Syntax error in code: {e}")
        return []
    except Exception as e:
        print(f"Error scanning code: {e}")
        return []

# %% ../../nbs/cli/pattern_scanner.ipynb 11
def extract_css_classes_from_node(
    node: ast.AST  # AST node to extract CSS classes from
) -> List[str]:  # List of CSS class strings found in the node
    """Recursively extract CSS classes from an AST node. Handles various patterns including combine_classes calls."""
    classes = []
    
    if isinstance(node, ast.Constant) and isinstance(node.value, str):
        # Simple string literal
        classes.extend(node.value.split())
    
    elif isinstance(node, ast.Call):
        # Function call
        func_name = None
        if isinstance(node.func, ast.Name):
            func_name = node.func.id
        elif isinstance(node.func, ast.Attribute):
            # Handle chained calls like p.x(4)
            # For now, we'll skip these as they're already using the library
            return classes
        
        if func_name == 'combine_classes':
            # Extract from all arguments
            for arg in node.args:
                classes.extend(extract_css_classes_from_node(arg))
    
    elif isinstance(node, ast.List) or isinstance(node, ast.Tuple):
        # List or tuple of classes
        for elem in node.elts:
            classes.extend(extract_css_classes_from_node(elem))
    
    elif isinstance(node, ast.BinOp) and isinstance(node.op, ast.Add):
        # String concatenation: "flex " + "items-center"
        classes.extend(extract_css_classes_from_node(node.left))
        classes.extend(extract_css_classes_from_node(node.right))
    
    # Clean up extracted classes
    cleaned_classes = []
    for cls in classes:
        # Remove extra whitespace and filter empty strings
        cls = cls.strip()
        if cls and not cls.startswith('<'):
            cleaned_classes.append(cls)
    
    return cleaned_classes

# %% ../../nbs/cli/pattern_scanner.ipynb 26
def display_patterns(
    patterns: List[ClsPattern],  # List of ClsPattern objects to display
    show_context: bool = True  # Whether to show the code context
):  # Displays patterns to stdout, returns nothing
    """Display found patterns in a formatted way."""
    if not patterns:
        print("No cls= patterns found in the code.")
        return
    
    print(f"Found {len(patterns)} cls= patterns:\n")
    
    for i, pattern in enumerate(patterns, 1):
        print(f"Pattern {i} (Line {pattern.line_number}):")
        
        if show_context:
            print(f"  Context: {pattern.context}")
        
        print(f"  Expression: {pattern.full_expression}")
        
        if pattern.uses_combine_classes:
            print(f"  ✓ Uses combine_classes")
        
        if pattern.css_classes:
            print(f"  CSS Classes ({len(pattern.css_classes)}):")
            for cls in pattern.css_classes:
                print(f"    - {cls}")
        else:
            print(f"  CSS Classes: (none)")
        
        print()  # Empty line between patterns

# %% ../../nbs/cli/pattern_scanner.ipynb 27
def get_unique_css_classes(
    patterns: List[ClsPattern]  # List of ClsPattern objects
) -> Set[str]:  # Set of unique CSS class strings
    "Extract all unique CSS classes from a list of patterns."
    unique_classes = set()
    for pattern in patterns:
        unique_classes.update(pattern.css_classes)
    return unique_classes

# %% ../../nbs/cli/pattern_scanner.ipynb 32
import re
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass

# %% ../../nbs/cli/pattern_scanner.ipynb 33
@dataclass
class AssertionPattern:
    """Represents a pattern extracted from a test assertion."""
    css_class: str  # The CSS class string (e.g., "p-4")
    factory_expression: str  # The factory expression (e.g., "p(4)")
    module_name: str  # Module where this was found
    example_name: str  # Test function name

# %% ../../nbs/cli/pattern_scanner.ipynb 34
def get_available_css_classes(
    assertion_patterns: List[AssertionPattern]  # List of assertion patterns from test examples
) -> Set[str]:  # Set of unique CSS class strings available in the library
    "Extract all unique CSS classes from assertion patterns. This handles multi-class assertion strings by splitting them."
    available_classes = set()
    
    for pattern in assertion_patterns:
        # Split multi-class strings and add each class
        css_classes = pattern.css_class.split()
        available_classes.update(css_classes)
    
    return available_classes

# %% ../../nbs/cli/pattern_scanner.ipynb 35
def extract_assertion_patterns(
    source_code: str,  # Source code of the test function
    module_name: str,  # Name of the module containing the test
    example_name: str  # Name of the test function
) -> List[AssertionPattern]:  # List of AssertionPattern objects
    "Extract assertion patterns from test example source code."
    patterns = []
    
    # Split into lines for better processing
    lines = source_code.split('\n')
    
    for line in lines:
        # Skip empty lines and comments
        if not line.strip() or line.strip().startswith('#'):
            continue
            
        # Pattern 1: assert str(factory_expr) == "css-class"
        # Use simple greedy match that works
        match = re.search(r'assert\s+str\s*\(\s*(.+)\s*\)\s*==\s*["\']([^"\']+)["\']', line)
        if match:
            factory_expr = match.group(1).strip()
            css_class = match.group(2).strip()
            
            # Skip if factory_expr contains quotes (it's probably a string literal)
            if '"' not in factory_expr and "'" not in factory_expr:
                patterns.append(AssertionPattern(
                    css_class=css_class,
                    factory_expression=factory_expr,
                    module_name=module_name,
                    example_name=example_name
                ))
                continue
        
        # Pattern 2: assert factory_expr == "css-class" (without str())
        # Only if not already matched by pattern 1
        if 'str(' not in line:
            match = re.search(r'assert\s+(.+?)\s*==\s*["\']([^"\']+)["\']', line)
            if match:
                factory_expr = match.group(1).strip()
                css_class = match.group(2).strip()
                
                # Check if this looks like a factory expression
                if ('"' not in factory_expr and "'" not in factory_expr and 
                    ('(' in factory_expr or '.' in factory_expr)):
                    patterns.append(AssertionPattern(
                        css_class=css_class,
                        factory_expression=factory_expr,
                        module_name=module_name,
                        example_name=example_name
                    ))
    
    return patterns

# %% ../../nbs/cli/pattern_scanner.ipynb 36
def collect_all_assertion_patterns(
) -> List[AssertionPattern]:  # List of AssertionPattern objects from all modules
    "Collect assertion patterns from all test examples in the library."
    from cjm_fasthtml_tailwind.cli.example_discovery import list_all_examples
    
    all_patterns = []
    
    # Get all test examples
    all_examples = list_all_examples()
    
    # Extract patterns from each example
    for module_name, examples in all_examples.items():
        for example in examples:
            patterns = extract_assertion_patterns(
                example.source,
                module_name,
                example.name
            )
            all_patterns.extend(patterns)
    
    return all_patterns

# %% ../../nbs/cli/pattern_scanner.ipynb 44
from enum import Enum

class MatchType(Enum):
    """Type of match found for a CSS class."""
    EXACT = "exact"  # Exact match found in available classes
    PATTERN = "pattern"  # Matches a known pattern (e.g., px-N)
    NO_MATCH = "no_match"  # No match found

@dataclass
class CSSClassMatch:
    """Represents a match result for a CSS class."""
    css_class: str  # The CSS class being matched
    match_type: MatchType  # Type of match found
    matched_pattern: Optional[str] = None  # The pattern it matches (for PATTERN type)
    similar_classes: List[str] = None  # Similar classes found in library
    suggested_replacement: Optional[str] = None  # Suggested replacement from library

# %% ../../nbs/cli/pattern_scanner.ipynb 45
def tokenize_css_class(
    css_class: str  # CSS class string (e.g., "bg-blue-500" or "hover:text-white")
) -> List[str]:  # List of tokens (e.g., ["bg", "blue", "500"] or ["hover:text", "white"])
    "Tokenize a CSS class by splitting on hyphens. Handles modifiers (hover:, focus:, etc.) separately."
    # Handle modifiers (everything before the first colon)
    if ':' in css_class:
        # Split on the last colon to handle multiple modifiers
        parts = css_class.rsplit(':', 1)
        modifier = parts[0] + ':'
        base_class = parts[1]
        
        # Tokenize the base class part
        if base_class.startswith('-'):
            tokens = base_class[1:].split('-')
            if tokens:
                tokens[0] = '-' + tokens[0]
            return [modifier] + tokens
        else:
            return [modifier] + base_class.split('-')
    
    # Handle negative values (leading hyphen)
    if css_class.startswith('-'):
        # Keep the negative sign with the first token
        tokens = css_class[1:].split('-')
        if tokens:
            tokens[0] = '-' + tokens[0]
        return tokens
    else:
        return css_class.split('-')

# %% ../../nbs/cli/pattern_scanner.ipynb 46
def find_pattern_matches(
    css_class: str,  # CSS class to match (e.g., "px-8" or "hover:text-white")
    available_classes: Set[str]  # Set of available CSS classes from the library
) -> Tuple[Optional[str], List[str]]:  # Tuple of (matched_pattern, similar_classes) - matched_pattern: Pattern prefix that matches (e.g., "px" for "px-8") - similar_classes: List of similar classes with the same pattern
    "Find pattern matches for a CSS class by progressively reducing tokens."
    tokens = tokenize_css_class(css_class)
    
    # Extract modifier if present
    modifier = ""
    base_tokens = tokens
    if tokens and tokens[0].endswith(':'):
        modifier = tokens[0]
        base_tokens = tokens[1:] if len(tokens) > 1 else []
    
    # Try progressively shorter patterns
    for i in range(len(base_tokens) - 1, 0, -1):
        # Build pattern prefix
        pattern_prefix = '-'.join(base_tokens[:i])
        
        # Include modifier in the search pattern if present
        if modifier:
            search_pattern = modifier + pattern_prefix + '-'
        else:
            search_pattern = pattern_prefix + '-'
        
        # Find all classes that start with this pattern
        similar_classes = [
            cls for cls in available_classes 
            if cls.startswith(search_pattern) and cls != css_class
        ]
        
        if similar_classes:
            # Return pattern without modifier for display
            return pattern_prefix, similar_classes
    
    return None, []

# %% ../../nbs/cli/pattern_scanner.ipynb 47
def match_css_class(
    css_class: str,  # CSS class to match
    available_classes: Set[str]  # Set of available CSS classes from the library
) -> CSSClassMatch:  # CSSClassMatch object with match details
    "Match a CSS class against available library classes."
    # Check for exact match first
    if css_class in available_classes:
        return CSSClassMatch(
            css_class=css_class,
            match_type=MatchType.EXACT,
            suggested_replacement=css_class
        )
    
    # Try pattern matching
    pattern, similar_classes = find_pattern_matches(css_class, available_classes)
    
    if pattern and similar_classes:
        # Sort similar classes for consistent output
        similar_classes = sorted(similar_classes)[:5]  # Limit to 5 examples
        
        return CSSClassMatch(
            css_class=css_class,
            match_type=MatchType.PATTERN,
            matched_pattern=pattern,
            similar_classes=similar_classes,
            suggested_replacement=None  # Could be enhanced to suggest closest match
        )
    
    # No match found
    return CSSClassMatch(
        css_class=css_class,
        match_type=MatchType.NO_MATCH
    )

# %% ../../nbs/cli/pattern_scanner.ipynb 48
def match_css_classes(
    css_classes: List[str],  # List of CSS classes to match
    available_classes: Set[str]  # Set of available CSS classes from the library
) -> Dict[str, CSSClassMatch]:  # Dictionary mapping CSS classes to their match results
    "Match multiple CSS classes against available library classes."
    matches = {}
    for css_class in css_classes:
        matches[css_class] = match_css_class(css_class, available_classes)
    return matches

# %% ../../nbs/cli/pattern_scanner.ipynb 49
def display_match_results(
    matches: Dict[str, CSSClassMatch]  # Dictionary of CSS classes to their match results
):  # Displays match results to stdout, returns nothing
    """Display match results in a formatted way."""
    # Group by match type
    exact_matches = []
    pattern_matches = []
    no_matches = []
    
    for css_class, match in matches.items():
        if match.match_type == MatchType.EXACT:
            exact_matches.append(css_class)
        elif match.match_type == MatchType.PATTERN:
            pattern_matches.append((css_class, match))
        else:
            no_matches.append(css_class)
    
    # Display results
    print("CSS Class Analysis Results:")
    print("=" * 60)
    
    if exact_matches:
        print(f"\n✓ Exact Matches ({len(exact_matches)}):")
        for cls in sorted(exact_matches):
            print(f"  - {cls}")
    
    if pattern_matches:
        print(f"\n~ Pattern Matches ({len(pattern_matches)}):")
        for cls, match in sorted(pattern_matches):
            print(f"  - {cls} → matches pattern '{match.matched_pattern}-*'")
            if match.similar_classes:
                print(f"    Examples: {', '.join(match.similar_classes[:3])}")
    
    if no_matches:
        print(f"\n✗ No Matches ({len(no_matches)}):")
        for cls in sorted(no_matches):
            print(f"  - {cls}")
    
    # Summary
    total = len(matches)
    replaceable = len(exact_matches) + len(pattern_matches)
    print(f"\nSummary: {replaceable}/{total} classes are potentially replaceable")

# %% ../../nbs/cli/pattern_scanner.ipynb 50
def analyze_code_patterns(
    code: str  # Python source code to analyze
) -> Dict[str, Any]:  # Dictionary with analysis results including patterns found and suggestions
    "Analyze Python code for replaceable CSS patterns."
    # Scan for patterns
    patterns = scan_python_code(code)
    
    # Get unique CSS classes
    unique_classes = get_unique_css_classes(patterns)
    
    # Get available classes from library
    assertion_patterns = collect_all_assertion_patterns()
    available_classes = get_available_css_classes(assertion_patterns)
    
    # Match CSS classes
    matches = match_css_classes(list(unique_classes), available_classes)
    
    # Prepare results
    results = {
        'total_patterns': len(patterns),
        'unique_classes': len(unique_classes),
        'matches': matches,
        'summary': {
            'exact_matches': sum(1 for m in matches.values() if m.match_type == MatchType.EXACT),
            'pattern_matches': sum(1 for m in matches.values() if m.match_type == MatchType.PATTERN),
            'no_matches': sum(1 for m in matches.values() if m.match_type == MatchType.NO_MATCH),
        },
        'patterns': patterns
    }
    
    return results

# %% ../../nbs/cli/pattern_scanner.ipynb 51
def display_code_analysis(
    code: str  # Python source code to analyze
):  # Displays analysis report to stdout, returns nothing
    """Analyze and display replaceable patterns in Python code."""
    results = analyze_code_patterns(code)
    
    print("Code Analysis Report")
    print("=" * 60)
    print(f"Total cls= patterns found: {results['total_patterns']}")
    print(f"Unique CSS classes: {results['unique_classes']}")
    print()
    
    # Display summary
    summary = results['summary']
    total_replaceable = summary['exact_matches'] + summary['pattern_matches']
    print(f"Replaceable Classes: {total_replaceable}/{results['unique_classes']}")
    print(f"  - Exact matches: {summary['exact_matches']}")
    print(f"  - Pattern matches: {summary['pattern_matches']}")
    print(f"  - No matches: {summary['no_matches']}")
    print()
    
    # Display matches by type
    display_match_results(results['matches'])
    
    # Show patterns with line numbers
    if results['patterns']:
        print("\nPatterns by Line:")
        print("-" * 60)
        for pattern in results['patterns']:
            replaceable = "✓" if pattern.css_classes and any(
                results['matches'].get(cls, CSSClassMatch(cls, MatchType.NO_MATCH)).match_type != MatchType.NO_MATCH 
                for cls in pattern.css_classes
            ) else "✗"
            
            print(f"Line {pattern.line_number}: {replaceable} {pattern.full_expression}")
            if pattern.uses_combine_classes:
                print(f"         ↳ Already uses combine_classes")

# %% ../../nbs/cli/pattern_scanner.ipynb 57
def find_assertion_for_class(
    css_class: str,  # The CSS class to find (e.g., "px-6")
    assertion_patterns: List[AssertionPattern]  # List of all assertion patterns from tests
) -> Optional[AssertionPattern]:  # AssertionPattern if found, None otherwise
    "Find the assertion pattern that demonstrates how to use a specific CSS class. Prioritizes exact single-class matches over multi-class assertions."
    # First pass: look for exact single-class matches
    for pattern in assertion_patterns:
        if pattern.css_class == css_class:
            return pattern
    
    # Second pass: look in multi-class assertions
    for pattern in assertion_patterns:
        assertion_classes = pattern.css_class.split()
        if css_class in assertion_classes and len(assertion_classes) > 1:
            return pattern
    
    return None

# %% ../../nbs/cli/pattern_scanner.ipynb 58
def find_pattern_examples(
    pattern_prefix: str,  # Pattern prefix to match (e.g., "px" for px-* pattern)
    assertion_patterns: List[AssertionPattern]  # List of all assertion patterns from tests
) -> List[AssertionPattern]:  # List of AssertionPattern objects that match the pattern
    "Find assertion examples that match a pattern prefix."
    matching_patterns = []
    pattern_with_dash = pattern_prefix + '-'
    
    for pattern in assertion_patterns:
        # Check each class in the assertion
        assertion_classes = pattern.css_class.split()
        for cls in assertion_classes:
            if cls.startswith(pattern_with_dash):
                matching_patterns.append(pattern)
                break  # Only add once per assertion
                
    return matching_patterns

# %% ../../nbs/cli/pattern_scanner.ipynb 59
def get_migration_suggestions(
    matches: Dict[str, CSSClassMatch],  # Dictionary of CSS class matches
    assertion_patterns: List[AssertionPattern],  # List of all assertion patterns from tests
    config: Optional[LibraryConfig] = None  # Optional configuration
) -> Dict[str, List[str]]:  # Dictionary mapping CSS classes to their migration suggestions
    "Generate migration suggestions for matched CSS classes."
    if config is None:
        config = get_active_config()
    
    suggestions = {}
    
    for css_class, match in matches.items():
        class_suggestions = []
        
        if match.match_type == MatchType.EXACT:
            # Find the exact assertion that demonstrates this class
            assertion = find_assertion_for_class(css_class, assertion_patterns)
            if assertion:
                # Extract feature name from example name
                feature = get_example_pattern(assertion.module_name).match(assertion.example_name).group(1)
                suggestion = f"View example: {config.cli_command} example {assertion.module_name} {feature}"
                class_suggestions.append(suggestion)
                
                # Check if the factory expression might be a helper function
                # Helper functions typically have parentheses and might be in the feature name
                if '(' in assertion.factory_expression and ')' in assertion.factory_expression:
                    # Extract potential function name
                    func_name = assertion.factory_expression.split('(')[0].strip()
                    
                    # Check if this might be a helper (not a factory like p.x or w.full)
                    if not ('.' in func_name and len(func_name.split('.')) == 2):
                        # This looks like a helper function
                        helper_suggestion = f"View helper: {config.cli_command} helper {assertion.module_name} {func_name}"
                        class_suggestions.append(helper_suggestion)
                
        elif match.match_type == MatchType.PATTERN:
            # Find examples that demonstrate this pattern
            pattern_assertions = find_pattern_examples(match.matched_pattern, assertion_patterns)
            if pattern_assertions:
                # Use a set to track unique suggestions
                unique_suggestions = set()
                
                # Show up to 3 unique examples
                for assertion in pattern_assertions:
                    feature = get_example_pattern(assertion.module_name).match(assertion.example_name).group(1)
                    suggestion = f"{config.cli_command} example {assertion.module_name} {feature}"
                    unique_suggestions.add(suggestion)
                    
                    # Stop if we have 3 unique suggestions
                    if len(unique_suggestions) >= 3:
                        break
                
                # Convert set back to list with proper formatting
                for i, suggestion in enumerate(sorted(unique_suggestions), 1):
                    class_suggestions.append(f"Pattern example {i}: {suggestion}")
        
        if class_suggestions:
            suggestions[css_class] = class_suggestions
    
    return suggestions

# %% ../../nbs/cli/pattern_scanner.ipynb 60
def display_migration_suggestions(
    code: str  # Python source code to analyze
):  # Displays migration suggestions to stdout, returns nothing
    """Analyze code and display migration suggestions."""
    # Get analysis results
    results = analyze_code_patterns(code)
    
    # Get assertion patterns
    assertion_patterns = collect_all_assertion_patterns()
    
    # Get migration suggestions
    suggestions = get_migration_suggestions(results['matches'], assertion_patterns)
    
    if not suggestions:
        print("No migration suggestions available.")
        return
    
    print("Migration Suggestions")
    print("=" * 60)
    print()
    
    for css_class in sorted(suggestions.keys()):
        match = results['matches'][css_class]
        match_type = "✓" if match.match_type == MatchType.EXACT else "~"
        
        print(f"{match_type} {css_class}:")
        for suggestion in suggestions[css_class]:
            print(f"  → {suggestion}")
        print()

# %% ../../nbs/cli/pattern_scanner.ipynb 61
def analyze_and_suggest(
    code: str  # Python source code to analyze
):  # Displays analysis and migration suggestions to stdout, returns nothing
    """Perform complete analysis of code with migration suggestions."""
    # First show the analysis
    display_code_analysis(code)
    
    # Then show migration suggestions if any replaceable patterns found
    results = analyze_code_patterns(code)
    summary = results['summary']
    
    if summary['exact_matches'] > 0 or summary['pattern_matches'] > 0:
        print("\n")
        display_migration_suggestions(code)

# %% ../../nbs/cli/pattern_scanner.ipynb 80
def scan_python_file(
    file_path: str  # Path to the Python file
) -> List[ClsPattern]:  # List of ClsPattern objects found in the file
    "Scan a Python file for cls= patterns."
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            code = f.read()
        
        return scan_python_code(code)
    
    except FileNotFoundError:
        print(f"Error: File not found: {file_path}")
        return []
    except Exception as e:
        print(f"Error reading file {file_path}: {e}")
        return []

# %% ../../nbs/cli/pattern_scanner.ipynb 81
def scan_jupyter_notebook(
    notebook_path: str  # Path to the Jupyter notebook (.ipynb)
) -> List[ClsPattern]:  # List of ClsPattern objects found in the notebook
    "Scan a Jupyter notebook for cls= patterns."
    try:
        from execnb.nbio import read_nb
        
        # Read the notebook
        nb = read_nb(notebook_path)
        
        all_patterns = []
        
        # Iterate through cells
        for cell in nb.cells:
            # Only process code cells
            if cell.cell_type == 'code':
                # Get the source code from the cell
                source = cell.source
                if isinstance(source, list):
                    source = ''.join(source)
                
                # Skip empty cells
                if not source.strip():
                    continue
                
                # Scan the cell code
                patterns = scan_python_code(source)
                
                # Add cell metadata to help identify location
                for pattern in patterns:
                    # Adjust line numbers to be relative to the cell
                    pattern.context = f"[Cell {cell.idx_}] {pattern.context}"
                
                all_patterns.extend(patterns)
        
        return all_patterns
        
    except ImportError:
        print("Error: execnb not installed. Install with: pip install execnb")
        return []
    except FileNotFoundError:
        print(f"Error: Notebook not found: {notebook_path}")
        return []
    except Exception as e:
        print(f"Error reading notebook {notebook_path}: {e}")
        return []

# %% ../../nbs/cli/pattern_scanner.ipynb 82
import os
from enum import Enum

class InputType(Enum):
    """Type of input being scanned."""
    CODE = "code"  # Direct code string
    PYTHON_FILE = "python_file"  # .py file
    NOTEBOOK = "notebook"  # .ipynb file
    
def detect_input_type(
    input_source: str  # Code string or file path
) -> InputType:  # InputType enum value
    "Detect the type of input based on the source string."
    # Check if it's a file path
    if os.path.exists(input_source):
        if input_source.endswith('.py'):
            return InputType.PYTHON_FILE
        elif input_source.endswith('.ipynb'):
            return InputType.NOTEBOOK
    
    # Check if it looks like a file path (even if file doesn't exist)
    if '/' in input_source or '\\' in input_source or input_source.endswith(('.py', '.ipynb')):
        if input_source.endswith('.py'):
            return InputType.PYTHON_FILE
        elif input_source.endswith('.ipynb'):
            return InputType.NOTEBOOK
    
    # Default to code string
    return InputType.CODE

# %% ../../nbs/cli/pattern_scanner.ipynb 83
def scan_input(
    input_source: str,  # Code string, Python file path, or notebook path
    input_type: Optional[InputType] = None  # Optional explicit input type. If None, will auto-detect.
) -> List[ClsPattern]:  # List of ClsPattern objects found
    "Scan various input types for cls= patterns."
    # Auto-detect input type if not specified
    if input_type is None:
        input_type = detect_input_type(input_source)
    
    # Scan based on input type
    if input_type == InputType.CODE:
        return scan_python_code(input_source)
    elif input_type == InputType.PYTHON_FILE:
        return scan_python_file(input_source)
    elif input_type == InputType.NOTEBOOK:
        return scan_jupyter_notebook(input_source)
    else:
        print(f"Error: Unknown input type: {input_type}")
        return []

# %% ../../nbs/cli/pattern_scanner.ipynb 84
def analyze_input(
    input_source: str,  # Code string, Python file path, or notebook path
    input_type: Optional[InputType] = None  # Optional explicit input type. If None, will auto-detect.
) -> Dict[str, Any]:  # Dictionary with analysis results
    "Analyze any input type for replaceable CSS patterns."
    # Scan for patterns
    patterns = scan_input(input_source, input_type)
    
    # Get unique CSS classes
    unique_classes = get_unique_css_classes(patterns)
    
    # Get available classes from library
    assertion_patterns = collect_all_assertion_patterns()
    available_classes = get_available_css_classes(assertion_patterns)
    
    # Match CSS classes
    matches = match_css_classes(list(unique_classes), available_classes)
    
    # Detect actual input type used
    actual_input_type = input_type or detect_input_type(input_source)
    
    # Prepare results
    results = {
        'input_type': actual_input_type.value,
        'input_source': input_source if actual_input_type == InputType.CODE else os.path.basename(input_source),
        'total_patterns': len(patterns),
        'unique_classes': len(unique_classes),
        'matches': matches,
        'summary': {
            'exact_matches': sum(1 for m in matches.values() if m.match_type == MatchType.EXACT),
            'pattern_matches': sum(1 for m in matches.values() if m.match_type == MatchType.PATTERN),
            'no_matches': sum(1 for m in matches.values() if m.match_type == MatchType.NO_MATCH),
        },
        'patterns': patterns
    }
    
    return results

# %% ../../nbs/cli/pattern_scanner.ipynb 85
def display_input_analysis(
    input_source: str,  # Code string, Python file path, or notebook path
    input_type: Optional[InputType] = None  # Optional explicit input type. If None, will auto-detect.
):  # Displays analysis report to stdout, returns nothing
    """Analyze and display replaceable patterns from any input type."""
    results = analyze_input(input_source, input_type)
    
    print("Pattern Analysis Report")
    print("=" * 60)
    print(f"Input Type: {results['input_type']}")
    print(f"Source: {results['input_source'][:50]}..." if results['input_type'] == 'code' else f"File: {results['input_source']}")
    print(f"Total cls= patterns found: {results['total_patterns']}")
    print(f"Unique CSS classes: {results['unique_classes']}")
    print()
    
    # Display summary
    summary = results['summary']
    total_replaceable = summary['exact_matches'] + summary['pattern_matches']
    print(f"Replaceable Classes: {total_replaceable}/{results['unique_classes']}")
    print(f"  - Exact matches: {summary['exact_matches']}")
    print(f"  - Pattern matches: {summary['pattern_matches']}")
    print(f"  - No matches: {summary['no_matches']}")
    print()
    
    # Display matches by type
    display_match_results(results['matches'])
    
    # Show patterns with line numbers
    if results['patterns']:
        print("\nPatterns by Location:")
        print("-" * 60)
        for pattern in results['patterns']:
            replaceable = "✓" if pattern.css_classes and any(
                results['matches'].get(cls, CSSClassMatch(cls, MatchType.NO_MATCH)).match_type != MatchType.NO_MATCH 
                for cls in pattern.css_classes
            ) else "✗"
            
            print(f"Line {pattern.line_number}: {replaceable} {pattern.full_expression}")
            if pattern.uses_combine_classes:
                print(f"         ↳ Already uses combine_classes")

# %% ../../nbs/cli/pattern_scanner.ipynb 86
def analyze_and_suggest_input(
    input_source: str,  # Code string, Python file path, or notebook path
    input_type: Optional[InputType] = None  # Optional explicit input type. If None, will auto-detect.
):  # Displays analysis and migration suggestions to stdout, returns nothing
    """Perform complete analysis with migration suggestions for any input type."""
    # First show the analysis
    display_input_analysis(input_source, input_type)
    
    # Get analysis results
    results = analyze_input(input_source, input_type)
    summary = results['summary']
    
    if summary['exact_matches'] > 0 or summary['pattern_matches'] > 0:
        print("\n")
        
        # Get assertion patterns for suggestions
        assertion_patterns = collect_all_assertion_patterns()
        
        # Get migration suggestions
        suggestions = get_migration_suggestions(results['matches'], assertion_patterns)
        
        if suggestions:
            print("Migration Suggestions")
            print("=" * 60)
            print()
            
            for css_class in sorted(suggestions.keys()):
                match = results['matches'][css_class]
                match_type = "✓" if match.match_type == MatchType.EXACT else "~"
                
                print(f"{match_type} {css_class}:")
                for suggestion in suggestions[css_class]:
                    print(f"  → {suggestion}")
                print()
