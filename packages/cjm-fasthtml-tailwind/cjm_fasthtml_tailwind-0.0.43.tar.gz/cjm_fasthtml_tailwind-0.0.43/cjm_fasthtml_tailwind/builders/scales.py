"""Numeric and named scale builders for Tailwind CSS utilities"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/builders/scales.ipynb.

# %% auto 0
__all__ = ['NUMERIC_SCALE', 'DECIMAL_SCALE', 'SPACING_SCALE', 'FRACTION_DENOMINATORS', 'FRACTIONS', 'SPACING_CONFIG',
           'SIZE_CONFIG', 'INSET_CONFIG', 'generate_fractions', 'ScaleConfig', 'ScaledUtility', 'ScaledFactory',
           'NegativeFactory', 'DirectionalScaledUtility', 'DirectionalScaledFactory', 'list_scale_values',
           'SimpleFactory', 'enums_to_simple_factory']

# %% ../../nbs/builders/scales.ipynb 3
from enum import Enum
from typing import Dict, List, Union, Optional, Tuple, Callable, Any
from dataclasses import dataclass
from cjm_fasthtml_tailwind.core.base import (
    NamedScale, CONTAINER_SCALES, TailwindScale, 
    BaseUtility, StandardUtility, DirectionalUtility,
    UtilityFactory, is_numeric_scale, BaseFactory, SingleValueUtility
)

# %% ../../nbs/builders/scales.ipynb 5
NUMERIC_SCALE = list(range(97)) # Standard spacing scale (0-96)

DECIMAL_SCALE = [0.5, 1.5, 2.5, 3.5] # Common decimal scales

SPACING_SCALE = sorted(set(NUMERIC_SCALE + DECIMAL_SCALE)) # Extended spacing scale with decimals

FRACTION_DENOMINATORS = [2, 3, 4, 5, 6, 12] # Fraction denominators supported by Tailwind

# %% ../../nbs/builders/scales.ipynb 6
def generate_fractions(
) -> List[str]:  # List of all valid Tailwind fraction strings sorted by value
    """Generate all valid Tailwind fractions."""
    fractions = []
    for denominator in FRACTION_DENOMINATORS:
        for numerator in range(1, denominator):
            fractions.append(f"{numerator}/{denominator}")
    return sorted(set(fractions), key=lambda x: eval(x))  # Sort by actual value

FRACTIONS = generate_fractions() # Pre-generate fractions

# %% ../../nbs/builders/scales.ipynb 8
@dataclass
class ScaleConfig:
    """Configuration for a scale builder."""
    numeric: bool = True  # Support numeric scales (0-96)
    decimals: bool = False  # Support decimal scales (0.5, 1.5, etc.)
    fractions: bool = False  # Support fractions (1/2, 1/3, etc.)
    named: Optional[List[NamedScale]] = None  # Named scales (xs, sm, md, etc.)
    special: Optional[Dict[str, str]] = None  # Special values (auto, full, screen, etc.)
    negative: bool = False  # Support negative values

# %% ../../nbs/builders/scales.ipynb 9
class ScaledUtility(StandardUtility):
    """Utility class with scale support."""
    
    def __init__(
        self, 
        prefix: str,  # The utility prefix (e.g., 'w', 'h', 'p')
        config: ScaleConfig,  # Configuration defining valid scales and values
        negative: bool = False  # Whether this is a negative variant
    ):
        """Initialize with prefix and scale configuration."""
        self.config = config
        self.negative = negative
        full_prefix = f"-{prefix}" if negative else prefix
        super().__init__(full_prefix)
    
    def _format_value(
        self,
        value: TailwindScale  # The value to format (can be numeric, fraction, or string)
    ) -> str:  # The formatted value string with appropriate wrapping
        """
        Format value according to Tailwind conventions with scale awareness:
        - Values with spaces: wrapped in brackets (arbitrary)
        - String numbers not in scale: wrapped in brackets
        - Decimal strings when decimals disabled: wrapped in brackets
        - Otherwise: use standard formatting
        """
        # First check if it's a string containing spaces
        if isinstance(value, str) and ' ' in value:
            return f"[{value}]"
        
        # Check if it's a string that looks like a decimal
        if isinstance(value, str) and '.' in value:
            try:
                float_val = float(value)
                # If decimals are disabled in config, treat decimal strings as arbitrary
                if not self.config.decimals:
                    return f"[{value}]"
                # If decimals are enabled, check if this specific decimal is in DECIMAL_SCALE
                elif float_val not in DECIMAL_SCALE:
                    return f"[{value}]"
            except ValueError:
                # Not a valid float, let parent handle it
                pass
        
        # Check if it's a string number that should be arbitrary
        if isinstance(value, str) and value.isdigit():
            # Check if this number is in the valid numeric scale for this utility
            if self.config.numeric and int(value) in NUMERIC_SCALE:
                # It's a valid numeric scale value, format normally
                return value
            else:
                # It's outside the scale, treat as arbitrary
                return f"[{value}]"
        
        # Otherwise use the standard formatting from parent class
        return super()._format_value(value)
    
    def get_valid_values(
        self
    ) -> List[Union[str, int, float]]:  # List of all valid values for this utility
        """Get all valid values for this utility."""
        values = []
        
        # Add numeric scales
        if self.config.numeric:
            values.extend(NUMERIC_SCALE)
        
        # Add decimal scales
        if self.config.decimals:
            values.extend(DECIMAL_SCALE)
        
        # Add fractions
        if self.config.fractions:
            values.extend(FRACTIONS)
        
        # Add named scales
        if self.config.named:
            values.extend([scale.name for scale in self.config.named])
        
        # Add special values
        if self.config.special:
            values.extend(self.config.special.keys())
        
        return values

# %% ../../nbs/builders/scales.ipynb 11
class ScaledFactory(UtilityFactory[ScaledUtility]):
    """Factory for creating scaled utilities with enhanced attribute access."""
    
    def __new__(
        cls: type,  # Factory class being instantiated
        prefix: Optional[str] = None,  # Utility prefix (e.g., 'w', 'h', 'p')
        config: Optional[ScaleConfig] = None,  # Scale configuration
        doc: Optional[str] = None  # Documentation string
    ):
        """Create a new instance with dynamic properties for tab-completion."""
        # If this is a subclass, just create a normal instance
        # Subclasses will add properties in __init__ if needed
        if cls is not ScaledFactory:
            return object.__new__(cls)
            
        # For direct ScaledFactory instances, create dynamic properties
        if prefix is not None and config is not None:
            # Create a unique subclass for this instance
            class_name = f"ScaledFactory_{prefix}_{id(config)}"
            
            # Create class attributes
            class_attrs = {}
            
            # Add properties for special values
            if config.special:
                for key, value in config.special.items():
                    prop_name = key.replace("-", "_")
                    # Create a property that returns a ScaledUtility instance
                    def make_property(
                        val: str  # CSS value for the property
                    ):
                        """Create property getter for special value."""
                        def getter(self):
                            """Get ScaledUtility instance for special value."""
                            instance = ScaledUtility(self.prefix, self.config)
                            instance._value = val
                            return instance
                        return property(getter)
                    class_attrs[prop_name] = make_property(value)
            
            # Add properties for named scales
            if config.named:
                for named_scale in config.named:
                    prop_name = f"_{named_scale.name}" if named_scale.name[0].isdigit() else named_scale.name
                    prop_name = prop_name.replace("-", "_")
                    # Create a property that returns a ScaledUtility instance
                    def make_property(
                        scale_name: str  # Name of the scale
                    ):
                        """Create property getter for named scale."""
                        def getter(self):
                            """Get ScaledUtility instance for named scale."""
                            instance = ScaledUtility(self.prefix, self.config)
                            instance._value = scale_name
                            return instance
                        return property(getter)
                    class_attrs[prop_name] = make_property(named_scale.name)
            
            # Create the dynamic subclass
            DynamicFactory = type(class_name, (ScaledFactory,), class_attrs)
            
            # Create and return an instance of the dynamic class
            instance = object.__new__(DynamicFactory)
            return instance
        
        # Default case
        return object.__new__(cls)
    
    def _add_dynamic_properties(self):
        """Add properties dynamically to the instance for tab-completion."""
        if not hasattr(self, 'config') or not self.config:
            return
            
        # Create a new class that inherits from the current class
        current_class = self.__class__
        class_name = f"{current_class.__name__}_Dynamic_{id(self.config)}"
        
        # Create class attributes
        class_attrs = {}
        
        # Copy existing class attributes
        for attr_name in dir(current_class):
            if not attr_name.startswith('_'):
                attr = getattr(current_class, attr_name)
                if not callable(attr) or isinstance(attr, property):
                    class_attrs[attr_name] = attr
        
        # Add properties for special values
        if self.config.special:
            for key, value in self.config.special.items():
                prop_name = key.replace("-", "_")
                # Skip if property already exists
                if hasattr(current_class, prop_name):
                    continue
                    
                # Create a property that returns a ScaledUtility instance
                def make_property(
                    val: str  # CSS value for the property
                ):
                    """Create property getter for special value."""
                    def getter(self):
                        """Get ScaledUtility instance for special value."""
                        instance = ScaledUtility(self.prefix, self.config)
                        instance._value = val
                        return instance
                    return property(getter)
                class_attrs[prop_name] = make_property(value)
        
        # Add properties for named scales
        if self.config.named:
            for named_scale in self.config.named:
                prop_name = f"_{named_scale.name}" if named_scale.name[0].isdigit() else named_scale.name
                prop_name = prop_name.replace("-", "_")
                # Skip if property already exists
                if hasattr(current_class, prop_name):
                    continue
                    
                # Create a property that returns a ScaledUtility instance
                def make_property(
                    scale_name: str  # Name of the scale
                ):
                    """Create property getter for named scale."""
                    def getter(self):
                        """Get ScaledUtility instance for named scale."""
                        instance = ScaledUtility(self.prefix, self.config)
                        instance._value = scale_name
                        return instance
                    return property(getter)
                class_attrs[prop_name] = make_property(named_scale.name)
        
        # Create the dynamic subclass
        DynamicClass = type(class_name, (current_class,), class_attrs)
        
        # Change the instance's class to the dynamic one
        self.__class__ = DynamicClass
    
    def __init__(
        self, 
        prefix: Optional[str] = None,  # The utility prefix (e.g., 'w', 'h', 'p')
        config: Optional[ScaleConfig] = None,  # Configuration defining valid scales and values
        doc: Optional[str] = None  # Optional documentation string
    ):
        """Initialize with prefix and scale configuration."""
        # Handle subclasses that might not pass all arguments
        if prefix is None:
            # Subclass must set these in its __init__
            return
            
        self.config = config
        super().__init__(ScaledUtility, prefix, doc)
        
        # Add dynamic properties if this is a subclass or properties weren't added in __new__
        if (self.__class__.__name__ == 'ScaledFactory' or 
            not any(isinstance(getattr(self.__class__, attr, None), property) 
                  for attr in dir(self.__class__) if not attr.startswith('_'))):
            self._add_dynamic_properties()
    
    def __call__(
        self, 
        value: Optional[TailwindScale] = None,  # The value to apply to the utility
        negative: bool = False  # Whether to create a negative variant
    ) -> ScaledUtility:  # A new scaled utility instance
        """Create a utility instance with optional value."""
        instance = ScaledUtility(self.prefix, self.config, negative)
        if value is not None:
            instance._value = instance._format_value(value)
        return instance
    
    def __getattr__(
        self,
        name: str  # The attribute name to convert to a utility value
    ) -> ScaledUtility:  # A new scaled utility instance with the attribute as value
        """
        Handle attribute access for named values.
        Examples: w.full, h.screen, p.auto, w._2xl
        """
        # Avoid recursion by checking if essential attributes exist
        if name in ['prefix', 'config']:
            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")
            
        # Handle negative prefix
        if name.startswith("neg_"):
            actual_name = name[4:]  # Remove "neg_" prefix
            # Handle leading underscore for negative values too
            if actual_name.startswith("_") and len(actual_name) > 1:
                actual_name = actual_name[1:]
            instance = ScaledUtility(self.prefix, self.config, negative=True)
            instance._value = actual_name.replace("_", "-")
            return instance
        
        # Handle leading underscore (for values that start with numbers)
        if name.startswith("_") and len(name) > 1:
            # Remove the leading underscore
            actual_name = name[1:]
        else:
            actual_name = name
        
        # Regular attribute access
        instance = ScaledUtility(self.prefix, self.config)
        instance._value = actual_name.replace("_", "-")
        return instance
    
    @property
    def negative(
        self
    ) -> 'NegativeFactory':  # A factory for creating negative variants
        """Return a negative variant factory."""
        return NegativeFactory(self.prefix, self.config)
    
    def get_info(
        self
    ) -> Dict[str, Any]:  # Dictionary with factory information
        """Get detailed information about this scaled factory."""
        valid_inputs = []
        
        if self.config.numeric:
            valid_inputs.append(f"Numeric scales: 0-{max(NUMERIC_SCALE)}")
        
        if self.config.decimals:
            valid_inputs.append(f"Decimal scales: {', '.join(str(d) for d in DECIMAL_SCALE)}")
        
        if self.config.fractions:
            valid_inputs.append(f"Fractions: {len(FRACTIONS)} supported (e.g., 1/2, 2/3, 3/4)")
        
        if self.config.named:
            named_values = [scale.name for scale in self.config.named]
            valid_inputs.append(f"Named scales: {', '.join(named_values)}")
        
        if self.config.special:
            valid_inputs.append(f"Special values: {', '.join(self.config.special.keys())}")
        
        valid_inputs.append("Arbitrary values: Any string with CSS units (e.g., '10px', '2.5rem')")
        valid_inputs.append("Custom properties: CSS variables starting with -- (e.g., '--spacing')")
        
        options = {
            'prefix': self.prefix,
            'supports_negative': self.config.negative
        }
        
        if self.config.negative:
            options['negative_access'] = 'Use .negative property or negative=True parameter'
        
        return {
            'description': self._doc,
            'valid_inputs': valid_inputs,
            'options': options
        }

# %% ../../nbs/builders/scales.ipynb 12
class NegativeFactory:
    """Factory for creating negative variants."""
    
    def __new__(
        cls: type,  # Factory class being instantiated
        prefix: str,  # Utility prefix (e.g., 'm', 'inset')
        config: ScaleConfig  # Scale configuration
    ):
        """Create a new instance with dynamic properties for tab-completion."""
        # Create a unique subclass for this instance
        class_name = f"NegativeFactory_{prefix}_{id(config)}"
        
        # Create class attributes
        class_attrs = {}
        
        # Add properties for special values
        if config.special:
            for key, value in config.special.items():
                # Skip 'auto' for negative values as it doesn't make sense
                if key == 'auto':
                    continue
                prop_name = key.replace("-", "_")
                # Create a property that returns a negative ScaledUtility instance
                def make_property(
                    val: str  # CSS value for the property
                ):
                    """Create property getter for negative special value."""
                    def getter(self):
                        """Get negative ScaledUtility instance for special value."""
                        instance = ScaledUtility(self.prefix, self.config, negative=True)
                        instance._value = val
                        return instance
                    return property(getter)
                class_attrs[prop_name] = make_property(value)
        
        # Create the dynamic subclass
        DynamicFactory = type(class_name, (NegativeFactory,), class_attrs)
        
        # Create and return an instance of the dynamic class
        instance = object.__new__(DynamicFactory)
        return instance
    
    def __init__(
        self,
        prefix: str,  # The utility prefix (e.g., 'm', 'inset')
        config: ScaleConfig  # Configuration defining valid scales and values
    ):
        """Initialize with prefix and scale configuration."""
        self.prefix = prefix
        self.config = config
    
    def __call__(
        self,
        value: TailwindScale  # The value to apply to the negative utility
    ) -> ScaledUtility:  # A new negative scaled utility instance
        """Create a negative utility instance."""
        instance = ScaledUtility(self.prefix, self.config, negative=True)
        instance._value = instance._format_value(value)
        return instance
    
    def __getattr__(
        self,
        name: str  # The attribute name to convert to a negative utility value
    ) -> ScaledUtility:  # A new negative scaled utility instance
        """Handle attribute access for negative named values."""
        instance = ScaledUtility(self.prefix, self.config, negative=True)
        instance._value = name.replace("_", "-")
        return instance

# %% ../../nbs/builders/scales.ipynb 14
class DirectionalScaledUtility(DirectionalUtility):
    """Directional utility with scale support."""
    
    def __init__(
        self, 
        prefix: str,  # The base utility prefix (e.g., 'p' for padding)
        direction: Optional[str],  # The direction suffix ('t', 'r', 'b', 'l', 'x', 'y')
        config: ScaleConfig,  # Configuration defining valid scales and values
        negative: bool = False  # Whether this is a negative variant
    ):
        """Initialize with prefix, direction, and scale configuration."""
        self.config = config
        self.negative = negative
        # Apply negative prefix before direction
        base_prefix = f"-{prefix}" if negative else prefix
        super().__init__(base_prefix, direction)

# %% ../../nbs/builders/scales.ipynb 15
class DirectionalScaledFactory(BaseFactory):
    """Factory for creating directional scaled utilities."""
    
    def __init__(
        self, 
        prefix: str,  # The base utility prefix (e.g., 'p' for padding, 'm' for margin)
        config: ScaleConfig,  # Configuration defining valid scales and values
        doc: Optional[str] = None  # Optional documentation string
    ):
        """Initialize with prefix and scale configuration."""
        doc = doc or f"Factory for {prefix} utilities with directional variants"
        super().__init__(doc)
        self.prefix = prefix
        self.config = config
        
        # Create direction-specific factories
        self.t = ScaledFactory(f"{prefix}t", config, f"Top {prefix} utilities")  # top
        self.r = ScaledFactory(f"{prefix}r", config, f"Right {prefix} utilities")  # right
        self.b = ScaledFactory(f"{prefix}b", config, f"Bottom {prefix} utilities")  # bottom
        self.l = ScaledFactory(f"{prefix}l", config, f"Left {prefix} utilities")  # left
        self.x = ScaledFactory(f"{prefix}x", config, f"Horizontal {prefix} utilities")  # horizontal
        self.y = ScaledFactory(f"{prefix}y", config, f"Vertical {prefix} utilities")  # vertical
    
    def __call__(
        self, 
        value: Optional[TailwindScale] = None,  # The value to apply to all directions
        negative: bool = False  # Whether to create a negative variant
    ) -> ScaledUtility:  # A new scaled utility for all directions
        """Create a utility instance for all directions."""
        return ScaledFactory(self.prefix, self.config, f"All sides {self.prefix} utilities")(value, negative)
    
    def __getattr__(
        self,
        name: str  # The attribute name to convert to a utility value
    ) -> ScaledUtility:  # A new scaled utility instance
        """Handle attribute access for named values."""
        return ScaledFactory(self.prefix, self.config).__getattr__(name)
    
    @property
    def negative(
        self
    ) -> 'NegativeFactory':  # A factory for creating negative variants
        """Return a negative variant factory."""
        return NegativeFactory(self.prefix, self.config)
    
    def get_info(
        self
    ) -> Dict[str, Any]:  # Dictionary with factory information
        """Get detailed information about this directional factory."""
        # Get valid inputs from the config (same as ScaledFactory)
        valid_inputs = []
        
        if self.config.numeric:
            valid_inputs.append(f"Numeric scales: 0-{max(NUMERIC_SCALE)}")
        
        if self.config.decimals:
            valid_inputs.append(f"Decimal scales: {', '.join(str(d) for d in DECIMAL_SCALE)}")
        
        if self.config.fractions:
            valid_inputs.append(f"Fractions: {len(FRACTIONS)} supported (e.g., 1/2, 2/3, 3/4)")
        
        if self.config.named:
            named_values = [scale.name for scale in self.config.named]
            valid_inputs.append(f"Named scales: {', '.join(named_values)}")
        
        if self.config.special:
            valid_inputs.append(f"Special values: {', '.join(self.config.special.keys())}")
        
        valid_inputs.append("Arbitrary values: Any string with CSS units (e.g., '10px', '2.5rem')")
        valid_inputs.append("Custom properties: CSS variables starting with -- (e.g., '--spacing')")
        
        options = {
            'prefix': self.prefix,
            'supports_negative': self.config.negative,
            'directional_variants': {
                't': 'top',
                'r': 'right', 
                'b': 'bottom',
                'l': 'left',
                'x': 'horizontal (left and right)',
                'y': 'vertical (top and bottom)'
            }
        }
        
        if self.config.negative:
            options['negative_access'] = 'Use .negative property or negative=True parameter'
        
        return {
            'description': self._doc,
            'valid_inputs': valid_inputs,
            'options': options
        }

# %% ../../nbs/builders/scales.ipynb 17
SPACING_CONFIG = ScaleConfig( # Spacing configuration (padding, margin, gap)
    numeric=True,
    decimals=True,
    fractions=False,
    named=None,
    special={"px": "px", "auto": "auto"},
    negative=True
)

SIZE_CONFIG = ScaleConfig( # Size configuration (width, height)
    numeric=True,
    decimals=True,
    fractions=True,
    named=CONTAINER_SCALES,
    special={
        "auto": "auto",
        "px": "px", 
        "full": "full",
        "screen": "screen",
        "svw": "svw",
        "svh": "svh",
        "lvw": "lvw", 
        "lvh": "lvh",
        "dvw": "dvw",
        "dvh": "dvh",
        "min": "min",
        "max": "max",
        "fit": "fit",
        "lh": "lh"  # line-height unit for height
    },
    negative=False
)

INSET_CONFIG = ScaleConfig( # Inset configuration (top, right, bottom, left)
    numeric=True,
    decimals=True,
    fractions=True,
    named=None,
    special={
        "auto": "auto",
        "px": "px",
        "full": "full"
    },
    negative=True
)

# %% ../../nbs/builders/scales.ipynb 40
def list_scale_values(
    config: ScaleConfig  # The scale configuration to extract values from
) -> Dict[str, List[Union[str, int, float]]]:  # Dictionary mapping scale types to their values
    """List all possible values for a scale configuration."""
    values = {
        "numeric": [],
        "decimals": [],
        "fractions": [],
        "named": [],
        "special": []
    }
    
    if config.numeric:
        values["numeric"] = NUMERIC_SCALE
    
    if config.decimals:
        values["decimals"] = DECIMAL_SCALE
    
    if config.fractions:
        values["fractions"] = FRACTIONS
    
    if config.named:
        values["named"] = [scale.name for scale in config.named]
    
    if config.special:
        values["special"] = list(config.special.keys())
    
    return values

# %% ../../nbs/builders/scales.ipynb 43
class SimpleFactory(BaseFactory):
    """Factory for utilities that are simple string values with modifier support."""
    
    def __new__(
        cls: type,  # Factory class being instantiated
        values_dict: Optional[Dict[str, str]] = None,  # Mapping of attribute names to CSS values
        doc: Optional[str] = None  # Documentation string
    ):
        """Create a new instance with dynamic properties for tab-completion."""
        # If this is a subclass calling super().__new__, just create the instance normally
        # We'll add properties later in __init__
        if cls is not SimpleFactory:
            return object.__new__(cls)
            
        # For direct SimpleFactory instances with values_dict provided
        if values_dict is not None:
            # Create a unique subclass for this instance to avoid conflicts
            class_name = f"SimpleFactory_{id(values_dict)}"
            
            # Create class attributes for each value
            class_attrs = {}
            
            # Add properties for each value
            for key, css_value in values_dict.items():
                prop_name = key.replace("-", "_")
                
                # Create a property that returns the cached utility
                def make_property(
                    css_val: str  # CSS value for the property
                ):
                    """Create property getter for CSS value."""
                    def getter(self):
                        """Get SingleValueUtility instance for CSS value."""
                        # Access the cache directly from __dict__ to avoid triggering __getattr__
                        cache = self.__dict__.get('_utility_cache', {})
                        if css_val not in cache:
                            from cjm_fasthtml_tailwind.core.base import SingleValueUtility
                            cache[css_val] = SingleValueUtility(css_val)
                            if '_utility_cache' not in self.__dict__:
                                self.__dict__['_utility_cache'] = cache
                        return cache[css_val]
                    return property(getter)
                
                class_attrs[prop_name] = make_property(css_value)
            
            # Create the dynamic subclass
            DynamicFactory = type(class_name, (SimpleFactory,), class_attrs)
            
            # Create and return an instance of the dynamic class
            instance = object.__new__(DynamicFactory)
            return instance
        
        # Default case
        return object.__new__(cls)
    
    def _add_dynamic_properties(
        self,
        values_dict: Dict[str, str]  # Mapping of attribute names to CSS values
    ):
        """Add properties dynamically to the instance for tab-completion."""
        # Create a new class that inherits from the current class
        current_class = self.__class__
        class_name = f"{current_class.__name__}_Dynamic_{id(values_dict)}"
        
        # Create class attributes for each value
        class_attrs = {}
        
        # Copy existing class attributes
        for attr_name in dir(current_class):
            if not attr_name.startswith('_'):
                attr = getattr(current_class, attr_name)
                if not callable(attr) or isinstance(attr, property):
                    class_attrs[attr_name] = attr
        
        # Add new properties for each value
        for key, css_value in values_dict.items():
            prop_name = key.replace("-", "_")
            
            # Skip if property already exists
            if hasattr(current_class, prop_name):
                continue
                
            # Create a property that returns the cached utility
            def make_property(
                css_val: str  # CSS value for the property
            ):
                """Create property getter for CSS value."""
                def getter(self):
                    """Get SingleValueUtility instance for CSS value."""
                    # Access the cache directly from __dict__ to avoid triggering __getattr__
                    cache = self.__dict__.get('_utility_cache', {})
                    if css_val not in cache:
                        from cjm_fasthtml_tailwind.core.base import SingleValueUtility
                        cache[css_val] = SingleValueUtility(css_val)
                        if '_utility_cache' not in self.__dict__:
                            self.__dict__['_utility_cache'] = cache
                    return cache[css_val]
                return property(getter)
            
            class_attrs[prop_name] = make_property(css_value)
        
        # Create the dynamic subclass
        DynamicClass = type(class_name, (current_class,), class_attrs)
        
        # Change the instance's class to the dynamic one
        self.__class__ = DynamicClass
    
    def __init__(
        self,
        values_dict: Optional[Dict[str, str]] = None,  # Dictionary mapping attribute names to CSS values
        doc: Optional[str] = None  # Optional documentation string
    ):
        """Initialize with a dictionary of values."""
        doc = doc or "Factory for simple utility values"
        super().__init__(doc)
        
        # Initialize with empty dict if not provided
        self._values = values_dict or {}
        # Cache utility instances for each value
        self._utility_cache = {}
        
        # Add dynamic properties if we have values and this is a subclass
        # or if this is a direct instance that didn't get properties in __new__
        if self._values and (self.__class__.__name__ == 'SimpleFactory' or 
                           not any(isinstance(getattr(self.__class__, attr, None), property) 
                                 for attr in dir(self.__class__))):
            self._add_dynamic_properties(self._values)
    
    def __getattr__(
        self,
        name: str  # The attribute name to look up
    ) -> Union[SingleValueUtility, Any]:  # A SingleValueUtility instance or attribute
        """Get utility instance by attribute name, converting underscores to hyphens."""
        # Handle underscore to hyphen conversion for multi-word values
        key = name.replace("_", "-")
        css_value = None
        
        if key in self._values:
            css_value = self._values[key]
        elif name in self._values:
            css_value = self._values[name]
        
        if css_value is not None:
            # Return cached utility instance or create new one
            if css_value not in self._utility_cache:
                from cjm_fasthtml_tailwind.core.base import SingleValueUtility
                self._utility_cache[css_value] = SingleValueUtility(css_value)
            return self._utility_cache[css_value]
        
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")
    
    def get_info(
        self
    ) -> Dict[str, Any]:  # Dictionary with factory information
        """Get information about this simple factory."""
        return {
            'description': self._doc,
            'valid_inputs': 'No inputs - access values as attributes with modifier support',
            'options': {
                'available_values': list(self._values.keys()),
                'supports_modifiers': True
            }
        }

# %% ../../nbs/builders/scales.ipynb 47
def enums_to_simple_factory(prefix:str, # The factory prefix
                            src_enums:List[Enum], # The source enums
                            doc:Optional[str]=None # The factory docstring.
                           ) -> SimpleFactory: # The resulting simple factory
    """Create a SimpleFactory using a string prefix and the values from a list of enums"""
    values_dict = {
        member.value: f"{prefix}-{member.value}" 
        for src_enum in src_enums 
        for member in src_enum 
    }
    return SimpleFactory(values_dict, doc)
