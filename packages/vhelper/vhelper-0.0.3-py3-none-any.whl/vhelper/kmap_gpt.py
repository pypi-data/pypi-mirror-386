"""
Generated by ChatGPT
"""

# from itertools import combinations


from sympy.logic.boolalg import simplify_logic, to_dnf


from sympy.parsing.sympy_parser import parse_expr
from sympy import symbols


def gray_order():
    return ["00", "01", "11", "10"]


def get_minterms_from_matrix(matrix):
    rows = gray_order()  # AB
    cols = gray_order()  # CD
    minterms = []
    for i in range(4):
        for j in range(4):
            if matrix[i][j] == 1:
                ab = rows[i]
                cd = cols[j]
                bin_str = ab + cd  # A B C D
                minterm = int(bin_str, 2)
                minterms.append(minterm)
    return minterms


def combine_terms(term1, term2):
    diff = 0
    res = []
    for a, b in zip(term1, term2):
        if a != b:
            diff += 1
            res.append("-")
        else:
            res.append(a)
    return "".join(res) if diff == 1 else None


def get_prime_implicants(minterms, num_vars):
    terms = [format(m, f"0{num_vars}b") for m in minterms]
    unchecked = set(terms)
    checked = set()
    prime_implicants = set()

    while unchecked:
        next_round = set()
        used = set()
        for t1, t2 in combinations(unchecked, 2):
            combined = combine_terms(t1, t2)
            if combined:
                used.add(t1)
                used.add(t2)
                next_round.add(combined)
        prime_implicants.update(unchecked - used)
        unchecked = next_round
    return prime_implicants


def term_covers(term, minterm):
    return all(tc == mc or tc == "-" for tc, mc in zip(term, minterm))


def get_essential_prime_implicants(prime_implicants, minterms, num_vars):
    table = {m: [] for m in minterms}
    for pi in prime_implicants:
        for m in minterms:
            if term_covers(pi, format(m, f"0{num_vars}b")):
                table[m].append(pi)
    essential = set()
    for m, pis in table.items():
        if len(pis) == 1:
            essential.add(pis[0])
    return essential


def term_to_expr(term, variables):
    result = ""
    for i, ch in enumerate(term):
        if ch == "1":
            result += variables[i]
        elif ch == "0":
            result += variables[i] + "'"
    return result


def kmap_matrix_to_expression(matrix, variables):
    """错误"""
    minterms = get_minterms_from_matrix(matrix)
    num_vars = len(variables)
    if len(minterms) == 0:
        return "0"
    if len(minterms) == 2**num_vars:
        return "1"
    prime_implicants = get_prime_implicants(minterms, num_vars)
    essentials = get_essential_prime_implicants(prime_implicants, minterms, num_vars)
    return " + ".join(term_to_expr(e, variables) for e in sorted(essentials))


def kmap_matrix_to_expression2(matrix, variables):
    """
    将kmap转换为函数表达式
    :return: 函数表达式
    :param kmap_matrix: kmap矩阵
    :param variables: 变量列表

    版本正确"""
    minterms = get_minterms_from_matrix(matrix)
    num_vars = len(variables)
    if len(minterms) == 0:
        return "0"
    if len(minterms) == 2**num_vars:
        return "1"

    # 获取所有 prime implicants
    prime_implicants = get_prime_implicants(minterms, num_vars)

    # 建立覆盖表
    table = {m: [] for m in minterms}
    for pi in prime_implicants:
        for m in minterms:
            if term_covers(pi, format(m, f"0{num_vars}b")):
                table[m].append(pi)

    # 贪心覆盖所有 minterm
    covered = set()
    selected = set()
    while len(covered) < len(minterms):
        best = max(
            prime_implicants,
            key=lambda pi: len(
                [m for m in minterms if m not in covered and term_covers(pi, format(m, f"0{num_vars}b"))]
            ),
        )
        selected.add(best)
        for m in minterms:
            if term_covers(best, format(m, f"0{num_vars}b")):
                covered.add(m)
        prime_implicants.remove(best)

    return " + ".join(term_to_expr(e, variables) for e in sorted(selected))


def apply_overline(expr):
    result = ""
    i = 0
    while i < len(expr):
        if i + 1 < len(expr) and expr[i + 1] == "'":
            result += overline(expr[i])
            i += 2  # skip the '
        else:
            result += expr[i]
            i += 1
    return result


def overline(char):
    return char + "\u0305"  # combining overline


# def parse_expr(expr_str):
#     from sympy import symbols, Not, And, Or, simplify_logic

#     expr_str = expr_str.replace(" ", "")  # 去空格
#     tokens = expr_str.split("+")  # 拆成每项
#     parsed_terms = []

#     for term in tokens:
#         factors = []
#         i = 0
#         while i < len(term):
#             var = term[i]
#             if i + 1 < len(term) and term[i + 1] == "'":
#                 factors.append(Not(symbols(var)))
#                 i += 2
#             else:
#                 factors.append(symbols(var))
#                 i += 1
#         parsed_terms.append(And(*factors))
#     return Or(*parsed_terms)


def compare_boolean_expressions(expr_str1, expr_str2):
    from sympy import symbols, Not, And, Or, simplify_logic

    expr1 = parse_expr(expr_str1)
    expr2 = parse_expr(expr_str2)

    # 检查逻辑等价：XOR 之后为 False 表示等价
    equivalent = simplify_logic(expr1 ^ expr2) == False
    return equivalent


if __name__ == "__main__":

    # 测试让gpt写的转换对不对，很呆，正确实现方法很简单，就是便利每一个1，然后化简
    kmap_matrix = [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 0]]

    expr1 = kmap_matrix_to_expression(kmap_matrix, ["A", "B", "C", "D"])
    expr2 = kmap_matrix_to_expression2(kmap_matrix, ["A", "B", "C", "D"])
    print(expr1)
    print(expr2)
    # expr1 = "B'C' + A'BC + AC' + AB'D"
    # expr2 = "B'C' + BCD' + A'B'D' + A'BC + AC' + AB'D"
    # expr3 = "AC' + B'C' + AB'D + BCD' + A'BC + A'CD'"
    result = compare_boolean_expressions(expr1, expr2)
    print(result)
