"""
Generated by ChatGPT
"""

# from itertools import combinations


from sympy.logic.boolalg import simplify_logic, to_dnf


from sympy.parsing.sympy_parser import parse_expr
from sympy import symbols

# variables = symbols("a b c d")
# expr_str = "(a & ~b & ~(c ^ d)) | (~a & b & ~c & d)"
# expr = parse_expr(expr_str, local_dict={str(v): v for v in variables})


def is_minimal_boolean(expr_str, variables):
    """
    判断布尔表达式是否为最简表达式
    :param expr_str: 字符串形式的布尔表达式，如 'c & ~d & ~a & b | c & d & ~a & b'
    :param variables: 变量名列表，如 ['a', 'b', 'c', 'd']
    :return: (是否最简, 原表达式项数, 最简表达式项数, 最简表达式字符串)
    """
    # 定义变量

    # 解析表达式
    variables = symbols(" ".join(variables))
    expr = parse_expr(expr_str, local_dict={str(v): v for v in variables})
    # expr = parse_expr(expr_str)

    # 化简
    simplified = simplify_logic(expr, form="dnf")

    # 转为标准析取范式
    expr_dnf = to_dnf(expr, simplify=False)
    simplified_dnf = to_dnf(simplified, simplify=True, force=True)

    # 判断逻辑等价
    is_equivalent = expr_dnf.equals(simplified_dnf)

    # 统计项数
    def count_terms(e):
        if e.func.__name__ == "Or":
            return len(e.args)
        elif e.func.__name__ == "And":
            return 1
        else:
            return 1

    expr_terms = count_terms(expr_dnf)
    simplified_terms = count_terms(simplified_dnf)

    # 是否最简（等价且项数一样）
    is_minimal = is_equivalent and (expr_terms == simplified_terms)

    return is_minimal, expr_terms, simplified_terms, str(simplified_dnf)


def kmap2truth_table(kmap, variables):
    """
    将卡诺图转换为真值表
    :param kmap: 卡诺图，二维列表，如 [[0,0,0,0],[0,0,0,1],...]
    :param variables: 变量名列表，如 ['a', 'b', 'c', 'd']
    :return: 真值表，二维列表，每行对应一个输入组合及其输出
    """
    num_vars = len(variables)
    num_rows = len(kmap)
    num_cols = len(kmap[0]) if num_rows > 0 else 0
    truth_table = []
    for i in range(num_rows):
        for j in range(num_cols):
            row = [int(bit) for bit in f"{i:0{num_vars}b}"] + [kmap[i][j]]
            truth_table.append(row)
    return truth_table


def kmap2expr_str(kmap, variables):
    """
    将卡诺图转换为布尔表达式字符串
    :param kmap: 卡诺图，二维列表，如 [[0,0,0,0],[0,0,0,1],...]
    :param variables: 变量名列表，如 ['a', 'b', 'c', 'd']
    :return: 布尔表达式字符串
    """
    # step1
    truth_table = kmap2truth_table(kmap, variables)
    minterms = []
    for row in truth_table:
        if row[-1] == 1:  # 只考虑输出为1的行
            term_parts = []
            for var, val in zip(variables, row[:-1]):
                if val == 1:
                    term_parts.append(var)
                else:
                    term_parts.append(f"~{var}")
            minterms.append(" & ".join(term_parts))
    expr_str = " | ".join(minterms)
    # step2 化简
    variables = symbols(" ".join(variables))
    expr = parse_expr(expr_str, local_dict={str(v): v for v in variables})
    simplified = simplify_logic(expr, form="dnf")

    # 转为标准析取范式
    # expr_dnf = to_dnf(expr, simplify=False)
    simplified_dnf = to_dnf(simplified, simplify=True, force=True)
    expr_str = str(simplified_dnf)
    return expr_str


if __name__ == "__main__":
    """
    # 最简测试
    # is_minimal_boolean("c & ~d & ~a & b | c & d & ~a & b | c & ~d & a & b | c & ~d & ~a & ~b", ["a", "b", "c", "d"])
    expr_str = "(a & ~b & ~(c ^ d)) | (~a & b & ~c & d)"
    # expr_str = "c & ~d & ~a & b | c & d & ~a & b | c & ~d & a & b | c & ~d & ~a & ~b"

    variables = ["a", "b", "c", "d"]
    is_min, n1, n2, simp = is_minimal_boolean(expr_str, variables)
    print(f"是否最简: {is_min}")
    print(f"原表达式项数: {n1}")
    print(f"最简表达式项数: {n2}")
    print(f"最简表达式: {simp}")
    """

    kmap = [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 0]]
    kmap = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1], [1, 1, 1, 0]]
    variables = ["a", "b", "c", "d"]
    expr_str = kmap2expr_str(kmap, variables)
    print(expr_str)
