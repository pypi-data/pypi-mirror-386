From 9555c5b22a0018ae721839f21fa2d2c3af66de02 Mon Sep 17 00:00:00 2001
From: Jean-Guillaume Dumas <Jean-Guillaume.Dumas@imag.fr>
Date: Thu, 11 Sep 2025 13:55:27 +0200
Subject: [PATCH] ntl-lzz_px init from generic vector already exist above, this
 one is for Coeff

---
 linbox/ring/ntl/ntl-lzz_px.h |  6 ++---
 linbox/ring/ntl/ntl-zz_p.h   | 14 +++++-----
 tests/test-field.h           | 50 ++++++++++++++++++------------------
 tests/test-ntl-lzz_pex.C     |  6 ++---
 tests/test-ntl-lzz_px.C      | 24 +++++++++++++----
 5 files changed, 56 insertions(+), 44 deletions(-)

diff --git a/linbox/ring/ntl/ntl-lzz_px.h b/linbox/ring/ntl/ntl-lzz_px.h
index 3672f23ca6..f6fa34b245 100644
--- a/linbox/ring/ntl/ntl-lzz_px.h
+++ b/linbox/ring/ntl/ntl-lzz_px.h
@@ -191,13 +191,11 @@ namespace LinBox
 		 * of the vector corresponds to the leading coefficients.  That is,
 		 * v[i] = coefficient of x^i.
 		 */
-		//Element& init( Element& p, const std::vector<Coeff>& v ) const
-      template <class E>
-		Element& init( Element& p, const std::vector<E>& v ) const
+		Element& init( Element& p, const std::vector<Coeff>& v ) const
 		{
 			p = 0;
 			for( long i = 0; i < (long)v.size(); ++i )
-				NTL::SetCoeff( p, i, v[ (size_t) i ] );
+                NTL::SetCoeff( p, i, v[ (size_t) i ] );
 			return p;
 		}
 
diff --git a/linbox/ring/ntl/ntl-zz_p.h b/linbox/ring/ntl/ntl-zz_p.h
index 55dfda621b..c9505b154f 100644
--- a/linbox/ring/ntl/ntl-zz_p.h
+++ b/linbox/ring/ntl/ntl-zz_p.h
@@ -77,7 +77,7 @@ namespace Givaro
 		unsigned char *txt;
 		typedef unsigned char u_char;
 		txt = new u_char[nb + 68];
-		// 			   if (!txt) Error("out of memory");
+		//			   if (!txt) Error("out of memory");
 		BytesFromZZ(txt, iy, nb);
 
 		x = 0;
@@ -159,7 +159,7 @@ namespace LinBox
 		NTL_ZZ_p_Initialiser () { }
 
 	};
-	
+
             // CP: to be changed in to a Givaro::GeneralRingRandIter ?
         template <class Element>
 	class UnparametricRandIter;
@@ -279,7 +279,7 @@ namespace LinBox
 			unsigned char *txt;
 			typedef unsigned char u_char;
 			txt = new u_char[nb + 68];
-			// 			   if (!txt) Error("out of memory");
+			//			   if (!txt) Error("out of memory");
 			BytesFromZZ(txt, iy, nb);
 
 			x = 0;
@@ -345,7 +345,7 @@ namespace LinBox
 			std::stringstream s;
 			s << Element::modulus();
 			s >> c;
-			return c; 
+			return c;
 			//return c = static_cast<integer>(to_long(Element::modulus()));
 		}
 
@@ -357,7 +357,7 @@ namespace LinBox
 		integer characteristic() const
 		{
 			integer c;
-			return characteristic(c); 
+			return characteristic(c);
 		}
 
 		/** Multiplicative Inverse.
@@ -460,7 +460,7 @@ namespace LinBox
 		 */
 		std::ostream &write (std::ostream &os, const Element &x) const
 		{
-		   	return Givaro::UnparametricOperations<Element>::write(os,x);
+			return Givaro::UnparametricOperations<Element>::write(os,x);
 		}
 	};
 
@@ -506,7 +506,7 @@ namespace LinBox
 		}
 
         const NTL_ZZ_p& ring() const { return _ring; }
-                
+
 
 		// UnparametricRandIter<NTL::ZZ_p>(const NTL_ZZ_p& R) :
 			// _size(R._size), _seed(R._seed)
diff --git a/tests/test-field.h b/tests/test-field.h
index ae5b79be07..ee62579586 100644
--- a/tests/test-field.h
+++ b/tests/test-field.h
@@ -136,7 +136,7 @@ bool testRing (Ring &F, const char *title, bool fieldp = true, bool runInitConve
 	typedef typename Ring::Element Element;
 	LinBox::integer p, q;
 	F.characteristic(p);
-	
+
 	Element zero, one, mOne, two, mTwo, three, five, six, eight;
 	F.init(zero); F.assign(zero, F.zero);
 	F.init(one); F.assign(one, F.one);
@@ -172,18 +172,18 @@ bool testRing (Ring &F, const char *title, bool fieldp = true, bool runInitConve
 	commentator().start ("\t--Testing correctness of 0 and 1");
 	part_pass = true;
 
-	if ( not F.isZero (zero) or not F.isZero(F.zero) ) 
+	if ( not F.isZero (zero) or not F.isZero(F.zero) )
 		part_pass = reportError( "isZero (0) is false", pass);
-	
-	if ( F.isZero (one) or F.isZero(F.one) ) 
+
+	if ( F.isZero (one) or F.isZero(F.one) )
 		part_pass = reportError( "isZero (1) is true", pass);
-	if ( F.isOne (zero) or F.isOne(F.zero) ) 
+	if ( F.isOne (zero) or F.isOne(F.zero) )
 		part_pass = reportError( "isOne (0) is true", pass);
-	if ( not F.isOne (one) or not F.isOne(F.one) ) 
+	if ( not F.isOne (one) or not F.isOne(F.one) )
 		part_pass = reportError( "isOne (1) is false", pass);
-	if ( not F.isUnit(one) or not F.isUnit(F.one) ) 
+	if ( not F.isUnit(one) or not F.isUnit(F.one) )
 		part_pass = reportError( "isUnit (1) is false", pass);
-	if ( F.isUnit(zero) or F.isUnit(F.zero) ) 
+	if ( F.isUnit(zero) or F.isUnit(F.zero) )
 		part_pass = reportError( "isUnit (0) is true", pass);
 	if ( !F.areEqual(F.mOne,mOne)) {
 		part_pass = reportError( "isMOne (-One) is false", pass);
@@ -205,7 +205,7 @@ bool testRing (Ring &F, const char *title, bool fieldp = true, bool runInitConve
 	commentator().progress ();
 
     if (runInitConvertIdentity) {
-                
+
 	commentator().start ("\t--Testing init/convert");
 	part_pass = true;
 
@@ -235,7 +235,7 @@ bool testRing (Ring &F, const char *title, bool fieldp = true, bool runInitConve
 	commentator().stop (MSG_STATUS (part_pass));
 	commentator().progress ();
         }
-        
+
 	commentator().start ("\t--Testing ring arithmetic");
 	part_pass = true;
 
@@ -349,7 +349,7 @@ bool testField (Field &F, const char *title, bool fieldp = true, bool runInitCon
 
     typename Field::Element a, b, c, d, e, f;
 	F.init(a);F.init(b);F.init(c);F.init(d);F.init(e);F.init(f);
-        
+
 	commentator().start ("\t--Testing field arithmetic");
 	bool part_pass = true;
 
@@ -367,7 +367,7 @@ bool testField (Field &F, const char *title, bool fieldp = true, bool runInitCon
 
 	if (!F.areEqual (a, F.one) || !F.areEqual (d, a))
 		part_pass = reportError( "Results of div incorrect", part_pass);
-	
+
 	commentator().stop (MSG_STATUS (part_pass));
 	commentator().progress ();
 
@@ -375,7 +375,7 @@ bool testField (Field &F, const char *title, bool fieldp = true, bool runInitCon
 	commentator().stop (MSG_STATUS (part_pass), (const char *) 0, "testField");
 
         return part_pass & testRing(F,title,fieldp,runInitConvertIdentity);
-        
+
 }
 
 /** Tests of algebraic properties of rings and fields */
@@ -1243,9 +1243,9 @@ namespace field_subtests {
 
 /* Convenience function to run all of the basic ring tests */
 template <class Ring>
-bool runBasicRingTests (const Ring &F, const char *desc, 
-		unsigned int iterations = 1, 
-		bool runCharacteristicTest = true, 
+bool runBasicRingTests (const Ring &F, const char *desc,
+		unsigned int iterations = 1,
+		bool runCharacteristicTest = true,
 		bool runInitConvertIdentity=true)
 {
 	bool pass = true;
@@ -1291,9 +1291,9 @@ bool runBasicRingTests (const Ring &F, const char *desc,
 
 /* Convenience function to run the tests appropriate to a principal ideal ring such as Z, Z_n, F[x], F[x]/<f> (any n or f, not necessarily prime). */
 template <class Ring>
-bool runPIRTests (const Ring &R, const char *desc, 
-		unsigned int iterations = 1, 
-		bool runCharacteristicTest = true, 
+bool runPIRTests (const Ring &R, const char *desc,
+		unsigned int iterations = 1,
+		bool runCharacteristicTest = true,
 		bool runInitConvertIdentity=true)
 {
 	ostringstream str;
@@ -1305,8 +1305,8 @@ bool runPIRTests (const Ring &R, const char *desc,
 	bool ret =  runBasicRingTests(R, desc, iterations, runCharacteristicTest, runInitConvertIdentity) ;
 	// test gcd, gcd with s,t, and lcm
 	typename Ring::Element a, b, g1, g2, d, s, t, h;
-	R.init(a); R.init(b); R.init(g1); R.init(g2); 
-	R.init(d); R.init(s); R.init(t); R.init(h); 
+	R.init(a); R.init(b); R.init(g1); R.init(g2);
+	R.init(d); R.init(s); R.init(t); R.init(h);
 	typename Ring::RandIter r (R,4);
 	r.random(a); r.random(b);
 	//R.write(std::cout << "a ", a) << std::endl;
@@ -1319,7 +1319,7 @@ bool runPIRTests (const Ring &R, const char *desc,
 	/* specs needed on this
 	if (not R.areEqual(g1, g2))
 		reportError("extended/nonextended gcd inconsistent", ret);
-	if (not ret) {std::cout << "long/short" << std::endl; 
+	if (not ret) {std::cout << "long/short" << std::endl;
 		R.write(std::cout << "g1 ", g1) << std::endl;
 		R.write(std::cout << "g2 ", g2) << std::endl;
 		exit(-1); }
@@ -1461,10 +1461,10 @@ namespace field_subtests {
 }// namespace field_subtests
 
 template <class Field>
-bool runFieldTests (const Field &F, const char *desc, 
-		unsigned int iterations = 1, 
+bool runFieldTests (const Field &F, const char *desc,
+		unsigned int iterations = 1,
 		size_t n = 0, // n is not actually used.
-		bool runCharacteristicTest = true, 
+		bool runCharacteristicTest = true,
 		bool runInitConvertIdentity=true)
 {
 	ostringstream str;
diff --git a/tests/test-ntl-lzz_pex.C b/tests/test-ntl-lzz_pex.C
index d9b436f61b..99dbf456ed 100644
--- a/tests/test-ntl-lzz_pex.C
+++ b/tests/test-ntl-lzz_pex.C
@@ -46,13 +46,13 @@ int main (int argc, char **argv)
 	static int iterations = 1;
 
 	static Argument args[] = {
-   		{ 'q', "-q Q", "Operate over the \"field\" GF(Q) [1].", TYPE_INTEGER, &q },
+		{ 'q', "-q Q", "Operate over the \"field\" GF(Q) [1].", TYPE_INTEGER, &q },
 		{ 'n', "-n N", "Set dimension of test vectors to NxN.", TYPE_INT,     &n },
 		{ 'i', "-i I", "Perform each test for I iterations.", TYPE_INT,     &iterations },
 		END_OF_ARGUMENTS
-   	};
+	};
 
-   	parseArguments (argc, argv, args);
+	parseArguments (argc, argv, args);
 
 	commentator().start("NTL_zz_pEX field test suite", "NTL_zz_pEX");
 	bool pass = true;
diff --git a/tests/test-ntl-lzz_px.C b/tests/test-ntl-lzz_px.C
index 950bf55d34..07d0e78fe9 100644
--- a/tests/test-ntl-lzz_px.C
+++ b/tests/test-ntl-lzz_px.C
@@ -31,7 +31,8 @@
 
 #include <iostream>
 #include <fstream>
-
+#include <string>
+#include <sstream>
 
 #include "linbox/ring/ntl.h"
 
@@ -41,18 +42,18 @@ using namespace LinBox;
 
 int main (int argc, char **argv)
 {
-	static integer q = 3;
+	static integer q = 31;
 	static size_t n = 10000;
 	static int iterations = 1;
 
 	static Argument args[] = {
-   		{ 'q', "-q Q", "Operate over the \"field\" GF(Q) [1].", TYPE_INTEGER, &q },
+		{ 'q', "-q Q", "Operate over the \"field\" GF(Q) [1].", TYPE_INTEGER, &q },
 		{ 'n', "-n N", "Set dimension of test vectors to NxN.", TYPE_INT,     &n },
 		{ 'i', "-i I", "Perform each test for I iterations.", TYPE_INT,     &iterations },
 		END_OF_ARGUMENTS
-   	};
+	};
 
-   	parseArguments (argc, argv, args);
+	parseArguments (argc, argv, args);
 
 	commentator().start("NTL_zz_pX field test suite", "NTL_zz_p");
 	bool pass = true;
@@ -68,6 +69,19 @@ int main (int argc, char **argv)
 
 	if (!runBasicRingTests (R, "NTL_zz_pX", (unsigned int)iterations, false)) pass = false;
 	if (!runPIRTests (R, "NTL_zz_pX", (unsigned int)iterations, false)) pass = false;
+
+	// Test generic i/o
+
+    std::stringstream ss;
+    ss << 3 << ' ' << Givaro::Integer(1) << ' ' << Givaro::Integer(-2)
+       << ' ' << Givaro::Integer(5) << ' ' << Givaro::Integer(-7) << std::endl;
+
+    NTL_zz_pX::Element P;
+
+    R.read(ss, P);
+    R.write(std::clog << "# P: ", P) << std::endl;
+
+
 	// needs PID tests as well...
 
 #if 0
