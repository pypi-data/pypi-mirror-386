# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ActionBatchesActionArgs',
    'ActionBatchesActionArgsDict',
    'ActionBatchesCallbackArgs',
    'ActionBatchesCallbackArgsDict',
    'ActionBatchesCallbackHttpServerArgs',
    'ActionBatchesCallbackHttpServerArgsDict',
    'ActionBatchesCallbackPayloadTemplateArgs',
    'ActionBatchesCallbackPayloadTemplateArgsDict',
    'ActionBatchesStatusArgs',
    'ActionBatchesStatusArgsDict',
    'ActionBatchesStatusCreatedResourceArgs',
    'ActionBatchesStatusCreatedResourceArgsDict',
    'AdaptivePolicyAclsRuleArgs',
    'AdaptivePolicyAclsRuleArgsDict',
    'AdaptivePolicyGroupsPolicyObjectArgs',
    'AdaptivePolicyGroupsPolicyObjectArgsDict',
    'AdaptivePolicyPoliciesAclArgs',
    'AdaptivePolicyPoliciesAclArgsDict',
    'AdaptivePolicyPoliciesDestinationGroupArgs',
    'AdaptivePolicyPoliciesDestinationGroupArgsDict',
    'AdaptivePolicyPoliciesSourceGroupArgs',
    'AdaptivePolicyPoliciesSourceGroupArgsDict',
    'AdminsNetworkArgs',
    'AdminsNetworkArgsDict',
    'AdminsTagArgs',
    'AdminsTagArgsDict',
    'AlertsProfilesAlertConditionArgs',
    'AlertsProfilesAlertConditionArgsDict',
    'AlertsProfilesRecipientsArgs',
    'AlertsProfilesRecipientsArgsDict',
    'ApplianceSecurityIntrusionAllowedRuleArgs',
    'ApplianceSecurityIntrusionAllowedRuleArgsDict',
    'ApplianceVpnThirdPartyVpnpeersPeerArgs',
    'ApplianceVpnThirdPartyVpnpeersPeerArgsDict',
    'ApplianceVpnThirdPartyVpnpeersPeerIpsecPoliciesArgs',
    'ApplianceVpnThirdPartyVpnpeersPeerIpsecPoliciesArgsDict',
    'ApplianceVpnThirdPartyVpnpeersPeersResponseArgs',
    'ApplianceVpnThirdPartyVpnpeersPeersResponseArgsDict',
    'ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPoliciesArgs',
    'ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPoliciesArgsDict',
    'ApplianceVpnVpnFirewallRulesRuleArgs',
    'ApplianceVpnVpnFirewallRulesRuleArgsDict',
    'BrandingPoliciesAdminSettingsArgs',
    'BrandingPoliciesAdminSettingsArgsDict',
    'BrandingPoliciesCustomLogoArgs',
    'BrandingPoliciesCustomLogoArgsDict',
    'BrandingPoliciesCustomLogoImageArgs',
    'BrandingPoliciesCustomLogoImageArgsDict',
    'BrandingPoliciesCustomLogoImagePreviewArgs',
    'BrandingPoliciesCustomLogoImagePreviewArgsDict',
    'BrandingPoliciesHelpSettingsArgs',
    'BrandingPoliciesHelpSettingsArgsDict',
    'CameraCustomAnalyticsArtifactsStatusArgs',
    'CameraCustomAnalyticsArtifactsStatusArgsDict',
    'CameraRolesAppliedOnDeviceArgs',
    'CameraRolesAppliedOnDeviceArgsDict',
    'CameraRolesAppliedOnNetworkArgs',
    'CameraRolesAppliedOnNetworkArgsDict',
    'CameraRolesAppliedOrgWideArgs',
    'CameraRolesAppliedOrgWideArgsDict',
    'ClaimItemArgs',
    'ClaimItemArgsDict',
    'ClaimItemLicenseArgs',
    'ClaimItemLicenseArgsDict',
    'ClaimParametersArgs',
    'ClaimParametersArgsDict',
    'ClaimParametersLicenseArgs',
    'ClaimParametersLicenseArgsDict',
    'CloneItemArgs',
    'CloneItemArgsDict',
    'CloneItemApiArgs',
    'CloneItemApiArgsDict',
    'CloneItemCloudArgs',
    'CloneItemCloudArgsDict',
    'CloneItemCloudRegionArgs',
    'CloneItemCloudRegionArgsDict',
    'CloneItemLicensingArgs',
    'CloneItemLicensingArgsDict',
    'CloneItemManagementArgs',
    'CloneItemManagementArgsDict',
    'CloneItemManagementDetailArgs',
    'CloneItemManagementDetailArgsDict',
    'CloneParametersArgs',
    'CloneParametersArgsDict',
    'ConfigTemplatesSwitchProfilesPortsMirrorArgs',
    'ConfigTemplatesSwitchProfilesPortsMirrorArgsDict',
    'ConfigTemplatesSwitchProfilesPortsModuleArgs',
    'ConfigTemplatesSwitchProfilesPortsModuleArgsDict',
    'ConfigTemplatesSwitchProfilesPortsProfileArgs',
    'ConfigTemplatesSwitchProfilesPortsProfileArgsDict',
    'InventoryClaimItemArgs',
    'InventoryClaimItemArgsDict',
    'InventoryClaimItemLicenseArgs',
    'InventoryClaimItemLicenseArgsDict',
    'InventoryClaimParametersArgs',
    'InventoryClaimParametersArgsDict',
    'InventoryClaimParametersLicenseArgs',
    'InventoryClaimParametersLicenseArgsDict',
    'InventoryOnboardingCloudMonitoringExportEventsParametersArgs',
    'InventoryOnboardingCloudMonitoringExportEventsParametersArgsDict',
    'InventoryOnboardingCloudMonitoringImportsParametersArgs',
    'InventoryOnboardingCloudMonitoringImportsParametersArgsDict',
    'InventoryOnboardingCloudMonitoringImportsParametersDeviceArgs',
    'InventoryOnboardingCloudMonitoringImportsParametersDeviceArgsDict',
    'InventoryOnboardingCloudMonitoringImportsParametersItemArgs',
    'InventoryOnboardingCloudMonitoringImportsParametersItemArgsDict',
    'InventoryOnboardingCloudMonitoringImportsParametersItemItemArgs',
    'InventoryOnboardingCloudMonitoringImportsParametersItemItemArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareItemArgs',
    'InventoryOnboardingCloudMonitoringPrepareItemArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareItemConfigParamsArgs',
    'InventoryOnboardingCloudMonitoringPrepareItemConfigParamsArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelArgs',
    'InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificateArgs',
    'InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificateArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserArgs',
    'InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecretArgs',
    'InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecretArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareParametersArgs',
    'InventoryOnboardingCloudMonitoringPrepareParametersArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceArgs',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnelArgs',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnelArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceUserArgs',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceUserArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyArgs',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListArgs',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyInArgs',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyInArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOutArgs',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOutArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationArgs',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroupArgs',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroupArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationArgs',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationArgsDict',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroupArgs',
    'InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroupArgsDict',
    'InventoryReleaseItemArgs',
    'InventoryReleaseItemArgsDict',
    'InventoryReleaseParametersArgs',
    'InventoryReleaseParametersArgsDict',
    'LicensesAssignSeatsItemArgs',
    'LicensesAssignSeatsItemArgsDict',
    'LicensesAssignSeatsItemResultingLicenseArgs',
    'LicensesAssignSeatsItemResultingLicenseArgsDict',
    'LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicenseArgs',
    'LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicenseArgsDict',
    'LicensesAssignSeatsParametersArgs',
    'LicensesAssignSeatsParametersArgsDict',
    'LicensesMoveItemArgs',
    'LicensesMoveItemArgsDict',
    'LicensesMoveParametersArgs',
    'LicensesMoveParametersArgsDict',
    'LicensesMoveSeatsItemArgs',
    'LicensesMoveSeatsItemArgsDict',
    'LicensesMoveSeatsParametersArgs',
    'LicensesMoveSeatsParametersArgsDict',
    'LicensesPermanentlyQueuedLicenseArgs',
    'LicensesPermanentlyQueuedLicenseArgsDict',
    'LicensesRenewSeatsItemArgs',
    'LicensesRenewSeatsItemArgsDict',
    'LicensesRenewSeatsItemResultingLicenseArgs',
    'LicensesRenewSeatsItemResultingLicenseArgsDict',
    'LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicenseArgs',
    'LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicenseArgsDict',
    'LicensesRenewSeatsParametersArgs',
    'LicensesRenewSeatsParametersArgsDict',
    'LicensingCotermLicensesMoveItemArgs',
    'LicensingCotermLicensesMoveItemArgsDict',
    'LicensingCotermLicensesMoveItemMovedLicenseArgs',
    'LicensingCotermLicensesMoveItemMovedLicenseArgsDict',
    'LicensingCotermLicensesMoveItemMovedLicenseCountArgs',
    'LicensingCotermLicensesMoveItemMovedLicenseCountArgsDict',
    'LicensingCotermLicensesMoveItemMovedLicenseEditionArgs',
    'LicensingCotermLicensesMoveItemMovedLicenseEditionArgsDict',
    'LicensingCotermLicensesMoveItemRemainderLicenseArgs',
    'LicensingCotermLicensesMoveItemRemainderLicenseArgsDict',
    'LicensingCotermLicensesMoveItemRemainderLicenseCountArgs',
    'LicensingCotermLicensesMoveItemRemainderLicenseCountArgsDict',
    'LicensingCotermLicensesMoveItemRemainderLicenseEditionArgs',
    'LicensingCotermLicensesMoveItemRemainderLicenseEditionArgsDict',
    'LicensingCotermLicensesMoveParametersArgs',
    'LicensingCotermLicensesMoveParametersArgsDict',
    'LicensingCotermLicensesMoveParametersDestinationArgs',
    'LicensingCotermLicensesMoveParametersDestinationArgsDict',
    'LicensingCotermLicensesMoveParametersLicenseArgs',
    'LicensingCotermLicensesMoveParametersLicenseArgsDict',
    'LicensingCotermLicensesMoveParametersLicenseCountArgs',
    'LicensingCotermLicensesMoveParametersLicenseCountArgsDict',
    'LoginSecurityApiAuthenticationArgs',
    'LoginSecurityApiAuthenticationArgsDict',
    'LoginSecurityApiAuthenticationIpRestrictionsForKeysArgs',
    'LoginSecurityApiAuthenticationIpRestrictionsForKeysArgsDict',
    'NetworksCombineItemArgs',
    'NetworksCombineItemArgsDict',
    'NetworksCombineItemResultingNetworkArgs',
    'NetworksCombineItemResultingNetworkArgsDict',
    'NetworksCombineParametersArgs',
    'NetworksCombineParametersArgsDict',
    'SamlRolesCameraArgs',
    'SamlRolesCameraArgsDict',
    'SamlRolesNetworkArgs',
    'SamlRolesNetworkArgsDict',
    'SamlRolesTagArgs',
    'SamlRolesTagArgsDict',
    'SmSentryPoliciesAssignmentsItemArgs',
    'SmSentryPoliciesAssignmentsItemArgsDict',
    'SmSentryPoliciesAssignmentsItemItemArgs',
    'SmSentryPoliciesAssignmentsItemItemArgsDict',
    'SmSentryPoliciesAssignmentsItemItemPolicyArgs',
    'SmSentryPoliciesAssignmentsItemItemPolicyArgsDict',
    'SmSentryPoliciesAssignmentsParametersArgs',
    'SmSentryPoliciesAssignmentsParametersArgsDict',
    'SmSentryPoliciesAssignmentsParametersItemArgs',
    'SmSentryPoliciesAssignmentsParametersItemArgsDict',
    'SmSentryPoliciesAssignmentsParametersItemPolicyArgs',
    'SmSentryPoliciesAssignmentsParametersItemPolicyArgsDict',
    'SwitchDevicesCloneParametersArgs',
    'SwitchDevicesCloneParametersArgsDict',
    'BaseApiArgs',
    'BaseApiArgsDict',
    'BaseCloudArgs',
    'BaseCloudArgsDict',
    'BaseCloudRegionArgs',
    'BaseCloudRegionArgsDict',
    'BaseLicensingArgs',
    'BaseLicensingArgsDict',
    'BaseManagementArgs',
    'BaseManagementArgsDict',
    'BaseManagementDetailArgs',
    'BaseManagementDetailArgsDict',
]

MYPY = False

if not MYPY:
    class ActionBatchesActionArgsDict(TypedDict):
        body: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data provided in the body of the Action. Contents depend on the Action type
        """
        operation: NotRequired[pulumi.Input[_builtins.str]]
        """
        The operation to be used by this action
        """
        resource: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the resource to be acted on
        """
elif False:
    ActionBatchesActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionBatchesActionArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input[_builtins.str]] = None,
                 operation: Optional[pulumi.Input[_builtins.str]] = None,
                 resource: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] body: Data provided in the body of the Action. Contents depend on the Action type
        :param pulumi.Input[_builtins.str] operation: The operation to be used by this action
        :param pulumi.Input[_builtins.str] resource: Unique identifier for the resource to be acted on
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data provided in the body of the Action. Contents depend on the Action type
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The operation to be used by this action
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the resource to be acted on
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource", value)


if not MYPY:
    class ActionBatchesCallbackArgsDict(TypedDict):
        http_server: NotRequired[pulumi.Input['ActionBatchesCallbackHttpServerArgsDict']]
        """
        The webhook receiver used for the callback webhook.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
        """
        payload_template: NotRequired[pulumi.Input['ActionBatchesCallbackPayloadTemplateArgsDict']]
        """
        The payload template of the webhook used for the callback
        """
        shared_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the callback
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
        """
elif False:
    ActionBatchesCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionBatchesCallbackArgs:
    def __init__(__self__, *,
                 http_server: Optional[pulumi.Input['ActionBatchesCallbackHttpServerArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 payload_template: Optional[pulumi.Input['ActionBatchesCallbackPayloadTemplateArgs']] = None,
                 shared_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ActionBatchesCallbackHttpServerArgs'] http_server: The webhook receiver used for the callback webhook.
        :param pulumi.Input[_builtins.str] id: The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
        :param pulumi.Input['ActionBatchesCallbackPayloadTemplateArgs'] payload_template: The payload template of the webhook used for the callback
        :param pulumi.Input[_builtins.str] shared_secret: A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        :param pulumi.Input[_builtins.str] status: The status of the callback
        :param pulumi.Input[_builtins.str] url: The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
        """
        if http_server is not None:
            pulumi.set(__self__, "http_server", http_server)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if payload_template is not None:
            pulumi.set(__self__, "payload_template", payload_template)
        if shared_secret is not None:
            pulumi.set(__self__, "shared_secret", shared_secret)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="httpServer")
    def http_server(self) -> Optional[pulumi.Input['ActionBatchesCallbackHttpServerArgs']]:
        """
        The webhook receiver used for the callback webhook.
        """
        return pulumi.get(self, "http_server")

    @http_server.setter
    def http_server(self, value: Optional[pulumi.Input['ActionBatchesCallbackHttpServerArgs']]):
        pulumi.set(self, "http_server", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="payloadTemplate")
    def payload_template(self) -> Optional[pulumi.Input['ActionBatchesCallbackPayloadTemplateArgs']]:
        """
        The payload template of the webhook used for the callback
        """
        return pulumi.get(self, "payload_template")

    @payload_template.setter
    def payload_template(self, value: Optional[pulumi.Input['ActionBatchesCallbackPayloadTemplateArgs']]):
        pulumi.set(self, "payload_template", value)

    @_builtins.property
    @pulumi.getter(name="sharedSecret")
    def shared_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        return pulumi.get(self, "shared_secret")

    @shared_secret.setter
    def shared_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shared_secret", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the callback
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ActionBatchesCallbackHttpServerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
elif False:
    ActionBatchesCallbackHttpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionBatchesCallbackHttpServerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ActionBatchesCallbackPayloadTemplateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
elif False:
    ActionBatchesCallbackPayloadTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionBatchesCallbackPayloadTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ActionBatchesStatusArgsDict(TypedDict):
        completed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag describing whether all actions in the action batch have completed
        """
        created_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['ActionBatchesStatusCreatedResourceArgsDict']]]]
        """
        Resources created as a result of this action batch
        """
        errors: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of errors encountered when running actions in the action batch
        """
        failed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag describing whether any actions in the action batch failed
        """
elif False:
    ActionBatchesStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionBatchesStatusArgs:
    def __init__(__self__, *,
                 completed: Optional[pulumi.Input[_builtins.bool]] = None,
                 created_resources: Optional[pulumi.Input[Sequence[pulumi.Input['ActionBatchesStatusCreatedResourceArgs']]]] = None,
                 errors: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 failed: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] completed: Flag describing whether all actions in the action batch have completed
        :param pulumi.Input[Sequence[pulumi.Input['ActionBatchesStatusCreatedResourceArgs']]] created_resources: Resources created as a result of this action batch
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] errors: List of errors encountered when running actions in the action batch
        :param pulumi.Input[_builtins.bool] failed: Flag describing whether any actions in the action batch failed
        """
        if completed is not None:
            pulumi.set(__self__, "completed", completed)
        if created_resources is not None:
            pulumi.set(__self__, "created_resources", created_resources)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if failed is not None:
            pulumi.set(__self__, "failed", failed)

    @_builtins.property
    @pulumi.getter
    def completed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag describing whether all actions in the action batch have completed
        """
        return pulumi.get(self, "completed")

    @completed.setter
    def completed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "completed", value)

    @_builtins.property
    @pulumi.getter(name="createdResources")
    def created_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActionBatchesStatusCreatedResourceArgs']]]]:
        """
        Resources created as a result of this action batch
        """
        return pulumi.get(self, "created_resources")

    @created_resources.setter
    def created_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActionBatchesStatusCreatedResourceArgs']]]]):
        pulumi.set(self, "created_resources", value)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of errors encountered when running actions in the action batch
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "errors", value)

    @_builtins.property
    @pulumi.getter
    def failed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag describing whether any actions in the action batch failed
        """
        return pulumi.get(self, "failed")

    @failed.setter
    def failed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "failed", value)


if not MYPY:
    class ActionBatchesStatusCreatedResourceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the created resource
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI, not including base, of the created resource
        """
elif False:
    ActionBatchesStatusCreatedResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionBatchesStatusCreatedResourceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the created resource
        :param pulumi.Input[_builtins.str] uri: URI, not including base, of the created resource
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the created resource
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI, not including base, of the created resource
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AdaptivePolicyAclsRuleArgsDict(TypedDict):
        dst_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination port
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'allow' or 'deny' traffic specified by this rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of protocol
        """
        src_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source port
        """
elif False:
    AdaptivePolicyAclsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdaptivePolicyAclsRuleArgs:
    def __init__(__self__, *,
                 dst_port: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 src_port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dst_port: Destination port
        :param pulumi.Input[_builtins.str] policy: 'allow' or 'deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] protocol: The type of protocol
        :param pulumi.Input[_builtins.str] src_port: Source port
        """
        if dst_port is not None:
            pulumi.set(__self__, "dst_port", dst_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)

    @_builtins.property
    @pulumi.getter(name="dstPort")
    def dst_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination port
        """
        return pulumi.get(self, "dst_port")

    @dst_port.setter
    def dst_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dst_port", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of protocol
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source port
        """
        return pulumi.get(self, "src_port")

    @src_port.setter
    def src_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_port", value)


if not MYPY:
    class AdaptivePolicyGroupsPolicyObjectArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the policy object
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the policy object
        """
elif False:
    AdaptivePolicyGroupsPolicyObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdaptivePolicyGroupsPolicyObjectArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the policy object
        :param pulumi.Input[_builtins.str] name: The name of the policy object
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the policy object
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the policy object
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AdaptivePolicyPoliciesAclArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the adaptive policy ACL
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the adaptive policy ACL
        """
elif False:
    AdaptivePolicyPoliciesAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdaptivePolicyPoliciesAclArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the adaptive policy ACL
        :param pulumi.Input[_builtins.str] name: The name of the adaptive policy ACL
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the adaptive policy ACL
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the adaptive policy ACL
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AdaptivePolicyPoliciesDestinationGroupArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the destination adaptive policy group
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the destination adaptive policy group
        """
        sgt: NotRequired[pulumi.Input[_builtins.int]]
        """
        The SGT of the destination adaptive policy group
        """
elif False:
    AdaptivePolicyPoliciesDestinationGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdaptivePolicyPoliciesDestinationGroupArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 sgt: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the destination adaptive policy group
        :param pulumi.Input[_builtins.str] name: The name of the destination adaptive policy group
        :param pulumi.Input[_builtins.int] sgt: The SGT of the destination adaptive policy group
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sgt is not None:
            pulumi.set(__self__, "sgt", sgt)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the destination adaptive policy group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the destination adaptive policy group
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def sgt(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The SGT of the destination adaptive policy group
        """
        return pulumi.get(self, "sgt")

    @sgt.setter
    def sgt(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "sgt", value)


if not MYPY:
    class AdaptivePolicyPoliciesSourceGroupArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the source adaptive policy group
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the source adaptive policy group
        """
        sgt: NotRequired[pulumi.Input[_builtins.int]]
        """
        The SGT of the source adaptive policy group
        """
elif False:
    AdaptivePolicyPoliciesSourceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdaptivePolicyPoliciesSourceGroupArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 sgt: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the source adaptive policy group
        :param pulumi.Input[_builtins.str] name: The name of the source adaptive policy group
        :param pulumi.Input[_builtins.int] sgt: The SGT of the source adaptive policy group
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sgt is not None:
            pulumi.set(__self__, "sgt", sgt)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the source adaptive policy group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the source adaptive policy group
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def sgt(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The SGT of the source adaptive policy group
        """
        return pulumi.get(self, "sgt")

    @sgt.setter
    def sgt(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "sgt", value)


if not MYPY:
    class AdminsNetworkArgsDict(TypedDict):
        access: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin's level of access to the network
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network ID
        """
elif False:
    AdminsNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdminsNetworkArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access: Admin's level of access to the network
        :param pulumi.Input[_builtins.str] id: Network ID
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin's level of access to the network
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AdminsTagArgsDict(TypedDict):
        access: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access level for the tag
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tag value
        """
elif False:
    AdminsTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdminsTagArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access: Access level for the tag
        :param pulumi.Input[_builtins.str] tag: Tag value
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access level for the tag
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tag value
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class AlertsProfilesAlertConditionArgsDict(TypedDict):
        bit_rate_bps: NotRequired[pulumi.Input[_builtins.int]]
        """
        The threshold the metric must cross to be valid for alerting. Used only for WAN Utilization alerts.
        """
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total duration in seconds that the threshold should be crossed before alerting
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The uplink observed for the alert
        """
        jitter_ms: NotRequired[pulumi.Input[_builtins.int]]
        """
        The threshold the metric must cross to be valid for alerting. Used only for VoIP Jitter alerts.
        """
        latency_ms: NotRequired[pulumi.Input[_builtins.int]]
        """
        The threshold the metric must cross to be valid for alerting. Used only for WAN Latency alerts.
        """
        loss_ratio: NotRequired[pulumi.Input[_builtins.float]]
        """
        The threshold the metric must cross to be valid for alerting. Used only for Packet Loss alerts.
        """
        mos: NotRequired[pulumi.Input[_builtins.float]]
        """
        The threshold the metric must drop below to be valid for alerting. Used only for VoIP MOS alerts.
        """
        window: NotRequired[pulumi.Input[_builtins.int]]
        """
        The look back period in seconds for sensing the alert
        """
elif False:
    AlertsProfilesAlertConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsProfilesAlertConditionArgs:
    def __init__(__self__, *,
                 bit_rate_bps: Optional[pulumi.Input[_builtins.int]] = None,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 jitter_ms: Optional[pulumi.Input[_builtins.int]] = None,
                 latency_ms: Optional[pulumi.Input[_builtins.int]] = None,
                 loss_ratio: Optional[pulumi.Input[_builtins.float]] = None,
                 mos: Optional[pulumi.Input[_builtins.float]] = None,
                 window: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] bit_rate_bps: The threshold the metric must cross to be valid for alerting. Used only for WAN Utilization alerts.
        :param pulumi.Input[_builtins.int] duration: The total duration in seconds that the threshold should be crossed before alerting
        :param pulumi.Input[_builtins.str] interface: The uplink observed for the alert
        :param pulumi.Input[_builtins.int] jitter_ms: The threshold the metric must cross to be valid for alerting. Used only for VoIP Jitter alerts.
        :param pulumi.Input[_builtins.int] latency_ms: The threshold the metric must cross to be valid for alerting. Used only for WAN Latency alerts.
        :param pulumi.Input[_builtins.float] loss_ratio: The threshold the metric must cross to be valid for alerting. Used only for Packet Loss alerts.
        :param pulumi.Input[_builtins.float] mos: The threshold the metric must drop below to be valid for alerting. Used only for VoIP MOS alerts.
        :param pulumi.Input[_builtins.int] window: The look back period in seconds for sensing the alert
        """
        if bit_rate_bps is not None:
            pulumi.set(__self__, "bit_rate_bps", bit_rate_bps)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if jitter_ms is not None:
            pulumi.set(__self__, "jitter_ms", jitter_ms)
        if latency_ms is not None:
            pulumi.set(__self__, "latency_ms", latency_ms)
        if loss_ratio is not None:
            pulumi.set(__self__, "loss_ratio", loss_ratio)
        if mos is not None:
            pulumi.set(__self__, "mos", mos)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @_builtins.property
    @pulumi.getter(name="bitRateBps")
    def bit_rate_bps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The threshold the metric must cross to be valid for alerting. Used only for WAN Utilization alerts.
        """
        return pulumi.get(self, "bit_rate_bps")

    @bit_rate_bps.setter
    def bit_rate_bps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bit_rate_bps", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total duration in seconds that the threshold should be crossed before alerting
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The uplink observed for the alert
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter(name="jitterMs")
    def jitter_ms(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The threshold the metric must cross to be valid for alerting. Used only for VoIP Jitter alerts.
        """
        return pulumi.get(self, "jitter_ms")

    @jitter_ms.setter
    def jitter_ms(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "jitter_ms", value)

    @_builtins.property
    @pulumi.getter(name="latencyMs")
    def latency_ms(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The threshold the metric must cross to be valid for alerting. Used only for WAN Latency alerts.
        """
        return pulumi.get(self, "latency_ms")

    @latency_ms.setter
    def latency_ms(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "latency_ms", value)

    @_builtins.property
    @pulumi.getter(name="lossRatio")
    def loss_ratio(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The threshold the metric must cross to be valid for alerting. Used only for Packet Loss alerts.
        """
        return pulumi.get(self, "loss_ratio")

    @loss_ratio.setter
    def loss_ratio(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "loss_ratio", value)

    @_builtins.property
    @pulumi.getter
    def mos(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The threshold the metric must drop below to be valid for alerting. Used only for VoIP MOS alerts.
        """
        return pulumi.get(self, "mos")

    @mos.setter
    def mos(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "mos", value)

    @_builtins.property
    @pulumi.getter
    def window(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The look back period in seconds for sensing the alert
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "window", value)


if not MYPY:
    class AlertsProfilesRecipientsArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of emails that will receive information about the alert
        """
        http_server_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list base64 encoded urls of webhook endpoints that will receive information about the alert
        """
elif False:
    AlertsProfilesRecipientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsProfilesRecipientsArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 http_server_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: A list of emails that will receive information about the alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] http_server_ids: A list base64 encoded urls of webhook endpoints that will receive information about the alert
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_server_ids is not None:
            pulumi.set(__self__, "http_server_ids", http_server_ids)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of emails that will receive information about the alert
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter(name="httpServerIds")
    def http_server_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list base64 encoded urls of webhook endpoints that will receive information about the alert
        """
        return pulumi.get(self, "http_server_ids")

    @http_server_ids.setter
    def http_server_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_server_ids", value)


if not MYPY:
    class ApplianceSecurityIntrusionAllowedRuleArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Message is optional and is ignored on a PUT call. It is allowed in order for PUT to be compatible with GET
        """
        rule_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A rule identifier of the format meraki:intrusion/snort/GID/\\n\\n/SID/\\n\\n. gid and sid can be obtained from either https://www.snort.org/rule-docs or as ruleIds from the security events in /organization/[orgId]/securityEvents
        """
elif False:
    ApplianceSecurityIntrusionAllowedRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSecurityIntrusionAllowedRuleArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] message: Message is optional and is ignored on a PUT call. It is allowed in order for PUT to be compatible with GET
        :param pulumi.Input[_builtins.str] rule_id: A rule identifier of the format meraki:intrusion/snort/GID/\\n\\n/SID/\\n\\n. gid and sid can be obtained from either https://www.snort.org/rule-docs or as ruleIds from the security events in /organization/[orgId]/securityEvents
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Message is optional and is ignored on a PUT call. It is allowed in order for PUT to be compatible with GET
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A rule identifier of the format meraki:intrusion/snort/GID/\\n\\n/SID/\\n\\n. gid and sid can be obtained from either https://www.snort.org/rule-docs or as ruleIds from the security events in /organization/[orgId]/securityEvents
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_id", value)


if not MYPY:
    class ApplianceVpnThirdPartyVpnpeersPeerArgsDict(TypedDict):
        ike_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
        """
        ipsec_policies: NotRequired[pulumi.Input['ApplianceVpnThirdPartyVpnpeersPeerIpsecPoliciesArgsDict']]
        """
        Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
        """
        ipsec_policies_preset: NotRequired[pulumi.Input[_builtins.str]]
        """
        One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
        """
        local_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the VPN peer
        """
        network_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
        """
        private_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of the private subnets of the VPN peer
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        [optional] The public IP of the VPN peer
        """
        remote_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The shared secret with the VPN peer
        """
elif False:
    ApplianceVpnThirdPartyVpnpeersPeerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVpnThirdPartyVpnpeersPeerArgs:
    def __init__(__self__, *,
                 ike_version: Optional[pulumi.Input[_builtins.str]] = None,
                 ipsec_policies: Optional[pulumi.Input['ApplianceVpnThirdPartyVpnpeersPeerIpsecPoliciesArgs']] = None,
                 ipsec_policies_preset: Optional[pulumi.Input[_builtins.str]] = None,
                 local_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 private_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ike_version: [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
        :param pulumi.Input['ApplianceVpnThirdPartyVpnpeersPeerIpsecPoliciesArgs'] ipsec_policies: Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
        :param pulumi.Input[_builtins.str] ipsec_policies_preset: One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
        :param pulumi.Input[_builtins.str] local_id: [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
        :param pulumi.Input[_builtins.str] name: The name of the VPN peer
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] network_tags: A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] private_subnets: The list of the private subnets of the VPN peer
        :param pulumi.Input[_builtins.str] public_ip: [optional] The public IP of the VPN peer
        :param pulumi.Input[_builtins.str] remote_id: [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
        :param pulumi.Input[_builtins.str] secret: The shared secret with the VPN peer
        """
        if ike_version is not None:
            pulumi.set(__self__, "ike_version", ike_version)
        if ipsec_policies is not None:
            pulumi.set(__self__, "ipsec_policies", ipsec_policies)
        if ipsec_policies_preset is not None:
            pulumi.set(__self__, "ipsec_policies_preset", ipsec_policies_preset)
        if local_id is not None:
            pulumi.set(__self__, "local_id", local_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_tags is not None:
            pulumi.set(__self__, "network_tags", network_tags)
        if private_subnets is not None:
            pulumi.set(__self__, "private_subnets", private_subnets)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if remote_id is not None:
            pulumi.set(__self__, "remote_id", remote_id)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="ikeVersion")
    def ike_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
        """
        return pulumi.get(self, "ike_version")

    @ike_version.setter
    def ike_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ike_version", value)

    @_builtins.property
    @pulumi.getter(name="ipsecPolicies")
    def ipsec_policies(self) -> Optional[pulumi.Input['ApplianceVpnThirdPartyVpnpeersPeerIpsecPoliciesArgs']]:
        """
        Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
        """
        return pulumi.get(self, "ipsec_policies")

    @ipsec_policies.setter
    def ipsec_policies(self, value: Optional[pulumi.Input['ApplianceVpnThirdPartyVpnpeersPeerIpsecPoliciesArgs']]):
        pulumi.set(self, "ipsec_policies", value)

    @_builtins.property
    @pulumi.getter(name="ipsecPoliciesPreset")
    def ipsec_policies_preset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
        """
        return pulumi.get(self, "ipsec_policies_preset")

    @ipsec_policies_preset.setter
    def ipsec_policies_preset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipsec_policies_preset", value)

    @_builtins.property
    @pulumi.getter(name="localId")
    def local_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
        """
        return pulumi.get(self, "local_id")

    @local_id.setter
    def local_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the VPN peer
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="networkTags")
    def network_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
        """
        return pulumi.get(self, "network_tags")

    @network_tags.setter
    def network_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "network_tags", value)

    @_builtins.property
    @pulumi.getter(name="privateSubnets")
    def private_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of the private subnets of the VPN peer
        """
        return pulumi.get(self, "private_subnets")

    @private_subnets.setter
    def private_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "private_subnets", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [optional] The public IP of the VPN peer
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="remoteId")
    def remote_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
        """
        return pulumi.get(self, "remote_id")

    @remote_id.setter
    def remote_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_id", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The shared secret with the VPN peer
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class ApplianceVpnThirdPartyVpnpeersPeerIpsecPoliciesArgsDict(TypedDict):
        child_auth_algos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
        """
        child_cipher_algos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
        """
        child_lifetime: NotRequired[pulumi.Input[_builtins.int]]
        """
        The lifetime of the Phase 2 SA in seconds.
        """
        child_pfs_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
        """
        ike_auth_algos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
        """
        ike_cipher_algos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
        """
        ike_diffie_hellman_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
        """
        ike_lifetime: NotRequired[pulumi.Input[_builtins.int]]
        """
        The lifetime of the Phase 1 SA in seconds.
        """
        ike_prf_algos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
        """
elif False:
    ApplianceVpnThirdPartyVpnpeersPeerIpsecPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVpnThirdPartyVpnpeersPeerIpsecPoliciesArgs:
    def __init__(__self__, *,
                 child_auth_algos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 child_cipher_algos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 child_lifetime: Optional[pulumi.Input[_builtins.int]] = None,
                 child_pfs_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ike_auth_algos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ike_cipher_algos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ike_diffie_hellman_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ike_lifetime: Optional[pulumi.Input[_builtins.int]] = None,
                 ike_prf_algos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] child_auth_algos: This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] child_cipher_algos: This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
        :param pulumi.Input[_builtins.int] child_lifetime: The lifetime of the Phase 2 SA in seconds.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] child_pfs_groups: This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ike_auth_algos: This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ike_cipher_algos: This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ike_diffie_hellman_groups: This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
        :param pulumi.Input[_builtins.int] ike_lifetime: The lifetime of the Phase 1 SA in seconds.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ike_prf_algos: [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
        """
        if child_auth_algos is not None:
            pulumi.set(__self__, "child_auth_algos", child_auth_algos)
        if child_cipher_algos is not None:
            pulumi.set(__self__, "child_cipher_algos", child_cipher_algos)
        if child_lifetime is not None:
            pulumi.set(__self__, "child_lifetime", child_lifetime)
        if child_pfs_groups is not None:
            pulumi.set(__self__, "child_pfs_groups", child_pfs_groups)
        if ike_auth_algos is not None:
            pulumi.set(__self__, "ike_auth_algos", ike_auth_algos)
        if ike_cipher_algos is not None:
            pulumi.set(__self__, "ike_cipher_algos", ike_cipher_algos)
        if ike_diffie_hellman_groups is not None:
            pulumi.set(__self__, "ike_diffie_hellman_groups", ike_diffie_hellman_groups)
        if ike_lifetime is not None:
            pulumi.set(__self__, "ike_lifetime", ike_lifetime)
        if ike_prf_algos is not None:
            pulumi.set(__self__, "ike_prf_algos", ike_prf_algos)

    @_builtins.property
    @pulumi.getter(name="childAuthAlgos")
    def child_auth_algos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
        """
        return pulumi.get(self, "child_auth_algos")

    @child_auth_algos.setter
    def child_auth_algos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "child_auth_algos", value)

    @_builtins.property
    @pulumi.getter(name="childCipherAlgos")
    def child_cipher_algos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
        """
        return pulumi.get(self, "child_cipher_algos")

    @child_cipher_algos.setter
    def child_cipher_algos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "child_cipher_algos", value)

    @_builtins.property
    @pulumi.getter(name="childLifetime")
    def child_lifetime(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The lifetime of the Phase 2 SA in seconds.
        """
        return pulumi.get(self, "child_lifetime")

    @child_lifetime.setter
    def child_lifetime(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "child_lifetime", value)

    @_builtins.property
    @pulumi.getter(name="childPfsGroups")
    def child_pfs_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
        """
        return pulumi.get(self, "child_pfs_groups")

    @child_pfs_groups.setter
    def child_pfs_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "child_pfs_groups", value)

    @_builtins.property
    @pulumi.getter(name="ikeAuthAlgos")
    def ike_auth_algos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
        """
        return pulumi.get(self, "ike_auth_algos")

    @ike_auth_algos.setter
    def ike_auth_algos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ike_auth_algos", value)

    @_builtins.property
    @pulumi.getter(name="ikeCipherAlgos")
    def ike_cipher_algos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
        """
        return pulumi.get(self, "ike_cipher_algos")

    @ike_cipher_algos.setter
    def ike_cipher_algos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ike_cipher_algos", value)

    @_builtins.property
    @pulumi.getter(name="ikeDiffieHellmanGroups")
    def ike_diffie_hellman_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
        """
        return pulumi.get(self, "ike_diffie_hellman_groups")

    @ike_diffie_hellman_groups.setter
    def ike_diffie_hellman_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ike_diffie_hellman_groups", value)

    @_builtins.property
    @pulumi.getter(name="ikeLifetime")
    def ike_lifetime(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The lifetime of the Phase 1 SA in seconds.
        """
        return pulumi.get(self, "ike_lifetime")

    @ike_lifetime.setter
    def ike_lifetime(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ike_lifetime", value)

    @_builtins.property
    @pulumi.getter(name="ikePrfAlgos")
    def ike_prf_algos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
        """
        return pulumi.get(self, "ike_prf_algos")

    @ike_prf_algos.setter
    def ike_prf_algos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ike_prf_algos", value)


if not MYPY:
    class ApplianceVpnThirdPartyVpnpeersPeersResponseArgsDict(TypedDict):
        ike_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
        """
        ipsec_policies: NotRequired[pulumi.Input['ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPoliciesArgsDict']]
        """
        Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
        """
        ipsec_policies_preset: NotRequired[pulumi.Input[_builtins.str]]
        """
        One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
        """
        local_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the VPN peer
        """
        network_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
        """
        private_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of the private subnets of the VPN peer
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        [optional] The public IP of the VPN peer
        """
        remote_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The shared secret with the VPN peer
        """
elif False:
    ApplianceVpnThirdPartyVpnpeersPeersResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVpnThirdPartyVpnpeersPeersResponseArgs:
    def __init__(__self__, *,
                 ike_version: Optional[pulumi.Input[_builtins.str]] = None,
                 ipsec_policies: Optional[pulumi.Input['ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPoliciesArgs']] = None,
                 ipsec_policies_preset: Optional[pulumi.Input[_builtins.str]] = None,
                 local_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 private_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ike_version: [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
        :param pulumi.Input['ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPoliciesArgs'] ipsec_policies: Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
        :param pulumi.Input[_builtins.str] ipsec_policies_preset: One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
        :param pulumi.Input[_builtins.str] local_id: [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
        :param pulumi.Input[_builtins.str] name: The name of the VPN peer
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] network_tags: A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] private_subnets: The list of the private subnets of the VPN peer
        :param pulumi.Input[_builtins.str] public_ip: [optional] The public IP of the VPN peer
        :param pulumi.Input[_builtins.str] remote_id: [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
        :param pulumi.Input[_builtins.str] secret: The shared secret with the VPN peer
        """
        if ike_version is not None:
            pulumi.set(__self__, "ike_version", ike_version)
        if ipsec_policies is not None:
            pulumi.set(__self__, "ipsec_policies", ipsec_policies)
        if ipsec_policies_preset is not None:
            pulumi.set(__self__, "ipsec_policies_preset", ipsec_policies_preset)
        if local_id is not None:
            pulumi.set(__self__, "local_id", local_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_tags is not None:
            pulumi.set(__self__, "network_tags", network_tags)
        if private_subnets is not None:
            pulumi.set(__self__, "private_subnets", private_subnets)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if remote_id is not None:
            pulumi.set(__self__, "remote_id", remote_id)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="ikeVersion")
    def ike_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
        """
        return pulumi.get(self, "ike_version")

    @ike_version.setter
    def ike_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ike_version", value)

    @_builtins.property
    @pulumi.getter(name="ipsecPolicies")
    def ipsec_policies(self) -> Optional[pulumi.Input['ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPoliciesArgs']]:
        """
        Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
        """
        return pulumi.get(self, "ipsec_policies")

    @ipsec_policies.setter
    def ipsec_policies(self, value: Optional[pulumi.Input['ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPoliciesArgs']]):
        pulumi.set(self, "ipsec_policies", value)

    @_builtins.property
    @pulumi.getter(name="ipsecPoliciesPreset")
    def ipsec_policies_preset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
        """
        return pulumi.get(self, "ipsec_policies_preset")

    @ipsec_policies_preset.setter
    def ipsec_policies_preset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipsec_policies_preset", value)

    @_builtins.property
    @pulumi.getter(name="localId")
    def local_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
        """
        return pulumi.get(self, "local_id")

    @local_id.setter
    def local_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the VPN peer
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="networkTags")
    def network_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
        """
        return pulumi.get(self, "network_tags")

    @network_tags.setter
    def network_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "network_tags", value)

    @_builtins.property
    @pulumi.getter(name="privateSubnets")
    def private_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of the private subnets of the VPN peer
        """
        return pulumi.get(self, "private_subnets")

    @private_subnets.setter
    def private_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "private_subnets", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [optional] The public IP of the VPN peer
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="remoteId")
    def remote_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
        """
        return pulumi.get(self, "remote_id")

    @remote_id.setter
    def remote_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_id", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The shared secret with the VPN peer
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPoliciesArgsDict(TypedDict):
        child_auth_algos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
        """
        child_cipher_algos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
        """
        child_lifetime: NotRequired[pulumi.Input[_builtins.int]]
        """
        The lifetime of the Phase 2 SA in seconds.
        """
        child_pfs_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
        """
        ike_auth_algos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
        """
        ike_cipher_algos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
        """
        ike_diffie_hellman_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
        """
        ike_lifetime: NotRequired[pulumi.Input[_builtins.int]]
        """
        The lifetime of the Phase 1 SA in seconds.
        """
        ike_prf_algos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
        """
elif False:
    ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPoliciesArgs:
    def __init__(__self__, *,
                 child_auth_algos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 child_cipher_algos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 child_lifetime: Optional[pulumi.Input[_builtins.int]] = None,
                 child_pfs_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ike_auth_algos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ike_cipher_algos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ike_diffie_hellman_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ike_lifetime: Optional[pulumi.Input[_builtins.int]] = None,
                 ike_prf_algos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] child_auth_algos: This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] child_cipher_algos: This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
        :param pulumi.Input[_builtins.int] child_lifetime: The lifetime of the Phase 2 SA in seconds.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] child_pfs_groups: This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ike_auth_algos: This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ike_cipher_algos: This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ike_diffie_hellman_groups: This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
        :param pulumi.Input[_builtins.int] ike_lifetime: The lifetime of the Phase 1 SA in seconds.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ike_prf_algos: [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
        """
        if child_auth_algos is not None:
            pulumi.set(__self__, "child_auth_algos", child_auth_algos)
        if child_cipher_algos is not None:
            pulumi.set(__self__, "child_cipher_algos", child_cipher_algos)
        if child_lifetime is not None:
            pulumi.set(__self__, "child_lifetime", child_lifetime)
        if child_pfs_groups is not None:
            pulumi.set(__self__, "child_pfs_groups", child_pfs_groups)
        if ike_auth_algos is not None:
            pulumi.set(__self__, "ike_auth_algos", ike_auth_algos)
        if ike_cipher_algos is not None:
            pulumi.set(__self__, "ike_cipher_algos", ike_cipher_algos)
        if ike_diffie_hellman_groups is not None:
            pulumi.set(__self__, "ike_diffie_hellman_groups", ike_diffie_hellman_groups)
        if ike_lifetime is not None:
            pulumi.set(__self__, "ike_lifetime", ike_lifetime)
        if ike_prf_algos is not None:
            pulumi.set(__self__, "ike_prf_algos", ike_prf_algos)

    @_builtins.property
    @pulumi.getter(name="childAuthAlgos")
    def child_auth_algos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
        """
        return pulumi.get(self, "child_auth_algos")

    @child_auth_algos.setter
    def child_auth_algos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "child_auth_algos", value)

    @_builtins.property
    @pulumi.getter(name="childCipherAlgos")
    def child_cipher_algos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
        """
        return pulumi.get(self, "child_cipher_algos")

    @child_cipher_algos.setter
    def child_cipher_algos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "child_cipher_algos", value)

    @_builtins.property
    @pulumi.getter(name="childLifetime")
    def child_lifetime(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The lifetime of the Phase 2 SA in seconds.
        """
        return pulumi.get(self, "child_lifetime")

    @child_lifetime.setter
    def child_lifetime(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "child_lifetime", value)

    @_builtins.property
    @pulumi.getter(name="childPfsGroups")
    def child_pfs_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
        """
        return pulumi.get(self, "child_pfs_groups")

    @child_pfs_groups.setter
    def child_pfs_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "child_pfs_groups", value)

    @_builtins.property
    @pulumi.getter(name="ikeAuthAlgos")
    def ike_auth_algos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
        """
        return pulumi.get(self, "ike_auth_algos")

    @ike_auth_algos.setter
    def ike_auth_algos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ike_auth_algos", value)

    @_builtins.property
    @pulumi.getter(name="ikeCipherAlgos")
    def ike_cipher_algos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
        """
        return pulumi.get(self, "ike_cipher_algos")

    @ike_cipher_algos.setter
    def ike_cipher_algos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ike_cipher_algos", value)

    @_builtins.property
    @pulumi.getter(name="ikeDiffieHellmanGroups")
    def ike_diffie_hellman_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
        """
        return pulumi.get(self, "ike_diffie_hellman_groups")

    @ike_diffie_hellman_groups.setter
    def ike_diffie_hellman_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ike_diffie_hellman_groups", value)

    @_builtins.property
    @pulumi.getter(name="ikeLifetime")
    def ike_lifetime(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The lifetime of the Phase 1 SA in seconds.
        """
        return pulumi.get(self, "ike_lifetime")

    @ike_lifetime.setter
    def ike_lifetime(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ike_lifetime", value)

    @_builtins.property
    @pulumi.getter(name="ikePrfAlgos")
    def ike_prf_algos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
        """
        return pulumi.get(self, "ike_prf_algos")

    @ike_prf_algos.setter
    def ike_prf_algos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ike_prf_algos", value)


if not MYPY:
    class ApplianceVpnVpnFirewallRulesRuleArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the rule (optional)
        """
        dest_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        dest_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'allow' or 'deny' traffic specified by this rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        src_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        src_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        syslog_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
elif False:
    ApplianceVpnVpnFirewallRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVpnVpnFirewallRulesRuleArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_port: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 src_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 src_port: Optional[pulumi.Input[_builtins.str]] = None,
                 syslog_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Description of the rule (optional)
        :param pulumi.Input[_builtins.str] dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param pulumi.Input[_builtins.str] dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.str] policy: 'allow' or 'deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        :param pulumi.Input[_builtins.str] src_cidr: Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        :param pulumi.Input[_builtins.str] src_port: Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.bool] syslog_enabled: Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if syslog_enabled is not None:
            pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @dest_cidr.setter
    def dest_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_cidr", value)

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @dest_port.setter
    def dest_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_port", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        return pulumi.get(self, "src_cidr")

    @src_cidr.setter
    def src_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_cidr", value)

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "src_port")

    @src_port.setter
    def src_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_port", value)

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        return pulumi.get(self, "syslog_enabled")

    @syslog_enabled.setter
    def syslog_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "syslog_enabled", value)


if not MYPY:
    class BrandingPoliciesAdminSettingsArgsDict(TypedDict):
        applies_to: NotRequired[pulumi.Input[_builtins.str]]
        """
        Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
          entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
          networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
          specify an array of tag names.
        """
elif False:
    BrandingPoliciesAdminSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingPoliciesAdminSettingsArgs:
    def __init__(__self__, *,
                 applies_to: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] applies_to: Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
                 entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
                 networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
                 specify an array of tag names.
        """
        if applies_to is not None:
            pulumi.set(__self__, "applies_to", applies_to)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="appliesTo")
    def applies_to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'.
        """
        return pulumi.get(self, "applies_to")

    @applies_to.setter
    def applies_to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "applies_to", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
          entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
          networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
          specify an array of tag names.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class BrandingPoliciesCustomLogoArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not there is a custom logo enabled.
        """
        image: NotRequired[pulumi.Input['BrandingPoliciesCustomLogoImageArgsDict']]
        """
        Properties of the image.
        """
elif False:
    BrandingPoliciesCustomLogoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingPoliciesCustomLogoArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 image: Optional[pulumi.Input['BrandingPoliciesCustomLogoImageArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether or not there is a custom logo enabled.
        :param pulumi.Input['BrandingPoliciesCustomLogoImageArgs'] image: Properties of the image.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not there is a custom logo enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['BrandingPoliciesCustomLogoImageArgs']]:
        """
        Properties of the image.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['BrandingPoliciesCustomLogoImageArgs']]):
        pulumi.set(self, "image", value)


if not MYPY:
    class BrandingPoliciesCustomLogoImageArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[_builtins.str]]
        """
        The file contents (a base 64 encoded string) of your new logo.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The format of the encoded contents.  Supported formats are 'png', 'gif', and jpg'.
        """
        preview: NotRequired[pulumi.Input['BrandingPoliciesCustomLogoImagePreviewArgsDict']]
        """
        Preview of the image
        """
elif False:
    BrandingPoliciesCustomLogoImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingPoliciesCustomLogoImageArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 preview: Optional[pulumi.Input['BrandingPoliciesCustomLogoImagePreviewArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] contents: The file contents (a base 64 encoded string) of your new logo.
        :param pulumi.Input[_builtins.str] format: The format of the encoded contents.  Supported formats are 'png', 'gif', and jpg'.
        :param pulumi.Input['BrandingPoliciesCustomLogoImagePreviewArgs'] preview: Preview of the image
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if preview is not None:
            pulumi.set(__self__, "preview", preview)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The file contents (a base 64 encoded string) of your new logo.
        """
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contents", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The format of the encoded contents.  Supported formats are 'png', 'gif', and jpg'.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def preview(self) -> Optional[pulumi.Input['BrandingPoliciesCustomLogoImagePreviewArgs']]:
        """
        Preview of the image
        """
        return pulumi.get(self, "preview")

    @preview.setter
    def preview(self, value: Optional[pulumi.Input['BrandingPoliciesCustomLogoImagePreviewArgs']]):
        pulumi.set(self, "preview", value)


if not MYPY:
    class BrandingPoliciesCustomLogoImagePreviewArgsDict(TypedDict):
        expires_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the preview image
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Url of the preview image
        """
elif False:
    BrandingPoliciesCustomLogoImagePreviewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingPoliciesCustomLogoImagePreviewArgs:
    def __init__(__self__, *,
                 expires_at: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expires_at: Timestamp of the preview image
        :param pulumi.Input[_builtins.str] url: Url of the preview image
        """
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the preview image
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expires_at", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Url of the preview image
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class BrandingPoliciesHelpSettingsArgsDict(TypedDict):
        api_docs_subtab: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'Help > API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
          'default or inherit', 'hide' or 'show'.
        """
        cases_subtab: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'Help > Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
          of 'default or inherit', 'hide' or 'show'.
        """
        cisco_meraki_product_documentation: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'Product Manuals' section of the 'Help > Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
        """
        community_subtab: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'Help > Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        data_protection_requests_subtab: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'Help > Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
          be audited. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        firewall_info_subtab: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'Help > Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
          listed. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        get_help_subtab: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'Help > Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
          that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
          and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        get_help_subtab_knowledge_base_search: NotRequired[pulumi.Input[_builtins.str]]
        """
        The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
        """
        hardware_replacements_subtab: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'Help > Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
          'default or inherit', 'hide' or 'show'.
        """
        help_tab: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
          customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        help_widget: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
          and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        new_features_subtab: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'Help > New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        sm_forums: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
          organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        support_contact_info: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'Contact Meraki Support' section of the 'Help > Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
        """
        universal_search_knowledge_base_search: NotRequired[pulumi.Input[_builtins.str]]
        """
        The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
          whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
        """
elif False:
    BrandingPoliciesHelpSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingPoliciesHelpSettingsArgs:
    def __init__(__self__, *,
                 api_docs_subtab: Optional[pulumi.Input[_builtins.str]] = None,
                 cases_subtab: Optional[pulumi.Input[_builtins.str]] = None,
                 cisco_meraki_product_documentation: Optional[pulumi.Input[_builtins.str]] = None,
                 community_subtab: Optional[pulumi.Input[_builtins.str]] = None,
                 data_protection_requests_subtab: Optional[pulumi.Input[_builtins.str]] = None,
                 firewall_info_subtab: Optional[pulumi.Input[_builtins.str]] = None,
                 get_help_subtab: Optional[pulumi.Input[_builtins.str]] = None,
                 get_help_subtab_knowledge_base_search: Optional[pulumi.Input[_builtins.str]] = None,
                 hardware_replacements_subtab: Optional[pulumi.Input[_builtins.str]] = None,
                 help_tab: Optional[pulumi.Input[_builtins.str]] = None,
                 help_widget: Optional[pulumi.Input[_builtins.str]] = None,
                 new_features_subtab: Optional[pulumi.Input[_builtins.str]] = None,
                 sm_forums: Optional[pulumi.Input[_builtins.str]] = None,
                 support_contact_info: Optional[pulumi.Input[_builtins.str]] = None,
                 universal_search_knowledge_base_search: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_docs_subtab: The 'Help > API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
                 'default or inherit', 'hide' or 'show'.
        :param pulumi.Input[_builtins.str] cases_subtab: The 'Help > Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
                 of 'default or inherit', 'hide' or 'show'.
        :param pulumi.Input[_builtins.str] cisco_meraki_product_documentation: The 'Product Manuals' section of the 'Help > Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
        :param pulumi.Input[_builtins.str] community_subtab: The 'Help > Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
        :param pulumi.Input[_builtins.str] data_protection_requests_subtab: The 'Help > Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
                 be audited. Can be one of 'default or inherit', 'hide' or 'show'.
        :param pulumi.Input[_builtins.str] firewall_info_subtab: The 'Help > Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
                 listed. Can be one of 'default or inherit', 'hide' or 'show'.
        :param pulumi.Input[_builtins.str] get_help_subtab: The 'Help > Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
                 that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
                 and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
        :param pulumi.Input[_builtins.str] get_help_subtab_knowledge_base_search: The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
        :param pulumi.Input[_builtins.str] hardware_replacements_subtab: The 'Help > Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
                 'default or inherit', 'hide' or 'show'.
        :param pulumi.Input[_builtins.str] help_tab: The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
                 customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
        :param pulumi.Input[_builtins.str] help_widget: The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
                 and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
        :param pulumi.Input[_builtins.str] new_features_subtab: The 'Help > New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
        :param pulumi.Input[_builtins.str] sm_forums: The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
                 organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
        :param pulumi.Input[_builtins.str] support_contact_info: The 'Contact Meraki Support' section of the 'Help > Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
        :param pulumi.Input[_builtins.str] universal_search_knowledge_base_search: The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
                 whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        if api_docs_subtab is not None:
            pulumi.set(__self__, "api_docs_subtab", api_docs_subtab)
        if cases_subtab is not None:
            pulumi.set(__self__, "cases_subtab", cases_subtab)
        if cisco_meraki_product_documentation is not None:
            pulumi.set(__self__, "cisco_meraki_product_documentation", cisco_meraki_product_documentation)
        if community_subtab is not None:
            pulumi.set(__self__, "community_subtab", community_subtab)
        if data_protection_requests_subtab is not None:
            pulumi.set(__self__, "data_protection_requests_subtab", data_protection_requests_subtab)
        if firewall_info_subtab is not None:
            pulumi.set(__self__, "firewall_info_subtab", firewall_info_subtab)
        if get_help_subtab is not None:
            pulumi.set(__self__, "get_help_subtab", get_help_subtab)
        if get_help_subtab_knowledge_base_search is not None:
            pulumi.set(__self__, "get_help_subtab_knowledge_base_search", get_help_subtab_knowledge_base_search)
        if hardware_replacements_subtab is not None:
            pulumi.set(__self__, "hardware_replacements_subtab", hardware_replacements_subtab)
        if help_tab is not None:
            pulumi.set(__self__, "help_tab", help_tab)
        if help_widget is not None:
            pulumi.set(__self__, "help_widget", help_widget)
        if new_features_subtab is not None:
            pulumi.set(__self__, "new_features_subtab", new_features_subtab)
        if sm_forums is not None:
            pulumi.set(__self__, "sm_forums", sm_forums)
        if support_contact_info is not None:
            pulumi.set(__self__, "support_contact_info", support_contact_info)
        if universal_search_knowledge_base_search is not None:
            pulumi.set(__self__, "universal_search_knowledge_base_search", universal_search_knowledge_base_search)

    @_builtins.property
    @pulumi.getter(name="apiDocsSubtab")
    def api_docs_subtab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'Help > API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
          'default or inherit', 'hide' or 'show'.
        """
        return pulumi.get(self, "api_docs_subtab")

    @api_docs_subtab.setter
    def api_docs_subtab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_docs_subtab", value)

    @_builtins.property
    @pulumi.getter(name="casesSubtab")
    def cases_subtab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'Help > Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
          of 'default or inherit', 'hide' or 'show'.
        """
        return pulumi.get(self, "cases_subtab")

    @cases_subtab.setter
    def cases_subtab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cases_subtab", value)

    @_builtins.property
    @pulumi.getter(name="ciscoMerakiProductDocumentation")
    def cisco_meraki_product_documentation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'Product Manuals' section of the 'Help > Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
        """
        return pulumi.get(self, "cisco_meraki_product_documentation")

    @cisco_meraki_product_documentation.setter
    def cisco_meraki_product_documentation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cisco_meraki_product_documentation", value)

    @_builtins.property
    @pulumi.getter(name="communitySubtab")
    def community_subtab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'Help > Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        return pulumi.get(self, "community_subtab")

    @community_subtab.setter
    def community_subtab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "community_subtab", value)

    @_builtins.property
    @pulumi.getter(name="dataProtectionRequestsSubtab")
    def data_protection_requests_subtab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'Help > Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
          be audited. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        return pulumi.get(self, "data_protection_requests_subtab")

    @data_protection_requests_subtab.setter
    def data_protection_requests_subtab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_protection_requests_subtab", value)

    @_builtins.property
    @pulumi.getter(name="firewallInfoSubtab")
    def firewall_info_subtab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'Help > Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
          listed. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        return pulumi.get(self, "firewall_info_subtab")

    @firewall_info_subtab.setter
    def firewall_info_subtab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firewall_info_subtab", value)

    @_builtins.property
    @pulumi.getter(name="getHelpSubtab")
    def get_help_subtab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'Help > Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
          that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
          and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        return pulumi.get(self, "get_help_subtab")

    @get_help_subtab.setter
    def get_help_subtab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "get_help_subtab", value)

    @_builtins.property
    @pulumi.getter(name="getHelpSubtabKnowledgeBaseSearch")
    def get_help_subtab_knowledge_base_search(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
        """
        return pulumi.get(self, "get_help_subtab_knowledge_base_search")

    @get_help_subtab_knowledge_base_search.setter
    def get_help_subtab_knowledge_base_search(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "get_help_subtab_knowledge_base_search", value)

    @_builtins.property
    @pulumi.getter(name="hardwareReplacementsSubtab")
    def hardware_replacements_subtab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'Help > Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
          'default or inherit', 'hide' or 'show'.
        """
        return pulumi.get(self, "hardware_replacements_subtab")

    @hardware_replacements_subtab.setter
    def hardware_replacements_subtab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hardware_replacements_subtab", value)

    @_builtins.property
    @pulumi.getter(name="helpTab")
    def help_tab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
          customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        return pulumi.get(self, "help_tab")

    @help_tab.setter
    def help_tab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "help_tab", value)

    @_builtins.property
    @pulumi.getter(name="helpWidget")
    def help_widget(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
          and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        return pulumi.get(self, "help_widget")

    @help_widget.setter
    def help_widget(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "help_widget", value)

    @_builtins.property
    @pulumi.getter(name="newFeaturesSubtab")
    def new_features_subtab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'Help > New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        return pulumi.get(self, "new_features_subtab")

    @new_features_subtab.setter
    def new_features_subtab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "new_features_subtab", value)

    @_builtins.property
    @pulumi.getter(name="smForums")
    def sm_forums(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
          organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        return pulumi.get(self, "sm_forums")

    @sm_forums.setter
    def sm_forums(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sm_forums", value)

    @_builtins.property
    @pulumi.getter(name="supportContactInfo")
    def support_contact_info(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'Contact Meraki Support' section of the 'Help > Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
        """
        return pulumi.get(self, "support_contact_info")

    @support_contact_info.setter
    def support_contact_info(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "support_contact_info", value)

    @_builtins.property
    @pulumi.getter(name="universalSearchKnowledgeBaseSearch")
    def universal_search_knowledge_base_search(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
          whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
        """
        return pulumi.get(self, "universal_search_knowledge_base_search")

    @universal_search_knowledge_base_search.setter
    def universal_search_knowledge_base_search(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "universal_search_knowledge_base_search", value)


if not MYPY:
    class CameraCustomAnalyticsArtifactsStatusArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status message
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status type
        """
elif False:
    CameraCustomAnalyticsArtifactsStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraCustomAnalyticsArtifactsStatusArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] message: Status message
        :param pulumi.Input[_builtins.str] type: Status type
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status message
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CameraRolesAppliedOnDeviceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device id.
        """
        in_networks_with_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network id scope
        """
        in_networks_with_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network tag scope
        """
        permission_level: NotRequired[pulumi.Input[_builtins.str]]
        permission_scope: NotRequired[pulumi.Input[_builtins.str]]
        permission_scope_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Permission scope id
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device tag.
        """
elif False:
    CameraRolesAppliedOnDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraRolesAppliedOnDeviceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 in_networks_with_id: Optional[pulumi.Input[_builtins.str]] = None,
                 in_networks_with_tag: Optional[pulumi.Input[_builtins.str]] = None,
                 permission_level: Optional[pulumi.Input[_builtins.str]] = None,
                 permission_scope: Optional[pulumi.Input[_builtins.str]] = None,
                 permission_scope_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Device id.
        :param pulumi.Input[_builtins.str] in_networks_with_id: Network id scope
        :param pulumi.Input[_builtins.str] in_networks_with_tag: Network tag scope
        :param pulumi.Input[_builtins.str] permission_scope_id: Permission scope id
        :param pulumi.Input[_builtins.str] tag: Device tag.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if in_networks_with_id is not None:
            pulumi.set(__self__, "in_networks_with_id", in_networks_with_id)
        if in_networks_with_tag is not None:
            pulumi.set(__self__, "in_networks_with_tag", in_networks_with_tag)
        if permission_level is not None:
            pulumi.set(__self__, "permission_level", permission_level)
        if permission_scope is not None:
            pulumi.set(__self__, "permission_scope", permission_scope)
        if permission_scope_id is not None:
            pulumi.set(__self__, "permission_scope_id", permission_scope_id)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="inNetworksWithId")
    def in_networks_with_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network id scope
        """
        return pulumi.get(self, "in_networks_with_id")

    @in_networks_with_id.setter
    def in_networks_with_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "in_networks_with_id", value)

    @_builtins.property
    @pulumi.getter(name="inNetworksWithTag")
    def in_networks_with_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network tag scope
        """
        return pulumi.get(self, "in_networks_with_tag")

    @in_networks_with_tag.setter
    def in_networks_with_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "in_networks_with_tag", value)

    @_builtins.property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "permission_level")

    @permission_level.setter
    def permission_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "permission_level", value)

    @_builtins.property
    @pulumi.getter(name="permissionScope")
    def permission_scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "permission_scope")

    @permission_scope.setter
    def permission_scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "permission_scope", value)

    @_builtins.property
    @pulumi.getter(name="permissionScopeId")
    def permission_scope_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Permission scope id
        """
        return pulumi.get(self, "permission_scope_id")

    @permission_scope_id.setter
    def permission_scope_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "permission_scope_id", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device tag.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class CameraRolesAppliedOnNetworkArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network id.
        """
        permission_level: NotRequired[pulumi.Input[_builtins.str]]
        permission_scope: NotRequired[pulumi.Input[_builtins.str]]
        permission_scope_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Permission scope id
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network tag
        """
elif False:
    CameraRolesAppliedOnNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraRolesAppliedOnNetworkArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 permission_level: Optional[pulumi.Input[_builtins.str]] = None,
                 permission_scope: Optional[pulumi.Input[_builtins.str]] = None,
                 permission_scope_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Network id.
        :param pulumi.Input[_builtins.str] permission_scope_id: Permission scope id
        :param pulumi.Input[_builtins.str] tag: Network tag
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if permission_level is not None:
            pulumi.set(__self__, "permission_level", permission_level)
        if permission_scope is not None:
            pulumi.set(__self__, "permission_scope", permission_scope)
        if permission_scope_id is not None:
            pulumi.set(__self__, "permission_scope_id", permission_scope_id)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "permission_level")

    @permission_level.setter
    def permission_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "permission_level", value)

    @_builtins.property
    @pulumi.getter(name="permissionScope")
    def permission_scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "permission_scope")

    @permission_scope.setter
    def permission_scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "permission_scope", value)

    @_builtins.property
    @pulumi.getter(name="permissionScopeId")
    def permission_scope_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Permission scope id
        """
        return pulumi.get(self, "permission_scope_id")

    @permission_scope_id.setter
    def permission_scope_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "permission_scope_id", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class CameraRolesAppliedOrgWideArgsDict(TypedDict):
        permission_level: NotRequired[pulumi.Input[_builtins.str]]
        permission_scope: NotRequired[pulumi.Input[_builtins.str]]
        permission_scope_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Permission scope id
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CameraRolesAppliedOrgWideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraRolesAppliedOrgWideArgs:
    def __init__(__self__, *,
                 permission_level: Optional[pulumi.Input[_builtins.str]] = None,
                 permission_scope: Optional[pulumi.Input[_builtins.str]] = None,
                 permission_scope_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] permission_scope_id: Permission scope id
        """
        if permission_level is not None:
            pulumi.set(__self__, "permission_level", permission_level)
        if permission_scope is not None:
            pulumi.set(__self__, "permission_scope", permission_scope)
        if permission_scope_id is not None:
            pulumi.set(__self__, "permission_scope_id", permission_scope_id)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "permission_level")

    @permission_level.setter
    def permission_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "permission_level", value)

    @_builtins.property
    @pulumi.getter(name="permissionScope")
    def permission_scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "permission_scope")

    @permission_scope.setter
    def permission_scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "permission_scope", value)

    @_builtins.property
    @pulumi.getter(name="permissionScopeId")
    def permission_scope_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Permission scope id
        """
        return pulumi.get(self, "permission_scope_id")

    @permission_scope_id.setter
    def permission_scope_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "permission_scope_id", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class ClaimItemArgsDict(TypedDict):
        licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClaimItemLicenseArgsDict']]]]
        """
        The licenses claimed
        """
        orders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The numbers of the orders claimed
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The serials of the devices claimed
        """
elif False:
    ClaimItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClaimItemArgs:
    def __init__(__self__, *,
                 licenses: Optional[pulumi.Input[Sequence[pulumi.Input['ClaimItemLicenseArgs']]]] = None,
                 orders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClaimItemLicenseArgs']]] licenses: The licenses claimed
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] orders: The numbers of the orders claimed
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: The serials of the devices claimed
        """
        if licenses is not None:
            pulumi.set(__self__, "licenses", licenses)
        if orders is not None:
            pulumi.set(__self__, "orders", orders)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClaimItemLicenseArgs']]]]:
        """
        The licenses claimed
        """
        return pulumi.get(self, "licenses")

    @licenses.setter
    def licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClaimItemLicenseArgs']]]]):
        pulumi.set(self, "licenses", value)

    @_builtins.property
    @pulumi.getter
    def orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The numbers of the orders claimed
        """
        return pulumi.get(self, "orders")

    @orders.setter
    def orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "orders", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The serials of the devices claimed
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)


if not MYPY:
    class ClaimItemLicenseArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the license
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The mode of the license
        """
elif False:
    ClaimItemLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClaimItemLicenseArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the license
        :param pulumi.Input[_builtins.str] mode: The mode of the license
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the license
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The mode of the license
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ClaimParametersArgsDict(TypedDict):
        licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClaimParametersLicenseArgsDict']]]]
        """
        The licenses that should be claimed
        """
        orders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The numbers of the orders that should be claimed
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The serials of the devices that should be claimed
        """
elif False:
    ClaimParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClaimParametersArgs:
    def __init__(__self__, *,
                 licenses: Optional[pulumi.Input[Sequence[pulumi.Input['ClaimParametersLicenseArgs']]]] = None,
                 orders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClaimParametersLicenseArgs']]] licenses: The licenses that should be claimed
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] orders: The numbers of the orders that should be claimed
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: The serials of the devices that should be claimed
        """
        if licenses is not None:
            pulumi.set(__self__, "licenses", licenses)
        if orders is not None:
            pulumi.set(__self__, "orders", orders)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClaimParametersLicenseArgs']]]]:
        """
        The licenses that should be claimed
        """
        return pulumi.get(self, "licenses")

    @licenses.setter
    def licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClaimParametersLicenseArgs']]]]):
        pulumi.set(self, "licenses", value)

    @_builtins.property
    @pulumi.getter
    def orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The numbers of the orders that should be claimed
        """
        return pulumi.get(self, "orders")

    @orders.setter
    def orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "orders", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The serials of the devices that should be claimed
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)


if not MYPY:
    class ClaimParametersLicenseArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the license
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. This parameter is legacy and does not apply to organizations with per-device licensing enabled.
        """
elif False:
    ClaimParametersLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClaimParametersLicenseArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the license
        :param pulumi.Input[_builtins.str] mode: Either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. This parameter is legacy and does not apply to organizations with per-device licensing enabled.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the license
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. This parameter is legacy and does not apply to organizations with per-device licensing enabled.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class CloneItemArgsDict(TypedDict):
        api: NotRequired[pulumi.Input['CloneItemApiArgsDict']]
        """
        API related settings
        """
        cloud: NotRequired[pulumi.Input['CloneItemCloudArgsDict']]
        """
        Data for this organization
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization ID
        """
        licensing: NotRequired[pulumi.Input['CloneItemLicensingArgsDict']]
        """
        Licensing related settings
        """
        management: NotRequired[pulumi.Input['CloneItemManagementArgsDict']]
        """
        Information about the organization's management system
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization name
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization URL
        """
elif False:
    CloneItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloneItemArgs:
    def __init__(__self__, *,
                 api: Optional[pulumi.Input['CloneItemApiArgs']] = None,
                 cloud: Optional[pulumi.Input['CloneItemCloudArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 licensing: Optional[pulumi.Input['CloneItemLicensingArgs']] = None,
                 management: Optional[pulumi.Input['CloneItemManagementArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['CloneItemApiArgs'] api: API related settings
        :param pulumi.Input['CloneItemCloudArgs'] cloud: Data for this organization
        :param pulumi.Input[_builtins.str] id: Organization ID
        :param pulumi.Input['CloneItemLicensingArgs'] licensing: Licensing related settings
        :param pulumi.Input['CloneItemManagementArgs'] management: Information about the organization's management system
        :param pulumi.Input[_builtins.str] name: Organization name
        :param pulumi.Input[_builtins.str] url: Organization URL
        """
        if api is not None:
            pulumi.set(__self__, "api", api)
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if licensing is not None:
            pulumi.set(__self__, "licensing", licensing)
        if management is not None:
            pulumi.set(__self__, "management", management)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def api(self) -> Optional[pulumi.Input['CloneItemApiArgs']]:
        """
        API related settings
        """
        return pulumi.get(self, "api")

    @api.setter
    def api(self, value: Optional[pulumi.Input['CloneItemApiArgs']]):
        pulumi.set(self, "api", value)

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> Optional[pulumi.Input['CloneItemCloudArgs']]:
        """
        Data for this organization
        """
        return pulumi.get(self, "cloud")

    @cloud.setter
    def cloud(self, value: Optional[pulumi.Input['CloneItemCloudArgs']]):
        pulumi.set(self, "cloud", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def licensing(self) -> Optional[pulumi.Input['CloneItemLicensingArgs']]:
        """
        Licensing related settings
        """
        return pulumi.get(self, "licensing")

    @licensing.setter
    def licensing(self, value: Optional[pulumi.Input['CloneItemLicensingArgs']]):
        pulumi.set(self, "licensing", value)

    @_builtins.property
    @pulumi.getter
    def management(self) -> Optional[pulumi.Input['CloneItemManagementArgs']]:
        """
        Information about the organization's management system
        """
        return pulumi.get(self, "management")

    @management.setter
    def management(self, value: Optional[pulumi.Input['CloneItemManagementArgs']]):
        pulumi.set(self, "management", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class CloneItemApiArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable API access
        """
elif False:
    CloneItemApiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloneItemApiArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable API access
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable API access
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class CloneItemCloudArgsDict(TypedDict):
        region: NotRequired[pulumi.Input['CloneItemCloudRegionArgsDict']]
        """
        Region info
        """
elif False:
    CloneItemCloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloneItemCloudArgs:
    def __init__(__self__, *,
                 region: Optional[pulumi.Input['CloneItemCloudRegionArgs']] = None):
        """
        :param pulumi.Input['CloneItemCloudRegionArgs'] region: Region info
        """
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input['CloneItemCloudRegionArgs']]:
        """
        Region info
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input['CloneItemCloudRegionArgs']]):
        pulumi.set(self, "region", value)


if not MYPY:
    class CloneItemCloudRegionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of region
        """
elif False:
    CloneItemCloudRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloneItemCloudRegionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of region
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of region
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CloneItemLicensingArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
        """
elif False:
    CloneItemLicensingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloneItemLicensingArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] model: Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)


if not MYPY:
    class CloneItemManagementArgsDict(TypedDict):
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloneItemManagementDetailArgsDict']]]]
        """
        Details related to organization management, possibly empty. Details may be named 'MSP ID', 'IP restriction mode for API', or 'IP restriction mode for dashboard', if the organization admin has configured any.
        """
elif False:
    CloneItemManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloneItemManagementArgs:
    def __init__(__self__, *,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input['CloneItemManagementDetailArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CloneItemManagementDetailArgs']]] details: Details related to organization management, possibly empty. Details may be named 'MSP ID', 'IP restriction mode for API', or 'IP restriction mode for dashboard', if the organization admin has configured any.
        """
        if details is not None:
            pulumi.set(__self__, "details", details)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloneItemManagementDetailArgs']]]]:
        """
        Details related to organization management, possibly empty. Details may be named 'MSP ID', 'IP restriction mode for API', or 'IP restriction mode for dashboard', if the organization admin has configured any.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloneItemManagementDetailArgs']]]]):
        pulumi.set(self, "details", value)


if not MYPY:
    class CloneItemManagementDetailArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of management data
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of management data
        """
elif False:
    CloneItemManagementDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloneItemManagementDetailArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of management data
        :param pulumi.Input[_builtins.str] value: Value of management data
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of management data
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of management data
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CloneParametersArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the new organization
        """
elif False:
    CloneParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloneParametersArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the new organization
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the new organization
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ConfigTemplatesSwitchProfilesPortsMirrorArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port mirror mode. Can be one of ('Destination port', 'Source port' or 'Not mirroring traffic').
        """
elif False:
    ConfigTemplatesSwitchProfilesPortsMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigTemplatesSwitchProfilesPortsMirrorArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The port mirror mode. Can be one of ('Destination port', 'Source port' or 'Not mirroring traffic').
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port mirror mode. Can be one of ('Destination port', 'Source port' or 'Not mirroring traffic').
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ConfigTemplatesSwitchProfilesPortsModuleArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The model of the expansion module.
        """
elif False:
    ConfigTemplatesSwitchProfilesPortsModuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigTemplatesSwitchProfilesPortsModuleArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The model of the expansion module.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The model of the expansion module.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)


if not MYPY:
    class ConfigTemplatesSwitchProfilesPortsProfileArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When enabled, override this port's configuration with a port profile.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        When enabled, the ID of the port profile used to override the port's configuration.
        """
        iname: NotRequired[pulumi.Input[_builtins.str]]
        """
        When enabled, the IName of the profile.
        """
elif False:
    ConfigTemplatesSwitchProfilesPortsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigTemplatesSwitchProfilesPortsProfileArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 iname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: When enabled, override this port's configuration with a port profile.
        :param pulumi.Input[_builtins.str] id: When enabled, the ID of the port profile used to override the port's configuration.
        :param pulumi.Input[_builtins.str] iname: When enabled, the IName of the profile.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iname is not None:
            pulumi.set(__self__, "iname", iname)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When enabled, override this port's configuration with a port profile.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When enabled, the ID of the port profile used to override the port's configuration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def iname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When enabled, the IName of the profile.
        """
        return pulumi.get(self, "iname")

    @iname.setter
    def iname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iname", value)


if not MYPY:
    class InventoryClaimItemArgsDict(TypedDict):
        licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input['InventoryClaimItemLicenseArgsDict']]]]
        """
        The licenses claimed
        """
        orders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The numbers of the orders claimed
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The serials of the devices claimed
        """
elif False:
    InventoryClaimItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryClaimItemArgs:
    def __init__(__self__, *,
                 licenses: Optional[pulumi.Input[Sequence[pulumi.Input['InventoryClaimItemLicenseArgs']]]] = None,
                 orders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InventoryClaimItemLicenseArgs']]] licenses: The licenses claimed
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] orders: The numbers of the orders claimed
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: The serials of the devices claimed
        """
        if licenses is not None:
            pulumi.set(__self__, "licenses", licenses)
        if orders is not None:
            pulumi.set(__self__, "orders", orders)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InventoryClaimItemLicenseArgs']]]]:
        """
        The licenses claimed
        """
        return pulumi.get(self, "licenses")

    @licenses.setter
    def licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InventoryClaimItemLicenseArgs']]]]):
        pulumi.set(self, "licenses", value)

    @_builtins.property
    @pulumi.getter
    def orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The numbers of the orders claimed
        """
        return pulumi.get(self, "orders")

    @orders.setter
    def orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "orders", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The serials of the devices claimed
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)


if not MYPY:
    class InventoryClaimItemLicenseArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the license
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The mode of the license
        """
elif False:
    InventoryClaimItemLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryClaimItemLicenseArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the license
        :param pulumi.Input[_builtins.str] mode: The mode of the license
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the license
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The mode of the license
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class InventoryClaimParametersArgsDict(TypedDict):
        licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input['InventoryClaimParametersLicenseArgsDict']]]]
        """
        The licenses that should be claimed
        """
        orders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The numbers of the orders that should be claimed
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The serials of the devices that should be claimed
        """
elif False:
    InventoryClaimParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryClaimParametersArgs:
    def __init__(__self__, *,
                 licenses: Optional[pulumi.Input[Sequence[pulumi.Input['InventoryClaimParametersLicenseArgs']]]] = None,
                 orders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InventoryClaimParametersLicenseArgs']]] licenses: The licenses that should be claimed
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] orders: The numbers of the orders that should be claimed
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: The serials of the devices that should be claimed
        """
        if licenses is not None:
            pulumi.set(__self__, "licenses", licenses)
        if orders is not None:
            pulumi.set(__self__, "orders", orders)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InventoryClaimParametersLicenseArgs']]]]:
        """
        The licenses that should be claimed
        """
        return pulumi.get(self, "licenses")

    @licenses.setter
    def licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InventoryClaimParametersLicenseArgs']]]]):
        pulumi.set(self, "licenses", value)

    @_builtins.property
    @pulumi.getter
    def orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The numbers of the orders that should be claimed
        """
        return pulumi.get(self, "orders")

    @orders.setter
    def orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "orders", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The serials of the devices that should be claimed
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)


if not MYPY:
    class InventoryClaimParametersLicenseArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the license
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Co-term licensing only: either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. Does not apply to organizations using per-device licensing model.
        """
elif False:
    InventoryClaimParametersLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryClaimParametersLicenseArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the license
        :param pulumi.Input[_builtins.str] mode: Co-term licensing only: either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. Does not apply to organizations using per-device licensing model.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the license
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Co-term licensing only: either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. Does not apply to organizations using per-device licensing model.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringExportEventsParametersArgsDict(TypedDict):
        log_event: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of log event this is recording, e.g. download or opening a banner
        """
        request: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used to describe if this event was the result of a redirect. E.g. a query param if an info banner is being used
        """
        target_os: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the onboarding distro being downloaded
        """
        timestamp: NotRequired[pulumi.Input[_builtins.int]]
        """
        A JavaScript UTC datetime stamp for when the even occurred
        """
elif False:
    InventoryOnboardingCloudMonitoringExportEventsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringExportEventsParametersArgs:
    def __init__(__self__, *,
                 log_event: Optional[pulumi.Input[_builtins.str]] = None,
                 request: Optional[pulumi.Input[_builtins.str]] = None,
                 target_os: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] log_event: The type of log event this is recording, e.g. download or opening a banner
        :param pulumi.Input[_builtins.str] request: Used to describe if this event was the result of a redirect. E.g. a query param if an info banner is being used
        :param pulumi.Input[_builtins.str] target_os: The name of the onboarding distro being downloaded
        :param pulumi.Input[_builtins.int] timestamp: A JavaScript UTC datetime stamp for when the even occurred
        """
        if log_event is not None:
            pulumi.set(__self__, "log_event", log_event)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if target_os is not None:
            pulumi.set(__self__, "target_os", target_os)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="logEvent")
    def log_event(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of log event this is recording, e.g. download or opening a banner
        """
        return pulumi.get(self, "log_event")

    @log_event.setter
    def log_event(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_event", value)

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used to describe if this event was the result of a redirect. E.g. a query param if an info banner is being used
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request", value)

    @_builtins.property
    @pulumi.getter(name="targetOs")
    def target_os(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the onboarding distro being downloaded
        """
        return pulumi.get(self, "target_os")

    @target_os.setter
    def target_os(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_os", value)

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A JavaScript UTC datetime stamp for when the even occurred
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timestamp", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringImportsParametersArgsDict(TypedDict):
        devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersDeviceArgsDict']]]]
        """
        A set of device imports to commit
        """
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersItemArgsDict']]]]
elif False:
    InventoryOnboardingCloudMonitoringImportsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringImportsParametersArgs:
    def __init__(__self__, *,
                 devices: Optional[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersDeviceArgs']]]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersDeviceArgs']]] devices: A set of device imports to commit
        """
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersDeviceArgs']]]]:
        """
        A set of device imports to commit
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersDeviceArgs']]]]):
        pulumi.set(self, "devices", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersItemArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringImportsParametersDeviceArgsDict(TypedDict):
        device_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Import ID from the Import operation
        """
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network Id
        """
        udi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device UDI certificate
        """
elif False:
    InventoryOnboardingCloudMonitoringImportsParametersDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringImportsParametersDeviceArgs:
    def __init__(__self__, *,
                 device_id: Optional[pulumi.Input[_builtins.str]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 udi: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_id: Import ID from the Import operation
        :param pulumi.Input[_builtins.str] network_id: Network Id
        :param pulumi.Input[_builtins.str] udi: Device UDI certificate
        """
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if udi is not None:
            pulumi.set(__self__, "udi", udi)

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Import ID from the Import operation
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_id", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network Id
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter
    def udi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device UDI certificate
        """
        return pulumi.get(self, "udi")

    @udi.setter
    def udi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "udi", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringImportsParametersItemArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersItemItemArgsDict']]]]
        """
        Array of ResponseOrganizationsCreateOrganizationInventoryOnboardingCloudMonitoringImport
        """
elif False:
    InventoryOnboardingCloudMonitoringImportsParametersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringImportsParametersItemArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersItemItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersItemItemArgs']]] items: Array of ResponseOrganizationsCreateOrganizationInventoryOnboardingCloudMonitoringImport
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersItemItemArgs']]]]:
        """
        Array of ResponseOrganizationsCreateOrganizationInventoryOnboardingCloudMonitoringImport
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringImportsParametersItemItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringImportsParametersItemItemArgsDict(TypedDict):
        import_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique id associated with the import of the device
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Response method
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud monitor import status
        """
elif False:
    InventoryOnboardingCloudMonitoringImportsParametersItemItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringImportsParametersItemItemArgs:
    def __init__(__self__, *,
                 import_id: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] import_id: Unique id associated with the import of the device
        :param pulumi.Input[_builtins.str] message: Response method
        :param pulumi.Input[_builtins.str] status: Cloud monitor import status
        """
        if import_id is not None:
            pulumi.set(__self__, "import_id", import_id)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="importId")
    def import_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique id associated with the import of the device
        """
        return pulumi.get(self, "import_id")

    @import_id.setter
    def import_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "import_id", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Response method
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud monitor import status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareItemArgsDict(TypedDict):
        config_params: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsArgsDict']]
        """
        Params used in order to connect to the device
        """
        device_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Import ID from the Import operation
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Message related to whether or not the device was found and can be imported.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The import status of the device
        """
        udi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device UDI certificate
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareItemArgs:
    def __init__(__self__, *,
                 config_params: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsArgs']] = None,
                 device_id: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 udi: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsArgs'] config_params: Params used in order to connect to the device
        :param pulumi.Input[_builtins.str] device_id: Import ID from the Import operation
        :param pulumi.Input[_builtins.str] message: Message related to whether or not the device was found and can be imported.
        :param pulumi.Input[_builtins.str] status: The import status of the device
        :param pulumi.Input[_builtins.str] udi: Device UDI certificate
        """
        if config_params is not None:
            pulumi.set(__self__, "config_params", config_params)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if udi is not None:
            pulumi.set(__self__, "udi", udi)

    @_builtins.property
    @pulumi.getter(name="configParams")
    def config_params(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsArgs']]:
        """
        Params used in order to connect to the device
        """
        return pulumi.get(self, "config_params")

    @config_params.setter
    def config_params(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsArgs']]):
        pulumi.set(self, "config_params", value)

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Import ID from the Import operation
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_id", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Message related to whether or not the device was found and can be imported.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The import status of the device
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def udi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device UDI certificate
        """
        return pulumi.get(self, "udi")

    @udi.setter
    def udi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "udi", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareItemConfigParamsArgsDict(TypedDict):
        cloud_static_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Static IP Address used to connect to the device
        """
        tunnel: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelArgsDict']]
        """
        Configuration options used to connect to the device
        """
        user: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserArgsDict']]
        """
        User credentials used to connect to the device
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareItemConfigParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareItemConfigParamsArgs:
    def __init__(__self__, *,
                 cloud_static_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 tunnel: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelArgs']] = None,
                 user: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] cloud_static_ip: Static IP Address used to connect to the device
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelArgs'] tunnel: Configuration options used to connect to the device
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserArgs'] user: User credentials used to connect to the device
        """
        if cloud_static_ip is not None:
            pulumi.set(__self__, "cloud_static_ip", cloud_static_ip)
        if tunnel is not None:
            pulumi.set(__self__, "tunnel", tunnel)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter(name="cloudStaticIp")
    def cloud_static_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Static IP Address used to connect to the device
        """
        return pulumi.get(self, "cloud_static_ip")

    @cloud_static_ip.setter
    def cloud_static_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloud_static_ip", value)

    @_builtins.property
    @pulumi.getter
    def tunnel(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelArgs']]:
        """
        Configuration options used to connect to the device
        """
        return pulumi.get(self, "tunnel")

    @tunnel.setter
    def tunnel(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelArgs']]):
        pulumi.set(self, "tunnel", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserArgs']]:
        """
        User credentials used to connect to the device
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserArgs']]):
        pulumi.set(self, "user", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        SSH tunnel URL used to connect to the device
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the tunnel we are attempting to connect to
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port used for the ssh tunnel.
        """
        root_certificate: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificateArgsDict']]
        """
        Root certificate information
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 root_certificate: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificateArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] host: SSH tunnel URL used to connect to the device
        :param pulumi.Input[_builtins.str] name: The name of the tunnel we are attempting to connect to
        :param pulumi.Input[_builtins.str] port: The port used for the ssh tunnel.
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificateArgs'] root_certificate: Root certificate information
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if root_certificate is not None:
            pulumi.set(__self__, "root_certificate", root_certificate)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SSH tunnel URL used to connect to the device
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the tunnel we are attempting to connect to
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port used for the ssh tunnel.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="rootCertificate")
    def root_certificate(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificateArgs']]:
        """
        Root certificate information
        """
        return pulumi.get(self, "root_certificate")

    @root_certificate.setter
    def root_certificate(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificateArgs']]):
        pulumi.set(self, "root_certificate", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificateArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public certificate value
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the server protected by the certificate
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificateArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content: Public certificate value
        :param pulumi.Input[_builtins.str] name: The name of the server protected by the certificate
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public certificate value
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the server protected by the certificate
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserArgsDict(TypedDict):
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public key for the registered user
        """
        secret: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecretArgsDict']]
        """
        Stores the user secret hash
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username added to Catalyst device
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserArgs:
    def __init__(__self__, *,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecretArgs']] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] public_key: The public key for the registered user
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecretArgs'] secret: Stores the user secret hash
        :param pulumi.Input[_builtins.str] username: The username added to Catalyst device
        """
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public key for the registered user
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecretArgs']]:
        """
        Stores the user secret hash
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username added to Catalyst device
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecretArgsDict(TypedDict):
        hash: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hashed secret
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecretArgs:
    def __init__(__self__, *,
                 hash: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hash: The hashed secret
        """
        if hash is not None:
            pulumi.set(__self__, "hash", hash)

    @_builtins.property
    @pulumi.getter
    def hash(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hashed secret
        """
        return pulumi.get(self, "hash")

    @hash.setter
    def hash(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hash", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareParametersArgsDict(TypedDict):
        devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceArgsDict']]]]
        """
        A set of devices to import (or update)
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareParametersArgs:
    def __init__(__self__, *,
                 devices: Optional[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceArgs']]] devices: A set of devices to import (or update)
        """
        if devices is not None:
            pulumi.set(__self__, "devices", devices)

    @_builtins.property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceArgs']]]]:
        """
        A set of devices to import (or update)
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceArgs']]]]):
        pulumi.set(self, "devices", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareParametersDeviceArgsDict(TypedDict):
        sudi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device SUDI certificate
        """
        tunnel: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnelArgsDict']]
        """
        TLS Related Parameters
        """
        user: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceUserArgsDict']]
        """
        User parameters
        """
        vty: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyArgsDict']]
        """
        VTY Related Parameters
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareParametersDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareParametersDeviceArgs:
    def __init__(__self__, *,
                 sudi: Optional[pulumi.Input[_builtins.str]] = None,
                 tunnel: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnelArgs']] = None,
                 user: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceUserArgs']] = None,
                 vty: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] sudi: Device SUDI certificate
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnelArgs'] tunnel: TLS Related Parameters
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceUserArgs'] user: User parameters
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyArgs'] vty: VTY Related Parameters
        """
        if sudi is not None:
            pulumi.set(__self__, "sudi", sudi)
        if tunnel is not None:
            pulumi.set(__self__, "tunnel", tunnel)
        if user is not None:
            pulumi.set(__self__, "user", user)
        if vty is not None:
            pulumi.set(__self__, "vty", vty)

    @_builtins.property
    @pulumi.getter
    def sudi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device SUDI certificate
        """
        return pulumi.get(self, "sudi")

    @sudi.setter
    def sudi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sudi", value)

    @_builtins.property
    @pulumi.getter
    def tunnel(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnelArgs']]:
        """
        TLS Related Parameters
        """
        return pulumi.get(self, "tunnel")

    @tunnel.setter
    def tunnel(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnelArgs']]):
        pulumi.set(self, "tunnel", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceUserArgs']]:
        """
        User parameters
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceUserArgs']]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter
    def vty(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyArgs']]:
        """
        VTY Related Parameters
        """
        return pulumi.get(self, "vty")

    @vty.setter
    def vty(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyArgs']]):
        pulumi.set(self, "vty", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnelArgsDict(TypedDict):
        certificate_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the configured TLS certificate
        """
        local_interface: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of the vlan expected to be used to connect to the cloud
        """
        loopback_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of the configured Loopback Interface used for TLS overlay
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the configured TLS tunnel
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnelArgs:
    def __init__(__self__, *,
                 certificate_name: Optional[pulumi.Input[_builtins.str]] = None,
                 local_interface: Optional[pulumi.Input[_builtins.int]] = None,
                 loopback_number: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate_name: Name of the configured TLS certificate
        :param pulumi.Input[_builtins.int] local_interface: Number of the vlan expected to be used to connect to the cloud
        :param pulumi.Input[_builtins.int] loopback_number: Number of the configured Loopback Interface used for TLS overlay
        :param pulumi.Input[_builtins.str] name: Name of the configured TLS tunnel
        """
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if local_interface is not None:
            pulumi.set(__self__, "local_interface", local_interface)
        if loopback_number is not None:
            pulumi.set(__self__, "loopback_number", loopback_number)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the configured TLS certificate
        """
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_name", value)

    @_builtins.property
    @pulumi.getter(name="localInterface")
    def local_interface(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of the vlan expected to be used to connect to the cloud
        """
        return pulumi.get(self, "local_interface")

    @local_interface.setter
    def local_interface(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_interface", value)

    @_builtins.property
    @pulumi.getter(name="loopbackNumber")
    def loopback_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of the configured Loopback Interface used for TLS overlay
        """
        return pulumi.get(self, "loopback_number")

    @loopback_number.setter
    def loopback_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "loopback_number", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the configured TLS tunnel
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareParametersDeviceUserArgsDict(TypedDict):
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the device user for Meraki monitoring
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareParametersDeviceUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareParametersDeviceUserArgs:
    def __init__(__self__, *,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] username: The name of the device user for Meraki monitoring
        """
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the device user for Meraki monitoring
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListArgsDict']]
        """
        AccessList details
        """
        authentication: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationArgsDict']]
        """
        VTY AAA authentication
        """
        authorization: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationArgsDict']]
        """
        VTY AAA authorization
        """
        end_line_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ending line VTY number
        """
        rotary_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        SSH rotary number
        """
        start_line_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Starting line VTY number
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListArgs']] = None,
                 authentication: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationArgs']] = None,
                 authorization: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationArgs']] = None,
                 end_line_number: Optional[pulumi.Input[_builtins.int]] = None,
                 rotary_number: Optional[pulumi.Input[_builtins.int]] = None,
                 start_line_number: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListArgs'] access_list: AccessList details
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationArgs'] authentication: VTY AAA authentication
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationArgs'] authorization: VTY AAA authorization
        :param pulumi.Input[_builtins.int] end_line_number: Ending line VTY number
        :param pulumi.Input[_builtins.int] rotary_number: SSH rotary number
        :param pulumi.Input[_builtins.int] start_line_number: Starting line VTY number
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if end_line_number is not None:
            pulumi.set(__self__, "end_line_number", end_line_number)
        if rotary_number is not None:
            pulumi.set(__self__, "rotary_number", rotary_number)
        if start_line_number is not None:
            pulumi.set(__self__, "start_line_number", start_line_number)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListArgs']]:
        """
        AccessList details
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListArgs']]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationArgs']]:
        """
        VTY AAA authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationArgs']]:
        """
        VTY AAA authorization
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @_builtins.property
    @pulumi.getter(name="endLineNumber")
    def end_line_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ending line VTY number
        """
        return pulumi.get(self, "end_line_number")

    @end_line_number.setter
    def end_line_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_line_number", value)

    @_builtins.property
    @pulumi.getter(name="rotaryNumber")
    def rotary_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        SSH rotary number
        """
        return pulumi.get(self, "rotary_number")

    @rotary_number.setter
    def rotary_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rotary_number", value)

    @_builtins.property
    @pulumi.getter(name="startLineNumber")
    def start_line_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Starting line VTY number
        """
        return pulumi.get(self, "start_line_number")

    @start_line_number.setter
    def start_line_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_line_number", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListArgsDict(TypedDict):
        vty_in: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyInArgsDict']]
        """
        VTY in ACL
        """
        vty_out: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOutArgsDict']]
        """
        VTY out ACL
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListArgs:
    def __init__(__self__, *,
                 vty_in: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyInArgs']] = None,
                 vty_out: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOutArgs']] = None):
        """
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyInArgs'] vty_in: VTY in ACL
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOutArgs'] vty_out: VTY out ACL
        """
        if vty_in is not None:
            pulumi.set(__self__, "vty_in", vty_in)
        if vty_out is not None:
            pulumi.set(__self__, "vty_out", vty_out)

    @_builtins.property
    @pulumi.getter(name="vtyIn")
    def vty_in(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyInArgs']]:
        """
        VTY in ACL
        """
        return pulumi.get(self, "vty_in")

    @vty_in.setter
    def vty_in(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyInArgs']]):
        pulumi.set(self, "vty_in", value)

    @_builtins.property
    @pulumi.getter(name="vtyOut")
    def vty_out(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOutArgs']]:
        """
        VTY out ACL
        """
        return pulumi.get(self, "vty_out")

    @vty_out.setter
    def vty_out(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOutArgs']]):
        pulumi.set(self, "vty_out", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyInArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyInArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyInArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOutArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOutArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationArgsDict(TypedDict):
        group: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroupArgsDict']]
        """
        Group Details
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroupArgs']] = None):
        """
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroupArgs'] group: Group Details
        """
        if group is not None:
            pulumi.set(__self__, "group", group)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroupArgs']]:
        """
        Group Details
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroupArgs']]):
        pulumi.set(self, "group", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroupArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group Name
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroupArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Group Name
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationArgsDict(TypedDict):
        group: NotRequired[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroupArgsDict']]
        """
        Group Details
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroupArgs']] = None):
        """
        :param pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroupArgs'] group: Group Details
        """
        if group is not None:
            pulumi.set(__self__, "group", group)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroupArgs']]:
        """
        Group Details
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroupArgs']]):
        pulumi.set(self, "group", value)


if not MYPY:
    class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroupArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group Name
        """
elif False:
    InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroupArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Group Name
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InventoryReleaseItemArgsDict(TypedDict):
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Serials of the devices that were released
        """
elif False:
    InventoryReleaseItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryReleaseItemArgs:
    def __init__(__self__, *,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: Serials of the devices that were released
        """
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Serials of the devices that were released
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)


if not MYPY:
    class InventoryReleaseParametersArgsDict(TypedDict):
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Serials of the devices that should be released
        """
elif False:
    InventoryReleaseParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryReleaseParametersArgs:
    def __init__(__self__, *,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: Serials of the devices that should be released
        """
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Serials of the devices that should be released
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)


if not MYPY:
    class LicensesAssignSeatsItemArgsDict(TypedDict):
        resulting_licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LicensesAssignSeatsItemResultingLicenseArgsDict']]]]
        """
        Resulting licenses from the move
        """
elif False:
    LicensesAssignSeatsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesAssignSeatsItemArgs:
    def __init__(__self__, *,
                 resulting_licenses: Optional[pulumi.Input[Sequence[pulumi.Input['LicensesAssignSeatsItemResultingLicenseArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LicensesAssignSeatsItemResultingLicenseArgs']]] resulting_licenses: Resulting licenses from the move
        """
        if resulting_licenses is not None:
            pulumi.set(__self__, "resulting_licenses", resulting_licenses)

    @_builtins.property
    @pulumi.getter(name="resultingLicenses")
    def resulting_licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LicensesAssignSeatsItemResultingLicenseArgs']]]]:
        """
        Resulting licenses from the move
        """
        return pulumi.get(self, "resulting_licenses")

    @resulting_licenses.setter
    def resulting_licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LicensesAssignSeatsItemResultingLicenseArgs']]]]):
        pulumi.set(self, "resulting_licenses", value)


if not MYPY:
    class LicensesAssignSeatsItemResultingLicenseArgsDict(TypedDict):
        activation_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date the license started burning
        """
        claim_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date the license was claimed into the organization
        """
        device_serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Serial number of the device the license is assigned to
        """
        duration_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration of the individual license
        """
        expiration_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date the license will expire
        """
        head_license_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the head license this license is queued behind. If there is no head license, it returns nil.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        License ID
        """
        license_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        License key
        """
        license_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        License type
        """
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the network the license is assigned to
        """
        order_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Order number
        """
        permanently_queued_licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicenseArgsDict']]]]
        """
        DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
        """
        seat_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seats of the license. Only applicable to SM licenses.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the license. All queued licenses have a status of *recentlyQueued*.
        """
        total_duration_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration of the license plus all permanently queued licenses associated with it
        """
elif False:
    LicensesAssignSeatsItemResultingLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesAssignSeatsItemResultingLicenseArgs:
    def __init__(__self__, *,
                 activation_date: Optional[pulumi.Input[_builtins.str]] = None,
                 claim_date: Optional[pulumi.Input[_builtins.str]] = None,
                 device_serial: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 expiration_date: Optional[pulumi.Input[_builtins.str]] = None,
                 head_license_id: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 license_key: Optional[pulumi.Input[_builtins.str]] = None,
                 license_type: Optional[pulumi.Input[_builtins.str]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 order_number: Optional[pulumi.Input[_builtins.str]] = None,
                 permanently_queued_licenses: Optional[pulumi.Input[Sequence[pulumi.Input['LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicenseArgs']]]] = None,
                 seat_count: Optional[pulumi.Input[_builtins.int]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 total_duration_in_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] activation_date: The date the license started burning
        :param pulumi.Input[_builtins.str] claim_date: The date the license was claimed into the organization
        :param pulumi.Input[_builtins.str] device_serial: Serial number of the device the license is assigned to
        :param pulumi.Input[_builtins.int] duration_in_days: The duration of the individual license
        :param pulumi.Input[_builtins.str] expiration_date: The date the license will expire
        :param pulumi.Input[_builtins.str] head_license_id: The id of the head license this license is queued behind. If there is no head license, it returns nil.
        :param pulumi.Input[_builtins.str] id: License ID
        :param pulumi.Input[_builtins.str] license_key: License key
        :param pulumi.Input[_builtins.str] license_type: License type
        :param pulumi.Input[_builtins.str] network_id: ID of the network the license is assigned to
        :param pulumi.Input[_builtins.str] order_number: Order number
        :param pulumi.Input[Sequence[pulumi.Input['LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicenseArgs']]] permanently_queued_licenses: DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
        :param pulumi.Input[_builtins.int] seat_count: The number of seats of the license. Only applicable to SM licenses.
        :param pulumi.Input[_builtins.str] state: The state of the license. All queued licenses have a status of *recentlyQueued*.
        :param pulumi.Input[_builtins.int] total_duration_in_days: The duration of the license plus all permanently queued licenses associated with it
        """
        if activation_date is not None:
            pulumi.set(__self__, "activation_date", activation_date)
        if claim_date is not None:
            pulumi.set(__self__, "claim_date", claim_date)
        if device_serial is not None:
            pulumi.set(__self__, "device_serial", device_serial)
        if duration_in_days is not None:
            pulumi.set(__self__, "duration_in_days", duration_in_days)
        if expiration_date is not None:
            pulumi.set(__self__, "expiration_date", expiration_date)
        if head_license_id is not None:
            pulumi.set(__self__, "head_license_id", head_license_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if license_key is not None:
            pulumi.set(__self__, "license_key", license_key)
        if license_type is not None:
            pulumi.set(__self__, "license_type", license_type)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if order_number is not None:
            pulumi.set(__self__, "order_number", order_number)
        if permanently_queued_licenses is not None:
            pulumi.set(__self__, "permanently_queued_licenses", permanently_queued_licenses)
        if seat_count is not None:
            pulumi.set(__self__, "seat_count", seat_count)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if total_duration_in_days is not None:
            pulumi.set(__self__, "total_duration_in_days", total_duration_in_days)

    @_builtins.property
    @pulumi.getter(name="activationDate")
    def activation_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date the license started burning
        """
        return pulumi.get(self, "activation_date")

    @activation_date.setter
    def activation_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "activation_date", value)

    @_builtins.property
    @pulumi.getter(name="claimDate")
    def claim_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date the license was claimed into the organization
        """
        return pulumi.get(self, "claim_date")

    @claim_date.setter
    def claim_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "claim_date", value)

    @_builtins.property
    @pulumi.getter(name="deviceSerial")
    def device_serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Serial number of the device the license is assigned to
        """
        return pulumi.get(self, "device_serial")

    @device_serial.setter
    def device_serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_serial", value)

    @_builtins.property
    @pulumi.getter(name="durationInDays")
    def duration_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration of the individual license
        """
        return pulumi.get(self, "duration_in_days")

    @duration_in_days.setter
    def duration_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_days", value)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date the license will expire
        """
        return pulumi.get(self, "expiration_date")

    @expiration_date.setter
    def expiration_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiration_date", value)

    @_builtins.property
    @pulumi.getter(name="headLicenseId")
    def head_license_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the head license this license is queued behind. If there is no head license, it returns nil.
        """
        return pulumi.get(self, "head_license_id")

    @head_license_id.setter
    def head_license_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "head_license_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License key
        """
        return pulumi.get(self, "license_key")

    @license_key.setter
    def license_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_key", value)

    @_builtins.property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License type
        """
        return pulumi.get(self, "license_type")

    @license_type.setter
    def license_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_type", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the network the license is assigned to
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter(name="orderNumber")
    def order_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Order number
        """
        return pulumi.get(self, "order_number")

    @order_number.setter
    def order_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "order_number", value)

    @_builtins.property
    @pulumi.getter(name="permanentlyQueuedLicenses")
    def permanently_queued_licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicenseArgs']]]]:
        """
        DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
        """
        return pulumi.get(self, "permanently_queued_licenses")

    @permanently_queued_licenses.setter
    def permanently_queued_licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicenseArgs']]]]):
        pulumi.set(self, "permanently_queued_licenses", value)

    @_builtins.property
    @pulumi.getter(name="seatCount")
    def seat_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seats of the license. Only applicable to SM licenses.
        """
        return pulumi.get(self, "seat_count")

    @seat_count.setter
    def seat_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "seat_count", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the license. All queued licenses have a status of *recentlyQueued*.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="totalDurationInDays")
    def total_duration_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration of the license plus all permanently queued licenses associated with it
        """
        return pulumi.get(self, "total_duration_in_days")

    @total_duration_in_days.setter
    def total_duration_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_duration_in_days", value)


if not MYPY:
    class LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicenseArgsDict(TypedDict):
        duration_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration of the individual license
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Permanently queued license ID
        """
        license_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        License key
        """
        license_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        License type
        """
        order_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Order number
        """
elif False:
    LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicenseArgs:
    def __init__(__self__, *,
                 duration_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 license_key: Optional[pulumi.Input[_builtins.str]] = None,
                 license_type: Optional[pulumi.Input[_builtins.str]] = None,
                 order_number: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] duration_in_days: The duration of the individual license
        :param pulumi.Input[_builtins.str] id: Permanently queued license ID
        :param pulumi.Input[_builtins.str] license_key: License key
        :param pulumi.Input[_builtins.str] license_type: License type
        :param pulumi.Input[_builtins.str] order_number: Order number
        """
        if duration_in_days is not None:
            pulumi.set(__self__, "duration_in_days", duration_in_days)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if license_key is not None:
            pulumi.set(__self__, "license_key", license_key)
        if license_type is not None:
            pulumi.set(__self__, "license_type", license_type)
        if order_number is not None:
            pulumi.set(__self__, "order_number", order_number)

    @_builtins.property
    @pulumi.getter(name="durationInDays")
    def duration_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration of the individual license
        """
        return pulumi.get(self, "duration_in_days")

    @duration_in_days.setter
    def duration_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_days", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Permanently queued license ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License key
        """
        return pulumi.get(self, "license_key")

    @license_key.setter
    def license_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_key", value)

    @_builtins.property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License type
        """
        return pulumi.get(self, "license_type")

    @license_type.setter
    def license_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_type", value)

    @_builtins.property
    @pulumi.getter(name="orderNumber")
    def order_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Order number
        """
        return pulumi.get(self, "order_number")

    @order_number.setter
    def order_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "order_number", value)


if not MYPY:
    class LicensesAssignSeatsParametersArgsDict(TypedDict):
        license_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the SM license to assign seats from
        """
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the SM network to assign the seats to
        """
        seat_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seats to assign to the SM network. Must be less than or equal to the total number of seats of the license
        """
elif False:
    LicensesAssignSeatsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesAssignSeatsParametersArgs:
    def __init__(__self__, *,
                 license_id: Optional[pulumi.Input[_builtins.str]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 seat_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] license_id: The ID of the SM license to assign seats from
        :param pulumi.Input[_builtins.str] network_id: The ID of the SM network to assign the seats to
        :param pulumi.Input[_builtins.int] seat_count: The number of seats to assign to the SM network. Must be less than or equal to the total number of seats of the license
        """
        if license_id is not None:
            pulumi.set(__self__, "license_id", license_id)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if seat_count is not None:
            pulumi.set(__self__, "seat_count", seat_count)

    @_builtins.property
    @pulumi.getter(name="licenseId")
    def license_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the SM license to assign seats from
        """
        return pulumi.get(self, "license_id")

    @license_id.setter
    def license_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_id", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the SM network to assign the seats to
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter(name="seatCount")
    def seat_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seats to assign to the SM network. Must be less than or equal to the total number of seats of the license
        """
        return pulumi.get(self, "seat_count")

    @seat_count.setter
    def seat_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "seat_count", value)


if not MYPY:
    class LicensesMoveItemArgsDict(TypedDict):
        dest_organization_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the organization to move the licenses to
        """
        license_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of IDs of licenses to move to the new organization
        """
elif False:
    LicensesMoveItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesMoveItemArgs:
    def __init__(__self__, *,
                 dest_organization_id: Optional[pulumi.Input[_builtins.str]] = None,
                 license_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] dest_organization_id: The ID of the organization to move the licenses to
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] license_ids: A list of IDs of licenses to move to the new organization
        """
        if dest_organization_id is not None:
            pulumi.set(__self__, "dest_organization_id", dest_organization_id)
        if license_ids is not None:
            pulumi.set(__self__, "license_ids", license_ids)

    @_builtins.property
    @pulumi.getter(name="destOrganizationId")
    def dest_organization_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the organization to move the licenses to
        """
        return pulumi.get(self, "dest_organization_id")

    @dest_organization_id.setter
    def dest_organization_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_organization_id", value)

    @_builtins.property
    @pulumi.getter(name="licenseIds")
    def license_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IDs of licenses to move to the new organization
        """
        return pulumi.get(self, "license_ids")

    @license_ids.setter
    def license_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "license_ids", value)


if not MYPY:
    class LicensesMoveParametersArgsDict(TypedDict):
        dest_organization_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the organization to move the licenses to
        """
        license_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of IDs of licenses to move to the new organization
        """
elif False:
    LicensesMoveParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesMoveParametersArgs:
    def __init__(__self__, *,
                 dest_organization_id: Optional[pulumi.Input[_builtins.str]] = None,
                 license_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] dest_organization_id: The ID of the organization to move the licenses to
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] license_ids: A list of IDs of licenses to move to the new organization
        """
        if dest_organization_id is not None:
            pulumi.set(__self__, "dest_organization_id", dest_organization_id)
        if license_ids is not None:
            pulumi.set(__self__, "license_ids", license_ids)

    @_builtins.property
    @pulumi.getter(name="destOrganizationId")
    def dest_organization_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the organization to move the licenses to
        """
        return pulumi.get(self, "dest_organization_id")

    @dest_organization_id.setter
    def dest_organization_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_organization_id", value)

    @_builtins.property
    @pulumi.getter(name="licenseIds")
    def license_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IDs of licenses to move to the new organization
        """
        return pulumi.get(self, "license_ids")

    @license_ids.setter
    def license_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "license_ids", value)


if not MYPY:
    class LicensesMoveSeatsItemArgsDict(TypedDict):
        dest_organization_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the organization to move the SM seats to
        """
        license_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the SM license to move the seats from
        """
        seat_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
        """
elif False:
    LicensesMoveSeatsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesMoveSeatsItemArgs:
    def __init__(__self__, *,
                 dest_organization_id: Optional[pulumi.Input[_builtins.str]] = None,
                 license_id: Optional[pulumi.Input[_builtins.str]] = None,
                 seat_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] dest_organization_id: The ID of the organization to move the SM seats to
        :param pulumi.Input[_builtins.str] license_id: The ID of the SM license to move the seats from
        :param pulumi.Input[_builtins.int] seat_count: The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
        """
        if dest_organization_id is not None:
            pulumi.set(__self__, "dest_organization_id", dest_organization_id)
        if license_id is not None:
            pulumi.set(__self__, "license_id", license_id)
        if seat_count is not None:
            pulumi.set(__self__, "seat_count", seat_count)

    @_builtins.property
    @pulumi.getter(name="destOrganizationId")
    def dest_organization_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the organization to move the SM seats to
        """
        return pulumi.get(self, "dest_organization_id")

    @dest_organization_id.setter
    def dest_organization_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_organization_id", value)

    @_builtins.property
    @pulumi.getter(name="licenseId")
    def license_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the SM license to move the seats from
        """
        return pulumi.get(self, "license_id")

    @license_id.setter
    def license_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_id", value)

    @_builtins.property
    @pulumi.getter(name="seatCount")
    def seat_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
        """
        return pulumi.get(self, "seat_count")

    @seat_count.setter
    def seat_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "seat_count", value)


if not MYPY:
    class LicensesMoveSeatsParametersArgsDict(TypedDict):
        dest_organization_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the organization to move the SM seats to
        """
        license_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the SM license to move the seats from
        """
        seat_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
        """
elif False:
    LicensesMoveSeatsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesMoveSeatsParametersArgs:
    def __init__(__self__, *,
                 dest_organization_id: Optional[pulumi.Input[_builtins.str]] = None,
                 license_id: Optional[pulumi.Input[_builtins.str]] = None,
                 seat_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] dest_organization_id: The ID of the organization to move the SM seats to
        :param pulumi.Input[_builtins.str] license_id: The ID of the SM license to move the seats from
        :param pulumi.Input[_builtins.int] seat_count: The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
        """
        if dest_organization_id is not None:
            pulumi.set(__self__, "dest_organization_id", dest_organization_id)
        if license_id is not None:
            pulumi.set(__self__, "license_id", license_id)
        if seat_count is not None:
            pulumi.set(__self__, "seat_count", seat_count)

    @_builtins.property
    @pulumi.getter(name="destOrganizationId")
    def dest_organization_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the organization to move the SM seats to
        """
        return pulumi.get(self, "dest_organization_id")

    @dest_organization_id.setter
    def dest_organization_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_organization_id", value)

    @_builtins.property
    @pulumi.getter(name="licenseId")
    def license_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the SM license to move the seats from
        """
        return pulumi.get(self, "license_id")

    @license_id.setter
    def license_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_id", value)

    @_builtins.property
    @pulumi.getter(name="seatCount")
    def seat_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
        """
        return pulumi.get(self, "seat_count")

    @seat_count.setter
    def seat_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "seat_count", value)


if not MYPY:
    class LicensesPermanentlyQueuedLicenseArgsDict(TypedDict):
        duration_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration of the individual license
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Permanently queued license ID
        """
        license_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        License key
        """
        license_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        License type
        """
        order_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Order number
        """
elif False:
    LicensesPermanentlyQueuedLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesPermanentlyQueuedLicenseArgs:
    def __init__(__self__, *,
                 duration_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 license_key: Optional[pulumi.Input[_builtins.str]] = None,
                 license_type: Optional[pulumi.Input[_builtins.str]] = None,
                 order_number: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] duration_in_days: The duration of the individual license
        :param pulumi.Input[_builtins.str] id: Permanently queued license ID
        :param pulumi.Input[_builtins.str] license_key: License key
        :param pulumi.Input[_builtins.str] license_type: License type
        :param pulumi.Input[_builtins.str] order_number: Order number
        """
        if duration_in_days is not None:
            pulumi.set(__self__, "duration_in_days", duration_in_days)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if license_key is not None:
            pulumi.set(__self__, "license_key", license_key)
        if license_type is not None:
            pulumi.set(__self__, "license_type", license_type)
        if order_number is not None:
            pulumi.set(__self__, "order_number", order_number)

    @_builtins.property
    @pulumi.getter(name="durationInDays")
    def duration_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration of the individual license
        """
        return pulumi.get(self, "duration_in_days")

    @duration_in_days.setter
    def duration_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_days", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Permanently queued license ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License key
        """
        return pulumi.get(self, "license_key")

    @license_key.setter
    def license_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_key", value)

    @_builtins.property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License type
        """
        return pulumi.get(self, "license_type")

    @license_type.setter
    def license_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_type", value)

    @_builtins.property
    @pulumi.getter(name="orderNumber")
    def order_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Order number
        """
        return pulumi.get(self, "order_number")

    @order_number.setter
    def order_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "order_number", value)


if not MYPY:
    class LicensesRenewSeatsItemArgsDict(TypedDict):
        resulting_licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LicensesRenewSeatsItemResultingLicenseArgsDict']]]]
        """
        Resulting licenses from the move
        """
elif False:
    LicensesRenewSeatsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesRenewSeatsItemArgs:
    def __init__(__self__, *,
                 resulting_licenses: Optional[pulumi.Input[Sequence[pulumi.Input['LicensesRenewSeatsItemResultingLicenseArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LicensesRenewSeatsItemResultingLicenseArgs']]] resulting_licenses: Resulting licenses from the move
        """
        if resulting_licenses is not None:
            pulumi.set(__self__, "resulting_licenses", resulting_licenses)

    @_builtins.property
    @pulumi.getter(name="resultingLicenses")
    def resulting_licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LicensesRenewSeatsItemResultingLicenseArgs']]]]:
        """
        Resulting licenses from the move
        """
        return pulumi.get(self, "resulting_licenses")

    @resulting_licenses.setter
    def resulting_licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LicensesRenewSeatsItemResultingLicenseArgs']]]]):
        pulumi.set(self, "resulting_licenses", value)


if not MYPY:
    class LicensesRenewSeatsItemResultingLicenseArgsDict(TypedDict):
        activation_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date the license started burning
        """
        claim_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date the license was claimed into the organization
        """
        device_serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Serial number of the device the license is assigned to
        """
        duration_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration of the individual license
        """
        expiration_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date the license will expire
        """
        head_license_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the head license this license is queued behind. If there is no head license, it returns nil.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        License ID
        """
        license_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        License key
        """
        license_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        License type
        """
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the network the license is assigned to
        """
        order_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Order number
        """
        permanently_queued_licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicenseArgsDict']]]]
        """
        DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
        """
        seat_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seats of the license. Only applicable to SM licenses.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the license. All queued licenses have a status of *recentlyQueued*.
        """
        total_duration_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration of the license plus all permanently queued licenses associated with it
        """
elif False:
    LicensesRenewSeatsItemResultingLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesRenewSeatsItemResultingLicenseArgs:
    def __init__(__self__, *,
                 activation_date: Optional[pulumi.Input[_builtins.str]] = None,
                 claim_date: Optional[pulumi.Input[_builtins.str]] = None,
                 device_serial: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 expiration_date: Optional[pulumi.Input[_builtins.str]] = None,
                 head_license_id: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 license_key: Optional[pulumi.Input[_builtins.str]] = None,
                 license_type: Optional[pulumi.Input[_builtins.str]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 order_number: Optional[pulumi.Input[_builtins.str]] = None,
                 permanently_queued_licenses: Optional[pulumi.Input[Sequence[pulumi.Input['LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicenseArgs']]]] = None,
                 seat_count: Optional[pulumi.Input[_builtins.int]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 total_duration_in_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] activation_date: The date the license started burning
        :param pulumi.Input[_builtins.str] claim_date: The date the license was claimed into the organization
        :param pulumi.Input[_builtins.str] device_serial: Serial number of the device the license is assigned to
        :param pulumi.Input[_builtins.int] duration_in_days: The duration of the individual license
        :param pulumi.Input[_builtins.str] expiration_date: The date the license will expire
        :param pulumi.Input[_builtins.str] head_license_id: The id of the head license this license is queued behind. If there is no head license, it returns nil.
        :param pulumi.Input[_builtins.str] id: License ID
        :param pulumi.Input[_builtins.str] license_key: License key
        :param pulumi.Input[_builtins.str] license_type: License type
        :param pulumi.Input[_builtins.str] network_id: ID of the network the license is assigned to
        :param pulumi.Input[_builtins.str] order_number: Order number
        :param pulumi.Input[Sequence[pulumi.Input['LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicenseArgs']]] permanently_queued_licenses: DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
        :param pulumi.Input[_builtins.int] seat_count: The number of seats of the license. Only applicable to SM licenses.
        :param pulumi.Input[_builtins.str] state: The state of the license. All queued licenses have a status of *recentlyQueued*.
        :param pulumi.Input[_builtins.int] total_duration_in_days: The duration of the license plus all permanently queued licenses associated with it
        """
        if activation_date is not None:
            pulumi.set(__self__, "activation_date", activation_date)
        if claim_date is not None:
            pulumi.set(__self__, "claim_date", claim_date)
        if device_serial is not None:
            pulumi.set(__self__, "device_serial", device_serial)
        if duration_in_days is not None:
            pulumi.set(__self__, "duration_in_days", duration_in_days)
        if expiration_date is not None:
            pulumi.set(__self__, "expiration_date", expiration_date)
        if head_license_id is not None:
            pulumi.set(__self__, "head_license_id", head_license_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if license_key is not None:
            pulumi.set(__self__, "license_key", license_key)
        if license_type is not None:
            pulumi.set(__self__, "license_type", license_type)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if order_number is not None:
            pulumi.set(__self__, "order_number", order_number)
        if permanently_queued_licenses is not None:
            pulumi.set(__self__, "permanently_queued_licenses", permanently_queued_licenses)
        if seat_count is not None:
            pulumi.set(__self__, "seat_count", seat_count)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if total_duration_in_days is not None:
            pulumi.set(__self__, "total_duration_in_days", total_duration_in_days)

    @_builtins.property
    @pulumi.getter(name="activationDate")
    def activation_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date the license started burning
        """
        return pulumi.get(self, "activation_date")

    @activation_date.setter
    def activation_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "activation_date", value)

    @_builtins.property
    @pulumi.getter(name="claimDate")
    def claim_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date the license was claimed into the organization
        """
        return pulumi.get(self, "claim_date")

    @claim_date.setter
    def claim_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "claim_date", value)

    @_builtins.property
    @pulumi.getter(name="deviceSerial")
    def device_serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Serial number of the device the license is assigned to
        """
        return pulumi.get(self, "device_serial")

    @device_serial.setter
    def device_serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_serial", value)

    @_builtins.property
    @pulumi.getter(name="durationInDays")
    def duration_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration of the individual license
        """
        return pulumi.get(self, "duration_in_days")

    @duration_in_days.setter
    def duration_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_days", value)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date the license will expire
        """
        return pulumi.get(self, "expiration_date")

    @expiration_date.setter
    def expiration_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiration_date", value)

    @_builtins.property
    @pulumi.getter(name="headLicenseId")
    def head_license_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the head license this license is queued behind. If there is no head license, it returns nil.
        """
        return pulumi.get(self, "head_license_id")

    @head_license_id.setter
    def head_license_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "head_license_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License key
        """
        return pulumi.get(self, "license_key")

    @license_key.setter
    def license_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_key", value)

    @_builtins.property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License type
        """
        return pulumi.get(self, "license_type")

    @license_type.setter
    def license_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_type", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the network the license is assigned to
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter(name="orderNumber")
    def order_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Order number
        """
        return pulumi.get(self, "order_number")

    @order_number.setter
    def order_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "order_number", value)

    @_builtins.property
    @pulumi.getter(name="permanentlyQueuedLicenses")
    def permanently_queued_licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicenseArgs']]]]:
        """
        DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
        """
        return pulumi.get(self, "permanently_queued_licenses")

    @permanently_queued_licenses.setter
    def permanently_queued_licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicenseArgs']]]]):
        pulumi.set(self, "permanently_queued_licenses", value)

    @_builtins.property
    @pulumi.getter(name="seatCount")
    def seat_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seats of the license. Only applicable to SM licenses.
        """
        return pulumi.get(self, "seat_count")

    @seat_count.setter
    def seat_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "seat_count", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the license. All queued licenses have a status of *recentlyQueued*.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="totalDurationInDays")
    def total_duration_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration of the license plus all permanently queued licenses associated with it
        """
        return pulumi.get(self, "total_duration_in_days")

    @total_duration_in_days.setter
    def total_duration_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_duration_in_days", value)


if not MYPY:
    class LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicenseArgsDict(TypedDict):
        duration_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration of the individual license
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Permanently queued license ID
        """
        license_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        License key
        """
        license_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        License type
        """
        order_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Order number
        """
elif False:
    LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicenseArgs:
    def __init__(__self__, *,
                 duration_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 license_key: Optional[pulumi.Input[_builtins.str]] = None,
                 license_type: Optional[pulumi.Input[_builtins.str]] = None,
                 order_number: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] duration_in_days: The duration of the individual license
        :param pulumi.Input[_builtins.str] id: Permanently queued license ID
        :param pulumi.Input[_builtins.str] license_key: License key
        :param pulumi.Input[_builtins.str] license_type: License type
        :param pulumi.Input[_builtins.str] order_number: Order number
        """
        if duration_in_days is not None:
            pulumi.set(__self__, "duration_in_days", duration_in_days)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if license_key is not None:
            pulumi.set(__self__, "license_key", license_key)
        if license_type is not None:
            pulumi.set(__self__, "license_type", license_type)
        if order_number is not None:
            pulumi.set(__self__, "order_number", order_number)

    @_builtins.property
    @pulumi.getter(name="durationInDays")
    def duration_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration of the individual license
        """
        return pulumi.get(self, "duration_in_days")

    @duration_in_days.setter
    def duration_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_days", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Permanently queued license ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License key
        """
        return pulumi.get(self, "license_key")

    @license_key.setter
    def license_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_key", value)

    @_builtins.property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License type
        """
        return pulumi.get(self, "license_type")

    @license_type.setter
    def license_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_type", value)

    @_builtins.property
    @pulumi.getter(name="orderNumber")
    def order_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Order number
        """
        return pulumi.get(self, "order_number")

    @order_number.setter
    def order_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "order_number", value)


if not MYPY:
    class LicensesRenewSeatsParametersArgsDict(TypedDict):
        license_id_to_renew: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the SM license to renew. This license must already be assigned to an SM network
        """
        unused_license_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SM license to use to renew the seats on 'licenseIdToRenew'. This license must have at least as many seats available as there are seats on 'licenseIdToRenew'
        """
elif False:
    LicensesRenewSeatsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensesRenewSeatsParametersArgs:
    def __init__(__self__, *,
                 license_id_to_renew: Optional[pulumi.Input[_builtins.str]] = None,
                 unused_license_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] license_id_to_renew: The ID of the SM license to renew. This license must already be assigned to an SM network
        :param pulumi.Input[_builtins.str] unused_license_id: The SM license to use to renew the seats on 'licenseIdToRenew'. This license must have at least as many seats available as there are seats on 'licenseIdToRenew'
        """
        if license_id_to_renew is not None:
            pulumi.set(__self__, "license_id_to_renew", license_id_to_renew)
        if unused_license_id is not None:
            pulumi.set(__self__, "unused_license_id", unused_license_id)

    @_builtins.property
    @pulumi.getter(name="licenseIdToRenew")
    def license_id_to_renew(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the SM license to renew. This license must already be assigned to an SM network
        """
        return pulumi.get(self, "license_id_to_renew")

    @license_id_to_renew.setter
    def license_id_to_renew(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_id_to_renew", value)

    @_builtins.property
    @pulumi.getter(name="unusedLicenseId")
    def unused_license_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SM license to use to renew the seats on 'licenseIdToRenew'. This license must have at least as many seats available as there are seats on 'licenseIdToRenew'
        """
        return pulumi.get(self, "unused_license_id")

    @unused_license_id.setter
    def unused_license_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unused_license_id", value)


if not MYPY:
    class LicensingCotermLicensesMoveItemArgsDict(TypedDict):
        moved_licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseArgsDict']]]]
        """
        Newly moved licenses created in the destination organization of the license move operation
        """
        remainder_licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseArgsDict']]]]
        """
        Remainder licenses created in the source organization as a result of moving a subset of the counts of a license
        """
elif False:
    LicensingCotermLicensesMoveItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensingCotermLicensesMoveItemArgs:
    def __init__(__self__, *,
                 moved_licenses: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseArgs']]]] = None,
                 remainder_licenses: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseArgs']]] moved_licenses: Newly moved licenses created in the destination organization of the license move operation
        :param pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseArgs']]] remainder_licenses: Remainder licenses created in the source organization as a result of moving a subset of the counts of a license
        """
        if moved_licenses is not None:
            pulumi.set(__self__, "moved_licenses", moved_licenses)
        if remainder_licenses is not None:
            pulumi.set(__self__, "remainder_licenses", remainder_licenses)

    @_builtins.property
    @pulumi.getter(name="movedLicenses")
    def moved_licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseArgs']]]]:
        """
        Newly moved licenses created in the destination organization of the license move operation
        """
        return pulumi.get(self, "moved_licenses")

    @moved_licenses.setter
    def moved_licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseArgs']]]]):
        pulumi.set(self, "moved_licenses", value)

    @_builtins.property
    @pulumi.getter(name="remainderLicenses")
    def remainder_licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseArgs']]]]:
        """
        Remainder licenses created in the source organization as a result of moving a subset of the counts of a license
        """
        return pulumi.get(self, "remainder_licenses")

    @remainder_licenses.setter
    def remainder_licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseArgs']]]]):
        pulumi.set(self, "remainder_licenses", value)


if not MYPY:
    class LicensingCotermLicensesMoveItemMovedLicenseArgsDict(TypedDict):
        claimed_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the license was claimed into the organization
        """
        counts: NotRequired[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseCountArgsDict']]]]
        """
        The counts of the license by model type
        """
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration (term length) of the license, measured in days
        """
        editions: NotRequired[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseEditionArgsDict']]]]
        """
        The editions of the license for each relevant product type
        """
        expired: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag to indicate if the license is expired
        """
        invalidated: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag to indicated that the license is invalidated
        """
        invalidated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the license was invalidated. Will be null for active licenses
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the license
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The operation mode of the license when it was claimed
        """
        organization_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the organization that the license is claimed in
        """
        started_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the license's term began (approximately the date when the license was created)
        """
elif False:
    LicensingCotermLicensesMoveItemMovedLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensingCotermLicensesMoveItemMovedLicenseArgs:
    def __init__(__self__, *,
                 claimed_at: Optional[pulumi.Input[_builtins.str]] = None,
                 counts: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseCountArgs']]]] = None,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 editions: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseEditionArgs']]]] = None,
                 expired: Optional[pulumi.Input[_builtins.bool]] = None,
                 invalidated: Optional[pulumi.Input[_builtins.bool]] = None,
                 invalidated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 organization_id: Optional[pulumi.Input[_builtins.str]] = None,
                 started_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] claimed_at: When the license was claimed into the organization
        :param pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseCountArgs']]] counts: The counts of the license by model type
        :param pulumi.Input[_builtins.int] duration: The duration (term length) of the license, measured in days
        :param pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseEditionArgs']]] editions: The editions of the license for each relevant product type
        :param pulumi.Input[_builtins.bool] expired: Flag to indicate if the license is expired
        :param pulumi.Input[_builtins.bool] invalidated: Flag to indicated that the license is invalidated
        :param pulumi.Input[_builtins.str] invalidated_at: When the license was invalidated. Will be null for active licenses
        :param pulumi.Input[_builtins.str] key: The key of the license
        :param pulumi.Input[_builtins.str] mode: The operation mode of the license when it was claimed
        :param pulumi.Input[_builtins.str] organization_id: The ID of the organization that the license is claimed in
        :param pulumi.Input[_builtins.str] started_at: When the license's term began (approximately the date when the license was created)
        """
        if claimed_at is not None:
            pulumi.set(__self__, "claimed_at", claimed_at)
        if counts is not None:
            pulumi.set(__self__, "counts", counts)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if editions is not None:
            pulumi.set(__self__, "editions", editions)
        if expired is not None:
            pulumi.set(__self__, "expired", expired)
        if invalidated is not None:
            pulumi.set(__self__, "invalidated", invalidated)
        if invalidated_at is not None:
            pulumi.set(__self__, "invalidated_at", invalidated_at)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @_builtins.property
    @pulumi.getter(name="claimedAt")
    def claimed_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the license was claimed into the organization
        """
        return pulumi.get(self, "claimed_at")

    @claimed_at.setter
    def claimed_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "claimed_at", value)

    @_builtins.property
    @pulumi.getter
    def counts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseCountArgs']]]]:
        """
        The counts of the license by model type
        """
        return pulumi.get(self, "counts")

    @counts.setter
    def counts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseCountArgs']]]]):
        pulumi.set(self, "counts", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration (term length) of the license, measured in days
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def editions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseEditionArgs']]]]:
        """
        The editions of the license for each relevant product type
        """
        return pulumi.get(self, "editions")

    @editions.setter
    def editions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemMovedLicenseEditionArgs']]]]):
        pulumi.set(self, "editions", value)

    @_builtins.property
    @pulumi.getter
    def expired(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag to indicate if the license is expired
        """
        return pulumi.get(self, "expired")

    @expired.setter
    def expired(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expired", value)

    @_builtins.property
    @pulumi.getter
    def invalidated(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag to indicated that the license is invalidated
        """
        return pulumi.get(self, "invalidated")

    @invalidated.setter
    def invalidated(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "invalidated", value)

    @_builtins.property
    @pulumi.getter(name="invalidatedAt")
    def invalidated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the license was invalidated. Will be null for active licenses
        """
        return pulumi.get(self, "invalidated_at")

    @invalidated_at.setter
    def invalidated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalidated_at", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the license
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The operation mode of the license when it was claimed
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the organization that the license is claimed in
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_id", value)

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the license's term began (approximately the date when the license was created)
        """
        return pulumi.get(self, "started_at")

    @started_at.setter
    def started_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_at", value)


if not MYPY:
    class LicensingCotermLicensesMoveItemMovedLicenseCountArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of counts the license contains of this model
        """
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The license model type
        """
elif False:
    LicensingCotermLicensesMoveItemMovedLicenseCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensingCotermLicensesMoveItemMovedLicenseCountArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] count: The number of counts the license contains of this model
        :param pulumi.Input[_builtins.str] model: The license model type
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of counts the license contains of this model
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The license model type
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)


if not MYPY:
    class LicensingCotermLicensesMoveItemMovedLicenseEditionArgsDict(TypedDict):
        edition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the license edition
        """
        product_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The product type of the license edition
        """
elif False:
    LicensingCotermLicensesMoveItemMovedLicenseEditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensingCotermLicensesMoveItemMovedLicenseEditionArgs:
    def __init__(__self__, *,
                 edition: Optional[pulumi.Input[_builtins.str]] = None,
                 product_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] edition: The name of the license edition
        :param pulumi.Input[_builtins.str] product_type: The product type of the license edition
        """
        if edition is not None:
            pulumi.set(__self__, "edition", edition)
        if product_type is not None:
            pulumi.set(__self__, "product_type", product_type)

    @_builtins.property
    @pulumi.getter
    def edition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the license edition
        """
        return pulumi.get(self, "edition")

    @edition.setter
    def edition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "edition", value)

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The product type of the license edition
        """
        return pulumi.get(self, "product_type")

    @product_type.setter
    def product_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "product_type", value)


if not MYPY:
    class LicensingCotermLicensesMoveItemRemainderLicenseArgsDict(TypedDict):
        claimed_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the license was claimed into the organization
        """
        counts: NotRequired[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseCountArgsDict']]]]
        """
        The counts of the license by model type
        """
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration (term length) of the license, measured in days
        """
        editions: NotRequired[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseEditionArgsDict']]]]
        """
        The editions of the license for each relevant product type
        """
        expired: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag to indicate if the license is expired
        """
        invalidated: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag to indicated that the license is invalidated
        """
        invalidated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the license was invalidated. Will be null for active licenses
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the license
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The operation mode of the license when it was claimed
        """
        organization_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the organization that the license is claimed in
        """
        started_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the license's term began (approximately the date when the license was created)
        """
elif False:
    LicensingCotermLicensesMoveItemRemainderLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensingCotermLicensesMoveItemRemainderLicenseArgs:
    def __init__(__self__, *,
                 claimed_at: Optional[pulumi.Input[_builtins.str]] = None,
                 counts: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseCountArgs']]]] = None,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 editions: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseEditionArgs']]]] = None,
                 expired: Optional[pulumi.Input[_builtins.bool]] = None,
                 invalidated: Optional[pulumi.Input[_builtins.bool]] = None,
                 invalidated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 organization_id: Optional[pulumi.Input[_builtins.str]] = None,
                 started_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] claimed_at: When the license was claimed into the organization
        :param pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseCountArgs']]] counts: The counts of the license by model type
        :param pulumi.Input[_builtins.int] duration: The duration (term length) of the license, measured in days
        :param pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseEditionArgs']]] editions: The editions of the license for each relevant product type
        :param pulumi.Input[_builtins.bool] expired: Flag to indicate if the license is expired
        :param pulumi.Input[_builtins.bool] invalidated: Flag to indicated that the license is invalidated
        :param pulumi.Input[_builtins.str] invalidated_at: When the license was invalidated. Will be null for active licenses
        :param pulumi.Input[_builtins.str] key: The key of the license
        :param pulumi.Input[_builtins.str] mode: The operation mode of the license when it was claimed
        :param pulumi.Input[_builtins.str] organization_id: The ID of the organization that the license is claimed in
        :param pulumi.Input[_builtins.str] started_at: When the license's term began (approximately the date when the license was created)
        """
        if claimed_at is not None:
            pulumi.set(__self__, "claimed_at", claimed_at)
        if counts is not None:
            pulumi.set(__self__, "counts", counts)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if editions is not None:
            pulumi.set(__self__, "editions", editions)
        if expired is not None:
            pulumi.set(__self__, "expired", expired)
        if invalidated is not None:
            pulumi.set(__self__, "invalidated", invalidated)
        if invalidated_at is not None:
            pulumi.set(__self__, "invalidated_at", invalidated_at)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @_builtins.property
    @pulumi.getter(name="claimedAt")
    def claimed_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the license was claimed into the organization
        """
        return pulumi.get(self, "claimed_at")

    @claimed_at.setter
    def claimed_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "claimed_at", value)

    @_builtins.property
    @pulumi.getter
    def counts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseCountArgs']]]]:
        """
        The counts of the license by model type
        """
        return pulumi.get(self, "counts")

    @counts.setter
    def counts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseCountArgs']]]]):
        pulumi.set(self, "counts", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration (term length) of the license, measured in days
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def editions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseEditionArgs']]]]:
        """
        The editions of the license for each relevant product type
        """
        return pulumi.get(self, "editions")

    @editions.setter
    def editions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveItemRemainderLicenseEditionArgs']]]]):
        pulumi.set(self, "editions", value)

    @_builtins.property
    @pulumi.getter
    def expired(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag to indicate if the license is expired
        """
        return pulumi.get(self, "expired")

    @expired.setter
    def expired(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expired", value)

    @_builtins.property
    @pulumi.getter
    def invalidated(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag to indicated that the license is invalidated
        """
        return pulumi.get(self, "invalidated")

    @invalidated.setter
    def invalidated(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "invalidated", value)

    @_builtins.property
    @pulumi.getter(name="invalidatedAt")
    def invalidated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the license was invalidated. Will be null for active licenses
        """
        return pulumi.get(self, "invalidated_at")

    @invalidated_at.setter
    def invalidated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalidated_at", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the license
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The operation mode of the license when it was claimed
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the organization that the license is claimed in
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_id", value)

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the license's term began (approximately the date when the license was created)
        """
        return pulumi.get(self, "started_at")

    @started_at.setter
    def started_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_at", value)


if not MYPY:
    class LicensingCotermLicensesMoveItemRemainderLicenseCountArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of counts the license contains of this model
        """
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The license model type
        """
elif False:
    LicensingCotermLicensesMoveItemRemainderLicenseCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensingCotermLicensesMoveItemRemainderLicenseCountArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] count: The number of counts the license contains of this model
        :param pulumi.Input[_builtins.str] model: The license model type
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of counts the license contains of this model
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The license model type
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)


if not MYPY:
    class LicensingCotermLicensesMoveItemRemainderLicenseEditionArgsDict(TypedDict):
        edition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the license edition
        """
        product_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The product type of the license edition
        """
elif False:
    LicensingCotermLicensesMoveItemRemainderLicenseEditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensingCotermLicensesMoveItemRemainderLicenseEditionArgs:
    def __init__(__self__, *,
                 edition: Optional[pulumi.Input[_builtins.str]] = None,
                 product_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] edition: The name of the license edition
        :param pulumi.Input[_builtins.str] product_type: The product type of the license edition
        """
        if edition is not None:
            pulumi.set(__self__, "edition", edition)
        if product_type is not None:
            pulumi.set(__self__, "product_type", product_type)

    @_builtins.property
    @pulumi.getter
    def edition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the license edition
        """
        return pulumi.get(self, "edition")

    @edition.setter
    def edition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "edition", value)

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The product type of the license edition
        """
        return pulumi.get(self, "product_type")

    @product_type.setter
    def product_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "product_type", value)


if not MYPY:
    class LicensingCotermLicensesMoveParametersArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input['LicensingCotermLicensesMoveParametersDestinationArgsDict']]
        """
        Destination data for the license move
        """
        licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveParametersLicenseArgsDict']]]]
        """
        The list of licenses to move
        """
elif False:
    LicensingCotermLicensesMoveParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensingCotermLicensesMoveParametersArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input['LicensingCotermLicensesMoveParametersDestinationArgs']] = None,
                 licenses: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveParametersLicenseArgs']]]] = None):
        """
        :param pulumi.Input['LicensingCotermLicensesMoveParametersDestinationArgs'] destination: Destination data for the license move
        :param pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveParametersLicenseArgs']]] licenses: The list of licenses to move
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if licenses is not None:
            pulumi.set(__self__, "licenses", licenses)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['LicensingCotermLicensesMoveParametersDestinationArgs']]:
        """
        Destination data for the license move
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['LicensingCotermLicensesMoveParametersDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveParametersLicenseArgs']]]]:
        """
        The list of licenses to move
        """
        return pulumi.get(self, "licenses")

    @licenses.setter
    def licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveParametersLicenseArgs']]]]):
        pulumi.set(self, "licenses", value)


if not MYPY:
    class LicensingCotermLicensesMoveParametersDestinationArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The claim mode of the moved license
        """
        organization_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The organization to move the license to
        """
elif False:
    LicensingCotermLicensesMoveParametersDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensingCotermLicensesMoveParametersDestinationArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 organization_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The claim mode of the moved license
        :param pulumi.Input[_builtins.str] organization_id: The organization to move the license to
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The claim mode of the moved license
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The organization to move the license to
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_id", value)


if not MYPY:
    class LicensingCotermLicensesMoveParametersLicenseArgsDict(TypedDict):
        counts: NotRequired[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveParametersLicenseCountArgsDict']]]]
        """
        The counts to move from the license by model type
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The license key to move counts from
        """
elif False:
    LicensingCotermLicensesMoveParametersLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensingCotermLicensesMoveParametersLicenseArgs:
    def __init__(__self__, *,
                 counts: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveParametersLicenseCountArgs']]]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveParametersLicenseCountArgs']]] counts: The counts to move from the license by model type
        :param pulumi.Input[_builtins.str] key: The license key to move counts from
        """
        if counts is not None:
            pulumi.set(__self__, "counts", counts)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def counts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveParametersLicenseCountArgs']]]]:
        """
        The counts to move from the license by model type
        """
        return pulumi.get(self, "counts")

    @counts.setter
    def counts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LicensingCotermLicensesMoveParametersLicenseCountArgs']]]]):
        pulumi.set(self, "counts", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The license key to move counts from
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class LicensingCotermLicensesMoveParametersLicenseCountArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of counts to move
        """
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The license model type to move counts of
        """
elif False:
    LicensingCotermLicensesMoveParametersLicenseCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicensingCotermLicensesMoveParametersLicenseCountArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] count: The number of counts to move
        :param pulumi.Input[_builtins.str] model: The license model type to move counts of
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of counts to move
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The license model type to move counts of
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)


if not MYPY:
    class LoginSecurityApiAuthenticationArgsDict(TypedDict):
        ip_restrictions_for_keys: NotRequired[pulumi.Input['LoginSecurityApiAuthenticationIpRestrictionsForKeysArgsDict']]
        """
        Details for API-only IP restrictions.
        """
elif False:
    LoginSecurityApiAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoginSecurityApiAuthenticationArgs:
    def __init__(__self__, *,
                 ip_restrictions_for_keys: Optional[pulumi.Input['LoginSecurityApiAuthenticationIpRestrictionsForKeysArgs']] = None):
        """
        :param pulumi.Input['LoginSecurityApiAuthenticationIpRestrictionsForKeysArgs'] ip_restrictions_for_keys: Details for API-only IP restrictions.
        """
        if ip_restrictions_for_keys is not None:
            pulumi.set(__self__, "ip_restrictions_for_keys", ip_restrictions_for_keys)

    @_builtins.property
    @pulumi.getter(name="ipRestrictionsForKeys")
    def ip_restrictions_for_keys(self) -> Optional[pulumi.Input['LoginSecurityApiAuthenticationIpRestrictionsForKeysArgs']]:
        """
        Details for API-only IP restrictions.
        """
        return pulumi.get(self, "ip_restrictions_for_keys")

    @ip_restrictions_for_keys.setter
    def ip_restrictions_for_keys(self, value: Optional[pulumi.Input['LoginSecurityApiAuthenticationIpRestrictionsForKeysArgs']]):
        pulumi.set(self, "ip_restrictions_for_keys", value)


if not MYPY:
    class LoginSecurityApiAuthenticationIpRestrictionsForKeysArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges.
        """
        ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
        """
elif False:
    LoginSecurityApiAuthenticationIpRestrictionsForKeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoginSecurityApiAuthenticationIpRestrictionsForKeysArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ranges: List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if ranges is not None:
            pulumi.set(__self__, "ranges", ranges)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
        """
        return pulumi.get(self, "ranges")

    @ranges.setter
    def ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ranges", value)


if not MYPY:
    class NetworksCombineItemArgsDict(TypedDict):
        resulting_network: NotRequired[pulumi.Input['NetworksCombineItemResultingNetworkArgsDict']]
        """
        Network after the combination
        """
elif False:
    NetworksCombineItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworksCombineItemArgs:
    def __init__(__self__, *,
                 resulting_network: Optional[pulumi.Input['NetworksCombineItemResultingNetworkArgs']] = None):
        """
        :param pulumi.Input['NetworksCombineItemResultingNetworkArgs'] resulting_network: Network after the combination
        """
        if resulting_network is not None:
            pulumi.set(__self__, "resulting_network", resulting_network)

    @_builtins.property
    @pulumi.getter(name="resultingNetwork")
    def resulting_network(self) -> Optional[pulumi.Input['NetworksCombineItemResultingNetworkArgs']]:
        """
        Network after the combination
        """
        return pulumi.get(self, "resulting_network")

    @resulting_network.setter
    def resulting_network(self, value: Optional[pulumi.Input['NetworksCombineItemResultingNetworkArgs']]):
        pulumi.set(self, "resulting_network", value)


if not MYPY:
    class NetworksCombineItemResultingNetworkArgsDict(TypedDict):
        enrollment_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enrollment string for the network
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network ID
        """
        is_bound_to_config_template: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the network is bound to a config template
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network name
        """
        notes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notes for the network
        """
        organization_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization ID
        """
        product_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of the product types that the network supports
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Network tags
        """
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timezone of the network
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL to the network Dashboard UI
        """
elif False:
    NetworksCombineItemResultingNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworksCombineItemResultingNetworkArgs:
    def __init__(__self__, *,
                 enrollment_string: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_bound_to_config_template: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 organization_id: Optional[pulumi.Input[_builtins.str]] = None,
                 product_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] enrollment_string: Enrollment string for the network
        :param pulumi.Input[_builtins.str] id: Network ID
        :param pulumi.Input[_builtins.bool] is_bound_to_config_template: If the network is bound to a config template
        :param pulumi.Input[_builtins.str] name: Network name
        :param pulumi.Input[_builtins.str] notes: Notes for the network
        :param pulumi.Input[_builtins.str] organization_id: Organization ID
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] product_types: List of the product types that the network supports
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: Network tags
        :param pulumi.Input[_builtins.str] time_zone: Timezone of the network
        :param pulumi.Input[_builtins.str] url: URL to the network Dashboard UI
        """
        if enrollment_string is not None:
            pulumi.set(__self__, "enrollment_string", enrollment_string)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_bound_to_config_template is not None:
            pulumi.set(__self__, "is_bound_to_config_template", is_bound_to_config_template)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)
        if product_types is not None:
            pulumi.set(__self__, "product_types", product_types)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="enrollmentString")
    def enrollment_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enrollment string for the network
        """
        return pulumi.get(self, "enrollment_string")

    @enrollment_string.setter
    def enrollment_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enrollment_string", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isBoundToConfigTemplate")
    def is_bound_to_config_template(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the network is bound to a config template
        """
        return pulumi.get(self, "is_bound_to_config_template")

    @is_bound_to_config_template.setter
    def is_bound_to_config_template(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_bound_to_config_template", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notes for the network
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization ID
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_id", value)

    @_builtins.property
    @pulumi.getter(name="productTypes")
    def product_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of the product types that the network supports
        """
        return pulumi.get(self, "product_types")

    @product_types.setter
    def product_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "product_types", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Network tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timezone of the network
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL to the network Dashboard UI
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class NetworksCombineParametersArgsDict(TypedDict):
        enrollment_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. All networks that are part of this combined network will have their enrollment string appended by '-network_type'. If left empty, all exisitng enrollment strings will be deleted.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the combined network
        """
        network_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of the network IDs that will be combined. If an ID of a combined network is included in this list, the other networks in the list will be grouped into that network
        """
elif False:
    NetworksCombineParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworksCombineParametersArgs:
    def __init__(__self__, *,
                 enrollment_string: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] enrollment_string: A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. All networks that are part of this combined network will have their enrollment string appended by '-network_type'. If left empty, all exisitng enrollment strings will be deleted.
        :param pulumi.Input[_builtins.str] name: The name of the combined network
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] network_ids: A list of the network IDs that will be combined. If an ID of a combined network is included in this list, the other networks in the list will be grouped into that network
        """
        if enrollment_string is not None:
            pulumi.set(__self__, "enrollment_string", enrollment_string)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_ids is not None:
            pulumi.set(__self__, "network_ids", network_ids)

    @_builtins.property
    @pulumi.getter(name="enrollmentString")
    def enrollment_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. All networks that are part of this combined network will have their enrollment string appended by '-network_type'. If left empty, all exisitng enrollment strings will be deleted.
        """
        return pulumi.get(self, "enrollment_string")

    @enrollment_string.setter
    def enrollment_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enrollment_string", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the combined network
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="networkIds")
    def network_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of the network IDs that will be combined. If an ID of a combined network is included in this list, the other networks in the list will be grouped into that network
        """
        return pulumi.get(self, "network_ids")

    @network_ids.setter
    def network_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "network_ids", value)


if not MYPY:
    class SamlRolesCameraArgsDict(TypedDict):
        access: NotRequired[pulumi.Input[_builtins.str]]
        """
        Camera access ability
        """
        org_wide: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not SAML administrator has org-wide access
        """
elif False:
    SamlRolesCameraArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SamlRolesCameraArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input[_builtins.str]] = None,
                 org_wide: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] access: Camera access ability
        :param pulumi.Input[_builtins.bool] org_wide: Whether or not SAML administrator has org-wide access
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if org_wide is not None:
            pulumi.set(__self__, "org_wide", org_wide)

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Camera access ability
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access", value)

    @_builtins.property
    @pulumi.getter(name="orgWide")
    def org_wide(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not SAML administrator has org-wide access
        """
        return pulumi.get(self, "org_wide")

    @org_wide.setter
    def org_wide(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "org_wide", value)


if not MYPY:
    class SamlRolesNetworkArgsDict(TypedDict):
        access: NotRequired[pulumi.Input[_builtins.str]]
        """
        The privilege of the SAML administrator on the network
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The network ID
        """
elif False:
    SamlRolesNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SamlRolesNetworkArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access: The privilege of the SAML administrator on the network
        :param pulumi.Input[_builtins.str] id: The network ID
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The privilege of the SAML administrator on the network
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The network ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class SamlRolesTagArgsDict(TypedDict):
        access: NotRequired[pulumi.Input[_builtins.str]]
        """
        The privilege of the SAML administrator on the tag
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the tag
        """
elif False:
    SamlRolesTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SamlRolesTagArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access: The privilege of the SAML administrator on the tag
        :param pulumi.Input[_builtins.str] tag: The name of the tag
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The privilege of the SAML administrator on the tag
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class SmSentryPoliciesAssignmentsItemArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsItemItemArgsDict']]]]
        """
        Sentry Group Policies for the Organization keyed by Network Id
        """
elif False:
    SmSentryPoliciesAssignmentsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmSentryPoliciesAssignmentsItemArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsItemItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsItemItemArgs']]] items: Sentry Group Policies for the Organization keyed by Network Id
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsItemItemArgs']]]]:
        """
        Sentry Group Policies for the Organization keyed by Network Id
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsItemItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class SmSentryPoliciesAssignmentsItemItemArgsDict(TypedDict):
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Id of the Network
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsItemItemPolicyArgsDict']]]]
        """
        Array of Sentry Group Policies for the Network
        """
elif False:
    SmSentryPoliciesAssignmentsItemItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmSentryPoliciesAssignmentsItemItemArgs:
    def __init__(__self__, *,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsItemItemPolicyArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] network_id: The Id of the Network
        :param pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsItemItemPolicyArgs']]] policies: Array of Sentry Group Policies for the Network
        """
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Id of the Network
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsItemItemPolicyArgs']]]]:
        """
        Array of Sentry Group Policies for the Network
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsItemItemPolicyArgs']]]]):
        pulumi.set(self, "policies", value)


if not MYPY:
    class SmSentryPoliciesAssignmentsItemItemPolicyArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The creation time of the Sentry Policy
        """
        group_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        The number of the Group Policy
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Id of the Group Policy. This is associated with the network specified by the networkId.
        """
        last_updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last update time of the Sentry Policy
        """
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Id of the Network the Sentry Policy is associated with. In a locale, this should be the Wireless Group if present, otherwise the Wired Group.
        """
        policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Id of the Sentry Policy
        """
        priority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The priority of the Sentry Policy
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scope of the Sentry Policy
        """
        sm_network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Id of the Systems Manager Network the Sentry Policy is assigned to
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The tags of the Sentry Policy
        """
elif False:
    SmSentryPoliciesAssignmentsItemItemPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmSentryPoliciesAssignmentsItemItemPolicyArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 group_number: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 last_updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 sm_network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: The creation time of the Sentry Policy
        :param pulumi.Input[_builtins.str] group_number: The number of the Group Policy
        :param pulumi.Input[_builtins.str] group_policy_id: The Id of the Group Policy. This is associated with the network specified by the networkId.
        :param pulumi.Input[_builtins.str] last_updated_at: The last update time of the Sentry Policy
        :param pulumi.Input[_builtins.str] network_id: The Id of the Network the Sentry Policy is associated with. In a locale, this should be the Wireless Group if present, otherwise the Wired Group.
        :param pulumi.Input[_builtins.str] policy_id: The Id of the Sentry Policy
        :param pulumi.Input[_builtins.str] priority: The priority of the Sentry Policy
        :param pulumi.Input[_builtins.str] scope: The scope of the Sentry Policy
        :param pulumi.Input[_builtins.str] sm_network_id: The Id of the Systems Manager Network the Sentry Policy is assigned to
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: The tags of the Sentry Policy
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if group_number is not None:
            pulumi.set(__self__, "group_number", group_number)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)
        if last_updated_at is not None:
            pulumi.set(__self__, "last_updated_at", last_updated_at)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sm_network_id is not None:
            pulumi.set(__self__, "sm_network_id", sm_network_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The creation time of the Sentry Policy
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="groupNumber")
    def group_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The number of the Group Policy
        """
        return pulumi.get(self, "group_number")

    @group_number.setter
    def group_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_number", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Id of the Group Policy. This is associated with the network specified by the networkId.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="lastUpdatedAt")
    def last_updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last update time of the Sentry Policy
        """
        return pulumi.get(self, "last_updated_at")

    @last_updated_at.setter
    def last_updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_updated_at", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Id of the Network the Sentry Policy is associated with. In a locale, this should be the Wireless Group if present, otherwise the Wired Group.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Id of the Sentry Policy
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The priority of the Sentry Policy
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scope of the Sentry Policy
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter(name="smNetworkId")
    def sm_network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Id of the Systems Manager Network the Sentry Policy is assigned to
        """
        return pulumi.get(self, "sm_network_id")

    @sm_network_id.setter
    def sm_network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sm_network_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The tags of the Sentry Policy
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SmSentryPoliciesAssignmentsParametersArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsParametersItemArgsDict']]]]
        """
        Sentry Group Policies for the Organization keyed by Network Id
        """
elif False:
    SmSentryPoliciesAssignmentsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmSentryPoliciesAssignmentsParametersArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsParametersItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsParametersItemArgs']]] items: Sentry Group Policies for the Organization keyed by Network Id
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsParametersItemArgs']]]]:
        """
        Sentry Group Policies for the Organization keyed by Network Id
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsParametersItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class SmSentryPoliciesAssignmentsParametersItemArgsDict(TypedDict):
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Id of the Network
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsParametersItemPolicyArgsDict']]]]
        """
        Array of Sentry Group Policies for the Network
        """
elif False:
    SmSentryPoliciesAssignmentsParametersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmSentryPoliciesAssignmentsParametersItemArgs:
    def __init__(__self__, *,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsParametersItemPolicyArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] network_id: The Id of the Network
        :param pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsParametersItemPolicyArgs']]] policies: Array of Sentry Group Policies for the Network
        """
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Id of the Network
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsParametersItemPolicyArgs']]]]:
        """
        Array of Sentry Group Policies for the Network
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SmSentryPoliciesAssignmentsParametersItemPolicyArgs']]]]):
        pulumi.set(self, "policies", value)


if not MYPY:
    class SmSentryPoliciesAssignmentsParametersItemPolicyArgsDict(TypedDict):
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Group Policy Id
        """
        policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Sentry Policy Id, if updating an existing Sentry Policy
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scope of the Sentry Policy
        """
        sm_network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Id of the Systems Manager Network
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The tags for the Sentry Policy
        """
elif False:
    SmSentryPoliciesAssignmentsParametersItemPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmSentryPoliciesAssignmentsParametersItemPolicyArgs:
    def __init__(__self__, *,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 sm_network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] group_policy_id: The Group Policy Id
        :param pulumi.Input[_builtins.str] policy_id: The Sentry Policy Id, if updating an existing Sentry Policy
        :param pulumi.Input[_builtins.str] scope: The scope of the Sentry Policy
        :param pulumi.Input[_builtins.str] sm_network_id: The Id of the Systems Manager Network
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: The tags for the Sentry Policy
        """
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sm_network_id is not None:
            pulumi.set(__self__, "sm_network_id", sm_network_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Group Policy Id
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Sentry Policy Id, if updating an existing Sentry Policy
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scope of the Sentry Policy
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter(name="smNetworkId")
    def sm_network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Id of the Systems Manager Network
        """
        return pulumi.get(self, "sm_network_id")

    @sm_network_id.setter
    def sm_network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sm_network_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The tags for the Sentry Policy
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SwitchDevicesCloneParametersArgsDict(TypedDict):
        source_serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Serial number of the source switch (must be on a network not bound to a template)
        """
        target_serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of serial numbers of one or more target switches (must be on a network not bound to a template)
        """
elif False:
    SwitchDevicesCloneParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchDevicesCloneParametersArgs:
    def __init__(__self__, *,
                 source_serial: Optional[pulumi.Input[_builtins.str]] = None,
                 target_serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] source_serial: Serial number of the source switch (must be on a network not bound to a template)
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] target_serials: Array of serial numbers of one or more target switches (must be on a network not bound to a template)
        """
        if source_serial is not None:
            pulumi.set(__self__, "source_serial", source_serial)
        if target_serials is not None:
            pulumi.set(__self__, "target_serials", target_serials)

    @_builtins.property
    @pulumi.getter(name="sourceSerial")
    def source_serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Serial number of the source switch (must be on a network not bound to a template)
        """
        return pulumi.get(self, "source_serial")

    @source_serial.setter
    def source_serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_serial", value)

    @_builtins.property
    @pulumi.getter(name="targetSerials")
    def target_serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of serial numbers of one or more target switches (must be on a network not bound to a template)
        """
        return pulumi.get(self, "target_serials")

    @target_serials.setter
    def target_serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "target_serials", value)


if not MYPY:
    class BaseApiArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable API access
        """
elif False:
    BaseApiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaseApiArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable API access
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable API access
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class BaseCloudArgsDict(TypedDict):
        region: NotRequired[pulumi.Input['BaseCloudRegionArgsDict']]
        """
        Region info
        """
elif False:
    BaseCloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaseCloudArgs:
    def __init__(__self__, *,
                 region: Optional[pulumi.Input['BaseCloudRegionArgs']] = None):
        """
        :param pulumi.Input['BaseCloudRegionArgs'] region: Region info
        """
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input['BaseCloudRegionArgs']]:
        """
        Region info
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input['BaseCloudRegionArgs']]):
        pulumi.set(self, "region", value)


if not MYPY:
    class BaseCloudRegionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of region
        """
elif False:
    BaseCloudRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaseCloudRegionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of region
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of region
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class BaseLicensingArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
        """
elif False:
    BaseLicensingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaseLicensingArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] model: Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)


if not MYPY:
    class BaseManagementArgsDict(TypedDict):
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input['BaseManagementDetailArgsDict']]]]
        """
        Details related to organization management, possibly empty. Details may be named 'MSP ID', 'IP restriction mode for API', or 'IP restriction mode for dashboard', if the organization admin has configured any.
        """
elif False:
    BaseManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaseManagementArgs:
    def __init__(__self__, *,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input['BaseManagementDetailArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BaseManagementDetailArgs']]] details: Details related to organization management, possibly empty. Details may be named 'MSP ID', 'IP restriction mode for API', or 'IP restriction mode for dashboard', if the organization admin has configured any.
        """
        if details is not None:
            pulumi.set(__self__, "details", details)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BaseManagementDetailArgs']]]]:
        """
        Details related to organization management, possibly empty. Details may be named 'MSP ID', 'IP restriction mode for API', or 'IP restriction mode for dashboard', if the organization admin has configured any.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BaseManagementDetailArgs']]]]):
        pulumi.set(self, "details", value)


if not MYPY:
    class BaseManagementDetailArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of management data
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of management data
        """
elif False:
    BaseManagementDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaseManagementDetailArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of management data
        :param pulumi.Input[_builtins.str] value: Value of management data
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of management data
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of management data
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


