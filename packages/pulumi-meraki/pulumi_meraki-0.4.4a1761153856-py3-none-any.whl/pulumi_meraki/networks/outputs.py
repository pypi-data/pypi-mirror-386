# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AlertsSettingsAlert',
    'AlertsSettingsAlertAlertDestinations',
    'AlertsSettingsAlertFilters',
    'AlertsSettingsAlertsResponse',
    'AlertsSettingsAlertsResponseAlertDestinations',
    'AlertsSettingsAlertsResponseFilters',
    'AlertsSettingsDefaultDestinations',
    'AlertsSettingsMuting',
    'AlertsSettingsMutingByPortSchedules',
    'ApplianceConnectivityMonitoringDestinationsDestination',
    'ApplianceContentFilteringBlockedUrlCategoriesResponse',
    'ApplianceFirewallCellularFirewallRulesRule',
    'ApplianceFirewallInboundFirewallRulesRule',
    'ApplianceFirewallInboundFirewallRulesRulesResponse',
    'ApplianceFirewallL3FirewallRulesRule',
    'ApplianceFirewallL3FirewallRulesRulesResponse',
    'ApplianceFirewallL7FirewallRulesRule',
    'ApplianceFirewallL7FirewallRulesRuleValueObj',
    'ApplianceFirewallL7FirewallRulesRulesResponse',
    'ApplianceFirewallL7FirewallRulesRulesResponseValueObj',
    'ApplianceFirewallOneToManyNatRulesRule',
    'ApplianceFirewallOneToManyNatRulesRulePortRule',
    'ApplianceFirewallOneToOneNatRulesRule',
    'ApplianceFirewallOneToOneNatRulesRuleAllowedInbound',
    'ApplianceFirewallPortForwardingRulesRule',
    'ApplianceFirewallSettingsSpoofingProtection',
    'ApplianceFirewallSettingsSpoofingProtectionIpSourceGuard',
    'AppliancePrefixesDelegatedStaticsOrigin',
    'ApplianceRfProfilesFiveGhzSettings',
    'ApplianceRfProfilesPerSsidSettings',
    'ApplianceRfProfilesPerSsidSettingsStatus1',
    'ApplianceRfProfilesPerSsidSettingsStatus2',
    'ApplianceRfProfilesPerSsidSettingsStatus3',
    'ApplianceRfProfilesPerSsidSettingsStatus4',
    'ApplianceRfProfilesTwoFourGhzSettings',
    'ApplianceSecurityIntrusionProtectedNetworks',
    'ApplianceSecurityMalwareAllowedFile',
    'ApplianceSecurityMalwareAllowedUrl',
    'ApplianceSettingsDynamicDns',
    'ApplianceSingleLanIpv6',
    'ApplianceSingleLanIpv6PrefixAssignment',
    'ApplianceSingleLanIpv6PrefixAssignmentOrigin',
    'ApplianceSingleLanMandatoryDhcp',
    'ApplianceSsidsDhcpEnforcedDeauthentication',
    'ApplianceSsidsDot11w',
    'ApplianceSsidsRadiusServer',
    'ApplianceSsidsRadiusServersResponse',
    'ApplianceTrafficShapingCustomPerformanceClassesParameters',
    'ApplianceTrafficShapingGlobalBandwidthLimits',
    'ApplianceTrafficShapingRulesRule',
    'ApplianceTrafficShapingRulesRuleDefinition',
    'ApplianceTrafficShapingRulesRuleDefinitionValueObj',
    'ApplianceTrafficShapingRulesRulePerClientBandwidthLimits',
    'ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits',
    'ApplianceTrafficShapingUplinkBandwidthBandwidthLimits',
    'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellular',
    'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1',
    'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2',
    'ApplianceTrafficShapingUplinkSelectionFailoverAndFailback',
    'ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediate',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreference',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClass',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilter',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValue',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestination',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSource',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreference',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilter',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValue',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestination',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSource',
    'ApplianceTrafficShapingVpnExclusionsItem',
    'ApplianceTrafficShapingVpnExclusionsItemCustom',
    'ApplianceTrafficShapingVpnExclusionsItemMajorApplication',
    'ApplianceTrafficShapingVpnExclusionsParameters',
    'ApplianceTrafficShapingVpnExclusionsParametersCustom',
    'ApplianceTrafficShapingVpnExclusionsParametersMajorApplication',
    'ApplianceVlansDhcpOption',
    'ApplianceVlansIpv6',
    'ApplianceVlansIpv6PrefixAssignment',
    'ApplianceVlansIpv6PrefixAssignmentOrigin',
    'ApplianceVlansMandatoryDhcp',
    'ApplianceVlansReservedIpRange',
    'ApplianceVpnBgpNeighbor',
    'ApplianceVpnBgpNeighborAuthentication',
    'ApplianceVpnBgpNeighborIpv6',
    'ApplianceVpnBgpNeighborTtlSecurity',
    'ApplianceVpnSiteToSiteVpnHub',
    'ApplianceVpnSiteToSiteVpnSubnet',
    'ApplianceWarmSpareWan1',
    'ApplianceWarmSpareWan2',
    'BindItem',
    'BindParameters',
    'CameraQualityRetentionProfilesVideoSettings',
    'CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72',
    'CameraQualityRetentionProfilesVideoSettingsMV12We',
    'CameraQualityRetentionProfilesVideoSettingsMV13',
    'CameraQualityRetentionProfilesVideoSettingsMV21MV71',
    'CameraQualityRetentionProfilesVideoSettingsMV22Xmv72X',
    'CameraQualityRetentionProfilesVideoSettingsMV32',
    'CameraQualityRetentionProfilesVideoSettingsMV33',
    'CameraQualityRetentionProfilesVideoSettingsMV52',
    'CameraQualityRetentionProfilesVideoSettingsMV63',
    'CameraQualityRetentionProfilesVideoSettingsMV63X',
    'CameraQualityRetentionProfilesVideoSettingsMV93',
    'CameraQualityRetentionProfilesVideoSettingsMV93X',
    'CameraWirelessProfilesIdentity',
    'CameraWirelessProfilesSsid',
    'CellularGatewayConnectivityMonitoringDestinationsDestination',
    'CellularGatewaySubnetPoolSubnet',
    'CellularGatewayUplinkBandwidthLimits',
    'ClientsProvisionItem',
    'ClientsProvisionItemClient',
    'ClientsProvisionParameters',
    'ClientsProvisionParametersClient',
    'ClientsProvisionParametersPoliciesBySecurityAppliance',
    'ClientsProvisionParametersPoliciesBySsid',
    'ClientsProvisionParametersPoliciesBySsidStatus0',
    'ClientsProvisionParametersPoliciesBySsidStatus10',
    'ClientsProvisionParametersPoliciesBySsidStatus11',
    'ClientsProvisionParametersPoliciesBySsidStatus12',
    'ClientsProvisionParametersPoliciesBySsidStatus13',
    'ClientsProvisionParametersPoliciesBySsidStatus14',
    'ClientsProvisionParametersPoliciesBySsidStatus1',
    'ClientsProvisionParametersPoliciesBySsidStatus2',
    'ClientsProvisionParametersPoliciesBySsidStatus3',
    'ClientsProvisionParametersPoliciesBySsidStatus4',
    'ClientsProvisionParametersPoliciesBySsidStatus5',
    'ClientsProvisionParametersPoliciesBySsidStatus6',
    'ClientsProvisionParametersPoliciesBySsidStatus7',
    'ClientsProvisionParametersPoliciesBySsidStatus8',
    'ClientsProvisionParametersPoliciesBySsidStatus9',
    'ClientsSplashAuthorizationStatusSsids',
    'ClientsSplashAuthorizationStatusSsidsStatus0',
    'ClientsSplashAuthorizationStatusSsidsStatus10',
    'ClientsSplashAuthorizationStatusSsidsStatus11',
    'ClientsSplashAuthorizationStatusSsidsStatus12',
    'ClientsSplashAuthorizationStatusSsidsStatus13',
    'ClientsSplashAuthorizationStatusSsidsStatus14',
    'ClientsSplashAuthorizationStatusSsidsStatus1',
    'ClientsSplashAuthorizationStatusSsidsStatus2',
    'ClientsSplashAuthorizationStatusSsidsStatus3',
    'ClientsSplashAuthorizationStatusSsidsStatus4',
    'ClientsSplashAuthorizationStatusSsidsStatus5',
    'ClientsSplashAuthorizationStatusSsidsStatus6',
    'ClientsSplashAuthorizationStatusSsidsStatus7',
    'ClientsSplashAuthorizationStatusSsidsStatus8',
    'ClientsSplashAuthorizationStatusSsidsStatus9',
    'DevicesClaimItem',
    'DevicesClaimParameters',
    'DevicesClaimVmxItem',
    'DevicesClaimVmxItemDetail',
    'DevicesClaimVmxParameters',
    'DevicesRemoveParameters',
    'FirmwareUpgradesProducts',
    'FirmwareUpgradesProductsAppliance',
    'FirmwareUpgradesProductsApplianceAvailableVersion',
    'FirmwareUpgradesProductsApplianceCurrentVersion',
    'FirmwareUpgradesProductsApplianceLastUpgrade',
    'FirmwareUpgradesProductsApplianceLastUpgradeFromVersion',
    'FirmwareUpgradesProductsApplianceLastUpgradeToVersion',
    'FirmwareUpgradesProductsApplianceNextUpgrade',
    'FirmwareUpgradesProductsApplianceNextUpgradeToVersion',
    'FirmwareUpgradesProductsCamera',
    'FirmwareUpgradesProductsCameraAvailableVersion',
    'FirmwareUpgradesProductsCameraCurrentVersion',
    'FirmwareUpgradesProductsCameraLastUpgrade',
    'FirmwareUpgradesProductsCameraLastUpgradeFromVersion',
    'FirmwareUpgradesProductsCameraLastUpgradeToVersion',
    'FirmwareUpgradesProductsCameraNextUpgrade',
    'FirmwareUpgradesProductsCameraNextUpgradeToVersion',
    'FirmwareUpgradesProductsCellularGateway',
    'FirmwareUpgradesProductsCellularGatewayAvailableVersion',
    'FirmwareUpgradesProductsCellularGatewayCurrentVersion',
    'FirmwareUpgradesProductsCellularGatewayLastUpgrade',
    'FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersion',
    'FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersion',
    'FirmwareUpgradesProductsCellularGatewayNextUpgrade',
    'FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersion',
    'FirmwareUpgradesProductsSensor',
    'FirmwareUpgradesProductsSensorAvailableVersion',
    'FirmwareUpgradesProductsSensorCurrentVersion',
    'FirmwareUpgradesProductsSensorLastUpgrade',
    'FirmwareUpgradesProductsSensorLastUpgradeFromVersion',
    'FirmwareUpgradesProductsSensorLastUpgradeToVersion',
    'FirmwareUpgradesProductsSensorNextUpgrade',
    'FirmwareUpgradesProductsSensorNextUpgradeToVersion',
    'FirmwareUpgradesProductsSwitch',
    'FirmwareUpgradesProductsSwitchAvailableVersion',
    'FirmwareUpgradesProductsSwitchCatalyst',
    'FirmwareUpgradesProductsSwitchCatalystNextUpgrade',
    'FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersion',
    'FirmwareUpgradesProductsSwitchCurrentVersion',
    'FirmwareUpgradesProductsSwitchLastUpgrade',
    'FirmwareUpgradesProductsSwitchLastUpgradeFromVersion',
    'FirmwareUpgradesProductsSwitchLastUpgradeToVersion',
    'FirmwareUpgradesProductsSwitchNextUpgrade',
    'FirmwareUpgradesProductsSwitchNextUpgradeToVersion',
    'FirmwareUpgradesProductsWireless',
    'FirmwareUpgradesProductsWirelessAvailableVersion',
    'FirmwareUpgradesProductsWirelessCurrentVersion',
    'FirmwareUpgradesProductsWirelessLastUpgrade',
    'FirmwareUpgradesProductsWirelessLastUpgradeFromVersion',
    'FirmwareUpgradesProductsWirelessLastUpgradeToVersion',
    'FirmwareUpgradesProductsWirelessNextUpgrade',
    'FirmwareUpgradesProductsWirelessNextUpgradeToVersion',
    'FirmwareUpgradesRollbacksItem',
    'FirmwareUpgradesRollbacksItemReason',
    'FirmwareUpgradesRollbacksItemToVersion',
    'FirmwareUpgradesRollbacksParameters',
    'FirmwareUpgradesRollbacksParametersReason',
    'FirmwareUpgradesRollbacksParametersToVersion',
    'FirmwareUpgradesStagedEventsDeferItem',
    'FirmwareUpgradesStagedEventsDeferItemProducts',
    'FirmwareUpgradesStagedEventsDeferItemProductsSwitch',
    'FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgrade',
    'FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersion',
    'FirmwareUpgradesStagedEventsDeferItemReason',
    'FirmwareUpgradesStagedEventsDeferItemStage',
    'FirmwareUpgradesStagedEventsDeferItemStageGroup',
    'FirmwareUpgradesStagedEventsDeferItemStageMilestones',
    'FirmwareUpgradesStagedEventsProducts',
    'FirmwareUpgradesStagedEventsProductsSwitch',
    'FirmwareUpgradesStagedEventsProductsSwitchCatalyst',
    'FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgrade',
    'FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersion',
    'FirmwareUpgradesStagedEventsProductsSwitchNextUpgrade',
    'FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersion',
    'FirmwareUpgradesStagedEventsReason',
    'FirmwareUpgradesStagedEventsRollbacksItem',
    'FirmwareUpgradesStagedEventsRollbacksItemProducts',
    'FirmwareUpgradesStagedEventsRollbacksItemProductsSwitch',
    'FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgrade',
    'FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersion',
    'FirmwareUpgradesStagedEventsRollbacksItemReason',
    'FirmwareUpgradesStagedEventsRollbacksItemStage',
    'FirmwareUpgradesStagedEventsRollbacksItemStageGroup',
    'FirmwareUpgradesStagedEventsRollbacksItemStageMilestones',
    'FirmwareUpgradesStagedEventsRollbacksParameters',
    'FirmwareUpgradesStagedEventsRollbacksParametersReason',
    'FirmwareUpgradesStagedEventsRollbacksParametersStage',
    'FirmwareUpgradesStagedEventsRollbacksParametersStageGroup',
    'FirmwareUpgradesStagedEventsRollbacksParametersStageMilestones',
    'FirmwareUpgradesStagedEventsStage',
    'FirmwareUpgradesStagedEventsStageGroup',
    'FirmwareUpgradesStagedEventsStageMilestones',
    'FirmwareUpgradesStagedGroupsAssignedDevices',
    'FirmwareUpgradesStagedGroupsAssignedDevicesDevice',
    'FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStack',
    'FirmwareUpgradesStagedStagesGroup',
    'FirmwareUpgradesStagedStagesJson',
    'FirmwareUpgradesStagedStagesJsonGroup',
    'FirmwareUpgradesUpgradeWindow',
    'FloorPlansBottomLeftCorner',
    'FloorPlansBottomRightCorner',
    'FloorPlansCenter',
    'FloorPlansDevice',
    'FloorPlansDeviceDetail',
    'FloorPlansTopLeftCorner',
    'FloorPlansTopRightCorner',
    'GroupPoliciesBandwidth',
    'GroupPoliciesBandwidthBandwidthLimits',
    'GroupPoliciesBonjourForwarding',
    'GroupPoliciesBonjourForwardingRule',
    'GroupPoliciesContentFiltering',
    'GroupPoliciesContentFilteringAllowedUrlPatterns',
    'GroupPoliciesContentFilteringBlockedUrlCategories',
    'GroupPoliciesContentFilteringBlockedUrlPatterns',
    'GroupPoliciesFirewallAndTrafficShaping',
    'GroupPoliciesFirewallAndTrafficShapingL3FirewallRule',
    'GroupPoliciesFirewallAndTrafficShapingL7FirewallRule',
    'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRule',
    'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinition',
    'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits',
    'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits',
    'GroupPoliciesScheduling',
    'GroupPoliciesSchedulingFriday',
    'GroupPoliciesSchedulingMonday',
    'GroupPoliciesSchedulingSaturday',
    'GroupPoliciesSchedulingSunday',
    'GroupPoliciesSchedulingThursday',
    'GroupPoliciesSchedulingTuesday',
    'GroupPoliciesSchedulingWednesday',
    'GroupPoliciesVlanTagging',
    'MerakiAuthUsersAuthorization',
    'MqttBrokersItem',
    'MqttBrokersItemAuthentication',
    'MqttBrokersItemSecurity',
    'MqttBrokersItemSecurityTls',
    'MqttBrokersParameters',
    'MqttBrokersParametersAuthentication',
    'MqttBrokersParametersSecurity',
    'MqttBrokersParametersSecurityTls',
    'SensorAlertsProfilesCondition',
    'SensorAlertsProfilesConditionThreshold',
    'SensorAlertsProfilesConditionThresholdApparentPower',
    'SensorAlertsProfilesConditionThresholdCurrent',
    'SensorAlertsProfilesConditionThresholdDoor',
    'SensorAlertsProfilesConditionThresholdFrequency',
    'SensorAlertsProfilesConditionThresholdHumidity',
    'SensorAlertsProfilesConditionThresholdIndoorAirQuality',
    'SensorAlertsProfilesConditionThresholdNoise',
    'SensorAlertsProfilesConditionThresholdNoiseAmbient',
    'SensorAlertsProfilesConditionThresholdPm25',
    'SensorAlertsProfilesConditionThresholdPowerFactor',
    'SensorAlertsProfilesConditionThresholdRealPower',
    'SensorAlertsProfilesConditionThresholdTemperature',
    'SensorAlertsProfilesConditionThresholdTvoc',
    'SensorAlertsProfilesConditionThresholdUpstreamPower',
    'SensorAlertsProfilesConditionThresholdVoltage',
    'SensorAlertsProfilesConditionThresholdWater',
    'SensorAlertsProfilesConditionsResponse',
    'SensorAlertsProfilesConditionsResponseThreshold',
    'SensorAlertsProfilesConditionsResponseThresholdApparentPower',
    'SensorAlertsProfilesConditionsResponseThresholdCurrent',
    'SensorAlertsProfilesConditionsResponseThresholdDoor',
    'SensorAlertsProfilesConditionsResponseThresholdFrequency',
    'SensorAlertsProfilesConditionsResponseThresholdHumidity',
    'SensorAlertsProfilesConditionsResponseThresholdIndoorAirQuality',
    'SensorAlertsProfilesConditionsResponseThresholdNoise',
    'SensorAlertsProfilesConditionsResponseThresholdNoiseAmbient',
    'SensorAlertsProfilesConditionsResponseThresholdPm25',
    'SensorAlertsProfilesConditionsResponseThresholdPowerFactor',
    'SensorAlertsProfilesConditionsResponseThresholdRealPower',
    'SensorAlertsProfilesConditionsResponseThresholdTemperature',
    'SensorAlertsProfilesConditionsResponseThresholdTvoc',
    'SensorAlertsProfilesConditionsResponseThresholdUpstreamPower',
    'SensorAlertsProfilesConditionsResponseThresholdVoltage',
    'SensorAlertsProfilesConditionsResponseThresholdWater',
    'SensorAlertsProfilesRecipients',
    'SensorAlertsProfilesSchedule',
    'SettingsFips',
    'SettingsLocalStatusPage',
    'SettingsLocalStatusPageAuthentication',
    'SettingsNamedVlans',
    'SettingsSecurePort',
    'SmBypassActivationLockAttemptsData',
    'SmBypassActivationLockAttemptsDataStatus2090938209',
    'SmBypassActivationLockAttemptsDataStatus38290139892',
    'SmDevicesCheckinItem',
    'SmDevicesCheckinParameters',
    'SmDevicesFieldsItem',
    'SmDevicesFieldsParameters',
    'SmDevicesFieldsParametersDeviceFields',
    'SmDevicesInstallAppsParameters',
    'SmDevicesLockItem',
    'SmDevicesLockParameters',
    'SmDevicesModifyTagsItem',
    'SmDevicesModifyTagsParameters',
    'SmDevicesMoveItem',
    'SmDevicesMoveParameters',
    'SmDevicesRebootItem',
    'SmDevicesRebootParameters',
    'SmDevicesShutdownItem',
    'SmDevicesShutdownParameters',
    'SmDevicesUnenrollItem',
    'SmDevicesUninstallAppsParameters',
    'SmDevicesWipeItem',
    'SmDevicesWipeParameters',
    'SnmpUser',
    'SplitItem',
    'SplitItemResultingNetwork',
    'SwitchAccessControlListsRule',
    'SwitchAccessControlListsRulesResponse',
    'SwitchAccessPoliciesCounts',
    'SwitchAccessPoliciesCountsPorts',
    'SwitchAccessPoliciesDot1x',
    'SwitchAccessPoliciesRadius',
    'SwitchAccessPoliciesRadiusAccountingServer',
    'SwitchAccessPoliciesRadiusAccountingServersResponse',
    'SwitchAccessPoliciesRadiusCriticalAuth',
    'SwitchAccessPoliciesRadiusServer',
    'SwitchAccessPoliciesRadiusServersResponse',
    'SwitchAlternateManagementInterfaceSwitch',
    'SwitchDhcpServerPolicyAlerts',
    'SwitchDhcpServerPolicyAlertsEmail',
    'SwitchDhcpServerPolicyArpInspection',
    'SwitchDhcpServerPolicyArpInspectionTrustedServersIpv4',
    'SwitchDscpToCosMappingsMapping',
    'SwitchLinkAggregationsSwitchPort',
    'SwitchLinkAggregationsSwitchProfilePort',
    'SwitchMtuOverride',
    'SwitchPortSchedulesPortSchedule',
    'SwitchPortSchedulesPortScheduleFriday',
    'SwitchPortSchedulesPortScheduleMonday',
    'SwitchPortSchedulesPortScheduleSaturday',
    'SwitchPortSchedulesPortScheduleSunday',
    'SwitchPortSchedulesPortScheduleThursday',
    'SwitchPortSchedulesPortScheduleTuesday',
    'SwitchPortSchedulesPortScheduleWednesday',
    'SwitchRoutingMulticastDefaultSettings',
    'SwitchRoutingMulticastOverride',
    'SwitchRoutingOspfArea',
    'SwitchRoutingOspfMd5AuthenticationKey',
    'SwitchRoutingOspfV3',
    'SwitchRoutingOspfV3Area',
    'SwitchSettingsMacBlocklist',
    'SwitchSettingsPowerException',
    'SwitchSettingsUplinkClientSampling',
    'SwitchStacksAddItem',
    'SwitchStacksAddParameters',
    'SwitchStacksRemoveItem',
    'SwitchStacksRemoveParameters',
    'SwitchStacksRoutingInterfacesDhcpDhcpOption',
    'SwitchStacksRoutingInterfacesDhcpFixedIpAssignment',
    'SwitchStacksRoutingInterfacesDhcpReservedIpRange',
    'SwitchStacksRoutingInterfacesIpv6',
    'SwitchStacksRoutingInterfacesOspfSettings',
    'SwitchStacksRoutingInterfacesOspfV3',
    'SwitchStpStpBridgePriority',
    'SwitchStpStpBridgePriorityResponse',
    'SyslogServersServer',
    'TrafficAnalysisCustomPieChartItem',
    'UnbindItem',
    'UnbindParameters',
    'VlanProfilesAssignmentsReassignItem',
    'VlanProfilesAssignmentsReassignItemVlanProfile',
    'VlanProfilesAssignmentsReassignParameters',
    'VlanProfilesAssignmentsReassignParametersVlanProfile',
    'VlanProfilesVlanGroup',
    'VlanProfilesVlanName',
    'VlanProfilesVlanNameAdaptivePolicyGroup',
    'WebhooksHttpServersPayloadTemplate',
    'WebhooksPayloadTemplatesHeader',
    'WebhooksPayloadTemplatesSharing',
    'WebhooksPayloadTemplatesSharingByNetwork',
    'WirelessAlternateManagementInterfaceAccessPoint',
    'WirelessBillingPlan',
    'WirelessBillingPlanBandwidthLimits',
    'WirelessEthernetPortsProfilesAssignItem',
    'WirelessEthernetPortsProfilesAssignParameters',
    'WirelessEthernetPortsProfilesPort',
    'WirelessEthernetPortsProfilesSetDefaultItem',
    'WirelessEthernetPortsProfilesSetDefaultParameters',
    'WirelessEthernetPortsProfilesUsbPort',
    'WirelessRfProfilesApBandSettings',
    'WirelessRfProfilesApBandSettingsBands',
    'WirelessRfProfilesFiveGhzSettings',
    'WirelessRfProfilesFlexRadios',
    'WirelessRfProfilesFlexRadiosByModel',
    'WirelessRfProfilesPerSsidSettings',
    'WirelessRfProfilesPerSsidSettingsStatus0',
    'WirelessRfProfilesPerSsidSettingsStatus0Bands',
    'WirelessRfProfilesPerSsidSettingsStatus10',
    'WirelessRfProfilesPerSsidSettingsStatus10Bands',
    'WirelessRfProfilesPerSsidSettingsStatus11',
    'WirelessRfProfilesPerSsidSettingsStatus11Bands',
    'WirelessRfProfilesPerSsidSettingsStatus12',
    'WirelessRfProfilesPerSsidSettingsStatus12Bands',
    'WirelessRfProfilesPerSsidSettingsStatus13',
    'WirelessRfProfilesPerSsidSettingsStatus13Bands',
    'WirelessRfProfilesPerSsidSettingsStatus14',
    'WirelessRfProfilesPerSsidSettingsStatus14Bands',
    'WirelessRfProfilesPerSsidSettingsStatus1',
    'WirelessRfProfilesPerSsidSettingsStatus1Bands',
    'WirelessRfProfilesPerSsidSettingsStatus2',
    'WirelessRfProfilesPerSsidSettingsStatus2Bands',
    'WirelessRfProfilesPerSsidSettingsStatus3',
    'WirelessRfProfilesPerSsidSettingsStatus3Bands',
    'WirelessRfProfilesPerSsidSettingsStatus4',
    'WirelessRfProfilesPerSsidSettingsStatus4Bands',
    'WirelessRfProfilesPerSsidSettingsStatus5',
    'WirelessRfProfilesPerSsidSettingsStatus5Bands',
    'WirelessRfProfilesPerSsidSettingsStatus6',
    'WirelessRfProfilesPerSsidSettingsStatus6Bands',
    'WirelessRfProfilesPerSsidSettingsStatus7',
    'WirelessRfProfilesPerSsidSettingsStatus7Bands',
    'WirelessRfProfilesPerSsidSettingsStatus8',
    'WirelessRfProfilesPerSsidSettingsStatus8Bands',
    'WirelessRfProfilesPerSsidSettingsStatus9',
    'WirelessRfProfilesPerSsidSettingsStatus9Bands',
    'WirelessRfProfilesSixGhzSettings',
    'WirelessRfProfilesTransmission',
    'WirelessRfProfilesTwoFourGhzSettings',
    'WirelessSettingsNamedVlans',
    'WirelessSettingsNamedVlansPoolDhcpMonitoring',
    'WirelessSettingsRegulatoryDomain',
    'WirelessSsidsActiveDirectory',
    'WirelessSsidsActiveDirectoryCredentials',
    'WirelessSsidsActiveDirectoryServer',
    'WirelessSsidsApTagsAndVlanId',
    'WirelessSsidsBonjourForwardingException',
    'WirelessSsidsBonjourForwardingRule',
    'WirelessSsidsDeviceTypeGroupPoliciesDeviceTypePolicy',
    'WirelessSsidsDnsRewrite',
    'WirelessSsidsDot11r',
    'WirelessSsidsDot11w',
    'WirelessSsidsEapOverrideEapolKey',
    'WirelessSsidsEapOverrideIdentity',
    'WirelessSsidsFirewallL3FirewallRulesRule',
    'WirelessSsidsFirewallL3FirewallRulesRulesResponse',
    'WirelessSsidsFirewallL7FirewallRulesRule',
    'WirelessSsidsFirewallL7FirewallRulesRuleValueObj',
    'WirelessSsidsGre',
    'WirelessSsidsGreConcentrator',
    'WirelessSsidsHotspot20MccMnc',
    'WirelessSsidsHotspot20NaiRealm',
    'WirelessSsidsHotspot20NaiRealmMethod',
    'WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypes',
    'WirelessSsidsHotspot20Operator',
    'WirelessSsidsHotspot20Venue',
    'WirelessSsidsLdap',
    'WirelessSsidsLdapCredentials',
    'WirelessSsidsLdapServer',
    'WirelessSsidsLdapServerCaCertificate',
    'WirelessSsidsLocalRadius',
    'WirelessSsidsLocalRadiusCertificateAuthentication',
    'WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificate',
    'WirelessSsidsLocalRadiusPasswordAuthentication',
    'WirelessSsidsNamedVlans',
    'WirelessSsidsNamedVlansRadius',
    'WirelessSsidsNamedVlansRadiusGuestVlan',
    'WirelessSsidsNamedVlansTagging',
    'WirelessSsidsNamedVlansTaggingByApTag',
    'WirelessSsidsOauth',
    'WirelessSsidsRadiusAccountingServer',
    'WirelessSsidsRadiusAccountingServersResponse',
    'WirelessSsidsRadiusServer',
    'WirelessSsidsRadiusServersResponse',
    'WirelessSsidsSchedulesRange',
    'WirelessSsidsSchedulesRangesInSecond',
    'WirelessSsidsSpeedBurst',
    'WirelessSsidsSplashSettingsBilling',
    'WirelessSsidsSplashSettingsBillingFreeAccess',
    'WirelessSsidsSplashSettingsGuestSponsorship',
    'WirelessSsidsSplashSettingsSelfRegistration',
    'WirelessSsidsSplashSettingsSentryEnrollment',
    'WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetwork',
    'WirelessSsidsSplashSettingsSplashImage',
    'WirelessSsidsSplashSettingsSplashImageImage',
    'WirelessSsidsSplashSettingsSplashLogo',
    'WirelessSsidsSplashSettingsSplashLogoImage',
    'WirelessSsidsSplashSettingsSplashPrepaidFront',
    'WirelessSsidsSplashSettingsSplashPrepaidFrontImage',
    'WirelessSsidsTrafficShapingRulesRule',
    'WirelessSsidsTrafficShapingRulesRuleDefinition',
    'WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimits',
    'WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits',
    'WirelessSsidsVpnConcentrator',
    'WirelessSsidsVpnFailover',
    'WirelessSsidsVpnSplitTunnel',
    'WirelessSsidsVpnSplitTunnelRule',
    'GetAlertsHistoryItemResult',
    'GetAlertsHistoryItemDestinationsResult',
    'GetAlertsHistoryItemDestinationsEmailResult',
    'GetAlertsHistoryItemDestinationsPushResult',
    'GetAlertsHistoryItemDestinationsSmsResult',
    'GetAlertsHistoryItemDestinationsWebhookResult',
    'GetAlertsHistoryItemDeviceResult',
    'GetAlertsSettingsItemResult',
    'GetAlertsSettingsItemAlertResult',
    'GetAlertsSettingsItemAlertAlertDestinationsResult',
    'GetAlertsSettingsItemAlertFiltersResult',
    'GetAlertsSettingsItemDefaultDestinationsResult',
    'GetApplianceConnectivityMonitoringDestinationsItemResult',
    'GetApplianceConnectivityMonitoringDestinationsItemDestinationResult',
    'GetApplianceContentFilteringCategoriesItemResult',
    'GetApplianceContentFilteringCategoriesItemCategoryResult',
    'GetApplianceContentFilteringItemResult',
    'GetApplianceContentFilteringItemBlockedUrlCategoryResult',
    'GetApplianceFirewallCellularFirewallRulesItemResult',
    'GetApplianceFirewallCellularFirewallRulesItemRuleResult',
    'GetApplianceFirewallFirewalledServicesItemResult',
    'GetApplianceFirewallInboundFirewallRulesItemResult',
    'GetApplianceFirewallInboundFirewallRulesItemRuleResult',
    'GetApplianceFirewallL3FirewallRulesItemResult',
    'GetApplianceFirewallL3FirewallRulesItemRuleResult',
    'GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemResult',
    'GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategoryResult',
    'GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategoryApplicationResult',
    'GetApplianceFirewallL7FirewallRulesItemResult',
    'GetApplianceFirewallL7FirewallRulesItemRuleResult',
    'GetApplianceFirewallOneToManyNatRulesItemResult',
    'GetApplianceFirewallOneToManyNatRulesItemRuleResult',
    'GetApplianceFirewallOneToManyNatRulesItemRulePortRuleResult',
    'GetApplianceFirewallOneToOneNatRulesItemResult',
    'GetApplianceFirewallOneToOneNatRulesItemRuleResult',
    'GetApplianceFirewallOneToOneNatRulesItemRuleAllowedInboundResult',
    'GetApplianceFirewallPortForwardingRulesItemResult',
    'GetApplianceFirewallPortForwardingRulesItemRuleResult',
    'GetApplianceFirewallSettingsItemResult',
    'GetApplianceFirewallSettingsItemSpoofingProtectionResult',
    'GetApplianceFirewallSettingsItemSpoofingProtectionIpSourceGuardResult',
    'GetAppliancePortsItemResult',
    'GetAppliancePrefixesDelegatedStaticsItemResult',
    'GetAppliancePrefixesDelegatedStaticsItemOriginResult',
    'GetApplianceRfProfilesItemResult',
    'GetApplianceRfProfilesItemFiveGhzSettingsResult',
    'GetApplianceRfProfilesItemPerSsidSettingsResult',
    'GetApplianceRfProfilesItemPerSsidSettingsStatus1Result',
    'GetApplianceRfProfilesItemPerSsidSettingsStatus2Result',
    'GetApplianceRfProfilesItemPerSsidSettingsStatus3Result',
    'GetApplianceRfProfilesItemPerSsidSettingsStatus4Result',
    'GetApplianceRfProfilesItemTwoFourGhzSettingsResult',
    'GetApplianceSecurityIntrusionItemResult',
    'GetApplianceSecurityIntrusionItemProtectedNetworksResult',
    'GetApplianceSecurityMalwareItemResult',
    'GetApplianceSecurityMalwareItemAllowedFileResult',
    'GetApplianceSecurityMalwareItemAllowedUrlResult',
    'GetApplianceSettingsItemResult',
    'GetApplianceSettingsItemDynamicDnsResult',
    'GetApplianceSingleLanItemResult',
    'GetApplianceSingleLanItemIpv6Result',
    'GetApplianceSingleLanItemIpv6PrefixAssignmentResult',
    'GetApplianceSingleLanItemIpv6PrefixAssignmentOriginResult',
    'GetApplianceSingleLanItemMandatoryDhcpResult',
    'GetApplianceSsidsItemResult',
    'GetApplianceSsidsItemRadiusServerResult',
    'GetApplianceTrafficShapingItemResult',
    'GetApplianceTrafficShapingItemGlobalBandwidthLimitsResult',
    'GetApplianceTrafficShapingRulesItemResult',
    'GetApplianceTrafficShapingRulesItemRuleResult',
    'GetApplianceTrafficShapingRulesItemRuleDefinitionResult',
    'GetApplianceTrafficShapingRulesItemRulePerClientBandwidthLimitsResult',
    'GetApplianceTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimitsResult',
    'GetApplianceTrafficShapingUplinkBandwidthItemResult',
    'GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsResult',
    'GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsCellularResult',
    'GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan1Result',
    'GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan2Result',
    'GetApplianceTrafficShapingUplinkSelectionItemResult',
    'GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailbackResult',
    'GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailbackImmediateResult',
    'GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceResult',
    'GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferencePerformanceClassResult',
    'GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterResult',
    'GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueResult',
    'GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueDestinationResult',
    'GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueSourceResult',
    'GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceResult',
    'GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterResult',
    'GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueResult',
    'GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueDestinationResult',
    'GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueSourceResult',
    'GetApplianceVlansItemResult',
    'GetApplianceVlansItemDhcpOptionResult',
    'GetApplianceVlansItemIpv6Result',
    'GetApplianceVlansItemIpv6PrefixAssignmentResult',
    'GetApplianceVlansItemIpv6PrefixAssignmentOriginResult',
    'GetApplianceVlansItemMandatoryDhcpResult',
    'GetApplianceVlansItemReservedIpRangeResult',
    'GetApplianceVlansSettingsItemResult',
    'GetApplianceVpnBgpItemResult',
    'GetApplianceVpnBgpItemNeighborResult',
    'GetApplianceVpnSiteToSiteVpnItemResult',
    'GetApplianceVpnSiteToSiteVpnItemHubResult',
    'GetApplianceVpnSiteToSiteVpnItemSubnetResult',
    'GetApplianceWarmSpareItemResult',
    'GetApplianceWarmSpareItemWan1Result',
    'GetApplianceWarmSpareItemWan2Result',
    'GetBluetoothClientsItemResult',
    'GetCameraQualityRetentionProfilesItemResult',
    'GetCameraQualityRetentionProfilesItemVideoSettingsResult',
    'GetCameraQualityRetentionProfilesItemVideoSettingsMV12MV22MV72Result',
    'GetCameraQualityRetentionProfilesItemVideoSettingsMV12WeResult',
    'GetCameraQualityRetentionProfilesItemVideoSettingsMV21MV71Result',
    'GetCameraQualityRetentionProfilesItemVideoSettingsMV32Result',
    'GetCameraWirelessProfilesItemResult',
    'GetCameraWirelessProfilesItemIdentityResult',
    'GetCameraWirelessProfilesItemSsidResult',
    'GetCellularGatewayConnectivityMonitoringDestinationsItemResult',
    'GetCellularGatewayConnectivityMonitoringDestinationsItemDestinationResult',
    'GetCellularGatewayDhcpItemResult',
    'GetCellularGatewaySubnetPoolItemResult',
    'GetCellularGatewaySubnetPoolItemSubnetResult',
    'GetCellularGatewayUplinkItemResult',
    'GetCellularGatewayUplinkItemBandwidthLimitsResult',
    'GetClientsItemResult',
    'GetClientsItemCdpResult',
    'GetClientsItemClientVpnConnectionResult',
    'GetClientsItemLldpResult',
    'GetClientsOverviewItemResult',
    'GetClientsOverviewItemCountsResult',
    'GetClientsOverviewItemUsagesResult',
    'GetClientsPolicyItemResult',
    'GetClientsSplashAuthorizationStatusItemResult',
    'GetClientsSplashAuthorizationStatusItemSsidsResult',
    'GetClientsSplashAuthorizationStatusItemSsidsStatus0Result',
    'GetClientsSplashAuthorizationStatusItemSsidsStatus2Result',
    'GetEventsEventTypesItemResult',
    'GetEventsItemResult',
    'GetEventsItemEventResult',
    'GetEventsItemEventEventDataResult',
    'GetFirmwareUpgradesItemResult',
    'GetFirmwareUpgradesItemProductsResult',
    'GetFirmwareUpgradesItemProductsApplianceResult',
    'GetFirmwareUpgradesItemProductsApplianceAvailableVersionResult',
    'GetFirmwareUpgradesItemProductsApplianceCurrentVersionResult',
    'GetFirmwareUpgradesItemProductsApplianceLastUpgradeResult',
    'GetFirmwareUpgradesItemProductsApplianceLastUpgradeFromVersionResult',
    'GetFirmwareUpgradesItemProductsApplianceLastUpgradeToVersionResult',
    'GetFirmwareUpgradesItemProductsApplianceNextUpgradeResult',
    'GetFirmwareUpgradesItemProductsApplianceNextUpgradeToVersionResult',
    'GetFirmwareUpgradesItemProductsCameraResult',
    'GetFirmwareUpgradesItemProductsCameraAvailableVersionResult',
    'GetFirmwareUpgradesItemProductsCameraCurrentVersionResult',
    'GetFirmwareUpgradesItemProductsCameraLastUpgradeResult',
    'GetFirmwareUpgradesItemProductsCameraLastUpgradeFromVersionResult',
    'GetFirmwareUpgradesItemProductsCameraLastUpgradeToVersionResult',
    'GetFirmwareUpgradesItemProductsCameraNextUpgradeResult',
    'GetFirmwareUpgradesItemProductsCameraNextUpgradeToVersionResult',
    'GetFirmwareUpgradesItemProductsCellularGatewayResult',
    'GetFirmwareUpgradesItemProductsCellularGatewayAvailableVersionResult',
    'GetFirmwareUpgradesItemProductsCellularGatewayCurrentVersionResult',
    'GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeResult',
    'GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeFromVersionResult',
    'GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeToVersionResult',
    'GetFirmwareUpgradesItemProductsCellularGatewayNextUpgradeResult',
    'GetFirmwareUpgradesItemProductsCellularGatewayNextUpgradeToVersionResult',
    'GetFirmwareUpgradesItemProductsSensorResult',
    'GetFirmwareUpgradesItemProductsSensorAvailableVersionResult',
    'GetFirmwareUpgradesItemProductsSensorCurrentVersionResult',
    'GetFirmwareUpgradesItemProductsSensorLastUpgradeResult',
    'GetFirmwareUpgradesItemProductsSensorLastUpgradeFromVersionResult',
    'GetFirmwareUpgradesItemProductsSensorLastUpgradeToVersionResult',
    'GetFirmwareUpgradesItemProductsSensorNextUpgradeResult',
    'GetFirmwareUpgradesItemProductsSensorNextUpgradeToVersionResult',
    'GetFirmwareUpgradesItemProductsSwitchResult',
    'GetFirmwareUpgradesItemProductsSwitchAvailableVersionResult',
    'GetFirmwareUpgradesItemProductsSwitchCurrentVersionResult',
    'GetFirmwareUpgradesItemProductsSwitchLastUpgradeResult',
    'GetFirmwareUpgradesItemProductsSwitchLastUpgradeFromVersionResult',
    'GetFirmwareUpgradesItemProductsSwitchLastUpgradeToVersionResult',
    'GetFirmwareUpgradesItemProductsSwitchNextUpgradeResult',
    'GetFirmwareUpgradesItemProductsSwitchNextUpgradeToVersionResult',
    'GetFirmwareUpgradesItemProductsWirelessResult',
    'GetFirmwareUpgradesItemProductsWirelessAvailableVersionResult',
    'GetFirmwareUpgradesItemProductsWirelessCurrentVersionResult',
    'GetFirmwareUpgradesItemProductsWirelessLastUpgradeResult',
    'GetFirmwareUpgradesItemProductsWirelessLastUpgradeFromVersionResult',
    'GetFirmwareUpgradesItemProductsWirelessLastUpgradeToVersionResult',
    'GetFirmwareUpgradesItemProductsWirelessNextUpgradeResult',
    'GetFirmwareUpgradesItemProductsWirelessNextUpgradeToVersionResult',
    'GetFirmwareUpgradesItemUpgradeWindowResult',
    'GetFirmwareUpgradesStagedEventsItemResult',
    'GetFirmwareUpgradesStagedEventsItemProductsResult',
    'GetFirmwareUpgradesStagedEventsItemProductsSwitchResult',
    'GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgradeResult',
    'GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgradeToVersionResult',
    'GetFirmwareUpgradesStagedEventsItemReasonResult',
    'GetFirmwareUpgradesStagedEventsItemStageResult',
    'GetFirmwareUpgradesStagedEventsItemStageGroupResult',
    'GetFirmwareUpgradesStagedEventsItemStageMilestonesResult',
    'GetFirmwareUpgradesStagedGroupsItemResult',
    'GetFirmwareUpgradesStagedGroupsItemAssignedDevicesResult',
    'GetFirmwareUpgradesStagedGroupsItemAssignedDevicesDeviceResult',
    'GetFirmwareUpgradesStagedGroupsItemAssignedDevicesSwitchStackResult',
    'GetFirmwareUpgradesStagedStagesItemResult',
    'GetFirmwareUpgradesStagedStagesItemGroupResult',
    'GetFloorPlansItemResult',
    'GetFloorPlansItemBottomLeftCornerResult',
    'GetFloorPlansItemBottomRightCornerResult',
    'GetFloorPlansItemCenterResult',
    'GetFloorPlansItemDeviceResult',
    'GetFloorPlansItemDeviceDetailResult',
    'GetFloorPlansItemTopLeftCornerResult',
    'GetFloorPlansItemTopRightCornerResult',
    'GetGroupPoliciesItemResult',
    'GetGroupPoliciesItemBandwidthResult',
    'GetGroupPoliciesItemBandwidthBandwidthLimitsResult',
    'GetGroupPoliciesItemBonjourForwardingResult',
    'GetGroupPoliciesItemBonjourForwardingRuleResult',
    'GetGroupPoliciesItemContentFilteringResult',
    'GetGroupPoliciesItemContentFilteringAllowedUrlPatternsResult',
    'GetGroupPoliciesItemContentFilteringBlockedUrlCategoriesResult',
    'GetGroupPoliciesItemContentFilteringBlockedUrlPatternsResult',
    'GetGroupPoliciesItemFirewallAndTrafficShapingResult',
    'GetGroupPoliciesItemFirewallAndTrafficShapingL3FirewallRuleResult',
    'GetGroupPoliciesItemFirewallAndTrafficShapingL7FirewallRuleResult',
    'GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRuleResult',
    'GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRuleDefinitionResult',
    'GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsResult',
    'GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsResult',
    'GetGroupPoliciesItemSchedulingResult',
    'GetGroupPoliciesItemSchedulingFridayResult',
    'GetGroupPoliciesItemSchedulingMondayResult',
    'GetGroupPoliciesItemSchedulingSaturdayResult',
    'GetGroupPoliciesItemSchedulingSundayResult',
    'GetGroupPoliciesItemSchedulingThursdayResult',
    'GetGroupPoliciesItemSchedulingTuesdayResult',
    'GetGroupPoliciesItemSchedulingWednesdayResult',
    'GetGroupPoliciesItemVlanTaggingResult',
    'GetHealthAlertsItemResult',
    'GetHealthAlertsItemScopeResult',
    'GetHealthAlertsItemScopeApplicationResult',
    'GetHealthAlertsItemScopeDeviceResult',
    'GetHealthAlertsItemScopeDeviceClientResult',
    'GetHealthAlertsItemScopeDeviceLldpResult',
    'GetHealthAlertsItemScopePeerResult',
    'GetHealthAlertsItemScopePeerNetworkResult',
    'GetInsightApplicationsHealthByTimeItemResult',
    'GetMerakiAuthUsersItemResult',
    'GetMerakiAuthUsersItemAuthorizationResult',
    'GetNetflowItemResult',
    'GetPiiPiiKeysItemResult',
    'GetPiiPiiKeysItemN1234Result',
    'GetPiiRequestsItemResult',
    'GetPiiSmDevicesForKeyItemResult',
    'GetPiiSmOwnersForKeyItemResult',
    'GetPoliciesByClientItemResult',
    'GetPoliciesByClientItemAssignedResult',
    'GetPoliciesByClientItemAssignedSsidResult',
    'GetSensorAlertsCurrentOverviewByMetricItemResult',
    'GetSensorAlertsCurrentOverviewByMetricItemCountsResult',
    'GetSensorAlertsCurrentOverviewByMetricItemCountsNoiseResult',
    'GetSensorAlertsOverviewByMetricItemResult',
    'GetSensorAlertsOverviewByMetricItemCountsResult',
    'GetSensorAlertsOverviewByMetricItemCountsNoiseResult',
    'GetSensorAlertsProfilesItemResult',
    'GetSensorAlertsProfilesItemConditionResult',
    'GetSensorAlertsProfilesItemConditionThresholdResult',
    'GetSensorAlertsProfilesItemConditionThresholdApparentPowerResult',
    'GetSensorAlertsProfilesItemConditionThresholdCurrentResult',
    'GetSensorAlertsProfilesItemConditionThresholdDoorResult',
    'GetSensorAlertsProfilesItemConditionThresholdFrequencyResult',
    'GetSensorAlertsProfilesItemConditionThresholdHumidityResult',
    'GetSensorAlertsProfilesItemConditionThresholdIndoorAirQualityResult',
    'GetSensorAlertsProfilesItemConditionThresholdNoiseResult',
    'GetSensorAlertsProfilesItemConditionThresholdNoiseAmbientResult',
    'GetSensorAlertsProfilesItemConditionThresholdPm25Result',
    'GetSensorAlertsProfilesItemConditionThresholdPowerFactorResult',
    'GetSensorAlertsProfilesItemConditionThresholdRealPowerResult',
    'GetSensorAlertsProfilesItemConditionThresholdTemperatureResult',
    'GetSensorAlertsProfilesItemConditionThresholdTvocResult',
    'GetSensorAlertsProfilesItemConditionThresholdUpstreamPowerResult',
    'GetSensorAlertsProfilesItemConditionThresholdVoltageResult',
    'GetSensorAlertsProfilesItemConditionThresholdWaterResult',
    'GetSensorAlertsProfilesItemRecipientsResult',
    'GetSensorAlertsProfilesItemScheduleResult',
    'GetSensorMqttBrokersItemResult',
    'GetSensorRelationshipsItemResult',
    'GetSensorRelationshipsItemDeviceResult',
    'GetSensorRelationshipsItemRelationshipsResult',
    'GetSensorRelationshipsItemRelationshipsLivestreamResult',
    'GetSensorRelationshipsItemRelationshipsLivestreamRelatedDeviceResult',
    'GetSettingsItemResult',
    'GetSettingsItemFipsResult',
    'GetSettingsItemLocalStatusPageResult',
    'GetSettingsItemLocalStatusPageAuthenticationResult',
    'GetSettingsItemNamedVlansResult',
    'GetSettingsItemSecurePortResult',
    'GetSmBypassActivationLockAttemptsItemResult',
    'GetSmBypassActivationLockAttemptsItemDataResult',
    'GetSmBypassActivationLockAttemptsItemDataStatus2090938209Result',
    'GetSmBypassActivationLockAttemptsItemDataStatus38290139892Result',
    'GetSmDevicesCellularUsageHistoryItemResult',
    'GetSmDevicesCertsItemResult',
    'GetSmDevicesConnectivityItemResult',
    'GetSmDevicesDesktopLogsItemResult',
    'GetSmDevicesDeviceCommandLogsItemResult',
    'GetSmDevicesDeviceProfilesItemResult',
    'GetSmDevicesItemResult',
    'GetSmDevicesNetworkAdaptersItemResult',
    'GetSmDevicesPerformanceHistoryItemResult',
    'GetSmDevicesPerformanceHistoryItemDiskUsageResult',
    'GetSmDevicesPerformanceHistoryItemDiskUsageCResult',
    'GetSmDevicesSecurityCentersItemResult',
    'GetSmDevicesWlanListsItemResult',
    'GetSmProfilesItemResult',
    'GetSmTargetGroupsItemResult',
    'GetSmTrustedAccessConfigsItemResult',
    'GetSmUserAccessDevicesItemResult',
    'GetSmUserAccessDevicesItemTrustedAccessConnectionResult',
    'GetSmUsersDeviceProfilesItemResult',
    'GetSmUsersItemResult',
    'GetSmUsersSoftwaresItemResult',
    'GetSnmpItemResult',
    'GetSnmpItemUserResult',
    'GetSwitchAccessControlListsItemResult',
    'GetSwitchAccessControlListsItemRuleResult',
    'GetSwitchAccessPoliciesItemResult',
    'GetSwitchAccessPoliciesItemCountsResult',
    'GetSwitchAccessPoliciesItemCountsPortsResult',
    'GetSwitchAccessPoliciesItemDot1xResult',
    'GetSwitchAccessPoliciesItemRadiusResult',
    'GetSwitchAccessPoliciesItemRadiusAccountingServerResult',
    'GetSwitchAccessPoliciesItemRadiusCriticalAuthResult',
    'GetSwitchAccessPoliciesItemRadiusServerResult',
    'GetSwitchAlternateManagementInterfaceItemResult',
    'GetSwitchAlternateManagementInterfaceItemSwitchResult',
    'GetSwitchDhcpServerPolicyArpInspectionTrustedServersItemResult',
    'GetSwitchDhcpServerPolicyArpInspectionTrustedServersItemIpv4Result',
    'GetSwitchDhcpServerPolicyArpInspectionWarningsByDeviceItemResult',
    'GetSwitchDhcpServerPolicyItemResult',
    'GetSwitchDhcpServerPolicyItemAlertsResult',
    'GetSwitchDhcpServerPolicyItemAlertsEmailResult',
    'GetSwitchDhcpServerPolicyItemArpInspectionResult',
    'GetSwitchDhcpV4ServersSeenItemResult',
    'GetSwitchDhcpV4ServersSeenItemDeviceResult',
    'GetSwitchDhcpV4ServersSeenItemDeviceInterfaceResult',
    'GetSwitchDhcpV4ServersSeenItemIpv4Result',
    'GetSwitchDhcpV4ServersSeenItemLastAckResult',
    'GetSwitchDhcpV4ServersSeenItemLastAckIpv4Result',
    'GetSwitchDhcpV4ServersSeenItemLastPacketResult',
    'GetSwitchDhcpV4ServersSeenItemLastPacketDestinationResult',
    'GetSwitchDhcpV4ServersSeenItemLastPacketDestinationIpv4Result',
    'GetSwitchDhcpV4ServersSeenItemLastPacketEthernetResult',
    'GetSwitchDhcpV4ServersSeenItemLastPacketFieldsResult',
    'GetSwitchDhcpV4ServersSeenItemLastPacketFieldsOptionResult',
    'GetSwitchDhcpV4ServersSeenItemLastPacketIpResult',
    'GetSwitchDhcpV4ServersSeenItemLastPacketIpDscpResult',
    'GetSwitchDhcpV4ServersSeenItemLastPacketSourceResult',
    'GetSwitchDhcpV4ServersSeenItemLastPacketSourceIpv4Result',
    'GetSwitchDhcpV4ServersSeenItemLastPacketUdpResult',
    'GetSwitchDhcpV4ServersSeenItemSeenByResult',
    'GetSwitchDscpToCosMappingsItemResult',
    'GetSwitchDscpToCosMappingsItemMappingResult',
    'GetSwitchLinkAggregationsItemResult',
    'GetSwitchLinkAggregationsItemSwitchPortResult',
    'GetSwitchMtuItemResult',
    'GetSwitchMtuItemOverrideResult',
    'GetSwitchPortSchedulesItemResult',
    'GetSwitchPortSchedulesItemPortScheduleResult',
    'GetSwitchPortSchedulesItemPortScheduleFridayResult',
    'GetSwitchPortSchedulesItemPortScheduleMondayResult',
    'GetSwitchPortSchedulesItemPortScheduleSaturdayResult',
    'GetSwitchPortSchedulesItemPortScheduleSundayResult',
    'GetSwitchPortSchedulesItemPortScheduleThursdayResult',
    'GetSwitchPortSchedulesItemPortScheduleTuesdayResult',
    'GetSwitchPortSchedulesItemPortScheduleWednesdayResult',
    'GetSwitchQosRulesOrderItemResult',
    'GetSwitchRoutingMulticastItemResult',
    'GetSwitchRoutingMulticastItemDefaultSettingsResult',
    'GetSwitchRoutingMulticastItemOverrideResult',
    'GetSwitchRoutingMulticastRendezvousPointsItemResult',
    'GetSwitchRoutingOspfItemResult',
    'GetSwitchRoutingOspfItemAreaResult',
    'GetSwitchRoutingOspfItemMd5AuthenticationKeyResult',
    'GetSwitchRoutingOspfItemV3Result',
    'GetSwitchRoutingOspfItemV3AreaResult',
    'GetSwitchSettingsItemResult',
    'GetSwitchSettingsItemMacBlocklistResult',
    'GetSwitchSettingsItemPowerExceptionResult',
    'GetSwitchSettingsItemUplinkClientSamplingResult',
    'GetSwitchStacksItemResult',
    'GetSwitchStacksRoutingInterfacesDhcpItemResult',
    'GetSwitchStacksRoutingInterfacesDhcpItemDhcpOptionResult',
    'GetSwitchStacksRoutingInterfacesDhcpItemFixedIpAssignmentResult',
    'GetSwitchStacksRoutingInterfacesDhcpItemReservedIpRangeResult',
    'GetSwitchStacksRoutingInterfacesItemResult',
    'GetSwitchStacksRoutingInterfacesItemIpv6Result',
    'GetSwitchStacksRoutingInterfacesItemOspfSettingsResult',
    'GetSwitchStacksRoutingInterfacesItemOspfV3Result',
    'GetSwitchStacksRoutingStaticRoutesItemResult',
    'GetSwitchStormControlItemResult',
    'GetSwitchStpItemResult',
    'GetSwitchStpItemStpBridgePriorityResult',
    'GetSyslogServersItemResult',
    'GetSyslogServersItemServerResult',
    'GetTopologyLinkLayerItemResult',
    'GetTopologyLinkLayerItemLinkResult',
    'GetTopologyLinkLayerItemLinkEndResult',
    'GetTopologyLinkLayerItemLinkEndDeviceResult',
    'GetTopologyLinkLayerItemLinkEndDiscoveredResult',
    'GetTopologyLinkLayerItemLinkEndDiscoveredCdpResult',
    'GetTopologyLinkLayerItemLinkEndDiscoveredLldpResult',
    'GetTopologyLinkLayerItemLinkEndNodeResult',
    'GetTopologyLinkLayerItemNodeResult',
    'GetTopologyLinkLayerItemNodeDiscoveredResult',
    'GetTopologyLinkLayerItemNodeDiscoveredLldpResult',
    'GetTrafficAnalysisItemResult',
    'GetTrafficAnalysisItemCustomPieChartItemResult',
    'GetTrafficShapingApplicationCategoriesItemResult',
    'GetTrafficShapingApplicationCategoriesItemApplicationCategoryResult',
    'GetTrafficShapingApplicationCategoriesItemApplicationCategoryApplicationResult',
    'GetTrafficShapingDscpTaggingOptionsItemResult',
    'GetVlanProfilesAssignmentsByDeviceItemResult',
    'GetVlanProfilesAssignmentsByDeviceItemStackResult',
    'GetVlanProfilesAssignmentsByDeviceItemVlanProfileResult',
    'GetVlanProfilesItemResult',
    'GetVlanProfilesItemVlanGroupResult',
    'GetVlanProfilesItemVlanNameResult',
    'GetVlanProfilesItemVlanNameAdaptivePolicyGroupResult',
    'GetWebhooksHttpServersItemResult',
    'GetWebhooksHttpServersItemPayloadTemplateResult',
    'GetWebhooksPayloadTemplatesItemResult',
    'GetWebhooksPayloadTemplatesItemHeaderResult',
    'GetWebhooksPayloadTemplatesItemSharingResult',
    'GetWebhooksPayloadTemplatesItemSharingByNetworkResult',
    'GetWebhooksWebhookTestsItemResult',
    'GetWirelessAlternateManagementInterfaceItemResult',
    'GetWirelessAlternateManagementInterfaceItemAccessPointResult',
    'GetWirelessBillingItemResult',
    'GetWirelessBillingItemPlanResult',
    'GetWirelessBillingItemPlanBandwidthLimitsResult',
    'GetWirelessBluetoothSettingsItemResult',
    'GetWirelessChannelUtilizationHistoryItemResult',
    'GetWirelessClientCountHistoryItemResult',
    'GetWirelessClientsConnectionStatsItemResult',
    'GetWirelessClientsConnectionStatsItemConnectionStatsResult',
    'GetWirelessClientsLatencyStatsItemResult',
    'GetWirelessClientsLatencyStatsItemLatencyStatsResult',
    'GetWirelessClientsLatencyStatsItemLatencyStatsBackgroundTrafficResult',
    'GetWirelessClientsLatencyStatsItemLatencyStatsBackgroundTrafficRawDistributionResult',
    'GetWirelessConnectionStatsItemResult',
    'GetWirelessDataRateHistoryItemResult',
    'GetWirelessDevicesConnectionStatsItemResult',
    'GetWirelessDevicesConnectionStatsItemConnectionStatsResult',
    'GetWirelessEthernetPortsProfilesItemResult',
    'GetWirelessEthernetPortsProfilesItemPortResult',
    'GetWirelessEthernetPortsProfilesItemUsbPortResult',
    'GetWirelessFailedConnectionsItemResult',
    'GetWirelessLatencyHistoryItemResult',
    'GetWirelessLatencyStatsItemResult',
    'GetWirelessLatencyStatsItemBackgroundTrafficResult',
    'GetWirelessLatencyStatsItemBackgroundTrafficRawDistributionResult',
    'GetWirelessMeshStatusesItemResult',
    'GetWirelessMeshStatusesItemLatestMeshPerformanceResult',
    'GetWirelessRfProfilesItemResult',
    'GetWirelessRfProfilesItemApBandSettingsResult',
    'GetWirelessRfProfilesItemApBandSettingsBandsResult',
    'GetWirelessRfProfilesItemFiveGhzSettingsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus0Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus0BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus10Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus10BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus11Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus11BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus12Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus12BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus13Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus13BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus14Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus14BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus1Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus1BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus2Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus2BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus3Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus3BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus4Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus4BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus5Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus5BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus6Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus6BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus7Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus7BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus8Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus8BandsResult',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus9Result',
    'GetWirelessRfProfilesItemPerSsidSettingsStatus9BandsResult',
    'GetWirelessRfProfilesItemSixGhzSettingsResult',
    'GetWirelessRfProfilesItemTransmissionResult',
    'GetWirelessRfProfilesItemTwoFourGhzSettingsResult',
    'GetWirelessSettingsItemResult',
    'GetWirelessSettingsItemNamedVlansResult',
    'GetWirelessSettingsItemNamedVlansPoolDhcpMonitoringResult',
    'GetWirelessSettingsItemRegulatoryDomainResult',
    'GetWirelessSignalQualityHistoryItemResult',
    'GetWirelessSsidsBonjourForwardingItemResult',
    'GetWirelessSsidsBonjourForwardingItemExceptionResult',
    'GetWirelessSsidsBonjourForwardingItemRuleResult',
    'GetWirelessSsidsDeviceTypeGroupPoliciesItemResult',
    'GetWirelessSsidsDeviceTypeGroupPoliciesItemDeviceTypePolicyResult',
    'GetWirelessSsidsEapOverrideItemResult',
    'GetWirelessSsidsEapOverrideItemEapolKeyResult',
    'GetWirelessSsidsEapOverrideItemIdentityResult',
    'GetWirelessSsidsFirewallL3FirewallRulesItemResult',
    'GetWirelessSsidsFirewallL3FirewallRulesItemRuleResult',
    'GetWirelessSsidsFirewallL7FirewallRulesItemResult',
    'GetWirelessSsidsFirewallL7FirewallRulesItemRuleResult',
    'GetWirelessSsidsHotspot20ItemResult',
    'GetWirelessSsidsHotspot20ItemMccMncResult',
    'GetWirelessSsidsHotspot20ItemNaiRealmResult',
    'GetWirelessSsidsHotspot20ItemNaiRealmMethodResult',
    'GetWirelessSsidsHotspot20ItemNaiRealmMethodAuthenticationTypesResult',
    'GetWirelessSsidsHotspot20ItemOperatorResult',
    'GetWirelessSsidsHotspot20ItemVenueResult',
    'GetWirelessSsidsIdentityPsksItemResult',
    'GetWirelessSsidsItemResult',
    'GetWirelessSsidsItemRadiusAccountingServerResult',
    'GetWirelessSsidsItemRadiusServerResult',
    'GetWirelessSsidsSchedulesItemResult',
    'GetWirelessSsidsSchedulesItemRangeResult',
    'GetWirelessSsidsSplashSettingsItemResult',
    'GetWirelessSsidsSplashSettingsItemBillingResult',
    'GetWirelessSsidsSplashSettingsItemBillingFreeAccessResult',
    'GetWirelessSsidsSplashSettingsItemGuestSponsorshipResult',
    'GetWirelessSsidsSplashSettingsItemSelfRegistrationResult',
    'GetWirelessSsidsSplashSettingsItemSentryEnrollmentResult',
    'GetWirelessSsidsSplashSettingsItemSentryEnrollmentSystemsManagerNetworkResult',
    'GetWirelessSsidsSplashSettingsItemSplashImageResult',
    'GetWirelessSsidsSplashSettingsItemSplashLogoResult',
    'GetWirelessSsidsSplashSettingsItemSplashPrepaidFrontResult',
    'GetWirelessSsidsTrafficShapingRulesItemResult',
    'GetWirelessSsidsTrafficShapingRulesItemRuleResult',
    'GetWirelessSsidsTrafficShapingRulesItemRuleDefinitionResult',
    'GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimitsResult',
    'GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimitsResult',
    'GetWirelessSsidsVpnItemResult',
    'GetWirelessSsidsVpnItemConcentratorResult',
    'GetWirelessSsidsVpnItemFailoverResult',
    'GetWirelessSsidsVpnItemSplitTunnelResult',
    'GetWirelessSsidsVpnItemSplitTunnelRuleResult',
    'GetWirelessUsageHistoryItemResult',
]

@pulumi.output_type
class AlertsSettingsAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertDestinations":
            suggest = "alert_destinations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertsSettingsAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertsSettingsAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertsSettingsAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_destinations: Optional['outputs.AlertsSettingsAlertAlertDestinations'] = None,
                 enabled: Optional[_builtins.bool] = None,
                 filters: Optional['outputs.AlertsSettingsAlertFilters'] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param 'AlertsSettingsAlertAlertDestinationsArgs' alert_destinations: A hash of destinations for this specific alert
        :param _builtins.bool enabled: A boolean depicting if the alert is turned on or off
        :param 'AlertsSettingsAlertFiltersArgs' filters: A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
        :param _builtins.str type: The type of alert
        """
        if alert_destinations is not None:
            pulumi.set(__self__, "alert_destinations", alert_destinations)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="alertDestinations")
    def alert_destinations(self) -> Optional['outputs.AlertsSettingsAlertAlertDestinations']:
        """
        A hash of destinations for this specific alert
        """
        return pulumi.get(self, "alert_destinations")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        A boolean depicting if the alert is turned on or off
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional['outputs.AlertsSettingsAlertFilters']:
        """
        A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of alert
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AlertsSettingsAlertAlertDestinations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allAdmins":
            suggest = "all_admins"
        elif key == "httpServerIds":
            suggest = "http_server_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertsSettingsAlertAlertDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertsSettingsAlertAlertDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertsSettingsAlertAlertDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_admins: Optional[_builtins.bool] = None,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 http_server_ids: Optional[Sequence[_builtins.str]] = None,
                 snmp: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool all_admins: If true, then all network admins will receive emails for this alert
        :param Sequence[_builtins.str] emails: A list of emails that will receive information about the alert
        :param Sequence[_builtins.str] http_server_ids: A list of HTTP server IDs to send a Webhook to for this alert
        :param _builtins.bool snmp: If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
        """
        if all_admins is not None:
            pulumi.set(__self__, "all_admins", all_admins)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_server_ids is not None:
            pulumi.set(__self__, "http_server_ids", http_server_ids)
        if snmp is not None:
            pulumi.set(__self__, "snmp", snmp)

    @_builtins.property
    @pulumi.getter(name="allAdmins")
    def all_admins(self) -> Optional[_builtins.bool]:
        """
        If true, then all network admins will receive emails for this alert
        """
        return pulumi.get(self, "all_admins")

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of emails that will receive information about the alert
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="httpServerIds")
    def http_server_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of HTTP server IDs to send a Webhook to for this alert
        """
        return pulumi.get(self, "http_server_ids")

    @_builtins.property
    @pulumi.getter
    def snmp(self) -> Optional[_builtins.bool]:
        """
        If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
        """
        return pulumi.get(self, "snmp")


@pulumi.output_type
class AlertsSettingsAlertFilters(dict):
    def __init__(__self__, *,
                 period: Optional[_builtins.int] = None,
                 threshold: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None):
        if period is not None:
            pulumi.set(__self__, "period", period)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertsSettingsAlertsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertDestinations":
            suggest = "alert_destinations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertsSettingsAlertsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertsSettingsAlertsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertsSettingsAlertsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_destinations: Optional['outputs.AlertsSettingsAlertsResponseAlertDestinations'] = None,
                 enabled: Optional[_builtins.bool] = None,
                 filters: Optional['outputs.AlertsSettingsAlertsResponseFilters'] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param 'AlertsSettingsAlertsResponseAlertDestinationsArgs' alert_destinations: A hash of destinations for this specific alert
        :param _builtins.bool enabled: A boolean depicting if the alert is turned on or off
        :param 'AlertsSettingsAlertsResponseFiltersArgs' filters: A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
        :param _builtins.str type: The type of alert
        """
        if alert_destinations is not None:
            pulumi.set(__self__, "alert_destinations", alert_destinations)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="alertDestinations")
    def alert_destinations(self) -> Optional['outputs.AlertsSettingsAlertsResponseAlertDestinations']:
        """
        A hash of destinations for this specific alert
        """
        return pulumi.get(self, "alert_destinations")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        A boolean depicting if the alert is turned on or off
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional['outputs.AlertsSettingsAlertsResponseFilters']:
        """
        A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of alert
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AlertsSettingsAlertsResponseAlertDestinations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allAdmins":
            suggest = "all_admins"
        elif key == "httpServerIds":
            suggest = "http_server_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertsSettingsAlertsResponseAlertDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertsSettingsAlertsResponseAlertDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertsSettingsAlertsResponseAlertDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_admins: Optional[_builtins.bool] = None,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 http_server_ids: Optional[Sequence[_builtins.str]] = None,
                 snmp: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool all_admins: If true, then all network admins will receive emails for this alert
        :param Sequence[_builtins.str] emails: A list of emails that will receive information about the alert
        :param Sequence[_builtins.str] http_server_ids: A list of HTTP server IDs to send a Webhook to for this alert
        :param _builtins.bool snmp: If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
        """
        if all_admins is not None:
            pulumi.set(__self__, "all_admins", all_admins)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_server_ids is not None:
            pulumi.set(__self__, "http_server_ids", http_server_ids)
        if snmp is not None:
            pulumi.set(__self__, "snmp", snmp)

    @_builtins.property
    @pulumi.getter(name="allAdmins")
    def all_admins(self) -> Optional[_builtins.bool]:
        """
        If true, then all network admins will receive emails for this alert
        """
        return pulumi.get(self, "all_admins")

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of emails that will receive information about the alert
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="httpServerIds")
    def http_server_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of HTTP server IDs to send a Webhook to for this alert
        """
        return pulumi.get(self, "http_server_ids")

    @_builtins.property
    @pulumi.getter
    def snmp(self) -> Optional[_builtins.bool]:
        """
        If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
        """
        return pulumi.get(self, "snmp")


@pulumi.output_type
class AlertsSettingsAlertsResponseFilters(dict):
    def __init__(__self__, *,
                 period: Optional[_builtins.int] = None,
                 threshold: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None):
        if period is not None:
            pulumi.set(__self__, "period", period)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AlertsSettingsDefaultDestinations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allAdmins":
            suggest = "all_admins"
        elif key == "httpServerIds":
            suggest = "http_server_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertsSettingsDefaultDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertsSettingsDefaultDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertsSettingsDefaultDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_admins: Optional[_builtins.bool] = None,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 http_server_ids: Optional[Sequence[_builtins.str]] = None,
                 snmp: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool all_admins: If true, then all network admins will receive emails.
        :param Sequence[_builtins.str] emails: A list of emails that will receive the alert(s).
        :param Sequence[_builtins.str] http_server_ids: A list of HTTP server IDs to send a Webhook to
        :param _builtins.bool snmp: If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network.
        """
        if all_admins is not None:
            pulumi.set(__self__, "all_admins", all_admins)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_server_ids is not None:
            pulumi.set(__self__, "http_server_ids", http_server_ids)
        if snmp is not None:
            pulumi.set(__self__, "snmp", snmp)

    @_builtins.property
    @pulumi.getter(name="allAdmins")
    def all_admins(self) -> Optional[_builtins.bool]:
        """
        If true, then all network admins will receive emails.
        """
        return pulumi.get(self, "all_admins")

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of emails that will receive the alert(s).
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="httpServerIds")
    def http_server_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of HTTP server IDs to send a Webhook to
        """
        return pulumi.get(self, "http_server_ids")

    @_builtins.property
    @pulumi.getter
    def snmp(self) -> Optional[_builtins.bool]:
        """
        If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network.
        """
        return pulumi.get(self, "snmp")


@pulumi.output_type
class AlertsSettingsMuting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byPortSchedules":
            suggest = "by_port_schedules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertsSettingsMuting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertsSettingsMuting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertsSettingsMuting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 by_port_schedules: Optional['outputs.AlertsSettingsMutingByPortSchedules'] = None):
        """
        :param 'AlertsSettingsMutingByPortSchedulesArgs' by_port_schedules: by_port_schedules
        """
        if by_port_schedules is not None:
            pulumi.set(__self__, "by_port_schedules", by_port_schedules)

    @_builtins.property
    @pulumi.getter(name="byPortSchedules")
    def by_port_schedules(self) -> Optional['outputs.AlertsSettingsMutingByPortSchedules']:
        """
        by_port_schedules
        """
        return pulumi.get(self, "by_port_schedules")


@pulumi.output_type
class AlertsSettingsMutingByPortSchedules(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: enabled
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApplianceConnectivityMonitoringDestinationsDestination(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None):
        """
        :param _builtins.bool default: Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
        :param _builtins.str description: Description of the testing destination. Optional, defaults to null
        :param _builtins.str ip: The IP address to test connectivity with
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the testing destination. Optional, defaults to null
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        The IP address to test connectivity with
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ApplianceContentFilteringBlockedUrlCategoriesResponse(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ApplianceFirewallCellularFirewallRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destCidr":
            suggest = "dest_cidr"
        elif key == "destPort":
            suggest = "dest_port"
        elif key == "srcCidr":
            suggest = "src_cidr"
        elif key == "srcPort":
            suggest = "src_port"
        elif key == "syslogEnabled":
            suggest = "syslog_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallCellularFirewallRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallCellularFirewallRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallCellularFirewallRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 dest_cidr: Optional[_builtins.str] = None,
                 dest_port: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 src_cidr: Optional[_builtins.str] = None,
                 src_port: Optional[_builtins.str] = None,
                 syslog_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param _builtins.str dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        :param _builtins.str src_cidr: Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        :param _builtins.str src_port: Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.bool syslog_enabled: Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if syslog_enabled is not None:
            pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        return pulumi.get(self, "src_cidr")

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "src_port")

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> Optional[_builtins.bool]:
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        return pulumi.get(self, "syslog_enabled")


@pulumi.output_type
class ApplianceFirewallInboundFirewallRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destCidr":
            suggest = "dest_cidr"
        elif key == "destPort":
            suggest = "dest_port"
        elif key == "srcCidr":
            suggest = "src_cidr"
        elif key == "srcPort":
            suggest = "src_port"
        elif key == "syslogEnabled":
            suggest = "syslog_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallInboundFirewallRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallInboundFirewallRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallInboundFirewallRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 dest_cidr: Optional[_builtins.str] = None,
                 dest_port: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 src_cidr: Optional[_builtins.str] = None,
                 src_port: Optional[_builtins.str] = None,
                 syslog_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param _builtins.str dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        :param _builtins.str src_cidr: Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        :param _builtins.str src_port: Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.bool syslog_enabled: Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if syslog_enabled is not None:
            pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        return pulumi.get(self, "src_cidr")

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "src_port")

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> Optional[_builtins.bool]:
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        return pulumi.get(self, "syslog_enabled")


@pulumi.output_type
class ApplianceFirewallInboundFirewallRulesRulesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destCidr":
            suggest = "dest_cidr"
        elif key == "destPort":
            suggest = "dest_port"
        elif key == "srcCidr":
            suggest = "src_cidr"
        elif key == "srcPort":
            suggest = "src_port"
        elif key == "syslogEnabled":
            suggest = "syslog_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallInboundFirewallRulesRulesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallInboundFirewallRulesRulesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallInboundFirewallRulesRulesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 dest_cidr: Optional[_builtins.str] = None,
                 dest_port: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 src_cidr: Optional[_builtins.str] = None,
                 src_port: Optional[_builtins.str] = None,
                 syslog_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param _builtins.str dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        :param _builtins.str src_cidr: Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        :param _builtins.str src_port: Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.bool syslog_enabled: Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if syslog_enabled is not None:
            pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        return pulumi.get(self, "src_cidr")

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "src_port")

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> Optional[_builtins.bool]:
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        return pulumi.get(self, "syslog_enabled")


@pulumi.output_type
class ApplianceFirewallL3FirewallRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destCidr":
            suggest = "dest_cidr"
        elif key == "destPort":
            suggest = "dest_port"
        elif key == "srcCidr":
            suggest = "src_cidr"
        elif key == "srcPort":
            suggest = "src_port"
        elif key == "syslogEnabled":
            suggest = "syslog_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallL3FirewallRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallL3FirewallRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallL3FirewallRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 dest_cidr: Optional[_builtins.str] = None,
                 dest_port: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 src_cidr: Optional[_builtins.str] = None,
                 src_port: Optional[_builtins.str] = None,
                 syslog_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param _builtins.str dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        :param _builtins.str src_cidr: Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        :param _builtins.str src_port: Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.bool syslog_enabled: Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if syslog_enabled is not None:
            pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        return pulumi.get(self, "src_cidr")

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "src_port")

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> Optional[_builtins.bool]:
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        return pulumi.get(self, "syslog_enabled")


@pulumi.output_type
class ApplianceFirewallL3FirewallRulesRulesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destCidr":
            suggest = "dest_cidr"
        elif key == "destPort":
            suggest = "dest_port"
        elif key == "srcCidr":
            suggest = "src_cidr"
        elif key == "srcPort":
            suggest = "src_port"
        elif key == "syslogEnabled":
            suggest = "syslog_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallL3FirewallRulesRulesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallL3FirewallRulesRulesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallL3FirewallRulesRulesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 dest_cidr: Optional[_builtins.str] = None,
                 dest_port: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 src_cidr: Optional[_builtins.str] = None,
                 src_port: Optional[_builtins.str] = None,
                 syslog_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param _builtins.str dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        :param _builtins.str src_cidr: Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        :param _builtins.str src_port: Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.bool syslog_enabled: Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if syslog_enabled is not None:
            pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        return pulumi.get(self, "src_cidr")

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "src_port")

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> Optional[_builtins.bool]:
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        return pulumi.get(self, "syslog_enabled")


@pulumi.output_type
class ApplianceFirewallL7FirewallRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueLists":
            suggest = "value_lists"
        elif key == "valueObj":
            suggest = "value_obj"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallL7FirewallRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallL7FirewallRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallL7FirewallRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None,
                 value_lists: Optional[Sequence[_builtins.str]] = None,
                 value_obj: Optional['outputs.ApplianceFirewallL7FirewallRulesRuleValueObj'] = None):
        """
        :param _builtins.str policy: 'Deny' traffic specified by this rule
        :param _builtins.str type: Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        :param _builtins.str value: The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. Send a string to request.
        :param Sequence[_builtins.str] value_lists: The 'value_list' of what you want to block. Send a lis of string in request.
        :param 'ApplianceFirewallL7FirewallRulesRuleValueObjArgs' value_obj: The 'value_obj' of what you want to block. Send a dict in request.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)
        if value_obj is not None:
            pulumi.set(__self__, "value_obj", value_obj)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'Deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. Send a string to request.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        The 'value_list' of what you want to block. Send a lis of string in request.
        """
        return pulumi.get(self, "value_lists")

    @_builtins.property
    @pulumi.getter(name="valueObj")
    def value_obj(self) -> Optional['outputs.ApplianceFirewallL7FirewallRulesRuleValueObj']:
        """
        The 'value_obj' of what you want to block. Send a dict in request.
        """
        return pulumi.get(self, "value_obj")


@pulumi.output_type
class ApplianceFirewallL7FirewallRulesRuleValueObj(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ApplianceFirewallL7FirewallRulesRulesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueLists":
            suggest = "value_lists"
        elif key == "valueObj":
            suggest = "value_obj"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallL7FirewallRulesRulesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallL7FirewallRulesRulesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallL7FirewallRulesRulesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None,
                 value_lists: Optional[Sequence[_builtins.str]] = None,
                 value_obj: Optional['outputs.ApplianceFirewallL7FirewallRulesRulesResponseValueObj'] = None):
        """
        :param _builtins.str policy: 'Deny' traffic specified by this rule
        :param _builtins.str type: Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        :param _builtins.str value: The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format.
        :param Sequence[_builtins.str] value_lists: The 'value_list' of what you want to block. Send a list in request
        :param 'ApplianceFirewallL7FirewallRulesRulesResponseValueObjArgs' value_obj: The 'value_obj' of what you want to block. Send a dict in request
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)
        if value_obj is not None:
            pulumi.set(__self__, "value_obj", value_obj)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'Deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        The 'value_list' of what you want to block. Send a list in request
        """
        return pulumi.get(self, "value_lists")

    @_builtins.property
    @pulumi.getter(name="valueObj")
    def value_obj(self) -> Optional['outputs.ApplianceFirewallL7FirewallRulesRulesResponseValueObj']:
        """
        The 'value_obj' of what you want to block. Send a dict in request
        """
        return pulumi.get(self, "value_obj")


@pulumi.output_type
class ApplianceFirewallL7FirewallRulesRulesResponseValueObj(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ApplianceFirewallOneToManyNatRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRules":
            suggest = "port_rules"
        elif key == "publicIp":
            suggest = "public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallOneToManyNatRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallOneToManyNatRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallOneToManyNatRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_rules: Optional[Sequence['outputs.ApplianceFirewallOneToManyNatRulesRulePortRule']] = None,
                 public_ip: Optional[_builtins.str] = None,
                 uplink: Optional[_builtins.str] = None):
        """
        :param Sequence['ApplianceFirewallOneToManyNatRulesRulePortRuleArgs'] port_rules: An array of associated forwarding rules
        :param _builtins.str public_ip: The IP address that will be used to access the internal resource from the WAN
        :param _builtins.str uplink: The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
        """
        if port_rules is not None:
            pulumi.set(__self__, "port_rules", port_rules)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if uplink is not None:
            pulumi.set(__self__, "uplink", uplink)

    @_builtins.property
    @pulumi.getter(name="portRules")
    def port_rules(self) -> Optional[Sequence['outputs.ApplianceFirewallOneToManyNatRulesRulePortRule']]:
        """
        An array of associated forwarding rules
        """
        return pulumi.get(self, "port_rules")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[_builtins.str]:
        """
        The IP address that will be used to access the internal resource from the WAN
        """
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def uplink(self) -> Optional[_builtins.str]:
        """
        The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
        """
        return pulumi.get(self, "uplink")


@pulumi.output_type
class ApplianceFirewallOneToManyNatRulesRulePortRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedIps":
            suggest = "allowed_ips"
        elif key == "localIp":
            suggest = "local_ip"
        elif key == "localPort":
            suggest = "local_port"
        elif key == "publicPort":
            suggest = "public_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallOneToManyNatRulesRulePortRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallOneToManyNatRulesRulePortRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallOneToManyNatRulesRulePortRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_ips: Optional[Sequence[_builtins.str]] = None,
                 local_ip: Optional[_builtins.str] = None,
                 local_port: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 public_port: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_ips: Remote IP addresses or ranges that are permitted to access the internal resource via this port forwarding rule, or 'any'
        :param _builtins.str local_ip: Local IP address to which traffic will be forwarded
        :param _builtins.str local_port: Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port
        :param _builtins.str name: A description of the rule
        :param _builtins.str protocol: 'tcp' or 'udp'
        :param _builtins.str public_port: Destination port of the traffic that is arriving on the WAN
        """
        if allowed_ips is not None:
            pulumi.set(__self__, "allowed_ips", allowed_ips)
        if local_ip is not None:
            pulumi.set(__self__, "local_ip", local_ip)
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_port is not None:
            pulumi.set(__self__, "public_port", public_port)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        Remote IP addresses or ranges that are permitted to access the internal resource via this port forwarding rule, or 'any'
        """
        return pulumi.get(self, "allowed_ips")

    @_builtins.property
    @pulumi.getter(name="localIp")
    def local_ip(self) -> Optional[_builtins.str]:
        """
        Local IP address to which traffic will be forwarded
        """
        return pulumi.get(self, "local_ip")

    @_builtins.property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[_builtins.str]:
        """
        Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port
        """
        return pulumi.get(self, "local_port")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A description of the rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        'tcp' or 'udp'
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="publicPort")
    def public_port(self) -> Optional[_builtins.str]:
        """
        Destination port of the traffic that is arriving on the WAN
        """
        return pulumi.get(self, "public_port")


@pulumi.output_type
class ApplianceFirewallOneToOneNatRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedInbounds":
            suggest = "allowed_inbounds"
        elif key == "lanIp":
            suggest = "lan_ip"
        elif key == "publicIp":
            suggest = "public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallOneToOneNatRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallOneToOneNatRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallOneToOneNatRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_inbounds: Optional[Sequence['outputs.ApplianceFirewallOneToOneNatRulesRuleAllowedInbound']] = None,
                 lan_ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 public_ip: Optional[_builtins.str] = None,
                 uplink: Optional[_builtins.str] = None):
        """
        :param Sequence['ApplianceFirewallOneToOneNatRulesRuleAllowedInboundArgs'] allowed_inbounds: The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource
        :param _builtins.str lan_ip: The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        :param _builtins.str name: A descriptive name for the rule
        :param _builtins.str public_ip: The IP address that will be used to access the internal resource from the WAN
        :param _builtins.str uplink: The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
        """
        if allowed_inbounds is not None:
            pulumi.set(__self__, "allowed_inbounds", allowed_inbounds)
        if lan_ip is not None:
            pulumi.set(__self__, "lan_ip", lan_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if uplink is not None:
            pulumi.set(__self__, "uplink", uplink)

    @_builtins.property
    @pulumi.getter(name="allowedInbounds")
    def allowed_inbounds(self) -> Optional[Sequence['outputs.ApplianceFirewallOneToOneNatRulesRuleAllowedInbound']]:
        """
        The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource
        """
        return pulumi.get(self, "allowed_inbounds")

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> Optional[_builtins.str]:
        """
        The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        """
        return pulumi.get(self, "lan_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A descriptive name for the rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[_builtins.str]:
        """
        The IP address that will be used to access the internal resource from the WAN
        """
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def uplink(self) -> Optional[_builtins.str]:
        """
        The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
        """
        return pulumi.get(self, "uplink")


@pulumi.output_type
class ApplianceFirewallOneToOneNatRulesRuleAllowedInbound(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedIps":
            suggest = "allowed_ips"
        elif key == "destinationPorts":
            suggest = "destination_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallOneToOneNatRulesRuleAllowedInbound. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallOneToOneNatRulesRuleAllowedInbound.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallOneToOneNatRulesRuleAllowedInbound.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_ips: Optional[Sequence[_builtins.str]] = None,
                 destination_ports: Optional[Sequence[_builtins.str]] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_ips: An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any'
        :param Sequence[_builtins.str] destination_ports: An array of ports or port ranges that will be forwarded to the host on the LAN
        :param _builtins.str protocol: Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
        """
        if allowed_ips is not None:
            pulumi.set(__self__, "allowed_ips", allowed_ips)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any'
        """
        return pulumi.get(self, "allowed_ips")

    @_builtins.property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of ports or port ranges that will be forwarded to the host on the LAN
        """
        return pulumi.get(self, "destination_ports")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ApplianceFirewallPortForwardingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedIps":
            suggest = "allowed_ips"
        elif key == "lanIp":
            suggest = "lan_ip"
        elif key == "localPort":
            suggest = "local_port"
        elif key == "publicPort":
            suggest = "public_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallPortForwardingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallPortForwardingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallPortForwardingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_ips: Optional[Sequence[_builtins.str]] = None,
                 lan_ip: Optional[_builtins.str] = None,
                 local_port: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 public_port: Optional[_builtins.str] = None,
                 uplink: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_ips: An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges (or any)
        :param _builtins.str lan_ip: The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        :param _builtins.str local_port: A port or port ranges that will receive the forwarded traffic from the WAN
        :param _builtins.str name: A descriptive name for the rule
        :param _builtins.str protocol: TCP or UDP
        :param _builtins.str public_port: A port or port ranges that will be forwarded to the host on the LAN
        :param _builtins.str uplink: The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both')
        """
        if allowed_ips is not None:
            pulumi.set(__self__, "allowed_ips", allowed_ips)
        if lan_ip is not None:
            pulumi.set(__self__, "lan_ip", lan_ip)
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_port is not None:
            pulumi.set(__self__, "public_port", public_port)
        if uplink is not None:
            pulumi.set(__self__, "uplink", uplink)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges (or any)
        """
        return pulumi.get(self, "allowed_ips")

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> Optional[_builtins.str]:
        """
        The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        """
        return pulumi.get(self, "lan_ip")

    @_builtins.property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[_builtins.str]:
        """
        A port or port ranges that will receive the forwarded traffic from the WAN
        """
        return pulumi.get(self, "local_port")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A descriptive name for the rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        TCP or UDP
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="publicPort")
    def public_port(self) -> Optional[_builtins.str]:
        """
        A port or port ranges that will be forwarded to the host on the LAN
        """
        return pulumi.get(self, "public_port")

    @_builtins.property
    @pulumi.getter
    def uplink(self) -> Optional[_builtins.str]:
        """
        The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both')
        """
        return pulumi.get(self, "uplink")


@pulumi.output_type
class ApplianceFirewallSettingsSpoofingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSourceGuard":
            suggest = "ip_source_guard"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceFirewallSettingsSpoofingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceFirewallSettingsSpoofingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceFirewallSettingsSpoofingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_source_guard: Optional['outputs.ApplianceFirewallSettingsSpoofingProtectionIpSourceGuard'] = None):
        """
        :param 'ApplianceFirewallSettingsSpoofingProtectionIpSourceGuardArgs' ip_source_guard: IP source address spoofing settings
        """
        if ip_source_guard is not None:
            pulumi.set(__self__, "ip_source_guard", ip_source_guard)

    @_builtins.property
    @pulumi.getter(name="ipSourceGuard")
    def ip_source_guard(self) -> Optional['outputs.ApplianceFirewallSettingsSpoofingProtectionIpSourceGuard']:
        """
        IP source address spoofing settings
        """
        return pulumi.get(self, "ip_source_guard")


@pulumi.output_type
class ApplianceFirewallSettingsSpoofingProtectionIpSourceGuard(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Mode of protection
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Mode of protection
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AppliancePrefixesDelegatedStaticsOrigin(dict):
    def __init__(__self__, *,
                 interfaces: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] interfaces: Uplink provided or independent
        :param _builtins.str type: Origin type
        """
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[Sequence[_builtins.str]]:
        """
        Uplink provided or independent
        """
        return pulumi.get(self, "interfaces")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Origin type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApplianceRfProfilesFiveGhzSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axEnabled":
            suggest = "ax_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceRfProfilesFiveGhzSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceRfProfilesFiveGhzSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceRfProfilesFiveGhzSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ax_enabled: Optional[_builtins.bool] = None,
                 min_bitrate: Optional[_builtins.int] = None):
        """
        :param _builtins.bool ax_enabled: Whether ax radio on 5Ghz band is on or off.
        :param _builtins.int min_bitrate: Min bitrate (Mbps) of 2.4Ghz band.
        """
        if ax_enabled is not None:
            pulumi.set(__self__, "ax_enabled", ax_enabled)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)

    @_builtins.property
    @pulumi.getter(name="axEnabled")
    def ax_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether ax radio on 5Ghz band is on or off.
        """
        return pulumi.get(self, "ax_enabled")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Min bitrate (Mbps) of 2.4Ghz band.
        """
        return pulumi.get(self, "min_bitrate")


@pulumi.output_type
class ApplianceRfProfilesPerSsidSettings(dict):
    def __init__(__self__, *,
                 status1: Optional['outputs.ApplianceRfProfilesPerSsidSettingsStatus1'] = None,
                 status2: Optional['outputs.ApplianceRfProfilesPerSsidSettingsStatus2'] = None,
                 status3: Optional['outputs.ApplianceRfProfilesPerSsidSettingsStatus3'] = None,
                 status4: Optional['outputs.ApplianceRfProfilesPerSsidSettingsStatus4'] = None):
        """
        :param 'ApplianceRfProfilesPerSsidSettingsStatus1Args' status1: Settings for SSID 1.
        :param 'ApplianceRfProfilesPerSsidSettingsStatus2Args' status2: Settings for SSID 2.
        :param 'ApplianceRfProfilesPerSsidSettingsStatus3Args' status3: Settings for SSID 3.
        :param 'ApplianceRfProfilesPerSsidSettingsStatus4Args' status4: Settings for SSID 4.
        """
        if status1 is not None:
            pulumi.set(__self__, "status1", status1)
        if status2 is not None:
            pulumi.set(__self__, "status2", status2)
        if status3 is not None:
            pulumi.set(__self__, "status3", status3)
        if status4 is not None:
            pulumi.set(__self__, "status4", status4)

    @_builtins.property
    @pulumi.getter
    def status1(self) -> Optional['outputs.ApplianceRfProfilesPerSsidSettingsStatus1']:
        """
        Settings for SSID 1.
        """
        return pulumi.get(self, "status1")

    @_builtins.property
    @pulumi.getter
    def status2(self) -> Optional['outputs.ApplianceRfProfilesPerSsidSettingsStatus2']:
        """
        Settings for SSID 2.
        """
        return pulumi.get(self, "status2")

    @_builtins.property
    @pulumi.getter
    def status3(self) -> Optional['outputs.ApplianceRfProfilesPerSsidSettingsStatus3']:
        """
        Settings for SSID 3.
        """
        return pulumi.get(self, "status3")

    @_builtins.property
    @pulumi.getter
    def status4(self) -> Optional['outputs.ApplianceRfProfilesPerSsidSettingsStatus4']:
        """
        Settings for SSID 4.
        """
        return pulumi.get(self, "status4")


@pulumi.output_type
class ApplianceRfProfilesPerSsidSettingsStatus1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceRfProfilesPerSsidSettingsStatus1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceRfProfilesPerSsidSettingsStatus1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceRfProfilesPerSsidSettingsStatus1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str band_operation_mode: Band mode of this SSID
        :param _builtins.bool band_steering_enabled: Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Band mode of this SSID
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        return pulumi.get(self, "band_steering_enabled")


@pulumi.output_type
class ApplianceRfProfilesPerSsidSettingsStatus2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceRfProfilesPerSsidSettingsStatus2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceRfProfilesPerSsidSettingsStatus2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceRfProfilesPerSsidSettingsStatus2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str band_operation_mode: Band mode of this SSID
        :param _builtins.bool band_steering_enabled: Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Band mode of this SSID
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        return pulumi.get(self, "band_steering_enabled")


@pulumi.output_type
class ApplianceRfProfilesPerSsidSettingsStatus3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceRfProfilesPerSsidSettingsStatus3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceRfProfilesPerSsidSettingsStatus3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceRfProfilesPerSsidSettingsStatus3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str band_operation_mode: Band mode of this SSID
        :param _builtins.bool band_steering_enabled: Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Band mode of this SSID
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        return pulumi.get(self, "band_steering_enabled")


@pulumi.output_type
class ApplianceRfProfilesPerSsidSettingsStatus4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceRfProfilesPerSsidSettingsStatus4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceRfProfilesPerSsidSettingsStatus4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceRfProfilesPerSsidSettingsStatus4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str band_operation_mode: Band mode of this SSID
        :param _builtins.bool band_steering_enabled: Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Band mode of this SSID
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        return pulumi.get(self, "band_steering_enabled")


@pulumi.output_type
class ApplianceRfProfilesTwoFourGhzSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axEnabled":
            suggest = "ax_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceRfProfilesTwoFourGhzSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceRfProfilesTwoFourGhzSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceRfProfilesTwoFourGhzSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ax_enabled: Optional[_builtins.bool] = None,
                 min_bitrate: Optional[_builtins.float] = None):
        """
        :param _builtins.bool ax_enabled: Whether ax radio on 2.4Ghz band is on or off.
        :param _builtins.float min_bitrate: Min bitrate (Mbps) of 2.4Ghz band.
        """
        if ax_enabled is not None:
            pulumi.set(__self__, "ax_enabled", ax_enabled)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)

    @_builtins.property
    @pulumi.getter(name="axEnabled")
    def ax_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether ax radio on 2.4Ghz band is on or off.
        """
        return pulumi.get(self, "ax_enabled")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.float]:
        """
        Min bitrate (Mbps) of 2.4Ghz band.
        """
        return pulumi.get(self, "min_bitrate")


@pulumi.output_type
class ApplianceSecurityIntrusionProtectedNetworks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCidrs":
            suggest = "excluded_cidrs"
        elif key == "includedCidrs":
            suggest = "included_cidrs"
        elif key == "useDefault":
            suggest = "use_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceSecurityIntrusionProtectedNetworks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceSecurityIntrusionProtectedNetworks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceSecurityIntrusionProtectedNetworks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 excluded_cidrs: Optional[Sequence[_builtins.str]] = None,
                 included_cidrs: Optional[Sequence[_builtins.str]] = None,
                 use_default: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] excluded_cidrs: List of IP addresses or subnets being excluded from protection
        :param Sequence[_builtins.str] included_cidrs: List of IP addresses or subnets being protected
        :param _builtins.bool use_default: Whether special IPv4 addresses should be used (see: https://tools.ietf.org/html/rfc5735)
        """
        if excluded_cidrs is not None:
            pulumi.set(__self__, "excluded_cidrs", excluded_cidrs)
        if included_cidrs is not None:
            pulumi.set(__self__, "included_cidrs", included_cidrs)
        if use_default is not None:
            pulumi.set(__self__, "use_default", use_default)

    @_builtins.property
    @pulumi.getter(name="excludedCidrs")
    def excluded_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of IP addresses or subnets being excluded from protection
        """
        return pulumi.get(self, "excluded_cidrs")

    @_builtins.property
    @pulumi.getter(name="includedCidrs")
    def included_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of IP addresses or subnets being protected
        """
        return pulumi.get(self, "included_cidrs")

    @_builtins.property
    @pulumi.getter(name="useDefault")
    def use_default(self) -> Optional[_builtins.bool]:
        """
        Whether special IPv4 addresses should be used (see: https://tools.ietf.org/html/rfc5735)
        """
        return pulumi.get(self, "use_default")


@pulumi.output_type
class ApplianceSecurityMalwareAllowedFile(dict):
    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: Comment about the allowed file
        :param _builtins.str sha256: The sha256 digest of allowed file
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Comment about the allowed file
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        The sha256 digest of allowed file
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class ApplianceSecurityMalwareAllowedUrl(dict):
    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: Comment about the allowed URL
        :param _builtins.str url: The allowed URL
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Comment about the allowed URL
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The allowed URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ApplianceSettingsDynamicDns(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 prefix: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Dynamic DNS enabled
        :param _builtins.str prefix: Dynamic DNS url prefix. DDNS must be enabled to update
        :param _builtins.str url: Dynamic DNS url. DDNS must be enabled to update
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Dynamic DNS enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Dynamic DNS url prefix. DDNS must be enabled to update
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Dynamic DNS url. DDNS must be enabled to update
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ApplianceSingleLanIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixAssignments":
            suggest = "prefix_assignments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceSingleLanIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceSingleLanIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceSingleLanIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 prefix_assignments: Optional[Sequence['outputs.ApplianceSingleLanIpv6PrefixAssignment']] = None):
        """
        :param _builtins.bool enabled: Enable IPv6 on single LAN
        :param Sequence['ApplianceSingleLanIpv6PrefixAssignmentArgs'] prefix_assignments: Prefix assignments on the single LAN
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if prefix_assignments is not None:
            pulumi.set(__self__, "prefix_assignments", prefix_assignments)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable IPv6 on single LAN
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="prefixAssignments")
    def prefix_assignments(self) -> Optional[Sequence['outputs.ApplianceSingleLanIpv6PrefixAssignment']]:
        """
        Prefix assignments on the single LAN
        """
        return pulumi.get(self, "prefix_assignments")


@pulumi.output_type
class ApplianceSingleLanIpv6PrefixAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticApplianceIp6":
            suggest = "static_appliance_ip6"
        elif key == "staticPrefix":
            suggest = "static_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceSingleLanIpv6PrefixAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceSingleLanIpv6PrefixAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceSingleLanIpv6PrefixAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autonomous: Optional[_builtins.bool] = None,
                 origin: Optional['outputs.ApplianceSingleLanIpv6PrefixAssignmentOrigin'] = None,
                 static_appliance_ip6: Optional[_builtins.str] = None,
                 static_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.bool autonomous: Auto assign a /64 prefix from the origin to the single LAN
        :param 'ApplianceSingleLanIpv6PrefixAssignmentOriginArgs' origin: The origin of the prefix
        :param _builtins.str static_appliance_ip6: Manual configuration of the IPv6 Appliance IP
        :param _builtins.str static_prefix: Manual configuration of a /64 prefix on the single LAN
        """
        if autonomous is not None:
            pulumi.set(__self__, "autonomous", autonomous)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if static_appliance_ip6 is not None:
            pulumi.set(__self__, "static_appliance_ip6", static_appliance_ip6)
        if static_prefix is not None:
            pulumi.set(__self__, "static_prefix", static_prefix)

    @_builtins.property
    @pulumi.getter
    def autonomous(self) -> Optional[_builtins.bool]:
        """
        Auto assign a /64 prefix from the origin to the single LAN
        """
        return pulumi.get(self, "autonomous")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional['outputs.ApplianceSingleLanIpv6PrefixAssignmentOrigin']:
        """
        The origin of the prefix
        """
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="staticApplianceIp6")
    def static_appliance_ip6(self) -> Optional[_builtins.str]:
        """
        Manual configuration of the IPv6 Appliance IP
        """
        return pulumi.get(self, "static_appliance_ip6")

    @_builtins.property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> Optional[_builtins.str]:
        """
        Manual configuration of a /64 prefix on the single LAN
        """
        return pulumi.get(self, "static_prefix")


@pulumi.output_type
class ApplianceSingleLanIpv6PrefixAssignmentOrigin(dict):
    def __init__(__self__, *,
                 interfaces: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] interfaces: Interfaces associated with the prefix
        :param _builtins.str type: Type of the origin
        """
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[Sequence[_builtins.str]]:
        """
        Interfaces associated with the prefix
        """
        return pulumi.get(self, "interfaces")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the origin
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApplianceSingleLanMandatoryDhcp(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enable Mandatory DHCP on single LAN.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable Mandatory DHCP on single LAN.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApplianceSsidsDhcpEnforcedDeauthentication(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enable DCHP Enforced Deauthentication on the SSID.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable DCHP Enforced Deauthentication on the SSID.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApplianceSsidsDot11w(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 required: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether 802.11w is enabled or not.
        :param _builtins.bool required: (Optional) Whether 802.11w is required or not.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether 802.11w is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        (Optional) Whether 802.11w is required or not.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class ApplianceSsidsRadiusServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: The IP address of your RADIUS server.
        :param _builtins.int port: The UDP port your RADIUS servers listens on for Access-requests.
        :param _builtins.str secret: The RADIUS client shared secret.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The IP address of your RADIUS server.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The UDP port your RADIUS servers listens on for Access-requests.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        The RADIUS client shared secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ApplianceSsidsRadiusServersResponse(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: The IP address of your RADIUS server.
        :param _builtins.int port: The UDP port your RADIUS servers listens on for Access-requests.
        :param _builtins.str secret: The RADIUS client shared secret.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The IP address of your RADIUS server.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The UDP port your RADIUS servers listens on for Access-requests.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        The RADIUS client shared secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ApplianceTrafficShapingCustomPerformanceClassesParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxJitter":
            suggest = "max_jitter"
        elif key == "maxLatency":
            suggest = "max_latency"
        elif key == "maxLossPercentage":
            suggest = "max_loss_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingCustomPerformanceClassesParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingCustomPerformanceClassesParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingCustomPerformanceClassesParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_jitter: Optional[_builtins.int] = None,
                 max_latency: Optional[_builtins.int] = None,
                 max_loss_percentage: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.int max_jitter: Maximum jitter in milliseconds
        :param _builtins.int max_latency: Maximum latency in milliseconds
        :param _builtins.int max_loss_percentage: Maximum percentage of packet loss
        :param _builtins.str name: Name of the custom performance class
        """
        if max_jitter is not None:
            pulumi.set(__self__, "max_jitter", max_jitter)
        if max_latency is not None:
            pulumi.set(__self__, "max_latency", max_latency)
        if max_loss_percentage is not None:
            pulumi.set(__self__, "max_loss_percentage", max_loss_percentage)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="maxJitter")
    def max_jitter(self) -> Optional[_builtins.int]:
        """
        Maximum jitter in milliseconds
        """
        return pulumi.get(self, "max_jitter")

    @_builtins.property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> Optional[_builtins.int]:
        """
        Maximum latency in milliseconds
        """
        return pulumi.get(self, "max_latency")

    @_builtins.property
    @pulumi.getter(name="maxLossPercentage")
    def max_loss_percentage(self) -> Optional[_builtins.int]:
        """
        Maximum percentage of packet loss
        """
        return pulumi.get(self, "max_loss_percentage")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the custom performance class
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ApplianceTrafficShapingGlobalBandwidthLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitDown":
            suggest = "limit_down"
        elif key == "limitUp":
            suggest = "limit_up"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingGlobalBandwidthLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingGlobalBandwidthLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingGlobalBandwidthLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_down: Optional[_builtins.int] = None,
                 limit_up: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit_down: The download bandwidth limit in Kbps. (0 represents no limit.)
        :param _builtins.int limit_up: The upload bandwidth limit in Kbps. (0 represents no limit.)
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[_builtins.int]:
        """
        The download bandwidth limit in Kbps. (0 represents no limit.)
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[_builtins.int]:
        """
        The upload bandwidth limit in Kbps. (0 represents no limit.)
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class ApplianceTrafficShapingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dscpTagValue":
            suggest = "dscp_tag_value"
        elif key == "perClientBandwidthLimits":
            suggest = "per_client_bandwidth_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definitions: Optional[Sequence['outputs.ApplianceTrafficShapingRulesRuleDefinition']] = None,
                 dscp_tag_value: Optional[_builtins.int] = None,
                 per_client_bandwidth_limits: Optional['outputs.ApplianceTrafficShapingRulesRulePerClientBandwidthLimits'] = None,
                 priority: Optional[_builtins.str] = None):
        """
        :param Sequence['ApplianceTrafficShapingRulesRuleDefinitionArgs'] definitions: A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        :param _builtins.int dscp_tag_value: The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
               For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        :param 'ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsArgs' per_client_bandwidth_limits: An object describing the bandwidth settings for your rule.
        :param _builtins.str priority: A string, indicating the priority level for packets bound to your rule.
               Can be 'low', 'normal' or 'high'.
        """
        if definitions is not None:
            pulumi.set(__self__, "definitions", definitions)
        if dscp_tag_value is not None:
            pulumi.set(__self__, "dscp_tag_value", dscp_tag_value)
        if per_client_bandwidth_limits is not None:
            pulumi.set(__self__, "per_client_bandwidth_limits", per_client_bandwidth_limits)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> Optional[Sequence['outputs.ApplianceTrafficShapingRulesRuleDefinition']]:
        """
        A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        """
        return pulumi.get(self, "definitions")

    @_builtins.property
    @pulumi.getter(name="dscpTagValue")
    def dscp_tag_value(self) -> Optional[_builtins.int]:
        """
        The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        """
        return pulumi.get(self, "dscp_tag_value")

    @_builtins.property
    @pulumi.getter(name="perClientBandwidthLimits")
    def per_client_bandwidth_limits(self) -> Optional['outputs.ApplianceTrafficShapingRulesRulePerClientBandwidthLimits']:
        """
        An object describing the bandwidth settings for your rule.
        """
        return pulumi.get(self, "per_client_bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.str]:
        """
        A string, indicating the priority level for packets bound to your rule.
        Can be 'low', 'normal' or 'high'.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class ApplianceTrafficShapingRulesRuleDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueLists":
            suggest = "value_lists"
        elif key == "valueObj":
            suggest = "value_obj"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingRulesRuleDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingRulesRuleDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingRulesRuleDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None,
                 value_lists: Optional[Sequence[_builtins.str]] = None,
                 value_obj: Optional['outputs.ApplianceTrafficShapingRulesRuleDefinitionValueObj'] = None):
        """
        :param _builtins.str type: The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        :param _builtins.str value: If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
               a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
               "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
               custom ports.
                If "type" is 'application' or 'applicationCategory', then "value" must be an object
               with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
               application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
               endpoint).
        :param Sequence[_builtins.str] value_lists: The 'value_list' of what you want to block. Send a list in request
        :param 'ApplianceTrafficShapingRulesRuleDefinitionValueObjArgs' value_obj: The 'value_obj' of what you want to block. Send a dict in request
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)
        if value_obj is not None:
            pulumi.set(__self__, "value_obj", value_obj)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
        a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
        "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
        custom ports.
         If "type" is 'application' or 'applicationCategory', then "value" must be an object
        with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
        application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
        endpoint).
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        The 'value_list' of what you want to block. Send a list in request
        """
        return pulumi.get(self, "value_lists")

    @_builtins.property
    @pulumi.getter(name="valueObj")
    def value_obj(self) -> Optional['outputs.ApplianceTrafficShapingRulesRuleDefinitionValueObj']:
        """
        The 'value_obj' of what you want to block. Send a dict in request
        """
        return pulumi.get(self, "value_obj")


@pulumi.output_type
class ApplianceTrafficShapingRulesRuleDefinitionValueObj(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ApplianceTrafficShapingRulesRulePerClientBandwidthLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthLimits":
            suggest = "bandwidth_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingRulesRulePerClientBandwidthLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingRulesRulePerClientBandwidthLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingRulesRulePerClientBandwidthLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_limits: Optional['outputs.ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits'] = None,
                 settings: Optional[_builtins.str] = None):
        """
        :param 'ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs' bandwidth_limits: The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        :param _builtins.str settings: How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        if bandwidth_limits is not None:
            pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> Optional['outputs.ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits']:
        """
        The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[_builtins.str]:
        """
        How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitDown":
            suggest = "limit_down"
        elif key == "limitUp":
            suggest = "limit_up"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_down: Optional[_builtins.int] = None,
                 limit_up: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit_down: The maximum download limit (integer, in Kbps).
        :param _builtins.int limit_up: The maximum upload limit (integer, in Kbps).
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[_builtins.int]:
        """
        The maximum download limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[_builtins.int]:
        """
        The maximum upload limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class ApplianceTrafficShapingUplinkBandwidthBandwidthLimits(dict):
    def __init__(__self__, *,
                 cellular: Optional['outputs.ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellular'] = None,
                 wan1: Optional['outputs.ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1'] = None,
                 wan2: Optional['outputs.ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2'] = None):
        """
        :param 'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellularArgs' cellular: uplink cellular configured limits [optional]
        :param 'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1Args' wan1: uplink wan1 configured limits [optional]
        :param 'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2Args' wan2: uplink wan2 configured limits [optional]
        """
        if cellular is not None:
            pulumi.set(__self__, "cellular", cellular)
        if wan1 is not None:
            pulumi.set(__self__, "wan1", wan1)
        if wan2 is not None:
            pulumi.set(__self__, "wan2", wan2)

    @_builtins.property
    @pulumi.getter
    def cellular(self) -> Optional['outputs.ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellular']:
        """
        uplink cellular configured limits [optional]
        """
        return pulumi.get(self, "cellular")

    @_builtins.property
    @pulumi.getter
    def wan1(self) -> Optional['outputs.ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1']:
        """
        uplink wan1 configured limits [optional]
        """
        return pulumi.get(self, "wan1")

    @_builtins.property
    @pulumi.getter
    def wan2(self) -> Optional['outputs.ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2']:
        """
        uplink wan2 configured limits [optional]
        """
        return pulumi.get(self, "wan2")


@pulumi.output_type
class ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellular(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitDown":
            suggest = "limit_down"
        elif key == "limitUp":
            suggest = "limit_up"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellular. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellular.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellular.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_down: Optional[_builtins.int] = None,
                 limit_up: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit_down: configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        :param _builtins.int limit_up: configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[_builtins.int]:
        """
        configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[_builtins.int]:
        """
        configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitDown":
            suggest = "limit_down"
        elif key == "limitUp":
            suggest = "limit_up"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_down: Optional[_builtins.int] = None,
                 limit_up: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit_down: configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        :param _builtins.int limit_up: configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[_builtins.int]:
        """
        configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[_builtins.int]:
        """
        configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitDown":
            suggest = "limit_down"
        elif key == "limitUp":
            suggest = "limit_up"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_down: Optional[_builtins.int] = None,
                 limit_up: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit_down: configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        :param _builtins.int limit_up: configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[_builtins.int]:
        """
        configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[_builtins.int]:
        """
        configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionFailoverAndFailback(dict):
    def __init__(__self__, *,
                 immediate: Optional['outputs.ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediate'] = None):
        """
        :param 'ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediateArgs' immediate: Immediate WAN failover and failback
        """
        if immediate is not None:
            pulumi.set(__self__, "immediate", immediate)

    @_builtins.property
    @pulumi.getter
    def immediate(self) -> Optional['outputs.ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediate']:
        """
        Immediate WAN failover and failback
        """
        return pulumi.get(self, "immediate")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediate(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether immediate WAN failover and failback is enabled
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether immediate WAN failover and failback is enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failOverCriterion":
            suggest = "fail_over_criterion"
        elif key == "performanceClass":
            suggest = "performance_class"
        elif key == "preferredUplink":
            suggest = "preferred_uplink"
        elif key == "trafficFilters":
            suggest = "traffic_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fail_over_criterion: Optional[_builtins.str] = None,
                 performance_class: Optional['outputs.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClass'] = None,
                 preferred_uplink: Optional[_builtins.str] = None,
                 traffic_filters: Optional[Sequence['outputs.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilter']] = None):
        """
        :param _builtins.str fail_over_criterion: Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
        :param 'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClassArgs' performance_class: Performance class setting for uplink preference rule
        :param _builtins.str preferred_uplink: Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
        :param Sequence['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterArgs'] traffic_filters: Traffic filters
        """
        if fail_over_criterion is not None:
            pulumi.set(__self__, "fail_over_criterion", fail_over_criterion)
        if performance_class is not None:
            pulumi.set(__self__, "performance_class", performance_class)
        if preferred_uplink is not None:
            pulumi.set(__self__, "preferred_uplink", preferred_uplink)
        if traffic_filters is not None:
            pulumi.set(__self__, "traffic_filters", traffic_filters)

    @_builtins.property
    @pulumi.getter(name="failOverCriterion")
    def fail_over_criterion(self) -> Optional[_builtins.str]:
        """
        Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
        """
        return pulumi.get(self, "fail_over_criterion")

    @_builtins.property
    @pulumi.getter(name="performanceClass")
    def performance_class(self) -> Optional['outputs.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClass']:
        """
        Performance class setting for uplink preference rule
        """
        return pulumi.get(self, "performance_class")

    @_builtins.property
    @pulumi.getter(name="preferredUplink")
    def preferred_uplink(self) -> Optional[_builtins.str]:
        """
        Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
        """
        return pulumi.get(self, "preferred_uplink")

    @_builtins.property
    @pulumi.getter(name="trafficFilters")
    def traffic_filters(self) -> Optional[Sequence['outputs.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilter']]:
        """
        Traffic filters
        """
        return pulumi.get(self, "traffic_filters")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClass(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "builtinPerformanceClassName":
            suggest = "builtin_performance_class_name"
        elif key == "customPerformanceClassId":
            suggest = "custom_performance_class_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 builtin_performance_class_name: Optional[_builtins.str] = None,
                 custom_performance_class_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str builtin_performance_class_name: Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'
        :param _builtins.str custom_performance_class_id: ID of created custom performance class, must be present when performanceClass type is "custom"
        :param _builtins.str type: Type of this performance class. Must be one of: 'builtin' or 'custom'
        """
        if builtin_performance_class_name is not None:
            pulumi.set(__self__, "builtin_performance_class_name", builtin_performance_class_name)
        if custom_performance_class_id is not None:
            pulumi.set(__self__, "custom_performance_class_id", custom_performance_class_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="builtinPerformanceClassName")
    def builtin_performance_class_name(self) -> Optional[_builtins.str]:
        """
        Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'
        """
        return pulumi.get(self, "builtin_performance_class_name")

    @_builtins.property
    @pulumi.getter(name="customPerformanceClassId")
    def custom_performance_class_id(self) -> Optional[_builtins.str]:
        """
        ID of created custom performance class, must be present when performanceClass type is "custom"
        """
        return pulumi.get(self, "custom_performance_class_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of this performance class. Must be one of: 'builtin' or 'custom'
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilter(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional['outputs.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValue'] = None):
        """
        :param _builtins.str type: Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
        :param 'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueArgs' value: Value of traffic filter
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['outputs.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValue']:
        """
        Value of traffic filter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValue(dict):
    def __init__(__self__, *,
                 destination: Optional['outputs.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestination'] = None,
                 id: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 source: Optional['outputs.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSource'] = None):
        """
        :param 'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestinationArgs' destination: Destination of 'custom' type traffic filter
        :param _builtins.str id: ID of 'applicationCategory' or 'application' type traffic filter
        :param _builtins.str protocol: Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
        :param 'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSourceArgs' source: Source of 'custom' type traffic filter
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestination']:
        """
        Destination of 'custom' type traffic filter
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of 'applicationCategory' or 'application' type traffic filter
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSource']:
        """
        Source of 'custom' type traffic filter
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestination(dict):
    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 fqdn: Optional[_builtins.str] = None,
                 host: Optional[_builtins.int] = None,
                 network: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 vlan: Optional[_builtins.int] = None):
        """
        :param _builtins.str cidr: CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property
        :param _builtins.str fqdn: FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com"
        :param _builtins.int host: Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        :param _builtins.str network: Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        :param _builtins.str port: E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        :param _builtins.int vlan: VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com"
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.int]:
        """
        Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[_builtins.int]:
        """
        VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSource(dict):
    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 host: Optional[_builtins.int] = None,
                 network: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 vlan: Optional[_builtins.int] = None):
        """
        :param _builtins.str cidr: CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        :param _builtins.int host: Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        :param _builtins.str network: Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        :param _builtins.str port: E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        :param _builtins.int vlan: VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.int]:
        """
        Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[_builtins.int]:
        """
        VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferredUplink":
            suggest = "preferred_uplink"
        elif key == "trafficFilters":
            suggest = "traffic_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred_uplink: Optional[_builtins.str] = None,
                 traffic_filters: Optional[Sequence['outputs.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilter']] = None):
        """
        :param _builtins.str preferred_uplink: Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
        :param Sequence['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterArgs'] traffic_filters: Traffic filters
        """
        if preferred_uplink is not None:
            pulumi.set(__self__, "preferred_uplink", preferred_uplink)
        if traffic_filters is not None:
            pulumi.set(__self__, "traffic_filters", traffic_filters)

    @_builtins.property
    @pulumi.getter(name="preferredUplink")
    def preferred_uplink(self) -> Optional[_builtins.str]:
        """
        Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
        """
        return pulumi.get(self, "preferred_uplink")

    @_builtins.property
    @pulumi.getter(name="trafficFilters")
    def traffic_filters(self) -> Optional[Sequence['outputs.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilter']]:
        """
        Traffic filters
        """
        return pulumi.get(self, "traffic_filters")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilter(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional['outputs.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValue'] = None):
        """
        :param _builtins.str type: Traffic filter type. Must be "custom"
        :param 'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueArgs' value: Value of traffic filter
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Traffic filter type. Must be "custom"
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['outputs.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValue']:
        """
        Value of traffic filter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValue(dict):
    def __init__(__self__, *,
                 destination: Optional['outputs.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestination'] = None,
                 protocol: Optional[_builtins.str] = None,
                 source: Optional['outputs.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSource'] = None):
        """
        :param 'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestinationArgs' destination: Destination of 'custom' type traffic filter
        :param _builtins.str protocol: Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
        :param 'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSourceArgs' source: Source of 'custom' type traffic filter
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestination']:
        """
        Destination of 'custom' type traffic filter
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSource']:
        """
        Source of 'custom' type traffic filter
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestination(dict):
    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.str cidr: CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any"
        :param _builtins.str port: E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any"
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSource(dict):
    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 host: Optional[_builtins.int] = None,
                 port: Optional[_builtins.str] = None,
                 vlan: Optional[_builtins.int] = None):
        """
        :param _builtins.str cidr: CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        :param _builtins.int host: Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        :param _builtins.str port: E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        :param _builtins.int vlan: VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.int]:
        """
        Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[_builtins.int]:
        """
        VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class ApplianceTrafficShapingVpnExclusionsItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "majorApplications":
            suggest = "major_applications"
        elif key == "networkId":
            suggest = "network_id"
        elif key == "networkName":
            suggest = "network_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingVpnExclusionsItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingVpnExclusionsItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingVpnExclusionsItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customs: Optional[Sequence['outputs.ApplianceTrafficShapingVpnExclusionsItemCustom']] = None,
                 major_applications: Optional[Sequence['outputs.ApplianceTrafficShapingVpnExclusionsItemMajorApplication']] = None,
                 network_id: Optional[_builtins.str] = None,
                 network_name: Optional[_builtins.str] = None):
        """
        :param Sequence['ApplianceTrafficShapingVpnExclusionsItemCustomArgs'] customs: Custom VPN exclusion rules.
        :param Sequence['ApplianceTrafficShapingVpnExclusionsItemMajorApplicationArgs'] major_applications: Major Application based VPN exclusion rules.
        :param _builtins.str network_id: ID of the network whose VPN exclusion rules are returned.
        :param _builtins.str network_name: Name of the network whose VPN exclusion rules are returned.
        """
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if major_applications is not None:
            pulumi.set(__self__, "major_applications", major_applications)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if network_name is not None:
            pulumi.set(__self__, "network_name", network_name)

    @_builtins.property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.ApplianceTrafficShapingVpnExclusionsItemCustom']]:
        """
        Custom VPN exclusion rules.
        """
        return pulumi.get(self, "customs")

    @_builtins.property
    @pulumi.getter(name="majorApplications")
    def major_applications(self) -> Optional[Sequence['outputs.ApplianceTrafficShapingVpnExclusionsItemMajorApplication']]:
        """
        Major Application based VPN exclusion rules.
        """
        return pulumi.get(self, "major_applications")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[_builtins.str]:
        """
        ID of the network whose VPN exclusion rules are returned.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> Optional[_builtins.str]:
        """
        Name of the network whose VPN exclusion rules are returned.
        """
        return pulumi.get(self, "network_name")


@pulumi.output_type
class ApplianceTrafficShapingVpnExclusionsItemCustom(dict):
    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination: Destination address; hostname required for DNS, IPv4 otherwise.
        :param _builtins.str port: Destination port.
        :param _builtins.str protocol: Protocol.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        """
        Destination address; hostname required for DNS, IPv4 otherwise.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Destination port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ApplianceTrafficShapingVpnExclusionsItemMajorApplication(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Application's Meraki ID.
        :param _builtins.str name: Application's name.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Application's Meraki ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Application's name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ApplianceTrafficShapingVpnExclusionsParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "majorApplications":
            suggest = "major_applications"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceTrafficShapingVpnExclusionsParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceTrafficShapingVpnExclusionsParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceTrafficShapingVpnExclusionsParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customs: Optional[Sequence['outputs.ApplianceTrafficShapingVpnExclusionsParametersCustom']] = None,
                 major_applications: Optional[Sequence['outputs.ApplianceTrafficShapingVpnExclusionsParametersMajorApplication']] = None):
        """
        :param Sequence['ApplianceTrafficShapingVpnExclusionsParametersCustomArgs'] customs: Custom VPN exclusion rules. Pass an empty array to clear existing rules.
        :param Sequence['ApplianceTrafficShapingVpnExclusionsParametersMajorApplicationArgs'] major_applications: Major Application based VPN exclusion rules. Pass an empty array to clear existing rules.
        """
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if major_applications is not None:
            pulumi.set(__self__, "major_applications", major_applications)

    @_builtins.property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.ApplianceTrafficShapingVpnExclusionsParametersCustom']]:
        """
        Custom VPN exclusion rules. Pass an empty array to clear existing rules.
        """
        return pulumi.get(self, "customs")

    @_builtins.property
    @pulumi.getter(name="majorApplications")
    def major_applications(self) -> Optional[Sequence['outputs.ApplianceTrafficShapingVpnExclusionsParametersMajorApplication']]:
        """
        Major Application based VPN exclusion rules. Pass an empty array to clear existing rules.
        """
        return pulumi.get(self, "major_applications")


@pulumi.output_type
class ApplianceTrafficShapingVpnExclusionsParametersCustom(dict):
    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination: Destination address; hostname required for DNS, IPv4 otherwise.
        :param _builtins.str port: Destination port.
        :param _builtins.str protocol: Protocol.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        """
        Destination address; hostname required for DNS, IPv4 otherwise.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Destination port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ApplianceTrafficShapingVpnExclusionsParametersMajorApplication(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Application's Meraki ID.
        :param _builtins.str name: Application's name.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Application's Meraki ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Application's name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ApplianceVlansDhcpOption(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str code: The code for the DHCP option. This should be an integer between 2 and 254.
        :param _builtins.str type: The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
        :param _builtins.str value: The value for the DHCP option
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        The code for the DHCP option. This should be an integer between 2 and 254.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value for the DHCP option
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ApplianceVlansIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixAssignments":
            suggest = "prefix_assignments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceVlansIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceVlansIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceVlansIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 prefix_assignments: Optional[Sequence['outputs.ApplianceVlansIpv6PrefixAssignment']] = None):
        """
        :param _builtins.bool enabled: Enable IPv6 on VLAN
        :param Sequence['ApplianceVlansIpv6PrefixAssignmentArgs'] prefix_assignments: Prefix assignments on the VLAN
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if prefix_assignments is not None:
            pulumi.set(__self__, "prefix_assignments", prefix_assignments)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable IPv6 on VLAN
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="prefixAssignments")
    def prefix_assignments(self) -> Optional[Sequence['outputs.ApplianceVlansIpv6PrefixAssignment']]:
        """
        Prefix assignments on the VLAN
        """
        return pulumi.get(self, "prefix_assignments")


@pulumi.output_type
class ApplianceVlansIpv6PrefixAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticApplianceIp6":
            suggest = "static_appliance_ip6"
        elif key == "staticPrefix":
            suggest = "static_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceVlansIpv6PrefixAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceVlansIpv6PrefixAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceVlansIpv6PrefixAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autonomous: Optional[_builtins.bool] = None,
                 origin: Optional['outputs.ApplianceVlansIpv6PrefixAssignmentOrigin'] = None,
                 static_appliance_ip6: Optional[_builtins.str] = None,
                 static_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.bool autonomous: Auto assign a /64 prefix from the origin to the VLAN
        :param 'ApplianceVlansIpv6PrefixAssignmentOriginArgs' origin: The origin of the prefix
        :param _builtins.str static_appliance_ip6: Manual configuration of the IPv6 Appliance IP
        :param _builtins.str static_prefix: Manual configuration of a /64 prefix on the VLAN
        """
        if autonomous is not None:
            pulumi.set(__self__, "autonomous", autonomous)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if static_appliance_ip6 is not None:
            pulumi.set(__self__, "static_appliance_ip6", static_appliance_ip6)
        if static_prefix is not None:
            pulumi.set(__self__, "static_prefix", static_prefix)

    @_builtins.property
    @pulumi.getter
    def autonomous(self) -> Optional[_builtins.bool]:
        """
        Auto assign a /64 prefix from the origin to the VLAN
        """
        return pulumi.get(self, "autonomous")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional['outputs.ApplianceVlansIpv6PrefixAssignmentOrigin']:
        """
        The origin of the prefix
        """
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="staticApplianceIp6")
    def static_appliance_ip6(self) -> Optional[_builtins.str]:
        """
        Manual configuration of the IPv6 Appliance IP
        """
        return pulumi.get(self, "static_appliance_ip6")

    @_builtins.property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> Optional[_builtins.str]:
        """
        Manual configuration of a /64 prefix on the VLAN
        """
        return pulumi.get(self, "static_prefix")


@pulumi.output_type
class ApplianceVlansIpv6PrefixAssignmentOrigin(dict):
    def __init__(__self__, *,
                 interfaces: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] interfaces: Interfaces associated with the prefix
        :param _builtins.str type: Type of the origin
        """
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[Sequence[_builtins.str]]:
        """
        Interfaces associated with the prefix
        """
        return pulumi.get(self, "interfaces")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the origin
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApplianceVlansMandatoryDhcp(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enable Mandatory DHCP on VLAN.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable Mandatory DHCP on VLAN.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApplianceVlansReservedIpRange(dict):
    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 end: Optional[_builtins.str] = None,
                 start: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: A text comment for the reserved range
        :param _builtins.str end: The last IP in the reserved range
        :param _builtins.str start: The first IP in the reserved range
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        A text comment for the reserved range
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.str]:
        """
        The last IP in the reserved range
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.str]:
        """
        The first IP in the reserved range
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class ApplianceVpnBgpNeighbor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowTransit":
            suggest = "allow_transit"
        elif key == "ebgpHoldTimer":
            suggest = "ebgp_hold_timer"
        elif key == "ebgpMultihop":
            suggest = "ebgp_multihop"
        elif key == "nextHopIp":
            suggest = "next_hop_ip"
        elif key == "receiveLimit":
            suggest = "receive_limit"
        elif key == "remoteAsNumber":
            suggest = "remote_as_number"
        elif key == "sourceInterface":
            suggest = "source_interface"
        elif key == "ttlSecurity":
            suggest = "ttl_security"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceVpnBgpNeighbor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceVpnBgpNeighbor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceVpnBgpNeighbor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_transit: Optional[_builtins.bool] = None,
                 authentication: Optional['outputs.ApplianceVpnBgpNeighborAuthentication'] = None,
                 ebgp_hold_timer: Optional[_builtins.int] = None,
                 ebgp_multihop: Optional[_builtins.int] = None,
                 ip: Optional[_builtins.str] = None,
                 ipv6: Optional['outputs.ApplianceVpnBgpNeighborIpv6'] = None,
                 next_hop_ip: Optional[_builtins.str] = None,
                 receive_limit: Optional[_builtins.int] = None,
                 remote_as_number: Optional[_builtins.int] = None,
                 source_interface: Optional[_builtins.str] = None,
                 ttl_security: Optional['outputs.ApplianceVpnBgpNeighborTtlSecurity'] = None):
        """
        :param _builtins.bool allow_transit: When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false.
        :param 'ApplianceVpnBgpNeighborAuthenticationArgs' authentication: Authentication settings between BGP peers.
        :param _builtins.int ebgp_hold_timer: The eBGP hold timer in seconds for each neighbor. The eBGP hold timer must be an integer between 12 and 240.
        :param _builtins.int ebgp_multihop: Configure this if the neighbor is not adjacent. The eBGP multi-hop must be an integer between 1 and 255.
        :param _builtins.str ip: The IPv4 address of the neighbor
        :param 'ApplianceVpnBgpNeighborIpv6Args' ipv6: Information regarding IPv6 address of the neighbor, Required if *ip* is not present.
        :param _builtins.str next_hop_ip: The IPv4 address of the remote BGP peer that will establish a TCP session with the local MX.
        :param _builtins.int receive_limit: The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0.
        :param _builtins.int remote_as_number: Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
        :param _builtins.str source_interface: The output interface for peering with the remote BGP peer. Valid values are: 'wan1', 'wan2' or 'vlan{VLAN ID}'(e.g. 'vlan123').
        :param 'ApplianceVpnBgpNeighborTtlSecurityArgs' ttl_security: Settings for BGP TTL security to protect BGP peering sessions from forged IP attacks.
        """
        if allow_transit is not None:
            pulumi.set(__self__, "allow_transit", allow_transit)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if ebgp_hold_timer is not None:
            pulumi.set(__self__, "ebgp_hold_timer", ebgp_hold_timer)
        if ebgp_multihop is not None:
            pulumi.set(__self__, "ebgp_multihop", ebgp_multihop)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if next_hop_ip is not None:
            pulumi.set(__self__, "next_hop_ip", next_hop_ip)
        if receive_limit is not None:
            pulumi.set(__self__, "receive_limit", receive_limit)
        if remote_as_number is not None:
            pulumi.set(__self__, "remote_as_number", remote_as_number)
        if source_interface is not None:
            pulumi.set(__self__, "source_interface", source_interface)
        if ttl_security is not None:
            pulumi.set(__self__, "ttl_security", ttl_security)

    @_builtins.property
    @pulumi.getter(name="allowTransit")
    def allow_transit(self) -> Optional[_builtins.bool]:
        """
        When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false.
        """
        return pulumi.get(self, "allow_transit")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.ApplianceVpnBgpNeighborAuthentication']:
        """
        Authentication settings between BGP peers.
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter(name="ebgpHoldTimer")
    def ebgp_hold_timer(self) -> Optional[_builtins.int]:
        """
        The eBGP hold timer in seconds for each neighbor. The eBGP hold timer must be an integer between 12 and 240.
        """
        return pulumi.get(self, "ebgp_hold_timer")

    @_builtins.property
    @pulumi.getter(name="ebgpMultihop")
    def ebgp_multihop(self) -> Optional[_builtins.int]:
        """
        Configure this if the neighbor is not adjacent. The eBGP multi-hop must be an integer between 1 and 255.
        """
        return pulumi.get(self, "ebgp_multihop")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        The IPv4 address of the neighbor
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional['outputs.ApplianceVpnBgpNeighborIpv6']:
        """
        Information regarding IPv6 address of the neighbor, Required if *ip* is not present.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="nextHopIp")
    def next_hop_ip(self) -> Optional[_builtins.str]:
        """
        The IPv4 address of the remote BGP peer that will establish a TCP session with the local MX.
        """
        return pulumi.get(self, "next_hop_ip")

    @_builtins.property
    @pulumi.getter(name="receiveLimit")
    def receive_limit(self) -> Optional[_builtins.int]:
        """
        The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0.
        """
        return pulumi.get(self, "receive_limit")

    @_builtins.property
    @pulumi.getter(name="remoteAsNumber")
    def remote_as_number(self) -> Optional[_builtins.int]:
        """
        Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
        """
        return pulumi.get(self, "remote_as_number")

    @_builtins.property
    @pulumi.getter(name="sourceInterface")
    def source_interface(self) -> Optional[_builtins.str]:
        """
        The output interface for peering with the remote BGP peer. Valid values are: 'wan1', 'wan2' or 'vlan{VLAN ID}'(e.g. 'vlan123').
        """
        return pulumi.get(self, "source_interface")

    @_builtins.property
    @pulumi.getter(name="ttlSecurity")
    def ttl_security(self) -> Optional['outputs.ApplianceVpnBgpNeighborTtlSecurity']:
        """
        Settings for BGP TTL security to protect BGP peering sessions from forged IP attacks.
        """
        return pulumi.get(self, "ttl_security")


@pulumi.output_type
class ApplianceVpnBgpNeighborAuthentication(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password to configure MD5 authentication between BGP peers.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password to configure MD5 authentication between BGP peers.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class ApplianceVpnBgpNeighborIpv6(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: The IPv6 address of the neighbor.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        The IPv6 address of the neighbor.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class ApplianceVpnBgpNeighborTtlSecurity(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Boolean value to enable or disable BGP TTL security.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean value to enable or disable BGP TTL security.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApplianceVpnSiteToSiteVpnHub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hubId":
            suggest = "hub_id"
        elif key == "useDefaultRoute":
            suggest = "use_default_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceVpnSiteToSiteVpnHub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceVpnSiteToSiteVpnHub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceVpnSiteToSiteVpnHub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hub_id: Optional[_builtins.str] = None,
                 use_default_route: Optional[_builtins.bool] = None):
        """
        :param _builtins.str hub_id: The network ID of the hub.
        :param _builtins.bool use_default_route: Indicates whether default route traffic should be sent to this hub.
        """
        if hub_id is not None:
            pulumi.set(__self__, "hub_id", hub_id)
        if use_default_route is not None:
            pulumi.set(__self__, "use_default_route", use_default_route)

    @_builtins.property
    @pulumi.getter(name="hubId")
    def hub_id(self) -> Optional[_builtins.str]:
        """
        The network ID of the hub.
        """
        return pulumi.get(self, "hub_id")

    @_builtins.property
    @pulumi.getter(name="useDefaultRoute")
    def use_default_route(self) -> Optional[_builtins.bool]:
        """
        Indicates whether default route traffic should be sent to this hub.
        """
        return pulumi.get(self, "use_default_route")


@pulumi.output_type
class ApplianceVpnSiteToSiteVpnSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localSubnet":
            suggest = "local_subnet"
        elif key == "useVpn":
            suggest = "use_vpn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplianceVpnSiteToSiteVpnSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplianceVpnSiteToSiteVpnSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplianceVpnSiteToSiteVpnSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_subnet: Optional[_builtins.str] = None,
                 use_vpn: Optional[_builtins.bool] = None):
        """
        :param _builtins.str local_subnet: The CIDR notation subnet used within the VPN
        :param _builtins.bool use_vpn: Indicates the presence of the subnet in the VPN
        """
        if local_subnet is not None:
            pulumi.set(__self__, "local_subnet", local_subnet)
        if use_vpn is not None:
            pulumi.set(__self__, "use_vpn", use_vpn)

    @_builtins.property
    @pulumi.getter(name="localSubnet")
    def local_subnet(self) -> Optional[_builtins.str]:
        """
        The CIDR notation subnet used within the VPN
        """
        return pulumi.get(self, "local_subnet")

    @_builtins.property
    @pulumi.getter(name="useVpn")
    def use_vpn(self) -> Optional[_builtins.bool]:
        """
        Indicates the presence of the subnet in the VPN
        """
        return pulumi.get(self, "use_vpn")


@pulumi.output_type
class ApplianceWarmSpareWan1(dict):
    def __init__(__self__, *,
                 ip: Optional[_builtins.str] = None,
                 subnet: Optional[_builtins.str] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet")


@pulumi.output_type
class ApplianceWarmSpareWan2(dict):
    def __init__(__self__, *,
                 ip: Optional[_builtins.str] = None,
                 subnet: Optional[_builtins.str] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet")


@pulumi.output_type
class BindItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configTemplateId":
            suggest = "config_template_id"
        elif key == "enrollmentString":
            suggest = "enrollment_string"
        elif key == "isBoundToConfigTemplate":
            suggest = "is_bound_to_config_template"
        elif key == "organizationId":
            suggest = "organization_id"
        elif key == "productTypes":
            suggest = "product_types"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BindItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BindItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BindItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_template_id: Optional[_builtins.str] = None,
                 enrollment_string: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 is_bound_to_config_template: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 notes: Optional[_builtins.str] = None,
                 organization_id: Optional[_builtins.str] = None,
                 product_types: Optional[Sequence[_builtins.str]] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 time_zone: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str config_template_id: ID of the config template the network is being bound to
        :param _builtins.str enrollment_string: Enrollment string for the network
        :param _builtins.str id: Network ID
        :param _builtins.bool is_bound_to_config_template: If the network is bound to a config template
        :param _builtins.str name: Network name
        :param _builtins.str notes: Notes for the network
        :param _builtins.str organization_id: Organization ID
        :param Sequence[_builtins.str] product_types: List of the product types that the network supports
        :param Sequence[_builtins.str] tags: Network tags
        :param _builtins.str time_zone: Timezone of the network
        :param _builtins.str url: URL to the network Dashboard UI
        """
        if config_template_id is not None:
            pulumi.set(__self__, "config_template_id", config_template_id)
        if enrollment_string is not None:
            pulumi.set(__self__, "enrollment_string", enrollment_string)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_bound_to_config_template is not None:
            pulumi.set(__self__, "is_bound_to_config_template", is_bound_to_config_template)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)
        if product_types is not None:
            pulumi.set(__self__, "product_types", product_types)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="configTemplateId")
    def config_template_id(self) -> Optional[_builtins.str]:
        """
        ID of the config template the network is being bound to
        """
        return pulumi.get(self, "config_template_id")

    @_builtins.property
    @pulumi.getter(name="enrollmentString")
    def enrollment_string(self) -> Optional[_builtins.str]:
        """
        Enrollment string for the network
        """
        return pulumi.get(self, "enrollment_string")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Network ID
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isBoundToConfigTemplate")
    def is_bound_to_config_template(self) -> Optional[_builtins.bool]:
        """
        If the network is bound to a config template
        """
        return pulumi.get(self, "is_bound_to_config_template")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Network name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[_builtins.str]:
        """
        Notes for the network
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[_builtins.str]:
        """
        Organization ID
        """
        return pulumi.get(self, "organization_id")

    @_builtins.property
    @pulumi.getter(name="productTypes")
    def product_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of the product types that the network supports
        """
        return pulumi.get(self, "product_types")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Network tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        Timezone of the network
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL to the network Dashboard UI
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class BindParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoBind":
            suggest = "auto_bind"
        elif key == "configTemplateId":
            suggest = "config_template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BindParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BindParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BindParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_bind: Optional[_builtins.bool] = None,
                 config_template_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_bind: Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
        :param _builtins.str config_template_id: The ID of the template to which the network should be bound.
        """
        if auto_bind is not None:
            pulumi.set(__self__, "auto_bind", auto_bind)
        if config_template_id is not None:
            pulumi.set(__self__, "config_template_id", config_template_id)

    @_builtins.property
    @pulumi.getter(name="autoBind")
    def auto_bind(self) -> Optional[_builtins.bool]:
        """
        Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
        """
        return pulumi.get(self, "auto_bind")

    @_builtins.property
    @pulumi.getter(name="configTemplateId")
    def config_template_id(self) -> Optional[_builtins.str]:
        """
        The ID of the template to which the network should be bound.
        """
        return pulumi.get(self, "config_template_id")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mV12MV22MV72":
            suggest = "m_v12_mv22_mv72"
        elif key == "mV12We":
            suggest = "m_v12_we"
        elif key == "mV13":
            suggest = "m_v13"
        elif key == "mV21MV71":
            suggest = "m_v21_mv71"
        elif key == "mV22Xmv72X":
            suggest = "m_v22_xmv72_x"
        elif key == "mV32":
            suggest = "m_v32"
        elif key == "mV33":
            suggest = "m_v33"
        elif key == "mV52":
            suggest = "m_v52"
        elif key == "mV63":
            suggest = "m_v63"
        elif key == "mV63X":
            suggest = "m_v63_x"
        elif key == "mV93":
            suggest = "m_v93"
        elif key == "mV93X":
            suggest = "m_v93_x"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CameraQualityRetentionProfilesVideoSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CameraQualityRetentionProfilesVideoSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CameraQualityRetentionProfilesVideoSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 m_v12_mv22_mv72: Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72'] = None,
                 m_v12_we: Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV12We'] = None,
                 m_v13: Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV13'] = None,
                 m_v21_mv71: Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV21MV71'] = None,
                 m_v22_xmv72_x: Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV22Xmv72X'] = None,
                 m_v32: Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV32'] = None,
                 m_v33: Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV33'] = None,
                 m_v52: Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV52'] = None,
                 m_v63: Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV63'] = None,
                 m_v63_x: Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV63X'] = None,
                 m_v93: Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV93'] = None,
                 m_v93_x: Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV93X'] = None):
        """
        :param 'CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72Args' m_v12_mv22_mv72: Quality and resolution for MV12/MV22/MV72 camera models.
        :param 'CameraQualityRetentionProfilesVideoSettingsMV12WeArgs' m_v12_we: Quality and resolution for MV12WE camera models.
        :param 'CameraQualityRetentionProfilesVideoSettingsMV13Args' m_v13: Quality and resolution for MV13 camera models.
        :param 'CameraQualityRetentionProfilesVideoSettingsMV21MV71Args' m_v21_mv71: Quality and resolution for MV21/MV71 camera models.
        :param 'CameraQualityRetentionProfilesVideoSettingsMV22Xmv72XArgs' m_v22_xmv72_x: Quality and resolution for MV22X/MV72X camera models.
        :param 'CameraQualityRetentionProfilesVideoSettingsMV32Args' m_v32: Quality and resolution for MV32 camera models.
        :param 'CameraQualityRetentionProfilesVideoSettingsMV33Args' m_v33: Quality and resolution for MV33 camera models.
        :param 'CameraQualityRetentionProfilesVideoSettingsMV52Args' m_v52: Quality and resolution for MV52 camera models.
        :param 'CameraQualityRetentionProfilesVideoSettingsMV63Args' m_v63: Quality and resolution for MV63 camera models.
        :param 'CameraQualityRetentionProfilesVideoSettingsMV63XArgs' m_v63_x: Quality and resolution for MV63X camera models.
        :param 'CameraQualityRetentionProfilesVideoSettingsMV93Args' m_v93: Quality and resolution for MV93 camera models.
        :param 'CameraQualityRetentionProfilesVideoSettingsMV93XArgs' m_v93_x: Quality and resolution for MV93X camera models.
        """
        if m_v12_mv22_mv72 is not None:
            pulumi.set(__self__, "m_v12_mv22_mv72", m_v12_mv22_mv72)
        if m_v12_we is not None:
            pulumi.set(__self__, "m_v12_we", m_v12_we)
        if m_v13 is not None:
            pulumi.set(__self__, "m_v13", m_v13)
        if m_v21_mv71 is not None:
            pulumi.set(__self__, "m_v21_mv71", m_v21_mv71)
        if m_v22_xmv72_x is not None:
            pulumi.set(__self__, "m_v22_xmv72_x", m_v22_xmv72_x)
        if m_v32 is not None:
            pulumi.set(__self__, "m_v32", m_v32)
        if m_v33 is not None:
            pulumi.set(__self__, "m_v33", m_v33)
        if m_v52 is not None:
            pulumi.set(__self__, "m_v52", m_v52)
        if m_v63 is not None:
            pulumi.set(__self__, "m_v63", m_v63)
        if m_v63_x is not None:
            pulumi.set(__self__, "m_v63_x", m_v63_x)
        if m_v93 is not None:
            pulumi.set(__self__, "m_v93", m_v93)
        if m_v93_x is not None:
            pulumi.set(__self__, "m_v93_x", m_v93_x)

    @_builtins.property
    @pulumi.getter(name="mV12MV22MV72")
    def m_v12_mv22_mv72(self) -> Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72']:
        """
        Quality and resolution for MV12/MV22/MV72 camera models.
        """
        return pulumi.get(self, "m_v12_mv22_mv72")

    @_builtins.property
    @pulumi.getter(name="mV12We")
    def m_v12_we(self) -> Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV12We']:
        """
        Quality and resolution for MV12WE camera models.
        """
        return pulumi.get(self, "m_v12_we")

    @_builtins.property
    @pulumi.getter(name="mV13")
    def m_v13(self) -> Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV13']:
        """
        Quality and resolution for MV13 camera models.
        """
        return pulumi.get(self, "m_v13")

    @_builtins.property
    @pulumi.getter(name="mV21MV71")
    def m_v21_mv71(self) -> Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV21MV71']:
        """
        Quality and resolution for MV21/MV71 camera models.
        """
        return pulumi.get(self, "m_v21_mv71")

    @_builtins.property
    @pulumi.getter(name="mV22Xmv72X")
    def m_v22_xmv72_x(self) -> Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV22Xmv72X']:
        """
        Quality and resolution for MV22X/MV72X camera models.
        """
        return pulumi.get(self, "m_v22_xmv72_x")

    @_builtins.property
    @pulumi.getter(name="mV32")
    def m_v32(self) -> Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV32']:
        """
        Quality and resolution for MV32 camera models.
        """
        return pulumi.get(self, "m_v32")

    @_builtins.property
    @pulumi.getter(name="mV33")
    def m_v33(self) -> Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV33']:
        """
        Quality and resolution for MV33 camera models.
        """
        return pulumi.get(self, "m_v33")

    @_builtins.property
    @pulumi.getter(name="mV52")
    def m_v52(self) -> Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV52']:
        """
        Quality and resolution for MV52 camera models.
        """
        return pulumi.get(self, "m_v52")

    @_builtins.property
    @pulumi.getter(name="mV63")
    def m_v63(self) -> Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV63']:
        """
        Quality and resolution for MV63 camera models.
        """
        return pulumi.get(self, "m_v63")

    @_builtins.property
    @pulumi.getter(name="mV63X")
    def m_v63_x(self) -> Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV63X']:
        """
        Quality and resolution for MV63X camera models.
        """
        return pulumi.get(self, "m_v63_x")

    @_builtins.property
    @pulumi.getter(name="mV93")
    def m_v93(self) -> Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV93']:
        """
        Quality and resolution for MV93 camera models.
        """
        return pulumi.get(self, "m_v93")

    @_builtins.property
    @pulumi.getter(name="mV93X")
    def m_v93_x(self) -> Optional['outputs.CameraQualityRetentionProfilesVideoSettingsMV93X']:
        """
        Quality and resolution for MV93X camera models.
        """
        return pulumi.get(self, "m_v93_x")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 resolution: Optional[_builtins.str] = None):
        """
        :param _builtins.str quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param _builtins.str resolution: Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[_builtins.str]:
        """
        Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettingsMV12We(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 resolution: Optional[_builtins.str] = None):
        """
        :param _builtins.str quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param _builtins.str resolution: Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[_builtins.str]:
        """
        Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettingsMV13(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 resolution: Optional[_builtins.str] = None):
        """
        :param _builtins.str quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param _builtins.str resolution: Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[_builtins.str]:
        """
        Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettingsMV21MV71(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 resolution: Optional[_builtins.str] = None):
        """
        :param _builtins.str quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param _builtins.str resolution: Resolution of the camera. Can be one of '1280x720'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[_builtins.str]:
        """
        Resolution of the camera. Can be one of '1280x720'.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettingsMV22Xmv72X(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 resolution: Optional[_builtins.str] = None):
        """
        :param _builtins.str quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param _builtins.str resolution: Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[_builtins.str]:
        """
        Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettingsMV32(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 resolution: Optional[_builtins.str] = None):
        """
        :param _builtins.str quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param _builtins.str resolution: Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[_builtins.str]:
        """
        Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettingsMV33(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 resolution: Optional[_builtins.str] = None):
        """
        :param _builtins.str quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param _builtins.str resolution: Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[_builtins.str]:
        """
        Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettingsMV52(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 resolution: Optional[_builtins.str] = None):
        """
        :param _builtins.str quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param _builtins.str resolution: Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[_builtins.str]:
        """
        Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettingsMV63(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 resolution: Optional[_builtins.str] = None):
        """
        :param _builtins.str quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param _builtins.str resolution: Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[_builtins.str]:
        """
        Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettingsMV63X(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 resolution: Optional[_builtins.str] = None):
        """
        :param _builtins.str quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param _builtins.str resolution: Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[_builtins.str]:
        """
        Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettingsMV93(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 resolution: Optional[_builtins.str] = None):
        """
        :param _builtins.str quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param _builtins.str resolution: Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[_builtins.str]:
        """
        Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class CameraQualityRetentionProfilesVideoSettingsMV93X(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 resolution: Optional[_builtins.str] = None):
        """
        :param _builtins.str quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param _builtins.str resolution: Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[_builtins.str]:
        """
        Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class CameraWirelessProfilesIdentity(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: The password of the identity.
        :param _builtins.str username: The username of the identity.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password of the identity.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username of the identity.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class CameraWirelessProfilesSsid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMode":
            suggest = "auth_mode"
        elif key == "encryptionMode":
            suggest = "encryption_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CameraWirelessProfilesSsid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CameraWirelessProfilesSsid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CameraWirelessProfilesSsid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_mode: Optional[_builtins.str] = None,
                 encryption_mode: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 psk: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_mode: The auth mode of the SSID. It can be set to ('psk', '8021x-radius').
        :param _builtins.str encryption_mode: The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius'
        :param _builtins.str name: The name of the SSID.
        :param _builtins.str psk: The pre-shared key of the SSID.
        """
        if auth_mode is not None:
            pulumi.set(__self__, "auth_mode", auth_mode)
        if encryption_mode is not None:
            pulumi.set(__self__, "encryption_mode", encryption_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if psk is not None:
            pulumi.set(__self__, "psk", psk)

    @_builtins.property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> Optional[_builtins.str]:
        """
        The auth mode of the SSID. It can be set to ('psk', '8021x-radius').
        """
        return pulumi.get(self, "auth_mode")

    @_builtins.property
    @pulumi.getter(name="encryptionMode")
    def encryption_mode(self) -> Optional[_builtins.str]:
        """
        The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius'
        """
        return pulumi.get(self, "encryption_mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the SSID.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def psk(self) -> Optional[_builtins.str]:
        """
        The pre-shared key of the SSID.
        """
        return pulumi.get(self, "psk")


@pulumi.output_type
class CellularGatewayConnectivityMonitoringDestinationsDestination(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None):
        """
        :param _builtins.bool default: Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
        :param _builtins.str description: Description of the testing destination. Optional, defaults to an empty string
        :param _builtins.str ip: The IP address to test connectivity with
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the testing destination. Optional, defaults to an empty string
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        The IP address to test connectivity with
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class CellularGatewaySubnetPoolSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applianceIp":
            suggest = "appliance_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CellularGatewaySubnetPoolSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CellularGatewaySubnetPoolSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CellularGatewaySubnetPoolSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 appliance_ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 serial: Optional[_builtins.str] = None,
                 subnet: Optional[_builtins.str] = None):
        if appliance_ip is not None:
            pulumi.set(__self__, "appliance_ip", appliance_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter(name="applianceIp")
    def appliance_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "appliance_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet")


@pulumi.output_type
class CellularGatewayUplinkBandwidthLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitDown":
            suggest = "limit_down"
        elif key == "limitUp":
            suggest = "limit_up"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CellularGatewayUplinkBandwidthLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CellularGatewayUplinkBandwidthLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CellularGatewayUplinkBandwidthLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_down: Optional[_builtins.int] = None,
                 limit_up: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit_down: The maximum download limit (integer, in Kbps). 'null' indicates no limit.
        :param _builtins.int limit_up: The maximum upload limit (integer, in Kbps). 'null' indicates no limit.
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[_builtins.int]:
        """
        The maximum download limit (integer, in Kbps). 'null' indicates no limit.
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[_builtins.int]:
        """
        The maximum upload limit (integer, in Kbps). 'null' indicates no limit.
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class ClientsProvisionItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clients: Optional[Sequence['outputs.ClientsProvisionItemClient']] = None,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param Sequence['ClientsProvisionItemClientArgs'] clients: The list of clients to provision
        :param _builtins.str device_policy: The name of the client's policy
        :param _builtins.str group_policy_id: The group policy identifier of the client
        """
        if clients is not None:
            pulumi.set(__self__, "clients", clients)
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Optional[Sequence['outputs.ClientsProvisionItemClient']]:
        """
        The list of clients to provision
        """
        return pulumi.get(self, "clients")

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The name of the client's policy
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The group policy identifier of the client
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionItemClient(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionItemClient. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionItemClient.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionItemClient.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 mac: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: The identifier of the client
        :param _builtins.str mac: The MAC address of the client
        :param _builtins.str message: The client's display message if its group policy is 'Blocked'
        :param _builtins.str name: The name of the client
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The identifier of the client
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[_builtins.str]:
        """
        The MAC address of the client
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The client's display message if its group policy is 'Blocked'
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the client
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ClientsProvisionParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"
        elif key == "policiesBySecurityAppliance":
            suggest = "policies_by_security_appliance"
        elif key == "policiesBySsid":
            suggest = "policies_by_ssid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clients: Optional[Sequence['outputs.ClientsProvisionParametersClient']] = None,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None,
                 policies_by_security_appliance: Optional['outputs.ClientsProvisionParametersPoliciesBySecurityAppliance'] = None,
                 policies_by_ssid: Optional['outputs.ClientsProvisionParametersPoliciesBySsid'] = None):
        """
        :param Sequence['ClientsProvisionParametersClientArgs'] clients: The array of clients to provision
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        :param 'ClientsProvisionParametersPoliciesBySecurityApplianceArgs' policies_by_security_appliance: An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
        :param 'ClientsProvisionParametersPoliciesBySsidArgs' policies_by_ssid: An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
        """
        if clients is not None:
            pulumi.set(__self__, "clients", clients)
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)
        if policies_by_security_appliance is not None:
            pulumi.set(__self__, "policies_by_security_appliance", policies_by_security_appliance)
        if policies_by_ssid is not None:
            pulumi.set(__self__, "policies_by_ssid", policies_by_ssid)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Optional[Sequence['outputs.ClientsProvisionParametersClient']]:
        """
        The array of clients to provision
        """
        return pulumi.get(self, "clients")

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @_builtins.property
    @pulumi.getter(name="policiesBySecurityAppliance")
    def policies_by_security_appliance(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySecurityAppliance']:
        """
        An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
        """
        return pulumi.get(self, "policies_by_security_appliance")

    @_builtins.property
    @pulumi.getter(name="policiesBySsid")
    def policies_by_ssid(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsid']:
        """
        An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
        """
        return pulumi.get(self, "policies_by_ssid")


@pulumi.output_type
class ClientsProvisionParametersClient(dict):
    def __init__(__self__, *,
                 mac: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str mac: The MAC address of the client. Required.
        :param _builtins.str name: The display name for the client. Optional. Limited to 255 bytes.
        """
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[_builtins.str]:
        """
        The MAC address of the client. Required.
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The display name for the client. Optional. Limited to 255 bytes.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySecurityAppliance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySecurityAppliance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySecurityAppliance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySecurityAppliance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked' or 'Normal'. Required.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked' or 'Normal'. Required.
        """
        return pulumi.get(self, "device_policy")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsid(dict):
    def __init__(__self__, *,
                 status0: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus0'] = None,
                 status1: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus1'] = None,
                 status10: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus10'] = None,
                 status11: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus11'] = None,
                 status12: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus12'] = None,
                 status13: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus13'] = None,
                 status14: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus14'] = None,
                 status2: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus2'] = None,
                 status3: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus3'] = None,
                 status4: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus4'] = None,
                 status5: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus5'] = None,
                 status6: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus6'] = None,
                 status7: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus7'] = None,
                 status8: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus8'] = None,
                 status9: Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus9'] = None):
        """
        :param 'ClientsProvisionParametersPoliciesBySsidStatus0Args' status0: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus1Args' status1: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus10Args' status10: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus11Args' status11: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus12Args' status12: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus13Args' status13: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus14Args' status14: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus2Args' status2: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus3Args' status3: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus4Args' status4: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus5Args' status5: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus6Args' status6: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus7Args' status7: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus8Args' status8: The number for the SSID
        :param 'ClientsProvisionParametersPoliciesBySsidStatus9Args' status9: The number for the SSID
        """
        if status0 is not None:
            pulumi.set(__self__, "status0", status0)
        if status1 is not None:
            pulumi.set(__self__, "status1", status1)
        if status10 is not None:
            pulumi.set(__self__, "status10", status10)
        if status11 is not None:
            pulumi.set(__self__, "status11", status11)
        if status12 is not None:
            pulumi.set(__self__, "status12", status12)
        if status13 is not None:
            pulumi.set(__self__, "status13", status13)
        if status14 is not None:
            pulumi.set(__self__, "status14", status14)
        if status2 is not None:
            pulumi.set(__self__, "status2", status2)
        if status3 is not None:
            pulumi.set(__self__, "status3", status3)
        if status4 is not None:
            pulumi.set(__self__, "status4", status4)
        if status5 is not None:
            pulumi.set(__self__, "status5", status5)
        if status6 is not None:
            pulumi.set(__self__, "status6", status6)
        if status7 is not None:
            pulumi.set(__self__, "status7", status7)
        if status8 is not None:
            pulumi.set(__self__, "status8", status8)
        if status9 is not None:
            pulumi.set(__self__, "status9", status9)

    @_builtins.property
    @pulumi.getter
    def status0(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus0']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status0")

    @_builtins.property
    @pulumi.getter
    def status1(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus1']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status1")

    @_builtins.property
    @pulumi.getter
    def status10(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus10']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status10")

    @_builtins.property
    @pulumi.getter
    def status11(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus11']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status11")

    @_builtins.property
    @pulumi.getter
    def status12(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus12']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status12")

    @_builtins.property
    @pulumi.getter
    def status13(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus13']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status13")

    @_builtins.property
    @pulumi.getter
    def status14(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus14']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status14")

    @_builtins.property
    @pulumi.getter
    def status2(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus2']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status2")

    @_builtins.property
    @pulumi.getter
    def status3(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus3']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status3")

    @_builtins.property
    @pulumi.getter
    def status4(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus4']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status4")

    @_builtins.property
    @pulumi.getter
    def status5(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus5']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status5")

    @_builtins.property
    @pulumi.getter
    def status6(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus6']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status6")

    @_builtins.property
    @pulumi.getter
    def status7(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus7']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status7")

    @_builtins.property
    @pulumi.getter
    def status8(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus8']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status8")

    @_builtins.property
    @pulumi.getter
    def status9(self) -> Optional['outputs.ClientsProvisionParametersPoliciesBySsidStatus9']:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status9")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus0(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus0. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus0.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus0.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus10(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus10. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus10.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus10.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus11(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus11. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus11.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus11.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus12(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus12. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus12.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus12.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus13(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus13. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus13.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus13.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus14(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus14. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus14.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus14.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus5(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus5. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus5.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus5.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus7(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus7. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus7.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus7.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus8(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus8. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus8.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus8.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsProvisionParametersPoliciesBySsidStatus9(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsProvisionParametersPoliciesBySsidStatus9. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus9.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsProvisionParametersPoliciesBySsidStatus9.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param _builtins.str group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsids(dict):
    def __init__(__self__, *,
                 status0: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus0'] = None,
                 status1: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus1'] = None,
                 status10: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus10'] = None,
                 status11: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus11'] = None,
                 status12: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus12'] = None,
                 status13: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus13'] = None,
                 status14: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus14'] = None,
                 status2: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus2'] = None,
                 status3: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus3'] = None,
                 status4: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus4'] = None,
                 status5: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus5'] = None,
                 status6: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus6'] = None,
                 status7: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus7'] = None,
                 status8: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus8'] = None,
                 status9: Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus9'] = None):
        """
        :param 'ClientsSplashAuthorizationStatusSsidsStatus0Args' status0: Splash authorization for SSID 0
        :param 'ClientsSplashAuthorizationStatusSsidsStatus1Args' status1: Splash authorization for SSID 1
        :param 'ClientsSplashAuthorizationStatusSsidsStatus10Args' status10: Splash authorization for SSID 10
        :param 'ClientsSplashAuthorizationStatusSsidsStatus11Args' status11: Splash authorization for SSID 11
        :param 'ClientsSplashAuthorizationStatusSsidsStatus12Args' status12: Splash authorization for SSID 12
        :param 'ClientsSplashAuthorizationStatusSsidsStatus13Args' status13: Splash authorization for SSID 13
        :param 'ClientsSplashAuthorizationStatusSsidsStatus14Args' status14: Splash authorization for SSID 14
        :param 'ClientsSplashAuthorizationStatusSsidsStatus2Args' status2: Splash authorization for SSID 2
        :param 'ClientsSplashAuthorizationStatusSsidsStatus3Args' status3: Splash authorization for SSID 3
        :param 'ClientsSplashAuthorizationStatusSsidsStatus4Args' status4: Splash authorization for SSID 4
        :param 'ClientsSplashAuthorizationStatusSsidsStatus5Args' status5: Splash authorization for SSID 5
        :param 'ClientsSplashAuthorizationStatusSsidsStatus6Args' status6: Splash authorization for SSID 6
        :param 'ClientsSplashAuthorizationStatusSsidsStatus7Args' status7: Splash authorization for SSID 7
        :param 'ClientsSplashAuthorizationStatusSsidsStatus8Args' status8: Splash authorization for SSID 8
        :param 'ClientsSplashAuthorizationStatusSsidsStatus9Args' status9: Splash authorization for SSID 9
        """
        if status0 is not None:
            pulumi.set(__self__, "status0", status0)
        if status1 is not None:
            pulumi.set(__self__, "status1", status1)
        if status10 is not None:
            pulumi.set(__self__, "status10", status10)
        if status11 is not None:
            pulumi.set(__self__, "status11", status11)
        if status12 is not None:
            pulumi.set(__self__, "status12", status12)
        if status13 is not None:
            pulumi.set(__self__, "status13", status13)
        if status14 is not None:
            pulumi.set(__self__, "status14", status14)
        if status2 is not None:
            pulumi.set(__self__, "status2", status2)
        if status3 is not None:
            pulumi.set(__self__, "status3", status3)
        if status4 is not None:
            pulumi.set(__self__, "status4", status4)
        if status5 is not None:
            pulumi.set(__self__, "status5", status5)
        if status6 is not None:
            pulumi.set(__self__, "status6", status6)
        if status7 is not None:
            pulumi.set(__self__, "status7", status7)
        if status8 is not None:
            pulumi.set(__self__, "status8", status8)
        if status9 is not None:
            pulumi.set(__self__, "status9", status9)

    @_builtins.property
    @pulumi.getter
    def status0(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus0']:
        """
        Splash authorization for SSID 0
        """
        return pulumi.get(self, "status0")

    @_builtins.property
    @pulumi.getter
    def status1(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus1']:
        """
        Splash authorization for SSID 1
        """
        return pulumi.get(self, "status1")

    @_builtins.property
    @pulumi.getter
    def status10(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus10']:
        """
        Splash authorization for SSID 10
        """
        return pulumi.get(self, "status10")

    @_builtins.property
    @pulumi.getter
    def status11(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus11']:
        """
        Splash authorization for SSID 11
        """
        return pulumi.get(self, "status11")

    @_builtins.property
    @pulumi.getter
    def status12(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus12']:
        """
        Splash authorization for SSID 12
        """
        return pulumi.get(self, "status12")

    @_builtins.property
    @pulumi.getter
    def status13(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus13']:
        """
        Splash authorization for SSID 13
        """
        return pulumi.get(self, "status13")

    @_builtins.property
    @pulumi.getter
    def status14(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus14']:
        """
        Splash authorization for SSID 14
        """
        return pulumi.get(self, "status14")

    @_builtins.property
    @pulumi.getter
    def status2(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus2']:
        """
        Splash authorization for SSID 2
        """
        return pulumi.get(self, "status2")

    @_builtins.property
    @pulumi.getter
    def status3(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus3']:
        """
        Splash authorization for SSID 3
        """
        return pulumi.get(self, "status3")

    @_builtins.property
    @pulumi.getter
    def status4(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus4']:
        """
        Splash authorization for SSID 4
        """
        return pulumi.get(self, "status4")

    @_builtins.property
    @pulumi.getter
    def status5(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus5']:
        """
        Splash authorization for SSID 5
        """
        return pulumi.get(self, "status5")

    @_builtins.property
    @pulumi.getter
    def status6(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus6']:
        """
        Splash authorization for SSID 6
        """
        return pulumi.get(self, "status6")

    @_builtins.property
    @pulumi.getter
    def status7(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus7']:
        """
        Splash authorization for SSID 7
        """
        return pulumi.get(self, "status7")

    @_builtins.property
    @pulumi.getter
    def status8(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus8']:
        """
        Splash authorization for SSID 8
        """
        return pulumi.get(self, "status8")

    @_builtins.property
    @pulumi.getter
    def status9(self) -> Optional['outputs.ClientsSplashAuthorizationStatusSsidsStatus9']:
        """
        Splash authorization for SSID 9
        """
        return pulumi.get(self, "status9")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus0(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizedAt":
            suggest = "authorized_at"
        elif key == "expiresAt":
            suggest = "expires_at"
        elif key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus0. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus0.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus0.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorized_at: Optional[_builtins.str] = None,
                 expires_at: Optional[_builtins.str] = None,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if authorized_at is not None:
            pulumi.set(__self__, "authorized_at", authorized_at)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="authorizedAt")
    def authorized_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "authorized_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus10(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus10. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus10.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus10.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus11(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus11. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus11.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus11.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus12(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus12. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus12.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus12.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus13(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus13. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus13.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus13.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus14(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus14. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus14.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus14.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus5(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus5. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus5.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus5.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus7(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus7. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus7.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus7.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus8(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus8. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus8.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus8.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class ClientsSplashAuthorizationStatusSsidsStatus9(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAuthorized":
            suggest = "is_authorized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientsSplashAuthorizationStatusSsidsStatus9. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus9.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientsSplashAuthorizationStatusSsidsStatus9.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_authorized: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[_builtins.bool]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class DevicesClaimItem(dict):
    def __init__(__self__, *,
                 serials: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] serials: The serials of the devices
        """
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        The serials of the devices
        """
        return pulumi.get(self, "serials")


@pulumi.output_type
class DevicesClaimParameters(dict):
    def __init__(__self__, *,
                 serials: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] serials: A list of serials of devices to claim
        """
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of serials of devices to claim
        """
        return pulumi.get(self, "serials")


@pulumi.output_type
class DevicesClaimVmxItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lanIp":
            suggest = "lan_ip"
        elif key == "networkId":
            suggest = "network_id"
        elif key == "productType":
            suggest = "product_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevicesClaimVmxItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevicesClaimVmxItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevicesClaimVmxItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 details: Optional[Sequence['outputs.DevicesClaimVmxItemDetail']] = None,
                 firmware: Optional[_builtins.str] = None,
                 imei: Optional[_builtins.str] = None,
                 lan_ip: Optional[_builtins.str] = None,
                 lat: Optional[_builtins.float] = None,
                 lng: Optional[_builtins.float] = None,
                 mac: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 network_id: Optional[_builtins.str] = None,
                 notes: Optional[_builtins.str] = None,
                 product_type: Optional[_builtins.str] = None,
                 serial: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str address: Physical address of the device
        :param Sequence['DevicesClaimVmxItemDetailArgs'] details: Additional device information
        :param _builtins.str firmware: Firmware version of the device
        :param _builtins.str imei: IMEI of the device, if applicable
        :param _builtins.str lan_ip: LAN IP address of the device
        :param _builtins.float lat: Latitude of the device
        :param _builtins.float lng: Longitude of the device
        :param _builtins.str mac: MAC address of the device
        :param _builtins.str model: Model of the device
        :param _builtins.str name: Name of the device
        :param _builtins.str network_id: ID of the network the device belongs to
        :param _builtins.str notes: Notes for the device, limited to 255 characters
        :param _builtins.str product_type: Product type of the device
        :param _builtins.str serial: Serial number of the device
        :param Sequence[_builtins.str] tags: List of tags assigned to the device
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if imei is not None:
            pulumi.set(__self__, "imei", imei)
        if lan_ip is not None:
            pulumi.set(__self__, "lan_ip", lan_ip)
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if product_type is not None:
            pulumi.set(__self__, "product_type", product_type)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Physical address of the device
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.DevicesClaimVmxItemDetail']]:
        """
        Additional device information
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Firmware version of the device
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def imei(self) -> Optional[_builtins.str]:
        """
        IMEI of the device, if applicable
        """
        return pulumi.get(self, "imei")

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> Optional[_builtins.str]:
        """
        LAN IP address of the device
        """
        return pulumi.get(self, "lan_ip")

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[_builtins.float]:
        """
        Latitude of the device
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[_builtins.float]:
        """
        Longitude of the device
        """
        return pulumi.get(self, "lng")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[_builtins.str]:
        """
        MAC address of the device
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Model of the device
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the device
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[_builtins.str]:
        """
        ID of the network the device belongs to
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[_builtins.str]:
        """
        Notes for the device, limited to 255 characters
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> Optional[_builtins.str]:
        """
        Product type of the device
        """
        return pulumi.get(self, "product_type")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        Serial number of the device
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags assigned to the device
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class DevicesClaimVmxItemDetail(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Additional property name
        :param _builtins.str value: Additional property value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Additional property name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Additional property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DevicesClaimVmxParameters(dict):
    def __init__(__self__, *,
                 size: Optional[_builtins.str] = None):
        """
        :param _builtins.str size: The size of the vMX you claim. It can be one of: small, medium, large, xlarge, 100
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        The size of the vMX you claim. It can be one of: small, medium, large, xlarge, 100
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class DevicesRemoveParameters(dict):
    def __init__(__self__, *,
                 serial: Optional[_builtins.str] = None):
        """
        :param _builtins.str serial: The serial of a device
        """
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        The serial of a device
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class FirmwareUpgradesProducts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellularGateway":
            suggest = "cellular_gateway"
        elif key == "switchCatalyst":
            suggest = "switch_catalyst"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProducts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProducts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProducts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 appliance: Optional['outputs.FirmwareUpgradesProductsAppliance'] = None,
                 camera: Optional['outputs.FirmwareUpgradesProductsCamera'] = None,
                 cellular_gateway: Optional['outputs.FirmwareUpgradesProductsCellularGateway'] = None,
                 sensor: Optional['outputs.FirmwareUpgradesProductsSensor'] = None,
                 switch: Optional['outputs.FirmwareUpgradesProductsSwitch'] = None,
                 switch_catalyst: Optional['outputs.FirmwareUpgradesProductsSwitchCatalyst'] = None,
                 wireless: Optional['outputs.FirmwareUpgradesProductsWireless'] = None):
        """
        :param 'FirmwareUpgradesProductsApplianceArgs' appliance: The network device to be updated
        :param 'FirmwareUpgradesProductsCameraArgs' camera: The network device to be updated
        :param 'FirmwareUpgradesProductsCellularGatewayArgs' cellular_gateway: The network device to be updated
        :param 'FirmwareUpgradesProductsSensorArgs' sensor: The network device to be updated
        :param 'FirmwareUpgradesProductsSwitchArgs' switch: The network device to be updated
        :param 'FirmwareUpgradesProductsSwitchCatalystArgs' switch_catalyst: The network device to be updated
        :param 'FirmwareUpgradesProductsWirelessArgs' wireless: The network device to be updated
        """
        if appliance is not None:
            pulumi.set(__self__, "appliance", appliance)
        if camera is not None:
            pulumi.set(__self__, "camera", camera)
        if cellular_gateway is not None:
            pulumi.set(__self__, "cellular_gateway", cellular_gateway)
        if sensor is not None:
            pulumi.set(__self__, "sensor", sensor)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if switch_catalyst is not None:
            pulumi.set(__self__, "switch_catalyst", switch_catalyst)
        if wireless is not None:
            pulumi.set(__self__, "wireless", wireless)

    @_builtins.property
    @pulumi.getter
    def appliance(self) -> Optional['outputs.FirmwareUpgradesProductsAppliance']:
        """
        The network device to be updated
        """
        return pulumi.get(self, "appliance")

    @_builtins.property
    @pulumi.getter
    def camera(self) -> Optional['outputs.FirmwareUpgradesProductsCamera']:
        """
        The network device to be updated
        """
        return pulumi.get(self, "camera")

    @_builtins.property
    @pulumi.getter(name="cellularGateway")
    def cellular_gateway(self) -> Optional['outputs.FirmwareUpgradesProductsCellularGateway']:
        """
        The network device to be updated
        """
        return pulumi.get(self, "cellular_gateway")

    @_builtins.property
    @pulumi.getter
    def sensor(self) -> Optional['outputs.FirmwareUpgradesProductsSensor']:
        """
        The network device to be updated
        """
        return pulumi.get(self, "sensor")

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional['outputs.FirmwareUpgradesProductsSwitch']:
        """
        The network device to be updated
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="switchCatalyst")
    def switch_catalyst(self) -> Optional['outputs.FirmwareUpgradesProductsSwitchCatalyst']:
        """
        The network device to be updated
        """
        return pulumi.get(self, "switch_catalyst")

    @_builtins.property
    @pulumi.getter
    def wireless(self) -> Optional['outputs.FirmwareUpgradesProductsWireless']:
        """
        The network device to be updated
        """
        return pulumi.get(self, "wireless")


@pulumi.output_type
class FirmwareUpgradesProductsAppliance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableVersions":
            suggest = "available_versions"
        elif key == "currentVersion":
            suggest = "current_version"
        elif key == "lastUpgrade":
            suggest = "last_upgrade"
        elif key == "nextUpgrade":
            suggest = "next_upgrade"
        elif key == "participateInNextBetaRelease":
            suggest = "participate_in_next_beta_release"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsAppliance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsAppliance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsAppliance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_versions: Optional[Sequence['outputs.FirmwareUpgradesProductsApplianceAvailableVersion']] = None,
                 current_version: Optional['outputs.FirmwareUpgradesProductsApplianceCurrentVersion'] = None,
                 last_upgrade: Optional['outputs.FirmwareUpgradesProductsApplianceLastUpgrade'] = None,
                 next_upgrade: Optional['outputs.FirmwareUpgradesProductsApplianceNextUpgrade'] = None,
                 participate_in_next_beta_release: Optional[_builtins.bool] = None):
        """
        :param Sequence['FirmwareUpgradesProductsApplianceAvailableVersionArgs'] available_versions: Firmware versions available for upgrade
        :param 'FirmwareUpgradesProductsApplianceCurrentVersionArgs' current_version: Details of the current version on the device
        :param 'FirmwareUpgradesProductsApplianceLastUpgradeArgs' last_upgrade: Details of the last firmware upgrade on the device
        :param 'FirmwareUpgradesProductsApplianceNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade on the device
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if available_versions is not None:
            pulumi.set(__self__, "available_versions", available_versions)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if last_upgrade is not None:
            pulumi.set(__self__, "last_upgrade", last_upgrade)
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Optional[Sequence['outputs.FirmwareUpgradesProductsApplianceAvailableVersion']]:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional['outputs.FirmwareUpgradesProductsApplianceCurrentVersion']:
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsApplianceLastUpgrade']:
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsApplianceNextUpgrade']:
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[_builtins.bool]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class FirmwareUpgradesProductsApplianceAvailableVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsApplianceAvailableVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsApplianceAvailableVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsApplianceAvailableVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsApplianceCurrentVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsApplianceCurrentVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsApplianceCurrentVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsApplianceCurrentVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsApplianceLastUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromVersion":
            suggest = "from_version"
        elif key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsApplianceLastUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsApplianceLastUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsApplianceLastUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_version: Optional['outputs.FirmwareUpgradesProductsApplianceLastUpgradeFromVersion'] = None,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsApplianceLastUpgradeToVersion'] = None):
        """
        :param 'FirmwareUpgradesProductsApplianceLastUpgradeFromVersionArgs' from_version: Details of the version the device upgraded from
        :param _builtins.str time: Timestamp of the last successful firmware upgrade
        :param 'FirmwareUpgradesProductsApplianceLastUpgradeToVersionArgs' to_version: Details of the version the device upgraded to
        """
        if from_version is not None:
            pulumi.set(__self__, "from_version", from_version)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> Optional['outputs.FirmwareUpgradesProductsApplianceLastUpgradeFromVersion']:
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsApplianceLastUpgradeToVersion']:
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsApplianceLastUpgradeFromVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsApplianceLastUpgradeFromVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsApplianceLastUpgradeFromVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsApplianceLastUpgradeFromVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsApplianceLastUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsApplianceLastUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsApplianceLastUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsApplianceLastUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsApplianceNextUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsApplianceNextUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsApplianceNextUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsApplianceNextUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsApplianceNextUpgradeToVersion'] = None):
        """
        :param _builtins.str time: Timestamp of the next scheduled firmware upgrade
        :param 'FirmwareUpgradesProductsApplianceNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to if it exists
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsApplianceNextUpgradeToVersion']:
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsApplianceNextUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsApplianceNextUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsApplianceNextUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsApplianceNextUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsCamera(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableVersions":
            suggest = "available_versions"
        elif key == "currentVersion":
            suggest = "current_version"
        elif key == "lastUpgrade":
            suggest = "last_upgrade"
        elif key == "nextUpgrade":
            suggest = "next_upgrade"
        elif key == "participateInNextBetaRelease":
            suggest = "participate_in_next_beta_release"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCamera. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCamera.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCamera.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_versions: Optional[Sequence['outputs.FirmwareUpgradesProductsCameraAvailableVersion']] = None,
                 current_version: Optional['outputs.FirmwareUpgradesProductsCameraCurrentVersion'] = None,
                 last_upgrade: Optional['outputs.FirmwareUpgradesProductsCameraLastUpgrade'] = None,
                 next_upgrade: Optional['outputs.FirmwareUpgradesProductsCameraNextUpgrade'] = None,
                 participate_in_next_beta_release: Optional[_builtins.bool] = None):
        """
        :param Sequence['FirmwareUpgradesProductsCameraAvailableVersionArgs'] available_versions: Firmware versions available for upgrade
        :param 'FirmwareUpgradesProductsCameraCurrentVersionArgs' current_version: Details of the current version on the device
        :param 'FirmwareUpgradesProductsCameraLastUpgradeArgs' last_upgrade: Details of the last firmware upgrade on the device
        :param 'FirmwareUpgradesProductsCameraNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade on the device
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if available_versions is not None:
            pulumi.set(__self__, "available_versions", available_versions)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if last_upgrade is not None:
            pulumi.set(__self__, "last_upgrade", last_upgrade)
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Optional[Sequence['outputs.FirmwareUpgradesProductsCameraAvailableVersion']]:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional['outputs.FirmwareUpgradesProductsCameraCurrentVersion']:
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsCameraLastUpgrade']:
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsCameraNextUpgrade']:
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[_builtins.bool]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class FirmwareUpgradesProductsCameraAvailableVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCameraAvailableVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCameraAvailableVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCameraAvailableVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsCameraCurrentVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCameraCurrentVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCameraCurrentVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCameraCurrentVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsCameraLastUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromVersion":
            suggest = "from_version"
        elif key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCameraLastUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCameraLastUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCameraLastUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_version: Optional['outputs.FirmwareUpgradesProductsCameraLastUpgradeFromVersion'] = None,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsCameraLastUpgradeToVersion'] = None):
        """
        :param 'FirmwareUpgradesProductsCameraLastUpgradeFromVersionArgs' from_version: Details of the version the device upgraded from
        :param _builtins.str time: Timestamp of the last successful firmware upgrade
        :param 'FirmwareUpgradesProductsCameraLastUpgradeToVersionArgs' to_version: Details of the version the device upgraded to
        """
        if from_version is not None:
            pulumi.set(__self__, "from_version", from_version)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> Optional['outputs.FirmwareUpgradesProductsCameraLastUpgradeFromVersion']:
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsCameraLastUpgradeToVersion']:
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsCameraLastUpgradeFromVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCameraLastUpgradeFromVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCameraLastUpgradeFromVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCameraLastUpgradeFromVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsCameraLastUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCameraLastUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCameraLastUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCameraLastUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsCameraNextUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCameraNextUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCameraNextUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCameraNextUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsCameraNextUpgradeToVersion'] = None):
        """
        :param _builtins.str time: Timestamp of the next scheduled firmware upgrade
        :param 'FirmwareUpgradesProductsCameraNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to if it exists
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsCameraNextUpgradeToVersion']:
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsCameraNextUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCameraNextUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCameraNextUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCameraNextUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsCellularGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableVersions":
            suggest = "available_versions"
        elif key == "currentVersion":
            suggest = "current_version"
        elif key == "lastUpgrade":
            suggest = "last_upgrade"
        elif key == "nextUpgrade":
            suggest = "next_upgrade"
        elif key == "participateInNextBetaRelease":
            suggest = "participate_in_next_beta_release"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCellularGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCellularGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCellularGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_versions: Optional[Sequence['outputs.FirmwareUpgradesProductsCellularGatewayAvailableVersion']] = None,
                 current_version: Optional['outputs.FirmwareUpgradesProductsCellularGatewayCurrentVersion'] = None,
                 last_upgrade: Optional['outputs.FirmwareUpgradesProductsCellularGatewayLastUpgrade'] = None,
                 next_upgrade: Optional['outputs.FirmwareUpgradesProductsCellularGatewayNextUpgrade'] = None,
                 participate_in_next_beta_release: Optional[_builtins.bool] = None):
        """
        :param Sequence['FirmwareUpgradesProductsCellularGatewayAvailableVersionArgs'] available_versions: Firmware versions available for upgrade
        :param 'FirmwareUpgradesProductsCellularGatewayCurrentVersionArgs' current_version: Details of the current version on the device
        :param 'FirmwareUpgradesProductsCellularGatewayLastUpgradeArgs' last_upgrade: Details of the last firmware upgrade on the device
        :param 'FirmwareUpgradesProductsCellularGatewayNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade on the device
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if available_versions is not None:
            pulumi.set(__self__, "available_versions", available_versions)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if last_upgrade is not None:
            pulumi.set(__self__, "last_upgrade", last_upgrade)
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Optional[Sequence['outputs.FirmwareUpgradesProductsCellularGatewayAvailableVersion']]:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional['outputs.FirmwareUpgradesProductsCellularGatewayCurrentVersion']:
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsCellularGatewayLastUpgrade']:
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsCellularGatewayNextUpgrade']:
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[_builtins.bool]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class FirmwareUpgradesProductsCellularGatewayAvailableVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCellularGatewayAvailableVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCellularGatewayAvailableVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCellularGatewayAvailableVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsCellularGatewayCurrentVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCellularGatewayCurrentVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCellularGatewayCurrentVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCellularGatewayCurrentVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsCellularGatewayLastUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromVersion":
            suggest = "from_version"
        elif key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCellularGatewayLastUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCellularGatewayLastUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCellularGatewayLastUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_version: Optional['outputs.FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersion'] = None,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersion'] = None):
        """
        :param 'FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersionArgs' from_version: Details of the version the device upgraded from
        :param _builtins.str time: Timestamp of the last successful firmware upgrade
        :param 'FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersionArgs' to_version: Details of the version the device upgraded to
        """
        if from_version is not None:
            pulumi.set(__self__, "from_version", from_version)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> Optional['outputs.FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersion']:
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersion']:
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsCellularGatewayNextUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCellularGatewayNextUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCellularGatewayNextUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCellularGatewayNextUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersion'] = None):
        """
        :param _builtins.str time: Timestamp of the next scheduled firmware upgrade
        :param 'FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to if it exists
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersion']:
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsSensor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableVersions":
            suggest = "available_versions"
        elif key == "currentVersion":
            suggest = "current_version"
        elif key == "lastUpgrade":
            suggest = "last_upgrade"
        elif key == "nextUpgrade":
            suggest = "next_upgrade"
        elif key == "participateInNextBetaRelease":
            suggest = "participate_in_next_beta_release"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSensor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSensor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSensor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_versions: Optional[Sequence['outputs.FirmwareUpgradesProductsSensorAvailableVersion']] = None,
                 current_version: Optional['outputs.FirmwareUpgradesProductsSensorCurrentVersion'] = None,
                 last_upgrade: Optional['outputs.FirmwareUpgradesProductsSensorLastUpgrade'] = None,
                 next_upgrade: Optional['outputs.FirmwareUpgradesProductsSensorNextUpgrade'] = None,
                 participate_in_next_beta_release: Optional[_builtins.bool] = None):
        """
        :param Sequence['FirmwareUpgradesProductsSensorAvailableVersionArgs'] available_versions: Firmware versions available for upgrade
        :param 'FirmwareUpgradesProductsSensorCurrentVersionArgs' current_version: Details of the current version on the device
        :param 'FirmwareUpgradesProductsSensorLastUpgradeArgs' last_upgrade: Details of the last firmware upgrade on the device
        :param 'FirmwareUpgradesProductsSensorNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade on the device
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if available_versions is not None:
            pulumi.set(__self__, "available_versions", available_versions)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if last_upgrade is not None:
            pulumi.set(__self__, "last_upgrade", last_upgrade)
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Optional[Sequence['outputs.FirmwareUpgradesProductsSensorAvailableVersion']]:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional['outputs.FirmwareUpgradesProductsSensorCurrentVersion']:
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsSensorLastUpgrade']:
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsSensorNextUpgrade']:
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[_builtins.bool]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class FirmwareUpgradesProductsSensorAvailableVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSensorAvailableVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSensorAvailableVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSensorAvailableVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsSensorCurrentVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSensorCurrentVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSensorCurrentVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSensorCurrentVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsSensorLastUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromVersion":
            suggest = "from_version"
        elif key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSensorLastUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSensorLastUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSensorLastUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_version: Optional['outputs.FirmwareUpgradesProductsSensorLastUpgradeFromVersion'] = None,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsSensorLastUpgradeToVersion'] = None):
        """
        :param 'FirmwareUpgradesProductsSensorLastUpgradeFromVersionArgs' from_version: Details of the version the device upgraded from
        :param _builtins.str time: Timestamp of the last successful firmware upgrade
        :param 'FirmwareUpgradesProductsSensorLastUpgradeToVersionArgs' to_version: Details of the version the device upgraded to
        """
        if from_version is not None:
            pulumi.set(__self__, "from_version", from_version)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> Optional['outputs.FirmwareUpgradesProductsSensorLastUpgradeFromVersion']:
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsSensorLastUpgradeToVersion']:
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsSensorLastUpgradeFromVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSensorLastUpgradeFromVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSensorLastUpgradeFromVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSensorLastUpgradeFromVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsSensorLastUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSensorLastUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSensorLastUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSensorLastUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsSensorNextUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSensorNextUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSensorNextUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSensorNextUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsSensorNextUpgradeToVersion'] = None):
        """
        :param _builtins.str time: Timestamp of the next scheduled firmware upgrade
        :param 'FirmwareUpgradesProductsSensorNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to if it exists
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsSensorNextUpgradeToVersion']:
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsSensorNextUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSensorNextUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSensorNextUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSensorNextUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsSwitch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableVersions":
            suggest = "available_versions"
        elif key == "currentVersion":
            suggest = "current_version"
        elif key == "lastUpgrade":
            suggest = "last_upgrade"
        elif key == "nextUpgrade":
            suggest = "next_upgrade"
        elif key == "participateInNextBetaRelease":
            suggest = "participate_in_next_beta_release"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSwitch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSwitch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSwitch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_versions: Optional[Sequence['outputs.FirmwareUpgradesProductsSwitchAvailableVersion']] = None,
                 current_version: Optional['outputs.FirmwareUpgradesProductsSwitchCurrentVersion'] = None,
                 last_upgrade: Optional['outputs.FirmwareUpgradesProductsSwitchLastUpgrade'] = None,
                 next_upgrade: Optional['outputs.FirmwareUpgradesProductsSwitchNextUpgrade'] = None,
                 participate_in_next_beta_release: Optional[_builtins.bool] = None):
        """
        :param Sequence['FirmwareUpgradesProductsSwitchAvailableVersionArgs'] available_versions: Firmware versions available for upgrade
        :param 'FirmwareUpgradesProductsSwitchCurrentVersionArgs' current_version: Details of the current version on the device
        :param 'FirmwareUpgradesProductsSwitchLastUpgradeArgs' last_upgrade: Details of the last firmware upgrade on the device
        :param 'FirmwareUpgradesProductsSwitchNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade on the device
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if available_versions is not None:
            pulumi.set(__self__, "available_versions", available_versions)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if last_upgrade is not None:
            pulumi.set(__self__, "last_upgrade", last_upgrade)
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Optional[Sequence['outputs.FirmwareUpgradesProductsSwitchAvailableVersion']]:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional['outputs.FirmwareUpgradesProductsSwitchCurrentVersion']:
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsSwitchLastUpgrade']:
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsSwitchNextUpgrade']:
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[_builtins.bool]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class FirmwareUpgradesProductsSwitchAvailableVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSwitchAvailableVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSwitchAvailableVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSwitchAvailableVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsSwitchCatalyst(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextUpgrade":
            suggest = "next_upgrade"
        elif key == "participateInNextBetaRelease":
            suggest = "participate_in_next_beta_release"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSwitchCatalyst. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSwitchCatalyst.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSwitchCatalyst.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_upgrade: Optional['outputs.FirmwareUpgradesProductsSwitchCatalystNextUpgrade'] = None,
                 participate_in_next_beta_release: Optional[_builtins.bool] = None):
        """
        :param 'FirmwareUpgradesProductsSwitchCatalystNextUpgradeArgs' next_upgrade: The pending firmware upgrade if it exists
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsSwitchCatalystNextUpgrade']:
        """
        The pending firmware upgrade if it exists
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[_builtins.bool]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class FirmwareUpgradesProductsSwitchCatalystNextUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSwitchCatalystNextUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSwitchCatalystNextUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSwitchCatalystNextUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersion'] = None):
        """
        :param _builtins.str time: The time of the last successful upgrade
        :param 'FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersionArgs' to_version: The version to be updated to
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        The time of the last successful upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersion']:
        """
        The version to be updated to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersion(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The version ID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The version ID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class FirmwareUpgradesProductsSwitchCurrentVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSwitchCurrentVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSwitchCurrentVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSwitchCurrentVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsSwitchLastUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromVersion":
            suggest = "from_version"
        elif key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSwitchLastUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSwitchLastUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSwitchLastUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_version: Optional['outputs.FirmwareUpgradesProductsSwitchLastUpgradeFromVersion'] = None,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsSwitchLastUpgradeToVersion'] = None):
        """
        :param 'FirmwareUpgradesProductsSwitchLastUpgradeFromVersionArgs' from_version: Details of the version the device upgraded from
        :param _builtins.str time: Timestamp of the last successful firmware upgrade
        :param 'FirmwareUpgradesProductsSwitchLastUpgradeToVersionArgs' to_version: Details of the version the device upgraded to
        """
        if from_version is not None:
            pulumi.set(__self__, "from_version", from_version)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> Optional['outputs.FirmwareUpgradesProductsSwitchLastUpgradeFromVersion']:
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsSwitchLastUpgradeToVersion']:
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsSwitchLastUpgradeFromVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSwitchLastUpgradeFromVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSwitchLastUpgradeFromVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSwitchLastUpgradeFromVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsSwitchLastUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSwitchLastUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSwitchLastUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSwitchLastUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsSwitchNextUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSwitchNextUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSwitchNextUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSwitchNextUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsSwitchNextUpgradeToVersion'] = None):
        """
        :param _builtins.str time: Timestamp of the next scheduled firmware upgrade
        :param 'FirmwareUpgradesProductsSwitchNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to if it exists
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsSwitchNextUpgradeToVersion']:
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsSwitchNextUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsSwitchNextUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsSwitchNextUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsSwitchNextUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsWireless(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableVersions":
            suggest = "available_versions"
        elif key == "currentVersion":
            suggest = "current_version"
        elif key == "lastUpgrade":
            suggest = "last_upgrade"
        elif key == "nextUpgrade":
            suggest = "next_upgrade"
        elif key == "participateInNextBetaRelease":
            suggest = "participate_in_next_beta_release"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsWireless. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsWireless.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsWireless.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_versions: Optional[Sequence['outputs.FirmwareUpgradesProductsWirelessAvailableVersion']] = None,
                 current_version: Optional['outputs.FirmwareUpgradesProductsWirelessCurrentVersion'] = None,
                 last_upgrade: Optional['outputs.FirmwareUpgradesProductsWirelessLastUpgrade'] = None,
                 next_upgrade: Optional['outputs.FirmwareUpgradesProductsWirelessNextUpgrade'] = None,
                 participate_in_next_beta_release: Optional[_builtins.bool] = None):
        """
        :param Sequence['FirmwareUpgradesProductsWirelessAvailableVersionArgs'] available_versions: Firmware versions available for upgrade
        :param 'FirmwareUpgradesProductsWirelessCurrentVersionArgs' current_version: Details of the current version on the device
        :param 'FirmwareUpgradesProductsWirelessLastUpgradeArgs' last_upgrade: Details of the last firmware upgrade on the device
        :param 'FirmwareUpgradesProductsWirelessNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade on the device
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if available_versions is not None:
            pulumi.set(__self__, "available_versions", available_versions)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if last_upgrade is not None:
            pulumi.set(__self__, "last_upgrade", last_upgrade)
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Optional[Sequence['outputs.FirmwareUpgradesProductsWirelessAvailableVersion']]:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional['outputs.FirmwareUpgradesProductsWirelessCurrentVersion']:
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsWirelessLastUpgrade']:
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional['outputs.FirmwareUpgradesProductsWirelessNextUpgrade']:
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[_builtins.bool]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class FirmwareUpgradesProductsWirelessAvailableVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsWirelessAvailableVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsWirelessAvailableVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsWirelessAvailableVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsWirelessCurrentVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsWirelessCurrentVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsWirelessCurrentVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsWirelessCurrentVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsWirelessLastUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromVersion":
            suggest = "from_version"
        elif key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsWirelessLastUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsWirelessLastUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsWirelessLastUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_version: Optional['outputs.FirmwareUpgradesProductsWirelessLastUpgradeFromVersion'] = None,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsWirelessLastUpgradeToVersion'] = None):
        """
        :param 'FirmwareUpgradesProductsWirelessLastUpgradeFromVersionArgs' from_version: Details of the version the device upgraded from
        :param _builtins.str time: Timestamp of the last successful firmware upgrade
        :param 'FirmwareUpgradesProductsWirelessLastUpgradeToVersionArgs' to_version: Details of the version the device upgraded to
        """
        if from_version is not None:
            pulumi.set(__self__, "from_version", from_version)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> Optional['outputs.FirmwareUpgradesProductsWirelessLastUpgradeFromVersion']:
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsWirelessLastUpgradeToVersion']:
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsWirelessLastUpgradeFromVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsWirelessLastUpgradeFromVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsWirelessLastUpgradeFromVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsWirelessLastUpgradeFromVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsWirelessLastUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsWirelessLastUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsWirelessLastUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsWirelessLastUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesProductsWirelessNextUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsWirelessNextUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsWirelessNextUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsWirelessNextUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesProductsWirelessNextUpgradeToVersion'] = None):
        """
        :param _builtins.str time: Timestamp of the next scheduled firmware upgrade
        :param 'FirmwareUpgradesProductsWirelessNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to if it exists
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesProductsWirelessNextUpgradeToVersion']:
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesProductsWirelessNextUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesProductsWirelessNextUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesProductsWirelessNextUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesProductsWirelessNextUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesRollbacksItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"
        elif key == "upgradeBatchId":
            suggest = "upgrade_batch_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesRollbacksItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesRollbacksItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesRollbacksItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 product: Optional[_builtins.str] = None,
                 reasons: Optional[Sequence['outputs.FirmwareUpgradesRollbacksItemReason']] = None,
                 status: Optional[_builtins.str] = None,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesRollbacksItemToVersion'] = None,
                 upgrade_batch_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str product: Product type to rollback (if the network is a combined network)
        :param Sequence['FirmwareUpgradesRollbacksItemReasonArgs'] reasons: Reasons for the rollback
        :param _builtins.str status: Status of the rollback
        :param _builtins.str time: Scheduled time for the rollback
        :param 'FirmwareUpgradesRollbacksItemToVersionArgs' to_version: Version to downgrade to (if the network has firmware flexibility)
        :param _builtins.str upgrade_batch_id: Batch ID of the firmware rollback
        """
        if product is not None:
            pulumi.set(__self__, "product", product)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)
        if upgrade_batch_id is not None:
            pulumi.set(__self__, "upgrade_batch_id", upgrade_batch_id)

    @_builtins.property
    @pulumi.getter
    def product(self) -> Optional[_builtins.str]:
        """
        Product type to rollback (if the network is a combined network)
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence['outputs.FirmwareUpgradesRollbacksItemReason']]:
        """
        Reasons for the rollback
        """
        return pulumi.get(self, "reasons")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the rollback
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Scheduled time for the rollback
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesRollbacksItemToVersion']:
        """
        Version to downgrade to (if the network has firmware flexibility)
        """
        return pulumi.get(self, "to_version")

    @_builtins.property
    @pulumi.getter(name="upgradeBatchId")
    def upgrade_batch_id(self) -> Optional[_builtins.str]:
        """
        Batch ID of the firmware rollback
        """
        return pulumi.get(self, "upgrade_batch_id")


@pulumi.output_type
class FirmwareUpgradesRollbacksItemReason(dict):
    def __init__(__self__, *,
                 category: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None):
        """
        :param _builtins.str category: Reason for the rollback
        :param _builtins.str comment: Additional comment about the rollback
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[_builtins.str]:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class FirmwareUpgradesRollbacksItemToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseDate":
            suggest = "release_date"
        elif key == "releaseType":
            suggest = "release_type"
        elif key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesRollbacksItemToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesRollbacksItemToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesRollbacksItemToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firmware: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 release_date: Optional[_builtins.str] = None,
                 release_type: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[_builtins.str]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesRollbacksParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesRollbacksParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesRollbacksParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesRollbacksParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 product: Optional[_builtins.str] = None,
                 reasons: Optional[Sequence['outputs.FirmwareUpgradesRollbacksParametersReason']] = None,
                 time: Optional[_builtins.str] = None,
                 to_version: Optional['outputs.FirmwareUpgradesRollbacksParametersToVersion'] = None):
        """
        :param _builtins.str product: Product type to rollback (if the network is a combined network)
        :param Sequence['FirmwareUpgradesRollbacksParametersReasonArgs'] reasons: Reasons for the rollback
        :param _builtins.str time: Scheduled time for the rollback
        :param 'FirmwareUpgradesRollbacksParametersToVersionArgs' to_version: Version to downgrade to (if the network has firmware flexibility)
        """
        if product is not None:
            pulumi.set(__self__, "product", product)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def product(self) -> Optional[_builtins.str]:
        """
        Product type to rollback (if the network is a combined network)
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence['outputs.FirmwareUpgradesRollbacksParametersReason']]:
        """
        Reasons for the rollback
        """
        return pulumi.get(self, "reasons")

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Scheduled time for the rollback
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesRollbacksParametersToVersion']:
        """
        Version to downgrade to (if the network has firmware flexibility)
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesRollbacksParametersReason(dict):
    def __init__(__self__, *,
                 category: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None):
        """
        :param _builtins.str category: Reason for the rollback
        :param _builtins.str comment: Additional comment about the rollback
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[_builtins.str]:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class FirmwareUpgradesRollbacksParametersToVersion(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The version ID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The version ID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class FirmwareUpgradesStagedEventsDeferItem(dict):
    def __init__(__self__, *,
                 products: Optional['outputs.FirmwareUpgradesStagedEventsDeferItemProducts'] = None,
                 reasons: Optional[Sequence['outputs.FirmwareUpgradesStagedEventsDeferItemReason']] = None,
                 stages: Optional[Sequence['outputs.FirmwareUpgradesStagedEventsDeferItemStage']] = None):
        """
        :param 'FirmwareUpgradesStagedEventsDeferItemProductsArgs' products: The network devices to be updated
        :param Sequence['FirmwareUpgradesStagedEventsDeferItemReasonArgs'] reasons: Reasons for the rollback
        :param Sequence['FirmwareUpgradesStagedEventsDeferItemStageArgs'] stages: The ordered stages in the network
        """
        if products is not None:
            pulumi.set(__self__, "products", products)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if stages is not None:
            pulumi.set(__self__, "stages", stages)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional['outputs.FirmwareUpgradesStagedEventsDeferItemProducts']:
        """
        The network devices to be updated
        """
        return pulumi.get(self, "products")

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence['outputs.FirmwareUpgradesStagedEventsDeferItemReason']]:
        """
        Reasons for the rollback
        """
        return pulumi.get(self, "reasons")

    @_builtins.property
    @pulumi.getter
    def stages(self) -> Optional[Sequence['outputs.FirmwareUpgradesStagedEventsDeferItemStage']]:
        """
        The ordered stages in the network
        """
        return pulumi.get(self, "stages")


@pulumi.output_type
class FirmwareUpgradesStagedEventsDeferItemProducts(dict):
    def __init__(__self__, *,
                 switch: Optional['outputs.FirmwareUpgradesStagedEventsDeferItemProductsSwitch'] = None):
        """
        :param 'FirmwareUpgradesStagedEventsDeferItemProductsSwitchArgs' switch: The Switch network to be updated
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional['outputs.FirmwareUpgradesStagedEventsDeferItemProductsSwitch']:
        """
        The Switch network to be updated
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class FirmwareUpgradesStagedEventsDeferItemProductsSwitch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextUpgrade":
            suggest = "next_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsDeferItemProductsSwitch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsDeferItemProductsSwitch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsDeferItemProductsSwitch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_upgrade: Optional['outputs.FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgrade'] = None):
        """
        :param 'FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade
        """
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional['outputs.FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgrade']:
        """
        Details of the next firmware upgrade
        """
        return pulumi.get(self, "next_upgrade")


@pulumi.output_type
class FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 to_version: Optional['outputs.FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersion'] = None):
        """
        :param 'FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to
        """
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersion']:
        """
        Details of the version the device will upgrade to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Id of the Version being upgraded to
        :param _builtins.str short_name: Firmware version short name
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the Version being upgraded to
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesStagedEventsDeferItemReason(dict):
    def __init__(__self__, *,
                 category: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None):
        """
        :param _builtins.str category: Reason for the rollback
        :param _builtins.str comment: Additional comment about the rollback
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[_builtins.str]:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class FirmwareUpgradesStagedEventsDeferItemStage(dict):
    def __init__(__self__, *,
                 group: Optional['outputs.FirmwareUpgradesStagedEventsDeferItemStageGroup'] = None,
                 milestones: Optional['outputs.FirmwareUpgradesStagedEventsDeferItemStageMilestones'] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param 'FirmwareUpgradesStagedEventsDeferItemStageGroupArgs' group: The staged upgrade group
        :param 'FirmwareUpgradesStagedEventsDeferItemStageMilestonesArgs' milestones: The Staged Upgrade Milestones for the stage
        :param _builtins.str status: Current upgrade status of the group
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if milestones is not None:
            pulumi.set(__self__, "milestones", milestones)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional['outputs.FirmwareUpgradesStagedEventsDeferItemStageGroup']:
        """
        The staged upgrade group
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def milestones(self) -> Optional['outputs.FirmwareUpgradesStagedEventsDeferItemStageMilestones']:
        """
        The Staged Upgrade Milestones for the stage
        """
        return pulumi.get(self, "milestones")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Current upgrade status of the group
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class FirmwareUpgradesStagedEventsDeferItemStageGroup(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the Staged Upgrade Group
        :param _builtins.str id: Id of the Staged Upgrade Group
        :param _builtins.str name: Name of the Staged Upgrade Group
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Staged Upgrade Group
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Staged Upgrade Group
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FirmwareUpgradesStagedEventsDeferItemStageMilestones(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canceledAt":
            suggest = "canceled_at"
        elif key == "completedAt":
            suggest = "completed_at"
        elif key == "scheduledFor":
            suggest = "scheduled_for"
        elif key == "startedAt":
            suggest = "started_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsDeferItemStageMilestones. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsDeferItemStageMilestones.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsDeferItemStageMilestones.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canceled_at: Optional[_builtins.str] = None,
                 completed_at: Optional[_builtins.str] = None,
                 scheduled_for: Optional[_builtins.str] = None,
                 started_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str canceled_at: Time that the group was canceled
        :param _builtins.str completed_at: Finish time for the group
        :param _builtins.str scheduled_for: Scheduled start time for the group
        :param _builtins.str started_at: Start time for the group
        """
        if canceled_at is not None:
            pulumi.set(__self__, "canceled_at", canceled_at)
        if completed_at is not None:
            pulumi.set(__self__, "completed_at", completed_at)
        if scheduled_for is not None:
            pulumi.set(__self__, "scheduled_for", scheduled_for)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @_builtins.property
    @pulumi.getter(name="canceledAt")
    def canceled_at(self) -> Optional[_builtins.str]:
        """
        Time that the group was canceled
        """
        return pulumi.get(self, "canceled_at")

    @_builtins.property
    @pulumi.getter(name="completedAt")
    def completed_at(self) -> Optional[_builtins.str]:
        """
        Finish time for the group
        """
        return pulumi.get(self, "completed_at")

    @_builtins.property
    @pulumi.getter(name="scheduledFor")
    def scheduled_for(self) -> Optional[_builtins.str]:
        """
        Scheduled start time for the group
        """
        return pulumi.get(self, "scheduled_for")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[_builtins.str]:
        """
        Start time for the group
        """
        return pulumi.get(self, "started_at")


@pulumi.output_type
class FirmwareUpgradesStagedEventsProducts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "switchCatalyst":
            suggest = "switch_catalyst"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsProducts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsProducts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsProducts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: Optional['outputs.FirmwareUpgradesStagedEventsProductsSwitch'] = None,
                 switch_catalyst: Optional['outputs.FirmwareUpgradesStagedEventsProductsSwitchCatalyst'] = None):
        """
        :param 'FirmwareUpgradesStagedEventsProductsSwitchArgs' switch: The Switch network to be updated
        :param 'FirmwareUpgradesStagedEventsProductsSwitchCatalystArgs' switch_catalyst: Version information for the switch network being upgraded
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if switch_catalyst is not None:
            pulumi.set(__self__, "switch_catalyst", switch_catalyst)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional['outputs.FirmwareUpgradesStagedEventsProductsSwitch']:
        """
        The Switch network to be updated
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="switchCatalyst")
    def switch_catalyst(self) -> Optional['outputs.FirmwareUpgradesStagedEventsProductsSwitchCatalyst']:
        """
        Version information for the switch network being upgraded
        """
        return pulumi.get(self, "switch_catalyst")


@pulumi.output_type
class FirmwareUpgradesStagedEventsProductsSwitch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextUpgrade":
            suggest = "next_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsProductsSwitch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsProductsSwitch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsProductsSwitch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_upgrade: Optional['outputs.FirmwareUpgradesStagedEventsProductsSwitchNextUpgrade'] = None):
        """
        :param 'FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade
        """
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional['outputs.FirmwareUpgradesStagedEventsProductsSwitchNextUpgrade']:
        """
        Details of the next firmware upgrade
        """
        return pulumi.get(self, "next_upgrade")


@pulumi.output_type
class FirmwareUpgradesStagedEventsProductsSwitchCatalyst(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextUpgrade":
            suggest = "next_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsProductsSwitchCatalyst. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsProductsSwitchCatalyst.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsProductsSwitchCatalyst.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_upgrade: Optional['outputs.FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgrade'] = None):
        """
        :param 'FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeArgs' next_upgrade: The next upgrade version for the switch network
        """
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional['outputs.FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgrade']:
        """
        The next upgrade version for the switch network
        """
        return pulumi.get(self, "next_upgrade")


@pulumi.output_type
class FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 to_version: Optional['outputs.FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersion'] = None):
        """
        :param 'FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersionArgs' to_version: The version to be updated to for switch Catalyst devices
        """
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersion']:
        """
        The version to be updated to for switch Catalyst devices
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersion(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The version ID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The version ID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class FirmwareUpgradesStagedEventsProductsSwitchNextUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsProductsSwitchNextUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsProductsSwitchNextUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsProductsSwitchNextUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 to_version: Optional['outputs.FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersion'] = None):
        """
        :param 'FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to
        """
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersion']:
        """
        Details of the version the device will upgrade to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Id of the Version being upgraded to
        :param _builtins.str short_name: Firmware version short name
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the Version being upgraded to
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesStagedEventsReason(dict):
    def __init__(__self__, *,
                 category: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None):
        """
        :param _builtins.str category: Reason for the rollback
        :param _builtins.str comment: Additional comment about the rollback
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[_builtins.str]:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksItem(dict):
    def __init__(__self__, *,
                 products: Optional['outputs.FirmwareUpgradesStagedEventsRollbacksItemProducts'] = None,
                 reasons: Optional[Sequence['outputs.FirmwareUpgradesStagedEventsRollbacksItemReason']] = None,
                 stages: Optional[Sequence['outputs.FirmwareUpgradesStagedEventsRollbacksItemStage']] = None):
        """
        :param 'FirmwareUpgradesStagedEventsRollbacksItemProductsArgs' products: The network devices to be updated
        :param Sequence['FirmwareUpgradesStagedEventsRollbacksItemReasonArgs'] reasons: Reasons for the rollback
        :param Sequence['FirmwareUpgradesStagedEventsRollbacksItemStageArgs'] stages: The ordered stages in the network
        """
        if products is not None:
            pulumi.set(__self__, "products", products)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if stages is not None:
            pulumi.set(__self__, "stages", stages)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional['outputs.FirmwareUpgradesStagedEventsRollbacksItemProducts']:
        """
        The network devices to be updated
        """
        return pulumi.get(self, "products")

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence['outputs.FirmwareUpgradesStagedEventsRollbacksItemReason']]:
        """
        Reasons for the rollback
        """
        return pulumi.get(self, "reasons")

    @_builtins.property
    @pulumi.getter
    def stages(self) -> Optional[Sequence['outputs.FirmwareUpgradesStagedEventsRollbacksItemStage']]:
        """
        The ordered stages in the network
        """
        return pulumi.get(self, "stages")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksItemProducts(dict):
    def __init__(__self__, *,
                 switch: Optional['outputs.FirmwareUpgradesStagedEventsRollbacksItemProductsSwitch'] = None):
        """
        :param 'FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchArgs' switch: The Switch network to be updated
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional['outputs.FirmwareUpgradesStagedEventsRollbacksItemProductsSwitch']:
        """
        The Switch network to be updated
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksItemProductsSwitch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextUpgrade":
            suggest = "next_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsRollbacksItemProductsSwitch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsRollbacksItemProductsSwitch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsRollbacksItemProductsSwitch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_upgrade: Optional['outputs.FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgrade'] = None):
        """
        :param 'FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade
        """
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional['outputs.FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgrade']:
        """
        Details of the next firmware upgrade
        """
        return pulumi.get(self, "next_upgrade")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toVersion":
            suggest = "to_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 to_version: Optional['outputs.FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersion'] = None):
        """
        :param 'FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to
        """
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional['outputs.FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersion']:
        """
        Details of the version the device will upgrade to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shortName":
            suggest = "short_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 short_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Id of the Version being upgraded to
        :param _builtins.str short_name: Firmware version short name
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the Version being upgraded to
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[_builtins.str]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksItemReason(dict):
    def __init__(__self__, *,
                 category: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None):
        """
        :param _builtins.str category: Reason for the rollback
        :param _builtins.str comment: Additional comment about the rollback
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[_builtins.str]:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksItemStage(dict):
    def __init__(__self__, *,
                 group: Optional['outputs.FirmwareUpgradesStagedEventsRollbacksItemStageGroup'] = None,
                 milestones: Optional['outputs.FirmwareUpgradesStagedEventsRollbacksItemStageMilestones'] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param 'FirmwareUpgradesStagedEventsRollbacksItemStageGroupArgs' group: The staged upgrade group
        :param 'FirmwareUpgradesStagedEventsRollbacksItemStageMilestonesArgs' milestones: The Staged Upgrade Milestones for the stage
        :param _builtins.str status: Current upgrade status of the group
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if milestones is not None:
            pulumi.set(__self__, "milestones", milestones)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional['outputs.FirmwareUpgradesStagedEventsRollbacksItemStageGroup']:
        """
        The staged upgrade group
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def milestones(self) -> Optional['outputs.FirmwareUpgradesStagedEventsRollbacksItemStageMilestones']:
        """
        The Staged Upgrade Milestones for the stage
        """
        return pulumi.get(self, "milestones")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Current upgrade status of the group
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksItemStageGroup(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the Staged Upgrade Group
        :param _builtins.str id: Id of the Staged Upgrade Group
        :param _builtins.str name: Name of the Staged Upgrade Group
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Staged Upgrade Group
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Staged Upgrade Group
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksItemStageMilestones(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canceledAt":
            suggest = "canceled_at"
        elif key == "completedAt":
            suggest = "completed_at"
        elif key == "scheduledFor":
            suggest = "scheduled_for"
        elif key == "startedAt":
            suggest = "started_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsRollbacksItemStageMilestones. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsRollbacksItemStageMilestones.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsRollbacksItemStageMilestones.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canceled_at: Optional[_builtins.str] = None,
                 completed_at: Optional[_builtins.str] = None,
                 scheduled_for: Optional[_builtins.str] = None,
                 started_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str canceled_at: Time that the group was canceled
        :param _builtins.str completed_at: Finish time for the group
        :param _builtins.str scheduled_for: Scheduled start time for the group
        :param _builtins.str started_at: Start time for the group
        """
        if canceled_at is not None:
            pulumi.set(__self__, "canceled_at", canceled_at)
        if completed_at is not None:
            pulumi.set(__self__, "completed_at", completed_at)
        if scheduled_for is not None:
            pulumi.set(__self__, "scheduled_for", scheduled_for)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @_builtins.property
    @pulumi.getter(name="canceledAt")
    def canceled_at(self) -> Optional[_builtins.str]:
        """
        Time that the group was canceled
        """
        return pulumi.get(self, "canceled_at")

    @_builtins.property
    @pulumi.getter(name="completedAt")
    def completed_at(self) -> Optional[_builtins.str]:
        """
        Finish time for the group
        """
        return pulumi.get(self, "completed_at")

    @_builtins.property
    @pulumi.getter(name="scheduledFor")
    def scheduled_for(self) -> Optional[_builtins.str]:
        """
        Scheduled start time for the group
        """
        return pulumi.get(self, "scheduled_for")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[_builtins.str]:
        """
        Start time for the group
        """
        return pulumi.get(self, "started_at")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksParameters(dict):
    def __init__(__self__, *,
                 reasons: Optional[Sequence['outputs.FirmwareUpgradesStagedEventsRollbacksParametersReason']] = None,
                 stages: Optional[Sequence['outputs.FirmwareUpgradesStagedEventsRollbacksParametersStage']] = None):
        """
        :param Sequence['FirmwareUpgradesStagedEventsRollbacksParametersReasonArgs'] reasons: The reason for rolling back the staged upgrade
        :param Sequence['FirmwareUpgradesStagedEventsRollbacksParametersStageArgs'] stages: All completed or in-progress stages in the network with their new start times. All pending stages will be canceled
        """
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if stages is not None:
            pulumi.set(__self__, "stages", stages)

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence['outputs.FirmwareUpgradesStagedEventsRollbacksParametersReason']]:
        """
        The reason for rolling back the staged upgrade
        """
        return pulumi.get(self, "reasons")

    @_builtins.property
    @pulumi.getter
    def stages(self) -> Optional[Sequence['outputs.FirmwareUpgradesStagedEventsRollbacksParametersStage']]:
        """
        All completed or in-progress stages in the network with their new start times. All pending stages will be canceled
        """
        return pulumi.get(self, "stages")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksParametersReason(dict):
    def __init__(__self__, *,
                 category: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None):
        """
        :param _builtins.str category: Reason for the rollback
        :param _builtins.str comment: Additional comment about the rollback
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[_builtins.str]:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksParametersStage(dict):
    def __init__(__self__, *,
                 group: Optional['outputs.FirmwareUpgradesStagedEventsRollbacksParametersStageGroup'] = None,
                 milestones: Optional['outputs.FirmwareUpgradesStagedEventsRollbacksParametersStageMilestones'] = None):
        """
        :param 'FirmwareUpgradesStagedEventsRollbacksParametersStageGroupArgs' group: The Staged Upgrade Group containing the name and ID
        :param 'FirmwareUpgradesStagedEventsRollbacksParametersStageMilestonesArgs' milestones: The Staged Upgrade Milestones for the specific stage
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if milestones is not None:
            pulumi.set(__self__, "milestones", milestones)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional['outputs.FirmwareUpgradesStagedEventsRollbacksParametersStageGroup']:
        """
        The Staged Upgrade Group containing the name and ID
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def milestones(self) -> Optional['outputs.FirmwareUpgradesStagedEventsRollbacksParametersStageMilestones']:
        """
        The Staged Upgrade Milestones for the specific stage
        """
        return pulumi.get(self, "milestones")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksParametersStageGroup(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: ID of the Staged Upgrade Group
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class FirmwareUpgradesStagedEventsRollbacksParametersStageMilestones(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scheduledFor":
            suggest = "scheduled_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsRollbacksParametersStageMilestones. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsRollbacksParametersStageMilestones.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsRollbacksParametersStageMilestones.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scheduled_for: Optional[_builtins.str] = None):
        """
        :param _builtins.str scheduled_for: The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
        """
        if scheduled_for is not None:
            pulumi.set(__self__, "scheduled_for", scheduled_for)

    @_builtins.property
    @pulumi.getter(name="scheduledFor")
    def scheduled_for(self) -> Optional[_builtins.str]:
        """
        The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
        """
        return pulumi.get(self, "scheduled_for")


@pulumi.output_type
class FirmwareUpgradesStagedEventsStage(dict):
    def __init__(__self__, *,
                 group: Optional['outputs.FirmwareUpgradesStagedEventsStageGroup'] = None,
                 milestones: Optional['outputs.FirmwareUpgradesStagedEventsStageMilestones'] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param 'FirmwareUpgradesStagedEventsStageGroupArgs' group: The staged upgrade group
        :param 'FirmwareUpgradesStagedEventsStageMilestonesArgs' milestones: The Staged Upgrade Milestones for the stage
        :param _builtins.str status: Current upgrade status of the group
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if milestones is not None:
            pulumi.set(__self__, "milestones", milestones)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional['outputs.FirmwareUpgradesStagedEventsStageGroup']:
        """
        The staged upgrade group
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def milestones(self) -> Optional['outputs.FirmwareUpgradesStagedEventsStageMilestones']:
        """
        The Staged Upgrade Milestones for the stage
        """
        return pulumi.get(self, "milestones")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Current upgrade status of the group
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class FirmwareUpgradesStagedEventsStageGroup(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the Staged Upgrade Group
        :param _builtins.str id: Id of the Staged Upgrade Group
        :param _builtins.str name: Name of the Staged Upgrade Group
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Staged Upgrade Group
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Staged Upgrade Group
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FirmwareUpgradesStagedEventsStageMilestones(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canceledAt":
            suggest = "canceled_at"
        elif key == "completedAt":
            suggest = "completed_at"
        elif key == "scheduledFor":
            suggest = "scheduled_for"
        elif key == "startedAt":
            suggest = "started_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedEventsStageMilestones. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedEventsStageMilestones.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedEventsStageMilestones.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canceled_at: Optional[_builtins.str] = None,
                 completed_at: Optional[_builtins.str] = None,
                 scheduled_for: Optional[_builtins.str] = None,
                 started_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str canceled_at: Time that the group was canceled
        :param _builtins.str completed_at: Finish time for the group
        :param _builtins.str scheduled_for: Scheduled start time for the group
        :param _builtins.str started_at: Start time for the group
        """
        if canceled_at is not None:
            pulumi.set(__self__, "canceled_at", canceled_at)
        if completed_at is not None:
            pulumi.set(__self__, "completed_at", completed_at)
        if scheduled_for is not None:
            pulumi.set(__self__, "scheduled_for", scheduled_for)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @_builtins.property
    @pulumi.getter(name="canceledAt")
    def canceled_at(self) -> Optional[_builtins.str]:
        """
        Time that the group was canceled
        """
        return pulumi.get(self, "canceled_at")

    @_builtins.property
    @pulumi.getter(name="completedAt")
    def completed_at(self) -> Optional[_builtins.str]:
        """
        Finish time for the group
        """
        return pulumi.get(self, "completed_at")

    @_builtins.property
    @pulumi.getter(name="scheduledFor")
    def scheduled_for(self) -> Optional[_builtins.str]:
        """
        Scheduled start time for the group
        """
        return pulumi.get(self, "scheduled_for")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[_builtins.str]:
        """
        Start time for the group
        """
        return pulumi.get(self, "started_at")


@pulumi.output_type
class FirmwareUpgradesStagedGroupsAssignedDevices(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "switchStacks":
            suggest = "switch_stacks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesStagedGroupsAssignedDevices. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesStagedGroupsAssignedDevices.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesStagedGroupsAssignedDevices.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 devices: Optional[Sequence['outputs.FirmwareUpgradesStagedGroupsAssignedDevicesDevice']] = None,
                 switch_stacks: Optional[Sequence['outputs.FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStack']] = None):
        """
        :param Sequence['FirmwareUpgradesStagedGroupsAssignedDevicesDeviceArgs'] devices: Data Array of Devices containing the name and serial
        :param Sequence['FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStackArgs'] switch_stacks: Data Array of Switch Stacks containing the name and id
        """
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if switch_stacks is not None:
            pulumi.set(__self__, "switch_stacks", switch_stacks)

    @_builtins.property
    @pulumi.getter
    def devices(self) -> Optional[Sequence['outputs.FirmwareUpgradesStagedGroupsAssignedDevicesDevice']]:
        """
        Data Array of Devices containing the name and serial
        """
        return pulumi.get(self, "devices")

    @_builtins.property
    @pulumi.getter(name="switchStacks")
    def switch_stacks(self) -> Optional[Sequence['outputs.FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStack']]:
        """
        Data Array of Switch Stacks containing the name and id
        """
        return pulumi.get(self, "switch_stacks")


@pulumi.output_type
class FirmwareUpgradesStagedGroupsAssignedDevicesDevice(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 serial: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the device
        :param _builtins.str serial: Serial of the device
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the device
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        Serial of the device
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStack(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: ID of the Switch Stack
        :param _builtins.str name: Name of the Switch Stack
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Switch Stack
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Switch Stack
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FirmwareUpgradesStagedStagesGroup(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the Staged Upgrade Group
        :param _builtins.str id: Id of the Staged Upgrade Group
        :param _builtins.str name: Name of the Staged Upgrade Group
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Staged Upgrade Group
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Staged Upgrade Group
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FirmwareUpgradesStagedStagesJson(dict):
    def __init__(__self__, *,
                 group: Optional['outputs.FirmwareUpgradesStagedStagesJsonGroup'] = None):
        """
        :param 'FirmwareUpgradesStagedStagesJsonGroupArgs' group: The Staged Upgrade Group
        """
        if group is not None:
            pulumi.set(__self__, "group", group)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional['outputs.FirmwareUpgradesStagedStagesJsonGroup']:
        """
        The Staged Upgrade Group
        """
        return pulumi.get(self, "group")


@pulumi.output_type
class FirmwareUpgradesStagedStagesJsonGroup(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: ID of the Staged Upgrade Group
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class FirmwareUpgradesUpgradeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "hourOfDay":
            suggest = "hour_of_day"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirmwareUpgradesUpgradeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirmwareUpgradesUpgradeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirmwareUpgradesUpgradeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: Optional[_builtins.str] = None,
                 hour_of_day: Optional[_builtins.str] = None):
        """
        :param _builtins.str day_of_week: Day of the week
        :param _builtins.str hour_of_day: Hour of the day
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if hour_of_day is not None:
            pulumi.set(__self__, "hour_of_day", hour_of_day)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.str]:
        """
        Day of the week
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> Optional[_builtins.str]:
        """
        Hour of the day
        """
        return pulumi.get(self, "hour_of_day")


@pulumi.output_type
class FloorPlansBottomLeftCorner(dict):
    def __init__(__self__, *,
                 lat: Optional[_builtins.float] = None,
                 lng: Optional[_builtins.float] = None):
        """
        :param _builtins.float lat: Latitude
        :param _builtins.float lng: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[_builtins.float]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[_builtins.float]:
        """
        Longitude
        """
        return pulumi.get(self, "lng")


@pulumi.output_type
class FloorPlansBottomRightCorner(dict):
    def __init__(__self__, *,
                 lat: Optional[_builtins.float] = None,
                 lng: Optional[_builtins.float] = None):
        """
        :param _builtins.float lat: Latitude
        :param _builtins.float lng: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[_builtins.float]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[_builtins.float]:
        """
        Longitude
        """
        return pulumi.get(self, "lng")


@pulumi.output_type
class FloorPlansCenter(dict):
    def __init__(__self__, *,
                 lat: Optional[_builtins.float] = None,
                 lng: Optional[_builtins.float] = None):
        """
        :param _builtins.float lat: Latitude
        :param _builtins.float lng: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[_builtins.float]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[_builtins.float]:
        """
        Longitude
        """
        return pulumi.get(self, "lng")


@pulumi.output_type
class FloorPlansDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lanIp":
            suggest = "lan_ip"
        elif key == "networkId":
            suggest = "network_id"
        elif key == "productType":
            suggest = "product_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FloorPlansDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FloorPlansDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FloorPlansDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 details: Optional[Sequence['outputs.FloorPlansDeviceDetail']] = None,
                 firmware: Optional[_builtins.str] = None,
                 imei: Optional[_builtins.str] = None,
                 lan_ip: Optional[_builtins.str] = None,
                 lat: Optional[_builtins.float] = None,
                 lng: Optional[_builtins.float] = None,
                 mac: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 network_id: Optional[_builtins.str] = None,
                 notes: Optional[_builtins.str] = None,
                 product_type: Optional[_builtins.str] = None,
                 serial: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str address: Physical address of the device
        :param Sequence['FloorPlansDeviceDetailArgs'] details: Additional device information
        :param _builtins.str firmware: Firmware version of the device
        :param _builtins.str imei: IMEI of the device, if applicable
        :param _builtins.str lan_ip: LAN IP address of the device
        :param _builtins.float lat: Latitude of the device
        :param _builtins.float lng: Longitude of the device
        :param _builtins.str mac: MAC address of the device
        :param _builtins.str model: Model of the device
        :param _builtins.str name: Name of the device
        :param _builtins.str network_id: ID of the network the device belongs to
        :param _builtins.str notes: Notes for the device, limited to 255 characters
        :param _builtins.str product_type: Product type of the device
        :param _builtins.str serial: Serial number of the device
        :param Sequence[_builtins.str] tags: List of tags assigned to the device
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if imei is not None:
            pulumi.set(__self__, "imei", imei)
        if lan_ip is not None:
            pulumi.set(__self__, "lan_ip", lan_ip)
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if product_type is not None:
            pulumi.set(__self__, "product_type", product_type)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Physical address of the device
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.FloorPlansDeviceDetail']]:
        """
        Additional device information
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Firmware version of the device
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def imei(self) -> Optional[_builtins.str]:
        """
        IMEI of the device, if applicable
        """
        return pulumi.get(self, "imei")

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> Optional[_builtins.str]:
        """
        LAN IP address of the device
        """
        return pulumi.get(self, "lan_ip")

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[_builtins.float]:
        """
        Latitude of the device
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[_builtins.float]:
        """
        Longitude of the device
        """
        return pulumi.get(self, "lng")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[_builtins.str]:
        """
        MAC address of the device
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Model of the device
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the device
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[_builtins.str]:
        """
        ID of the network the device belongs to
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[_builtins.str]:
        """
        Notes for the device, limited to 255 characters
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> Optional[_builtins.str]:
        """
        Product type of the device
        """
        return pulumi.get(self, "product_type")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        Serial number of the device
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags assigned to the device
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class FloorPlansDeviceDetail(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Additional property name
        :param _builtins.str value: Additional property value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Additional property name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Additional property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FloorPlansTopLeftCorner(dict):
    def __init__(__self__, *,
                 lat: Optional[_builtins.float] = None,
                 lng: Optional[_builtins.float] = None):
        """
        :param _builtins.float lat: Latitude
        :param _builtins.float lng: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[_builtins.float]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[_builtins.float]:
        """
        Longitude
        """
        return pulumi.get(self, "lng")


@pulumi.output_type
class FloorPlansTopRightCorner(dict):
    def __init__(__self__, *,
                 lat: Optional[_builtins.float] = None,
                 lng: Optional[_builtins.float] = None):
        """
        :param _builtins.float lat: Latitude
        :param _builtins.float lng: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[_builtins.float]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[_builtins.float]:
        """
        Longitude
        """
        return pulumi.get(self, "lng")


@pulumi.output_type
class GroupPoliciesBandwidth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthLimits":
            suggest = "bandwidth_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesBandwidth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesBandwidth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesBandwidth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_limits: Optional['outputs.GroupPoliciesBandwidthBandwidthLimits'] = None,
                 settings: Optional[_builtins.str] = None):
        """
        :param 'GroupPoliciesBandwidthBandwidthLimitsArgs' bandwidth_limits: The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
        :param _builtins.str settings: How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
        """
        if bandwidth_limits is not None:
            pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> Optional['outputs.GroupPoliciesBandwidthBandwidthLimits']:
        """
        The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[_builtins.str]:
        """
        How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GroupPoliciesBandwidthBandwidthLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitDown":
            suggest = "limit_down"
        elif key == "limitUp":
            suggest = "limit_up"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesBandwidthBandwidthLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesBandwidthBandwidthLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesBandwidthBandwidthLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_down: Optional[_builtins.int] = None,
                 limit_up: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit_down: The maximum download limit (integer, in Kbps). null indicates no limit
        :param _builtins.int limit_up: The maximum upload limit (integer, in Kbps). null indicates no limit
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[_builtins.int]:
        """
        The maximum download limit (integer, in Kbps). null indicates no limit
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[_builtins.int]:
        """
        The maximum upload limit (integer, in Kbps). null indicates no limit
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class GroupPoliciesBonjourForwarding(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.GroupPoliciesBonjourForwardingRule']] = None,
                 settings: Optional[_builtins.str] = None):
        """
        :param Sequence['GroupPoliciesBonjourForwardingRuleArgs'] rules: A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
        :param _builtins.str settings: How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.GroupPoliciesBonjourForwardingRule']]:
        """
        A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
        """
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[_builtins.str]:
        """
        How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GroupPoliciesBonjourForwardingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesBonjourForwardingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesBonjourForwardingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesBonjourForwardingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 services: Optional[Sequence[_builtins.str]] = None,
                 vlan_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: A description for your Bonjour forwarding rule. Optional.
        :param Sequence[_builtins.str] services: A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        :param _builtins.str vlan_id: The ID of the service VLAN. Required.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description for your Bonjour forwarding rule. Optional.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        """
        The ID of the service VLAN. Required.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GroupPoliciesContentFiltering(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedUrlPatterns":
            suggest = "allowed_url_patterns"
        elif key == "blockedUrlCategories":
            suggest = "blocked_url_categories"
        elif key == "blockedUrlPatterns":
            suggest = "blocked_url_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesContentFiltering. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesContentFiltering.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesContentFiltering.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_url_patterns: Optional['outputs.GroupPoliciesContentFilteringAllowedUrlPatterns'] = None,
                 blocked_url_categories: Optional['outputs.GroupPoliciesContentFilteringBlockedUrlCategories'] = None,
                 blocked_url_patterns: Optional['outputs.GroupPoliciesContentFilteringBlockedUrlPatterns'] = None):
        """
        :param 'GroupPoliciesContentFilteringAllowedUrlPatternsArgs' allowed_url_patterns: Settings for allowed URL patterns
        :param 'GroupPoliciesContentFilteringBlockedUrlCategoriesArgs' blocked_url_categories: Settings for blocked URL categories
        :param 'GroupPoliciesContentFilteringBlockedUrlPatternsArgs' blocked_url_patterns: Settings for blocked URL patterns
        """
        if allowed_url_patterns is not None:
            pulumi.set(__self__, "allowed_url_patterns", allowed_url_patterns)
        if blocked_url_categories is not None:
            pulumi.set(__self__, "blocked_url_categories", blocked_url_categories)
        if blocked_url_patterns is not None:
            pulumi.set(__self__, "blocked_url_patterns", blocked_url_patterns)

    @_builtins.property
    @pulumi.getter(name="allowedUrlPatterns")
    def allowed_url_patterns(self) -> Optional['outputs.GroupPoliciesContentFilteringAllowedUrlPatterns']:
        """
        Settings for allowed URL patterns
        """
        return pulumi.get(self, "allowed_url_patterns")

    @_builtins.property
    @pulumi.getter(name="blockedUrlCategories")
    def blocked_url_categories(self) -> Optional['outputs.GroupPoliciesContentFilteringBlockedUrlCategories']:
        """
        Settings for blocked URL categories
        """
        return pulumi.get(self, "blocked_url_categories")

    @_builtins.property
    @pulumi.getter(name="blockedUrlPatterns")
    def blocked_url_patterns(self) -> Optional['outputs.GroupPoliciesContentFilteringBlockedUrlPatterns']:
        """
        Settings for blocked URL patterns
        """
        return pulumi.get(self, "blocked_url_patterns")


@pulumi.output_type
class GroupPoliciesContentFilteringAllowedUrlPatterns(dict):
    def __init__(__self__, *,
                 patterns: Optional[Sequence[_builtins.str]] = None,
                 settings: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] patterns: A list of URL patterns that are allowed
        :param _builtins.str settings: How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of URL patterns that are allowed
        """
        return pulumi.get(self, "patterns")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[_builtins.str]:
        """
        How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GroupPoliciesContentFilteringBlockedUrlCategories(dict):
    def __init__(__self__, *,
                 categories: Optional[Sequence[_builtins.str]] = None,
                 settings: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] categories: A list of URL categories to block
        :param _builtins.str settings: How URL categories are applied. Can be 'network default', 'append' or 'override'.
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def categories(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of URL categories to block
        """
        return pulumi.get(self, "categories")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[_builtins.str]:
        """
        How URL categories are applied. Can be 'network default', 'append' or 'override'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GroupPoliciesContentFilteringBlockedUrlPatterns(dict):
    def __init__(__self__, *,
                 patterns: Optional[Sequence[_builtins.str]] = None,
                 settings: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] patterns: A list of URL patterns that are blocked
        :param _builtins.str settings: How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of URL patterns that are blocked
        """
        return pulumi.get(self, "patterns")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[_builtins.str]:
        """
        How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GroupPoliciesFirewallAndTrafficShaping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "l3FirewallRules":
            suggest = "l3_firewall_rules"
        elif key == "l7FirewallRules":
            suggest = "l7_firewall_rules"
        elif key == "trafficShapingRules":
            suggest = "traffic_shaping_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesFirewallAndTrafficShaping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesFirewallAndTrafficShaping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesFirewallAndTrafficShaping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 l3_firewall_rules: Optional[Sequence['outputs.GroupPoliciesFirewallAndTrafficShapingL3FirewallRule']] = None,
                 l7_firewall_rules: Optional[Sequence['outputs.GroupPoliciesFirewallAndTrafficShapingL7FirewallRule']] = None,
                 settings: Optional[_builtins.str] = None,
                 traffic_shaping_rules: Optional[Sequence['outputs.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRule']] = None):
        """
        :param Sequence['GroupPoliciesFirewallAndTrafficShapingL3FirewallRuleArgs'] l3_firewall_rules: An ordered array of the L3 firewall rules
        :param Sequence['GroupPoliciesFirewallAndTrafficShapingL7FirewallRuleArgs'] l7_firewall_rules: An ordered array of L7 firewall rules
        :param _builtins.str settings: How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
        :param Sequence['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleArgs'] traffic_shaping_rules: An array of traffic shaping rules. Rules are applied in the order that
               they are specified in. An empty list (or null) means no rules. Note that
               you are allowed a maximum of 8 rules.
        """
        if l3_firewall_rules is not None:
            pulumi.set(__self__, "l3_firewall_rules", l3_firewall_rules)
        if l7_firewall_rules is not None:
            pulumi.set(__self__, "l7_firewall_rules", l7_firewall_rules)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if traffic_shaping_rules is not None:
            pulumi.set(__self__, "traffic_shaping_rules", traffic_shaping_rules)

    @_builtins.property
    @pulumi.getter(name="l3FirewallRules")
    def l3_firewall_rules(self) -> Optional[Sequence['outputs.GroupPoliciesFirewallAndTrafficShapingL3FirewallRule']]:
        """
        An ordered array of the L3 firewall rules
        """
        return pulumi.get(self, "l3_firewall_rules")

    @_builtins.property
    @pulumi.getter(name="l7FirewallRules")
    def l7_firewall_rules(self) -> Optional[Sequence['outputs.GroupPoliciesFirewallAndTrafficShapingL7FirewallRule']]:
        """
        An ordered array of L7 firewall rules
        """
        return pulumi.get(self, "l7_firewall_rules")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[_builtins.str]:
        """
        How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter(name="trafficShapingRules")
    def traffic_shaping_rules(self) -> Optional[Sequence['outputs.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRule']]:
        """
        An array of traffic shaping rules. Rules are applied in the order that
        they are specified in. An empty list (or null) means no rules. Note that
        you are allowed a maximum of 8 rules.
        """
        return pulumi.get(self, "traffic_shaping_rules")


@pulumi.output_type
class GroupPoliciesFirewallAndTrafficShapingL3FirewallRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destCidr":
            suggest = "dest_cidr"
        elif key == "destPort":
            suggest = "dest_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesFirewallAndTrafficShapingL3FirewallRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesFirewallAndTrafficShapingL3FirewallRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesFirewallAndTrafficShapingL3FirewallRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 dest_cidr: Optional[_builtins.str] = None,
                 dest_port: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dest_cidr: Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
        :param _builtins.str dest_port: Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[_builtins.str]:
        """
        Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
        """
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[_builtins.str]:
        """
        Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GroupPoliciesFirewallAndTrafficShapingL7FirewallRule(dict):
    def __init__(__self__, *,
                 policy: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str policy: The policy applied to matching traffic. Must be 'deny'.
        :param _builtins.str type: Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
        :param _builtins.str value: The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        The policy applied to matching traffic. Must be 'deny'.
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GroupPoliciesFirewallAndTrafficShapingTrafficShapingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dscpTagValue":
            suggest = "dscp_tag_value"
        elif key == "pcpTagValue":
            suggest = "pcp_tag_value"
        elif key == "perClientBandwidthLimits":
            suggest = "per_client_bandwidth_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesFirewallAndTrafficShapingTrafficShapingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesFirewallAndTrafficShapingTrafficShapingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesFirewallAndTrafficShapingTrafficShapingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definitions: Optional[Sequence['outputs.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinition']] = None,
                 dscp_tag_value: Optional[_builtins.int] = None,
                 pcp_tag_value: Optional[_builtins.int] = None,
                 per_client_bandwidth_limits: Optional['outputs.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits'] = None,
                 priority: Optional[_builtins.str] = None):
        """
        :param Sequence['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinitionArgs'] definitions: A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        :param _builtins.int dscp_tag_value: The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
               For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        :param _builtins.int pcp_tag_value: The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
               null means 'Do not set PCP tag'.
        :param 'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsArgs' per_client_bandwidth_limits: An object describing the bandwidth settings for your rule.
        :param _builtins.str priority: A string, indicating the priority level for packets bound to your rule.
               Can be 'low', 'normal' or 'high'.
        """
        if definitions is not None:
            pulumi.set(__self__, "definitions", definitions)
        if dscp_tag_value is not None:
            pulumi.set(__self__, "dscp_tag_value", dscp_tag_value)
        if pcp_tag_value is not None:
            pulumi.set(__self__, "pcp_tag_value", pcp_tag_value)
        if per_client_bandwidth_limits is not None:
            pulumi.set(__self__, "per_client_bandwidth_limits", per_client_bandwidth_limits)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> Optional[Sequence['outputs.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinition']]:
        """
        A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        """
        return pulumi.get(self, "definitions")

    @_builtins.property
    @pulumi.getter(name="dscpTagValue")
    def dscp_tag_value(self) -> Optional[_builtins.int]:
        """
        The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        """
        return pulumi.get(self, "dscp_tag_value")

    @_builtins.property
    @pulumi.getter(name="pcpTagValue")
    def pcp_tag_value(self) -> Optional[_builtins.int]:
        """
        The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
        null means 'Do not set PCP tag'.
        """
        return pulumi.get(self, "pcp_tag_value")

    @_builtins.property
    @pulumi.getter(name="perClientBandwidthLimits")
    def per_client_bandwidth_limits(self) -> Optional['outputs.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits']:
        """
        An object describing the bandwidth settings for your rule.
        """
        return pulumi.get(self, "per_client_bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.str]:
        """
        A string, indicating the priority level for packets bound to your rule.
        Can be 'low', 'normal' or 'high'.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinition(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        :param _builtins.str value: If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
               a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
               "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
               custom ports.
                If "type" is 'application' or 'applicationCategory', then "value" must be an object
               with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
               application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
               endpoint).
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
        a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
        "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
        custom ports.
         If "type" is 'application' or 'applicationCategory', then "value" must be an object
        with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
        application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
        endpoint).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthLimits":
            suggest = "bandwidth_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_limits: Optional['outputs.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits'] = None,
                 settings: Optional[_builtins.str] = None):
        """
        :param 'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsArgs' bandwidth_limits: The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        :param _builtins.str settings: How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        if bandwidth_limits is not None:
            pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> Optional['outputs.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits']:
        """
        The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[_builtins.str]:
        """
        How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitDown":
            suggest = "limit_down"
        elif key == "limitUp":
            suggest = "limit_up"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_down: Optional[_builtins.int] = None,
                 limit_up: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit_down: The maximum download limit (integer, in Kbps).
        :param _builtins.int limit_up: The maximum upload limit (integer, in Kbps).
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[_builtins.int]:
        """
        The maximum download limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[_builtins.int]:
        """
        The maximum upload limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class GroupPoliciesScheduling(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 friday: Optional['outputs.GroupPoliciesSchedulingFriday'] = None,
                 monday: Optional['outputs.GroupPoliciesSchedulingMonday'] = None,
                 saturday: Optional['outputs.GroupPoliciesSchedulingSaturday'] = None,
                 sunday: Optional['outputs.GroupPoliciesSchedulingSunday'] = None,
                 thursday: Optional['outputs.GroupPoliciesSchedulingThursday'] = None,
                 tuesday: Optional['outputs.GroupPoliciesSchedulingTuesday'] = None,
                 wednesday: Optional['outputs.GroupPoliciesSchedulingWednesday'] = None):
        """
        :param _builtins.bool enabled: Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
        :param 'GroupPoliciesSchedulingFridayArgs' friday: The schedule object for Friday.
        :param 'GroupPoliciesSchedulingMondayArgs' monday: The schedule object for Monday.
        :param 'GroupPoliciesSchedulingSaturdayArgs' saturday: The schedule object for Saturday.
        :param 'GroupPoliciesSchedulingSundayArgs' sunday: The schedule object for Sunday.
        :param 'GroupPoliciesSchedulingThursdayArgs' thursday: The schedule object for Thursday.
        :param 'GroupPoliciesSchedulingTuesdayArgs' tuesday: The schedule object for Tuesday.
        :param 'GroupPoliciesSchedulingWednesdayArgs' wednesday: The schedule object for Wednesday.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if friday is not None:
            pulumi.set(__self__, "friday", friday)
        if monday is not None:
            pulumi.set(__self__, "monday", monday)
        if saturday is not None:
            pulumi.set(__self__, "saturday", saturday)
        if sunday is not None:
            pulumi.set(__self__, "sunday", sunday)
        if thursday is not None:
            pulumi.set(__self__, "thursday", thursday)
        if tuesday is not None:
            pulumi.set(__self__, "tuesday", tuesday)
        if wednesday is not None:
            pulumi.set(__self__, "wednesday", wednesday)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def friday(self) -> Optional['outputs.GroupPoliciesSchedulingFriday']:
        """
        The schedule object for Friday.
        """
        return pulumi.get(self, "friday")

    @_builtins.property
    @pulumi.getter
    def monday(self) -> Optional['outputs.GroupPoliciesSchedulingMonday']:
        """
        The schedule object for Monday.
        """
        return pulumi.get(self, "monday")

    @_builtins.property
    @pulumi.getter
    def saturday(self) -> Optional['outputs.GroupPoliciesSchedulingSaturday']:
        """
        The schedule object for Saturday.
        """
        return pulumi.get(self, "saturday")

    @_builtins.property
    @pulumi.getter
    def sunday(self) -> Optional['outputs.GroupPoliciesSchedulingSunday']:
        """
        The schedule object for Sunday.
        """
        return pulumi.get(self, "sunday")

    @_builtins.property
    @pulumi.getter
    def thursday(self) -> Optional['outputs.GroupPoliciesSchedulingThursday']:
        """
        The schedule object for Thursday.
        """
        return pulumi.get(self, "thursday")

    @_builtins.property
    @pulumi.getter
    def tuesday(self) -> Optional['outputs.GroupPoliciesSchedulingTuesday']:
        """
        The schedule object for Tuesday.
        """
        return pulumi.get(self, "tuesday")

    @_builtins.property
    @pulumi.getter
    def wednesday(self) -> Optional['outputs.GroupPoliciesSchedulingWednesday']:
        """
        The schedule object for Wednesday.
        """
        return pulumi.get(self, "wednesday")


@pulumi.output_type
class GroupPoliciesSchedulingFriday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesSchedulingFriday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesSchedulingFriday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesSchedulingFriday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GroupPoliciesSchedulingMonday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesSchedulingMonday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesSchedulingMonday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesSchedulingMonday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GroupPoliciesSchedulingSaturday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesSchedulingSaturday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesSchedulingSaturday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesSchedulingSaturday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GroupPoliciesSchedulingSunday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesSchedulingSunday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesSchedulingSunday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesSchedulingSunday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GroupPoliciesSchedulingThursday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesSchedulingThursday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesSchedulingThursday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesSchedulingThursday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GroupPoliciesSchedulingTuesday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesSchedulingTuesday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesSchedulingTuesday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesSchedulingTuesday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GroupPoliciesSchedulingWednesday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesSchedulingWednesday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesSchedulingWednesday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesSchedulingWednesday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GroupPoliciesVlanTagging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPoliciesVlanTagging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPoliciesVlanTagging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPoliciesVlanTagging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 settings: Optional[_builtins.str] = None,
                 vlan_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str settings: How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
        :param _builtins.str vlan_id: The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
        """
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[_builtins.str]:
        """
        How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        """
        The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class MerakiAuthUsersAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizedByEmail":
            suggest = "authorized_by_email"
        elif key == "authorizedByName":
            suggest = "authorized_by_name"
        elif key == "authorizedZone":
            suggest = "authorized_zone"
        elif key == "expiresAt":
            suggest = "expires_at"
        elif key == "ssidNumber":
            suggest = "ssid_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MerakiAuthUsersAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MerakiAuthUsersAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MerakiAuthUsersAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorized_by_email: Optional[_builtins.str] = None,
                 authorized_by_name: Optional[_builtins.str] = None,
                 authorized_zone: Optional[_builtins.str] = None,
                 expires_at: Optional[_builtins.str] = None,
                 ssid_number: Optional[_builtins.int] = None):
        """
        :param _builtins.str authorized_by_email: User is authorized by the account email address
        :param _builtins.str authorized_by_name: User is authorized by the account name
        :param _builtins.str authorized_zone: Authorized zone of the user
        :param _builtins.str expires_at: Authorization expiration time
        :param _builtins.int ssid_number: SSID number
        """
        if authorized_by_email is not None:
            pulumi.set(__self__, "authorized_by_email", authorized_by_email)
        if authorized_by_name is not None:
            pulumi.set(__self__, "authorized_by_name", authorized_by_name)
        if authorized_zone is not None:
            pulumi.set(__self__, "authorized_zone", authorized_zone)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if ssid_number is not None:
            pulumi.set(__self__, "ssid_number", ssid_number)

    @_builtins.property
    @pulumi.getter(name="authorizedByEmail")
    def authorized_by_email(self) -> Optional[_builtins.str]:
        """
        User is authorized by the account email address
        """
        return pulumi.get(self, "authorized_by_email")

    @_builtins.property
    @pulumi.getter(name="authorizedByName")
    def authorized_by_name(self) -> Optional[_builtins.str]:
        """
        User is authorized by the account name
        """
        return pulumi.get(self, "authorized_by_name")

    @_builtins.property
    @pulumi.getter(name="authorizedZone")
    def authorized_zone(self) -> Optional[_builtins.str]:
        """
        Authorized zone of the user
        """
        return pulumi.get(self, "authorized_zone")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[_builtins.str]:
        """
        Authorization expiration time
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="ssidNumber")
    def ssid_number(self) -> Optional[_builtins.int]:
        """
        SSID number
        """
        return pulumi.get(self, "ssid_number")


@pulumi.output_type
class MqttBrokersItem(dict):
    def __init__(__self__, *,
                 authentication: Optional['outputs.MqttBrokersItemAuthentication'] = None,
                 host: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 security: Optional['outputs.MqttBrokersItemSecurity'] = None):
        """
        :param 'MqttBrokersItemAuthenticationArgs' authentication: Authentication settings of the MQTT broker
        :param _builtins.str host: Host name/IP address where the MQTT broker runs.
        :param _builtins.str id: ID of the MQTT Broker.
        :param _builtins.str name: Name of the MQTT Broker.
        :param _builtins.int port: Host port though which the MQTT broker can be reached.
        :param 'MqttBrokersItemSecurityArgs' security: Security settings of the MQTT broker.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if security is not None:
            pulumi.set(__self__, "security", security)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.MqttBrokersItemAuthentication']:
        """
        Authentication settings of the MQTT broker
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Host name/IP address where the MQTT broker runs.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the MQTT Broker.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the MQTT Broker.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Host port though which the MQTT broker can be reached.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def security(self) -> Optional['outputs.MqttBrokersItemSecurity']:
        """
        Security settings of the MQTT broker.
        """
        return pulumi.get(self, "security")


@pulumi.output_type
class MqttBrokersItemAuthentication(dict):
    def __init__(__self__, *,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str username: Username for the MQTT broker.
        """
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Username for the MQTT broker.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class MqttBrokersItemSecurity(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 tls: Optional['outputs.MqttBrokersItemSecurityTls'] = None):
        """
        :param _builtins.str mode: Security protocol of the MQTT broker.
        :param 'MqttBrokersItemSecurityTlsArgs' tls: TLS settings of the MQTT broker.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Security protocol of the MQTT broker.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional['outputs.MqttBrokersItemSecurityTls']:
        """
        TLS settings of the MQTT broker.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class MqttBrokersItemSecurityTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hasCaCertificate":
            suggest = "has_ca_certificate"
        elif key == "verifyHostnames":
            suggest = "verify_hostnames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MqttBrokersItemSecurityTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MqttBrokersItemSecurityTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MqttBrokersItemSecurityTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 has_ca_certificate: Optional[_builtins.bool] = None,
                 verify_hostnames: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool has_ca_certificate: Indicates whether the CA certificate is set
        :param _builtins.bool verify_hostnames: Whether the TLS hostname verification is enabled for the MQTT broker.
        """
        if has_ca_certificate is not None:
            pulumi.set(__self__, "has_ca_certificate", has_ca_certificate)
        if verify_hostnames is not None:
            pulumi.set(__self__, "verify_hostnames", verify_hostnames)

    @_builtins.property
    @pulumi.getter(name="hasCaCertificate")
    def has_ca_certificate(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the CA certificate is set
        """
        return pulumi.get(self, "has_ca_certificate")

    @_builtins.property
    @pulumi.getter(name="verifyHostnames")
    def verify_hostnames(self) -> Optional[_builtins.bool]:
        """
        Whether the TLS hostname verification is enabled for the MQTT broker.
        """
        return pulumi.get(self, "verify_hostnames")


@pulumi.output_type
class MqttBrokersParameters(dict):
    def __init__(__self__, *,
                 authentication: Optional['outputs.MqttBrokersParametersAuthentication'] = None,
                 host: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 security: Optional['outputs.MqttBrokersParametersSecurity'] = None):
        """
        :param 'MqttBrokersParametersAuthenticationArgs' authentication: Authentication settings of the MQTT broker
        :param _builtins.str host: Host name/IP address where the MQTT broker runs.
        :param _builtins.str name: Name of the MQTT broker.
        :param _builtins.int port: Host port though which the MQTT broker can be reached.
        :param 'MqttBrokersParametersSecurityArgs' security: Security settings of the MQTT broker.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if security is not None:
            pulumi.set(__self__, "security", security)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.MqttBrokersParametersAuthentication']:
        """
        Authentication settings of the MQTT broker
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Host name/IP address where the MQTT broker runs.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the MQTT broker.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Host port though which the MQTT broker can be reached.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def security(self) -> Optional['outputs.MqttBrokersParametersSecurity']:
        """
        Security settings of the MQTT broker.
        """
        return pulumi.get(self, "security")


@pulumi.output_type
class MqttBrokersParametersAuthentication(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password for the MQTT broker.
        :param _builtins.str username: Username for the MQTT broker.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for the MQTT broker.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Username for the MQTT broker.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class MqttBrokersParametersSecurity(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 tls: Optional['outputs.MqttBrokersParametersSecurityTls'] = None):
        """
        :param _builtins.str mode: Security protocol of the MQTT broker.
        :param 'MqttBrokersParametersSecurityTlsArgs' tls: TLS settings of the MQTT broker.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Security protocol of the MQTT broker.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional['outputs.MqttBrokersParametersSecurityTls']:
        """
        TLS settings of the MQTT broker.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class MqttBrokersParametersSecurityTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "verifyHostnames":
            suggest = "verify_hostnames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MqttBrokersParametersSecurityTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MqttBrokersParametersSecurityTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MqttBrokersParametersSecurityTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None,
                 verify_hostnames: Optional[_builtins.bool] = None):
        """
        :param _builtins.str ca_certificate: CA Certificate of the MQTT broker.
        :param _builtins.bool verify_hostnames: Whether the TLS hostname verification is enabled for the MQTT broker.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if verify_hostnames is not None:
            pulumi.set(__self__, "verify_hostnames", verify_hostnames)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        """
        CA Certificate of the MQTT broker.
        """
        return pulumi.get(self, "ca_certificate")

    @_builtins.property
    @pulumi.getter(name="verifyHostnames")
    def verify_hostnames(self) -> Optional[_builtins.bool]:
        """
        Whether the TLS hostname verification is enabled for the MQTT broker.
        """
        return pulumi.get(self, "verify_hostnames")


@pulumi.output_type
class SensorAlertsProfilesCondition(dict):
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 duration: Optional[_builtins.int] = None,
                 metric: Optional[_builtins.str] = None,
                 threshold: Optional['outputs.SensorAlertsProfilesConditionThreshold'] = None):
        """
        :param _builtins.str direction: If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
        :param _builtins.int duration: Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
        :param _builtins.str metric: The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
        :param 'SensorAlertsProfilesConditionThresholdArgs' threshold: Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.int]:
        """
        Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.str]:
        """
        The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.SensorAlertsProfilesConditionThreshold']:
        """
        Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class SensorAlertsProfilesConditionThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apparentPower":
            suggest = "apparent_power"
        elif key == "indoorAirQuality":
            suggest = "indoor_air_quality"
        elif key == "powerFactor":
            suggest = "power_factor"
        elif key == "realPower":
            suggest = "real_power"
        elif key == "upstreamPower":
            suggest = "upstream_power"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SensorAlertsProfilesConditionThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SensorAlertsProfilesConditionThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SensorAlertsProfilesConditionThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apparent_power: Optional['outputs.SensorAlertsProfilesConditionThresholdApparentPower'] = None,
                 current: Optional['outputs.SensorAlertsProfilesConditionThresholdCurrent'] = None,
                 door: Optional['outputs.SensorAlertsProfilesConditionThresholdDoor'] = None,
                 frequency: Optional['outputs.SensorAlertsProfilesConditionThresholdFrequency'] = None,
                 humidity: Optional['outputs.SensorAlertsProfilesConditionThresholdHumidity'] = None,
                 indoor_air_quality: Optional['outputs.SensorAlertsProfilesConditionThresholdIndoorAirQuality'] = None,
                 noise: Optional['outputs.SensorAlertsProfilesConditionThresholdNoise'] = None,
                 pm25: Optional['outputs.SensorAlertsProfilesConditionThresholdPm25'] = None,
                 power_factor: Optional['outputs.SensorAlertsProfilesConditionThresholdPowerFactor'] = None,
                 real_power: Optional['outputs.SensorAlertsProfilesConditionThresholdRealPower'] = None,
                 temperature: Optional['outputs.SensorAlertsProfilesConditionThresholdTemperature'] = None,
                 tvoc: Optional['outputs.SensorAlertsProfilesConditionThresholdTvoc'] = None,
                 upstream_power: Optional['outputs.SensorAlertsProfilesConditionThresholdUpstreamPower'] = None,
                 voltage: Optional['outputs.SensorAlertsProfilesConditionThresholdVoltage'] = None,
                 water: Optional['outputs.SensorAlertsProfilesConditionThresholdWater'] = None):
        """
        :param 'SensorAlertsProfilesConditionThresholdApparentPowerArgs' apparent_power: Apparent power threshold. 'draw' must be provided.
        :param 'SensorAlertsProfilesConditionThresholdCurrentArgs' current: Electrical current threshold. 'level' must be provided.
        :param 'SensorAlertsProfilesConditionThresholdDoorArgs' door: Door open threshold. 'open' must be provided and set to true.
        :param 'SensorAlertsProfilesConditionThresholdFrequencyArgs' frequency: Electrical frequency threshold. 'level' must be provided.
        :param 'SensorAlertsProfilesConditionThresholdHumidityArgs' humidity: Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
        :param 'SensorAlertsProfilesConditionThresholdIndoorAirQualityArgs' indoor_air_quality: Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
        :param 'SensorAlertsProfilesConditionThresholdNoiseArgs' noise: Noise threshold. 'ambient' must be provided.
        :param 'SensorAlertsProfilesConditionThresholdPm25Args' pm25: PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
        :param 'SensorAlertsProfilesConditionThresholdPowerFactorArgs' power_factor: Power factor threshold. 'percentage' must be provided.
        :param 'SensorAlertsProfilesConditionThresholdRealPowerArgs' real_power: Real power threshold. 'draw' must be provided.
        :param 'SensorAlertsProfilesConditionThresholdTemperatureArgs' temperature: Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
        :param 'SensorAlertsProfilesConditionThresholdTvocArgs' tvoc: TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
        :param 'SensorAlertsProfilesConditionThresholdUpstreamPowerArgs' upstream_power: Upstream power threshold. 'outageDetected' must be provided and set to true.
        :param 'SensorAlertsProfilesConditionThresholdVoltageArgs' voltage: Voltage threshold. 'level' must be provided.
        :param 'SensorAlertsProfilesConditionThresholdWaterArgs' water: Water detection threshold. 'present' must be provided and set to true.
        """
        if apparent_power is not None:
            pulumi.set(__self__, "apparent_power", apparent_power)
        if current is not None:
            pulumi.set(__self__, "current", current)
        if door is not None:
            pulumi.set(__self__, "door", door)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if humidity is not None:
            pulumi.set(__self__, "humidity", humidity)
        if indoor_air_quality is not None:
            pulumi.set(__self__, "indoor_air_quality", indoor_air_quality)
        if noise is not None:
            pulumi.set(__self__, "noise", noise)
        if pm25 is not None:
            pulumi.set(__self__, "pm25", pm25)
        if power_factor is not None:
            pulumi.set(__self__, "power_factor", power_factor)
        if real_power is not None:
            pulumi.set(__self__, "real_power", real_power)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if tvoc is not None:
            pulumi.set(__self__, "tvoc", tvoc)
        if upstream_power is not None:
            pulumi.set(__self__, "upstream_power", upstream_power)
        if voltage is not None:
            pulumi.set(__self__, "voltage", voltage)
        if water is not None:
            pulumi.set(__self__, "water", water)

    @_builtins.property
    @pulumi.getter(name="apparentPower")
    def apparent_power(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdApparentPower']:
        """
        Apparent power threshold. 'draw' must be provided.
        """
        return pulumi.get(self, "apparent_power")

    @_builtins.property
    @pulumi.getter
    def current(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdCurrent']:
        """
        Electrical current threshold. 'level' must be provided.
        """
        return pulumi.get(self, "current")

    @_builtins.property
    @pulumi.getter
    def door(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdDoor']:
        """
        Door open threshold. 'open' must be provided and set to true.
        """
        return pulumi.get(self, "door")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdFrequency']:
        """
        Electrical frequency threshold. 'level' must be provided.
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter
    def humidity(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdHumidity']:
        """
        Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
        """
        return pulumi.get(self, "humidity")

    @_builtins.property
    @pulumi.getter(name="indoorAirQuality")
    def indoor_air_quality(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdIndoorAirQuality']:
        """
        Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
        """
        return pulumi.get(self, "indoor_air_quality")

    @_builtins.property
    @pulumi.getter
    def noise(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdNoise']:
        """
        Noise threshold. 'ambient' must be provided.
        """
        return pulumi.get(self, "noise")

    @_builtins.property
    @pulumi.getter
    def pm25(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdPm25']:
        """
        PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        return pulumi.get(self, "pm25")

    @_builtins.property
    @pulumi.getter(name="powerFactor")
    def power_factor(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdPowerFactor']:
        """
        Power factor threshold. 'percentage' must be provided.
        """
        return pulumi.get(self, "power_factor")

    @_builtins.property
    @pulumi.getter(name="realPower")
    def real_power(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdRealPower']:
        """
        Real power threshold. 'draw' must be provided.
        """
        return pulumi.get(self, "real_power")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdTemperature']:
        """
        Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter
    def tvoc(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdTvoc']:
        """
        TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        return pulumi.get(self, "tvoc")

    @_builtins.property
    @pulumi.getter(name="upstreamPower")
    def upstream_power(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdUpstreamPower']:
        """
        Upstream power threshold. 'outageDetected' must be provided and set to true.
        """
        return pulumi.get(self, "upstream_power")

    @_builtins.property
    @pulumi.getter
    def voltage(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdVoltage']:
        """
        Voltage threshold. 'level' must be provided.
        """
        return pulumi.get(self, "voltage")

    @_builtins.property
    @pulumi.getter
    def water(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdWater']:
        """
        Water detection threshold. 'present' must be provided and set to true.
        """
        return pulumi.get(self, "water")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdApparentPower(dict):
    def __init__(__self__, *,
                 draw: Optional[_builtins.float] = None):
        """
        :param _builtins.float draw: Alerting threshold in volt-amps. Must be between 0 and 3750.
        """
        if draw is not None:
            pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in volt-amps. Must be between 0 and 3750.
        """
        return pulumi.get(self, "draw")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdCurrent(dict):
    def __init__(__self__, *,
                 draw: Optional[_builtins.float] = None):
        """
        :param _builtins.float draw: Alerting threshold in amps. Must be between 0 and 15.
        """
        if draw is not None:
            pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in amps. Must be between 0 and 15.
        """
        return pulumi.get(self, "draw")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdDoor(dict):
    def __init__(__self__, *,
                 open: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool open: Alerting threshold for a door open event. Must be set to true.
        """
        if open is not None:
            pulumi.set(__self__, "open", open)

    @_builtins.property
    @pulumi.getter
    def open(self) -> Optional[_builtins.bool]:
        """
        Alerting threshold for a door open event. Must be set to true.
        """
        return pulumi.get(self, "open")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdFrequency(dict):
    def __init__(__self__, *,
                 level: Optional[_builtins.float] = None):
        """
        :param _builtins.float level: Alerting threshold in hertz. Must be between 0 and 60.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in hertz. Must be between 0 and 60.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdHumidity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativePercentage":
            suggest = "relative_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SensorAlertsProfilesConditionThresholdHumidity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SensorAlertsProfilesConditionThresholdHumidity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SensorAlertsProfilesConditionThresholdHumidity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 relative_percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.str quality: Alerting threshold as a qualitative humidity level.
        :param _builtins.int relative_percentage: Alerting threshold in %RH.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if relative_percentage is not None:
            pulumi.set(__self__, "relative_percentage", relative_percentage)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Alerting threshold as a qualitative humidity level.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter(name="relativePercentage")
    def relative_percentage(self) -> Optional[_builtins.int]:
        """
        Alerting threshold in %RH.
        """
        return pulumi.get(self, "relative_percentage")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdIndoorAirQuality(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 score: Optional[_builtins.int] = None):
        """
        :param _builtins.str quality: Alerting threshold as a qualitative indoor air quality level.
        :param _builtins.int score: Alerting threshold as indoor air quality score.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if score is not None:
            pulumi.set(__self__, "score", score)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Alerting threshold as a qualitative indoor air quality level.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def score(self) -> Optional[_builtins.int]:
        """
        Alerting threshold as indoor air quality score.
        """
        return pulumi.get(self, "score")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdNoise(dict):
    def __init__(__self__, *,
                 ambient: Optional['outputs.SensorAlertsProfilesConditionThresholdNoiseAmbient'] = None):
        """
        :param 'SensorAlertsProfilesConditionThresholdNoiseAmbientArgs' ambient: Ambient noise threshold. One of 'level' or 'quality' must be provided.
        """
        if ambient is not None:
            pulumi.set(__self__, "ambient", ambient)

    @_builtins.property
    @pulumi.getter
    def ambient(self) -> Optional['outputs.SensorAlertsProfilesConditionThresholdNoiseAmbient']:
        """
        Ambient noise threshold. One of 'level' or 'quality' must be provided.
        """
        return pulumi.get(self, "ambient")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdNoiseAmbient(dict):
    def __init__(__self__, *,
                 level: Optional[_builtins.int] = None,
                 quality: Optional[_builtins.str] = None):
        """
        :param _builtins.int level: Alerting threshold as adjusted decibels.
        :param _builtins.str quality: Alerting threshold as a qualitative ambient noise level.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.int]:
        """
        Alerting threshold as adjusted decibels.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Alerting threshold as a qualitative ambient noise level.
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdPm25(dict):
    def __init__(__self__, *,
                 concentration: Optional[_builtins.int] = None,
                 quality: Optional[_builtins.str] = None):
        """
        :param _builtins.int concentration: Alerting threshold as PM2.5 parts per million.
        :param _builtins.str quality: Alerting threshold as a qualitative PM2.5 level.
        """
        if concentration is not None:
            pulumi.set(__self__, "concentration", concentration)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def concentration(self) -> Optional[_builtins.int]:
        """
        Alerting threshold as PM2.5 parts per million.
        """
        return pulumi.get(self, "concentration")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Alerting threshold as a qualitative PM2.5 level.
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdPowerFactor(dict):
    def __init__(__self__, *,
                 percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.int percentage: Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
        """
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdRealPower(dict):
    def __init__(__self__, *,
                 draw: Optional[_builtins.float] = None):
        """
        :param _builtins.float draw: Alerting threshold in watts. Must be between 0 and 3750.
        """
        if draw is not None:
            pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in watts. Must be between 0 and 3750.
        """
        return pulumi.get(self, "draw")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdTemperature(dict):
    def __init__(__self__, *,
                 celsius: Optional[_builtins.float] = None,
                 fahrenheit: Optional[_builtins.float] = None,
                 quality: Optional[_builtins.str] = None):
        """
        :param _builtins.float celsius: Alerting threshold in degrees Celsius.
        :param _builtins.float fahrenheit: Alerting threshold in degrees Fahrenheit.
        :param _builtins.str quality: Alerting threshold as a qualitative temperature level.
        """
        if celsius is not None:
            pulumi.set(__self__, "celsius", celsius)
        if fahrenheit is not None:
            pulumi.set(__self__, "fahrenheit", fahrenheit)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def celsius(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in degrees Celsius.
        """
        return pulumi.get(self, "celsius")

    @_builtins.property
    @pulumi.getter
    def fahrenheit(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in degrees Fahrenheit.
        """
        return pulumi.get(self, "fahrenheit")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Alerting threshold as a qualitative temperature level.
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdTvoc(dict):
    def __init__(__self__, *,
                 concentration: Optional[_builtins.int] = None,
                 quality: Optional[_builtins.str] = None):
        """
        :param _builtins.int concentration: Alerting threshold as TVOC micrograms per cubic meter.
        :param _builtins.str quality: Alerting threshold as a qualitative TVOC level.
        """
        if concentration is not None:
            pulumi.set(__self__, "concentration", concentration)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def concentration(self) -> Optional[_builtins.int]:
        """
        Alerting threshold as TVOC micrograms per cubic meter.
        """
        return pulumi.get(self, "concentration")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Alerting threshold as a qualitative TVOC level.
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdUpstreamPower(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outageDetected":
            suggest = "outage_detected"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SensorAlertsProfilesConditionThresholdUpstreamPower. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SensorAlertsProfilesConditionThresholdUpstreamPower.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SensorAlertsProfilesConditionThresholdUpstreamPower.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 outage_detected: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool outage_detected: Alerting threshold for an upstream power event. Must be set to true.
        """
        if outage_detected is not None:
            pulumi.set(__self__, "outage_detected", outage_detected)

    @_builtins.property
    @pulumi.getter(name="outageDetected")
    def outage_detected(self) -> Optional[_builtins.bool]:
        """
        Alerting threshold for an upstream power event. Must be set to true.
        """
        return pulumi.get(self, "outage_detected")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdVoltage(dict):
    def __init__(__self__, *,
                 level: Optional[_builtins.float] = None):
        """
        :param _builtins.float level: Alerting threshold in volts. Must be between 0 and 250.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in volts. Must be between 0 and 250.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class SensorAlertsProfilesConditionThresholdWater(dict):
    def __init__(__self__, *,
                 present: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool present: Alerting threshold for a water detection event. Must be set to true.
        """
        if present is not None:
            pulumi.set(__self__, "present", present)

    @_builtins.property
    @pulumi.getter
    def present(self) -> Optional[_builtins.bool]:
        """
        Alerting threshold for a water detection event. Must be set to true.
        """
        return pulumi.get(self, "present")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponse(dict):
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 duration: Optional[_builtins.int] = None,
                 metric: Optional[_builtins.str] = None,
                 threshold: Optional['outputs.SensorAlertsProfilesConditionsResponseThreshold'] = None):
        """
        :param _builtins.str direction: If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
        :param _builtins.int duration: Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
        :param _builtins.str metric: The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
        :param 'SensorAlertsProfilesConditionsResponseThresholdArgs' threshold: Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.int]:
        """
        Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.str]:
        """
        The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThreshold']:
        """
        Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apparentPower":
            suggest = "apparent_power"
        elif key == "indoorAirQuality":
            suggest = "indoor_air_quality"
        elif key == "powerFactor":
            suggest = "power_factor"
        elif key == "realPower":
            suggest = "real_power"
        elif key == "upstreamPower":
            suggest = "upstream_power"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SensorAlertsProfilesConditionsResponseThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SensorAlertsProfilesConditionsResponseThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SensorAlertsProfilesConditionsResponseThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apparent_power: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdApparentPower'] = None,
                 current: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdCurrent'] = None,
                 door: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdDoor'] = None,
                 frequency: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdFrequency'] = None,
                 humidity: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdHumidity'] = None,
                 indoor_air_quality: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdIndoorAirQuality'] = None,
                 noise: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdNoise'] = None,
                 pm25: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdPm25'] = None,
                 power_factor: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdPowerFactor'] = None,
                 real_power: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdRealPower'] = None,
                 temperature: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdTemperature'] = None,
                 tvoc: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdTvoc'] = None,
                 upstream_power: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdUpstreamPower'] = None,
                 voltage: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdVoltage'] = None,
                 water: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdWater'] = None):
        """
        :param 'SensorAlertsProfilesConditionsResponseThresholdApparentPowerArgs' apparent_power: Apparent power threshold. 'draw' must be provided.
        :param 'SensorAlertsProfilesConditionsResponseThresholdCurrentArgs' current: Electrical current threshold. 'level' must be provided.
        :param 'SensorAlertsProfilesConditionsResponseThresholdDoorArgs' door: Door open threshold. 'open' must be provided and set to true.
        :param 'SensorAlertsProfilesConditionsResponseThresholdFrequencyArgs' frequency: Electrical frequency threshold. 'level' must be provided.
        :param 'SensorAlertsProfilesConditionsResponseThresholdHumidityArgs' humidity: Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
        :param 'SensorAlertsProfilesConditionsResponseThresholdIndoorAirQualityArgs' indoor_air_quality: Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
        :param 'SensorAlertsProfilesConditionsResponseThresholdNoiseArgs' noise: Noise threshold. 'ambient' must be provided.
        :param 'SensorAlertsProfilesConditionsResponseThresholdPm25Args' pm25: PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
        :param 'SensorAlertsProfilesConditionsResponseThresholdPowerFactorArgs' power_factor: Power factor threshold. 'percentage' must be provided.
        :param 'SensorAlertsProfilesConditionsResponseThresholdRealPowerArgs' real_power: Real power threshold. 'draw' must be provided.
        :param 'SensorAlertsProfilesConditionsResponseThresholdTemperatureArgs' temperature: Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
        :param 'SensorAlertsProfilesConditionsResponseThresholdTvocArgs' tvoc: TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
        :param 'SensorAlertsProfilesConditionsResponseThresholdUpstreamPowerArgs' upstream_power: Upstream power threshold. 'outageDetected' must be provided and set to true.
        :param 'SensorAlertsProfilesConditionsResponseThresholdVoltageArgs' voltage: Voltage threshold. 'level' must be provided.
        :param 'SensorAlertsProfilesConditionsResponseThresholdWaterArgs' water: Water detection threshold. 'present' must be provided and set to true.
        """
        if apparent_power is not None:
            pulumi.set(__self__, "apparent_power", apparent_power)
        if current is not None:
            pulumi.set(__self__, "current", current)
        if door is not None:
            pulumi.set(__self__, "door", door)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if humidity is not None:
            pulumi.set(__self__, "humidity", humidity)
        if indoor_air_quality is not None:
            pulumi.set(__self__, "indoor_air_quality", indoor_air_quality)
        if noise is not None:
            pulumi.set(__self__, "noise", noise)
        if pm25 is not None:
            pulumi.set(__self__, "pm25", pm25)
        if power_factor is not None:
            pulumi.set(__self__, "power_factor", power_factor)
        if real_power is not None:
            pulumi.set(__self__, "real_power", real_power)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if tvoc is not None:
            pulumi.set(__self__, "tvoc", tvoc)
        if upstream_power is not None:
            pulumi.set(__self__, "upstream_power", upstream_power)
        if voltage is not None:
            pulumi.set(__self__, "voltage", voltage)
        if water is not None:
            pulumi.set(__self__, "water", water)

    @_builtins.property
    @pulumi.getter(name="apparentPower")
    def apparent_power(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdApparentPower']:
        """
        Apparent power threshold. 'draw' must be provided.
        """
        return pulumi.get(self, "apparent_power")

    @_builtins.property
    @pulumi.getter
    def current(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdCurrent']:
        """
        Electrical current threshold. 'level' must be provided.
        """
        return pulumi.get(self, "current")

    @_builtins.property
    @pulumi.getter
    def door(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdDoor']:
        """
        Door open threshold. 'open' must be provided and set to true.
        """
        return pulumi.get(self, "door")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdFrequency']:
        """
        Electrical frequency threshold. 'level' must be provided.
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter
    def humidity(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdHumidity']:
        """
        Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
        """
        return pulumi.get(self, "humidity")

    @_builtins.property
    @pulumi.getter(name="indoorAirQuality")
    def indoor_air_quality(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdIndoorAirQuality']:
        """
        Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
        """
        return pulumi.get(self, "indoor_air_quality")

    @_builtins.property
    @pulumi.getter
    def noise(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdNoise']:
        """
        Noise threshold. 'ambient' must be provided.
        """
        return pulumi.get(self, "noise")

    @_builtins.property
    @pulumi.getter
    def pm25(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdPm25']:
        """
        PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        return pulumi.get(self, "pm25")

    @_builtins.property
    @pulumi.getter(name="powerFactor")
    def power_factor(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdPowerFactor']:
        """
        Power factor threshold. 'percentage' must be provided.
        """
        return pulumi.get(self, "power_factor")

    @_builtins.property
    @pulumi.getter(name="realPower")
    def real_power(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdRealPower']:
        """
        Real power threshold. 'draw' must be provided.
        """
        return pulumi.get(self, "real_power")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdTemperature']:
        """
        Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter
    def tvoc(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdTvoc']:
        """
        TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        return pulumi.get(self, "tvoc")

    @_builtins.property
    @pulumi.getter(name="upstreamPower")
    def upstream_power(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdUpstreamPower']:
        """
        Upstream power threshold. 'outageDetected' must be provided and set to true.
        """
        return pulumi.get(self, "upstream_power")

    @_builtins.property
    @pulumi.getter
    def voltage(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdVoltage']:
        """
        Voltage threshold. 'level' must be provided.
        """
        return pulumi.get(self, "voltage")

    @_builtins.property
    @pulumi.getter
    def water(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdWater']:
        """
        Water detection threshold. 'present' must be provided and set to true.
        """
        return pulumi.get(self, "water")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdApparentPower(dict):
    def __init__(__self__, *,
                 draw: Optional[_builtins.float] = None):
        """
        :param _builtins.float draw: Alerting threshold in volt-amps. Must be between 0 and 3750.
        """
        if draw is not None:
            pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in volt-amps. Must be between 0 and 3750.
        """
        return pulumi.get(self, "draw")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdCurrent(dict):
    def __init__(__self__, *,
                 draw: Optional[_builtins.float] = None):
        """
        :param _builtins.float draw: Alerting threshold in amps. Must be between 0 and 15.
        """
        if draw is not None:
            pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in amps. Must be between 0 and 15.
        """
        return pulumi.get(self, "draw")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdDoor(dict):
    def __init__(__self__, *,
                 open: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool open: Alerting threshold for a door open event. Must be set to true.
        """
        if open is not None:
            pulumi.set(__self__, "open", open)

    @_builtins.property
    @pulumi.getter
    def open(self) -> Optional[_builtins.bool]:
        """
        Alerting threshold for a door open event. Must be set to true.
        """
        return pulumi.get(self, "open")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdFrequency(dict):
    def __init__(__self__, *,
                 level: Optional[_builtins.float] = None):
        """
        :param _builtins.float level: Alerting threshold in hertz. Must be between 0 and 60.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in hertz. Must be between 0 and 60.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdHumidity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativePercentage":
            suggest = "relative_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SensorAlertsProfilesConditionsResponseThresholdHumidity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SensorAlertsProfilesConditionsResponseThresholdHumidity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SensorAlertsProfilesConditionsResponseThresholdHumidity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 relative_percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.str quality: Alerting threshold as a qualitative humidity level.
        :param _builtins.int relative_percentage: Alerting threshold in %RH.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if relative_percentage is not None:
            pulumi.set(__self__, "relative_percentage", relative_percentage)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Alerting threshold as a qualitative humidity level.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter(name="relativePercentage")
    def relative_percentage(self) -> Optional[_builtins.int]:
        """
        Alerting threshold in %RH.
        """
        return pulumi.get(self, "relative_percentage")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdIndoorAirQuality(dict):
    def __init__(__self__, *,
                 quality: Optional[_builtins.str] = None,
                 score: Optional[_builtins.int] = None):
        """
        :param _builtins.str quality: Alerting threshold as a qualitative indoor air quality level.
        :param _builtins.int score: Alerting threshold as indoor air quality score.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if score is not None:
            pulumi.set(__self__, "score", score)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Alerting threshold as a qualitative indoor air quality level.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def score(self) -> Optional[_builtins.int]:
        """
        Alerting threshold as indoor air quality score.
        """
        return pulumi.get(self, "score")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdNoise(dict):
    def __init__(__self__, *,
                 ambient: Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdNoiseAmbient'] = None):
        """
        :param 'SensorAlertsProfilesConditionsResponseThresholdNoiseAmbientArgs' ambient: Ambient noise threshold. One of 'level' or 'quality' must be provided.
        """
        if ambient is not None:
            pulumi.set(__self__, "ambient", ambient)

    @_builtins.property
    @pulumi.getter
    def ambient(self) -> Optional['outputs.SensorAlertsProfilesConditionsResponseThresholdNoiseAmbient']:
        """
        Ambient noise threshold. One of 'level' or 'quality' must be provided.
        """
        return pulumi.get(self, "ambient")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdNoiseAmbient(dict):
    def __init__(__self__, *,
                 level: Optional[_builtins.int] = None,
                 quality: Optional[_builtins.str] = None):
        """
        :param _builtins.int level: Alerting threshold as adjusted decibels.
        :param _builtins.str quality: Alerting threshold as a qualitative ambient noise level.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.int]:
        """
        Alerting threshold as adjusted decibels.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Alerting threshold as a qualitative ambient noise level.
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdPm25(dict):
    def __init__(__self__, *,
                 concentration: Optional[_builtins.int] = None,
                 quality: Optional[_builtins.str] = None):
        """
        :param _builtins.int concentration: Alerting threshold as PM2.5 parts per million.
        :param _builtins.str quality: Alerting threshold as a qualitative PM2.5 level.
        """
        if concentration is not None:
            pulumi.set(__self__, "concentration", concentration)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def concentration(self) -> Optional[_builtins.int]:
        """
        Alerting threshold as PM2.5 parts per million.
        """
        return pulumi.get(self, "concentration")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Alerting threshold as a qualitative PM2.5 level.
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdPowerFactor(dict):
    def __init__(__self__, *,
                 percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.int percentage: Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
        """
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdRealPower(dict):
    def __init__(__self__, *,
                 draw: Optional[_builtins.float] = None):
        """
        :param _builtins.float draw: Alerting threshold in watts. Must be between 0 and 3750.
        """
        if draw is not None:
            pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in watts. Must be between 0 and 3750.
        """
        return pulumi.get(self, "draw")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdTemperature(dict):
    def __init__(__self__, *,
                 celsius: Optional[_builtins.float] = None,
                 fahrenheit: Optional[_builtins.float] = None,
                 quality: Optional[_builtins.str] = None):
        """
        :param _builtins.float celsius: Alerting threshold in degrees Celsius.
        :param _builtins.float fahrenheit: Alerting threshold in degrees Fahrenheit.
        :param _builtins.str quality: Alerting threshold as a qualitative temperature level.
        """
        if celsius is not None:
            pulumi.set(__self__, "celsius", celsius)
        if fahrenheit is not None:
            pulumi.set(__self__, "fahrenheit", fahrenheit)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def celsius(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in degrees Celsius.
        """
        return pulumi.get(self, "celsius")

    @_builtins.property
    @pulumi.getter
    def fahrenheit(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in degrees Fahrenheit.
        """
        return pulumi.get(self, "fahrenheit")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Alerting threshold as a qualitative temperature level.
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdTvoc(dict):
    def __init__(__self__, *,
                 concentration: Optional[_builtins.int] = None,
                 quality: Optional[_builtins.str] = None):
        """
        :param _builtins.int concentration: Alerting threshold as TVOC micrograms per cubic meter.
        :param _builtins.str quality: Alerting threshold as a qualitative TVOC level.
        """
        if concentration is not None:
            pulumi.set(__self__, "concentration", concentration)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def concentration(self) -> Optional[_builtins.int]:
        """
        Alerting threshold as TVOC micrograms per cubic meter.
        """
        return pulumi.get(self, "concentration")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Alerting threshold as a qualitative TVOC level.
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdUpstreamPower(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outageDetected":
            suggest = "outage_detected"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SensorAlertsProfilesConditionsResponseThresholdUpstreamPower. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SensorAlertsProfilesConditionsResponseThresholdUpstreamPower.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SensorAlertsProfilesConditionsResponseThresholdUpstreamPower.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 outage_detected: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool outage_detected: Alerting threshold for an upstream power event. Must be set to true.
        """
        if outage_detected is not None:
            pulumi.set(__self__, "outage_detected", outage_detected)

    @_builtins.property
    @pulumi.getter(name="outageDetected")
    def outage_detected(self) -> Optional[_builtins.bool]:
        """
        Alerting threshold for an upstream power event. Must be set to true.
        """
        return pulumi.get(self, "outage_detected")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdVoltage(dict):
    def __init__(__self__, *,
                 level: Optional[_builtins.float] = None):
        """
        :param _builtins.float level: Alerting threshold in volts. Must be between 0 and 250.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.float]:
        """
        Alerting threshold in volts. Must be between 0 and 250.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class SensorAlertsProfilesConditionsResponseThresholdWater(dict):
    def __init__(__self__, *,
                 present: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool present: Alerting threshold for a water detection event. Must be set to true.
        """
        if present is not None:
            pulumi.set(__self__, "present", present)

    @_builtins.property
    @pulumi.getter
    def present(self) -> Optional[_builtins.bool]:
        """
        Alerting threshold for a water detection event. Must be set to true.
        """
        return pulumi.get(self, "present")


@pulumi.output_type
class SensorAlertsProfilesRecipients(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpServerIds":
            suggest = "http_server_ids"
        elif key == "smsNumbers":
            suggest = "sms_numbers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SensorAlertsProfilesRecipients. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SensorAlertsProfilesRecipients.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SensorAlertsProfilesRecipients.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 http_server_ids: Optional[Sequence[_builtins.str]] = None,
                 sms_numbers: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] emails: A list of emails that will receive information about the alert.
        :param Sequence[_builtins.str] http_server_ids: A list of webhook endpoint IDs that will receive information about the alert.
        :param Sequence[_builtins.str] sms_numbers: A list of SMS numbers that will receive information about the alert.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_server_ids is not None:
            pulumi.set(__self__, "http_server_ids", http_server_ids)
        if sms_numbers is not None:
            pulumi.set(__self__, "sms_numbers", sms_numbers)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of emails that will receive information about the alert.
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="httpServerIds")
    def http_server_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of webhook endpoint IDs that will receive information about the alert.
        """
        return pulumi.get(self, "http_server_ids")

    @_builtins.property
    @pulumi.getter(name="smsNumbers")
    def sms_numbers(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of SMS numbers that will receive information about the alert.
        """
        return pulumi.get(self, "sms_numbers")


@pulumi.output_type
class SensorAlertsProfilesSchedule(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
        :param _builtins.str name: Name of the sensor schedule to use with the alert profile.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the sensor schedule to use with the alert profile.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SettingsFips(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables / disables FIPS on the network.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables / disables FIPS on the network.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SettingsLocalStatusPage(dict):
    def __init__(__self__, *,
                 authentication: Optional['outputs.SettingsLocalStatusPageAuthentication'] = None):
        """
        :param 'SettingsLocalStatusPageAuthenticationArgs' authentication: A hash of Local Status page(s)' authentication options applied to the Network.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.SettingsLocalStatusPageAuthentication']:
        """
        A hash of Local Status page(s)' authentication options applied to the Network.
        """
        return pulumi.get(self, "authentication")


@pulumi.output_type
class SettingsLocalStatusPageAuthentication(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Enables / disables the authentication on Local Status page(s).
        :param _builtins.str password: The password used for Local Status Page(s). Set this to null to clear the password.
        :param _builtins.str username: The username used for Local Status Page(s).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables / disables the authentication on Local Status page(s).
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password used for Local Status Page(s). Set this to null to clear the password.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username used for Local Status Page(s).
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SettingsNamedVlans(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables / disables Named VLANs on the Network.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables / disables Named VLANs on the Network.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SettingsSecurePort(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables / disables SecureConnect on the network. Optional.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables / disables SecureConnect on the network. Optional.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SmBypassActivationLockAttemptsData(dict):
    def __init__(__self__, *,
                 status2090938209: Optional['outputs.SmBypassActivationLockAttemptsDataStatus2090938209'] = None,
                 status38290139892: Optional['outputs.SmBypassActivationLockAttemptsDataStatus38290139892'] = None):
        if status2090938209 is not None:
            pulumi.set(__self__, "status2090938209", status2090938209)
        if status38290139892 is not None:
            pulumi.set(__self__, "status38290139892", status38290139892)

    @_builtins.property
    @pulumi.getter
    def status2090938209(self) -> Optional['outputs.SmBypassActivationLockAttemptsDataStatus2090938209']:
        return pulumi.get(self, "status2090938209")

    @_builtins.property
    @pulumi.getter
    def status38290139892(self) -> Optional['outputs.SmBypassActivationLockAttemptsDataStatus38290139892']:
        return pulumi.get(self, "status38290139892")


@pulumi.output_type
class SmBypassActivationLockAttemptsDataStatus2090938209(dict):
    def __init__(__self__, *,
                 errors: Optional[Sequence[_builtins.str]] = None,
                 success: Optional[_builtins.bool] = None):
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if success is not None:
            pulumi.set(__self__, "success", success)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "errors")

    @_builtins.property
    @pulumi.getter
    def success(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "success")


@pulumi.output_type
class SmBypassActivationLockAttemptsDataStatus38290139892(dict):
    def __init__(__self__, *,
                 success: Optional[_builtins.bool] = None):
        if success is not None:
            pulumi.set(__self__, "success", success)

    @_builtins.property
    @pulumi.getter
    def success(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "success")


@pulumi.output_type
class SmDevicesCheckinItem(dict):
    def __init__(__self__, *,
                 ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ids: The Meraki Ids of the set of devices.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The Meraki Ids of the set of devices.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class SmDevicesCheckinParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wifiMacs":
            suggest = "wifi_macs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesCheckinParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesCheckinParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesCheckinParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ids: Optional[Sequence[_builtins.str]] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 serials: Optional[Sequence[_builtins.str]] = None,
                 wifi_macs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ids: The ids of the devices to be checked-in.
        :param Sequence[_builtins.str] scopes: The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.
        :param Sequence[_builtins.str] serials: The serials of the devices to be checked-in.
        :param Sequence[_builtins.str] wifi_macs: The wifiMacs of the devices to be checked-in.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if wifi_macs is not None:
            pulumi.set(__self__, "wifi_macs", wifi_macs)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The ids of the devices to be checked-in.
        """
        return pulumi.get(self, "ids")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        The serials of the devices to be checked-in.
        """
        return pulumi.get(self, "serials")

    @_builtins.property
    @pulumi.getter(name="wifiMacs")
    def wifi_macs(self) -> Optional[Sequence[_builtins.str]]:
        """
        The wifiMacs of the devices to be checked-in.
        """
        return pulumi.get(self, "wifi_macs")


@pulumi.output_type
class SmDevicesFieldsItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wifiMac":
            suggest = "wifi_mac"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesFieldsItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesFieldsItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesFieldsItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 notes: Optional[_builtins.str] = None,
                 serial: Optional[_builtins.str] = None,
                 wifi_mac: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The Meraki Id of the device record.
        :param _builtins.str name: The name of the device.
        :param _builtins.str notes: Notes associated with the device.
        :param _builtins.str serial: The device serial.
        :param _builtins.str wifi_mac: The MAC of the device.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if wifi_mac is not None:
            pulumi.set(__self__, "wifi_mac", wifi_mac)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The Meraki Id of the device record.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the device.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[_builtins.str]:
        """
        Notes associated with the device.
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        The device serial.
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="wifiMac")
    def wifi_mac(self) -> Optional[_builtins.str]:
        """
        The MAC of the device.
        """
        return pulumi.get(self, "wifi_mac")


@pulumi.output_type
class SmDevicesFieldsParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceFields":
            suggest = "device_fields"
        elif key == "wifiMac":
            suggest = "wifi_mac"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesFieldsParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesFieldsParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesFieldsParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_fields: Optional['outputs.SmDevicesFieldsParametersDeviceFields'] = None,
                 id: Optional[_builtins.str] = None,
                 serial: Optional[_builtins.str] = None,
                 wifi_mac: Optional[_builtins.str] = None):
        """
        :param 'SmDevicesFieldsParametersDeviceFieldsArgs' device_fields: The new fields of the device. Each field of this object is optional.
        :param _builtins.str id: The id of the device to be modified.
        :param _builtins.str serial: The serial of the device to be modified.
        :param _builtins.str wifi_mac: The wifiMac of the device to be modified.
        """
        if device_fields is not None:
            pulumi.set(__self__, "device_fields", device_fields)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if wifi_mac is not None:
            pulumi.set(__self__, "wifi_mac", wifi_mac)

    @_builtins.property
    @pulumi.getter(name="deviceFields")
    def device_fields(self) -> Optional['outputs.SmDevicesFieldsParametersDeviceFields']:
        """
        The new fields of the device. Each field of this object is optional.
        """
        return pulumi.get(self, "device_fields")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The id of the device to be modified.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        The serial of the device to be modified.
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="wifiMac")
    def wifi_mac(self) -> Optional[_builtins.str]:
        """
        The wifiMac of the device to be modified.
        """
        return pulumi.get(self, "wifi_mac")


@pulumi.output_type
class SmDevicesFieldsParametersDeviceFields(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 notes: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: New name for the device
        :param _builtins.str notes: New notes for the device
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        New name for the device
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[_builtins.str]:
        """
        New notes for the device
        """
        return pulumi.get(self, "notes")


@pulumi.output_type
class SmDevicesInstallAppsParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appIds":
            suggest = "app_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesInstallAppsParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesInstallAppsParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesInstallAppsParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_ids: Optional[Sequence[_builtins.str]] = None,
                 force: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] app_ids: ids of applications to be installed
        :param _builtins.bool force: By default, installation of an app which is believed to already be present on the device will be skipped. If you'd like to force the installation of the app, set this parameter to true.
        """
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)
        if force is not None:
            pulumi.set(__self__, "force", force)

    @_builtins.property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        ids of applications to be installed
        """
        return pulumi.get(self, "app_ids")

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[_builtins.bool]:
        """
        By default, installation of an app which is believed to already be present on the device will be skipped. If you'd like to force the installation of the app, set this parameter to true.
        """
        return pulumi.get(self, "force")


@pulumi.output_type
class SmDevicesLockItem(dict):
    def __init__(__self__, *,
                 ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ids: The Meraki Ids of the set of devices.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The Meraki Ids of the set of devices.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class SmDevicesLockParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wifiMacs":
            suggest = "wifi_macs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesLockParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesLockParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesLockParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ids: Optional[Sequence[_builtins.str]] = None,
                 pin: Optional[_builtins.int] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 serials: Optional[Sequence[_builtins.str]] = None,
                 wifi_macs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ids: The ids of the devices to be locked.
        :param _builtins.int pin: The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
        :param Sequence[_builtins.str] scopes: The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
        :param Sequence[_builtins.str] serials: The serials of the devices to be locked.
        :param Sequence[_builtins.str] wifi_macs: The wifiMacs of the devices to be locked.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if pin is not None:
            pulumi.set(__self__, "pin", pin)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if wifi_macs is not None:
            pulumi.set(__self__, "wifi_macs", wifi_macs)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The ids of the devices to be locked.
        """
        return pulumi.get(self, "ids")

    @_builtins.property
    @pulumi.getter
    def pin(self) -> Optional[_builtins.int]:
        """
        The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
        """
        return pulumi.get(self, "pin")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        The serials of the devices to be locked.
        """
        return pulumi.get(self, "serials")

    @_builtins.property
    @pulumi.getter(name="wifiMacs")
    def wifi_macs(self) -> Optional[Sequence[_builtins.str]]:
        """
        The wifiMacs of the devices to be locked.
        """
        return pulumi.get(self, "wifi_macs")


@pulumi.output_type
class SmDevicesModifyTagsItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wifiMac":
            suggest = "wifi_mac"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesModifyTagsItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesModifyTagsItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesModifyTagsItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 serial: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 wifi_mac: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The Meraki Id of the device record.
        :param _builtins.str serial: The device serial.
        :param Sequence[_builtins.str] tags: An array of tags associated with the device.
        :param _builtins.str wifi_mac: The MAC of the device.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if wifi_mac is not None:
            pulumi.set(__self__, "wifi_mac", wifi_mac)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The Meraki Id of the device record.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        The device serial.
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of tags associated with the device.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="wifiMac")
    def wifi_mac(self) -> Optional[_builtins.str]:
        """
        The MAC of the device.
        """
        return pulumi.get(self, "wifi_mac")


@pulumi.output_type
class SmDevicesModifyTagsParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updateAction":
            suggest = "update_action"
        elif key == "wifiMacs":
            suggest = "wifi_macs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesModifyTagsParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesModifyTagsParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesModifyTagsParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ids: Optional[Sequence[_builtins.str]] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 serials: Optional[Sequence[_builtins.str]] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 update_action: Optional[_builtins.str] = None,
                 wifi_macs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ids: The ids of the devices to be modified.
        :param Sequence[_builtins.str] scopes: The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
        :param Sequence[_builtins.str] serials: The serials of the devices to be modified.
        :param Sequence[_builtins.str] tags: The tags to be added, deleted, or updated.
        :param _builtins.str update_action: One of add, delete, or update. Only devices that have been modified will be returned.
        :param Sequence[_builtins.str] wifi_macs: The wifiMacs of the devices to be modified.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if update_action is not None:
            pulumi.set(__self__, "update_action", update_action)
        if wifi_macs is not None:
            pulumi.set(__self__, "wifi_macs", wifi_macs)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The ids of the devices to be modified.
        """
        return pulumi.get(self, "ids")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        The serials of the devices to be modified.
        """
        return pulumi.get(self, "serials")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        The tags to be added, deleted, or updated.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="updateAction")
    def update_action(self) -> Optional[_builtins.str]:
        """
        One of add, delete, or update. Only devices that have been modified will be returned.
        """
        return pulumi.get(self, "update_action")

    @_builtins.property
    @pulumi.getter(name="wifiMacs")
    def wifi_macs(self) -> Optional[Sequence[_builtins.str]]:
        """
        The wifiMacs of the devices to be modified.
        """
        return pulumi.get(self, "wifi_macs")


@pulumi.output_type
class SmDevicesMoveItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "newNetwork":
            suggest = "new_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesMoveItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesMoveItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesMoveItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ids: Optional[Sequence[_builtins.str]] = None,
                 new_network: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] ids: The Meraki Ids of the set of devices.
        :param _builtins.str new_network: The network to which the devices was moved.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if new_network is not None:
            pulumi.set(__self__, "new_network", new_network)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The Meraki Ids of the set of devices.
        """
        return pulumi.get(self, "ids")

    @_builtins.property
    @pulumi.getter(name="newNetwork")
    def new_network(self) -> Optional[_builtins.str]:
        """
        The network to which the devices was moved.
        """
        return pulumi.get(self, "new_network")


@pulumi.output_type
class SmDevicesMoveParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "newNetwork":
            suggest = "new_network"
        elif key == "wifiMacs":
            suggest = "wifi_macs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesMoveParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesMoveParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesMoveParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ids: Optional[Sequence[_builtins.str]] = None,
                 new_network: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 serials: Optional[Sequence[_builtins.str]] = None,
                 wifi_macs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ids: The ids of the devices to be moved.
        :param _builtins.str new_network: The new network to which the devices will be moved.
        :param Sequence[_builtins.str] scopes: The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved.
        :param Sequence[_builtins.str] serials: The serials of the devices to be moved.
        :param Sequence[_builtins.str] wifi_macs: The wifiMacs of the devices to be moved.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if new_network is not None:
            pulumi.set(__self__, "new_network", new_network)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if wifi_macs is not None:
            pulumi.set(__self__, "wifi_macs", wifi_macs)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The ids of the devices to be moved.
        """
        return pulumi.get(self, "ids")

    @_builtins.property
    @pulumi.getter(name="newNetwork")
    def new_network(self) -> Optional[_builtins.str]:
        """
        The new network to which the devices will be moved.
        """
        return pulumi.get(self, "new_network")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        The serials of the devices to be moved.
        """
        return pulumi.get(self, "serials")

    @_builtins.property
    @pulumi.getter(name="wifiMacs")
    def wifi_macs(self) -> Optional[Sequence[_builtins.str]]:
        """
        The wifiMacs of the devices to be moved.
        """
        return pulumi.get(self, "wifi_macs")


@pulumi.output_type
class SmDevicesRebootItem(dict):
    def __init__(__self__, *,
                 ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ids: The Meraki Ids of the set of endpoints.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The Meraki Ids of the set of endpoints.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class SmDevicesRebootParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kextPaths":
            suggest = "kext_paths"
        elif key == "notifyUser":
            suggest = "notify_user"
        elif key == "rebuildKernelCache":
            suggest = "rebuild_kernel_cache"
        elif key == "requestRequiresNetworkTether":
            suggest = "request_requires_network_tether"
        elif key == "wifiMacs":
            suggest = "wifi_macs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesRebootParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesRebootParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesRebootParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ids: Optional[Sequence[_builtins.str]] = None,
                 kext_paths: Optional[Sequence[_builtins.str]] = None,
                 notify_user: Optional[_builtins.bool] = None,
                 rebuild_kernel_cache: Optional[_builtins.bool] = None,
                 request_requires_network_tether: Optional[_builtins.bool] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 serials: Optional[Sequence[_builtins.str]] = None,
                 wifi_macs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ids: The ids of the endpoints to be rebooted.
        :param Sequence[_builtins.str] kext_paths: The KextPaths of the endpoints to be rebooted. Available for macOS 11+
        :param _builtins.bool notify_user: Whether or not to notify the user before rebooting the endpoint. Available for macOS 11.3+
        :param _builtins.bool rebuild_kernel_cache: Whether or not to rebuild the kernel cache when rebooting the endpoint. Available for macOS 11+
        :param _builtins.bool request_requires_network_tether: Whether or not the request requires network tethering. Available for macOS and supervised iOS or tvOS
        :param Sequence[_builtins.str] scopes: The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be rebooted.
        :param Sequence[_builtins.str] serials: The serials of the endpoints to be rebooted.
        :param Sequence[_builtins.str] wifi_macs: The wifiMacs of the endpoints to be rebooted.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if kext_paths is not None:
            pulumi.set(__self__, "kext_paths", kext_paths)
        if notify_user is not None:
            pulumi.set(__self__, "notify_user", notify_user)
        if rebuild_kernel_cache is not None:
            pulumi.set(__self__, "rebuild_kernel_cache", rebuild_kernel_cache)
        if request_requires_network_tether is not None:
            pulumi.set(__self__, "request_requires_network_tether", request_requires_network_tether)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if wifi_macs is not None:
            pulumi.set(__self__, "wifi_macs", wifi_macs)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The ids of the endpoints to be rebooted.
        """
        return pulumi.get(self, "ids")

    @_builtins.property
    @pulumi.getter(name="kextPaths")
    def kext_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        The KextPaths of the endpoints to be rebooted. Available for macOS 11+
        """
        return pulumi.get(self, "kext_paths")

    @_builtins.property
    @pulumi.getter(name="notifyUser")
    def notify_user(self) -> Optional[_builtins.bool]:
        """
        Whether or not to notify the user before rebooting the endpoint. Available for macOS 11.3+
        """
        return pulumi.get(self, "notify_user")

    @_builtins.property
    @pulumi.getter(name="rebuildKernelCache")
    def rebuild_kernel_cache(self) -> Optional[_builtins.bool]:
        """
        Whether or not to rebuild the kernel cache when rebooting the endpoint. Available for macOS 11+
        """
        return pulumi.get(self, "rebuild_kernel_cache")

    @_builtins.property
    @pulumi.getter(name="requestRequiresNetworkTether")
    def request_requires_network_tether(self) -> Optional[_builtins.bool]:
        """
        Whether or not the request requires network tethering. Available for macOS and supervised iOS or tvOS
        """
        return pulumi.get(self, "request_requires_network_tether")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be rebooted.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        The serials of the endpoints to be rebooted.
        """
        return pulumi.get(self, "serials")

    @_builtins.property
    @pulumi.getter(name="wifiMacs")
    def wifi_macs(self) -> Optional[Sequence[_builtins.str]]:
        """
        The wifiMacs of the endpoints to be rebooted.
        """
        return pulumi.get(self, "wifi_macs")


@pulumi.output_type
class SmDevicesShutdownItem(dict):
    def __init__(__self__, *,
                 ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ids: The Meraki Ids of the set of endpoints.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The Meraki Ids of the set of endpoints.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class SmDevicesShutdownParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wifiMacs":
            suggest = "wifi_macs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesShutdownParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesShutdownParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesShutdownParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ids: Optional[Sequence[_builtins.str]] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 serials: Optional[Sequence[_builtins.str]] = None,
                 wifi_macs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ids: The ids of the endpoints to be shutdown.
        :param Sequence[_builtins.str] scopes: The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be shutdown.
        :param Sequence[_builtins.str] serials: The serials of the endpoints to be shutdown.
        :param Sequence[_builtins.str] wifi_macs: The wifiMacs of the endpoints to be shutdown.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if wifi_macs is not None:
            pulumi.set(__self__, "wifi_macs", wifi_macs)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The ids of the endpoints to be shutdown.
        """
        return pulumi.get(self, "ids")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be shutdown.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        The serials of the endpoints to be shutdown.
        """
        return pulumi.get(self, "serials")

    @_builtins.property
    @pulumi.getter(name="wifiMacs")
    def wifi_macs(self) -> Optional[Sequence[_builtins.str]]:
        """
        The wifiMacs of the endpoints to be shutdown.
        """
        return pulumi.get(self, "wifi_macs")


@pulumi.output_type
class SmDevicesUnenrollItem(dict):
    def __init__(__self__, *,
                 success: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool success: Boolean indicating whether the operation was completed successfully.
        """
        if success is not None:
            pulumi.set(__self__, "success", success)

    @_builtins.property
    @pulumi.getter
    def success(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating whether the operation was completed successfully.
        """
        return pulumi.get(self, "success")


@pulumi.output_type
class SmDevicesUninstallAppsParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appIds":
            suggest = "app_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesUninstallAppsParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesUninstallAppsParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesUninstallAppsParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] app_ids: ids of applications to be uninstalled
        """
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)

    @_builtins.property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        ids of applications to be uninstalled
        """
        return pulumi.get(self, "app_ids")


@pulumi.output_type
class SmDevicesWipeItem(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The Meraki Id of the devices.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The Meraki Id of the devices.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SmDevicesWipeParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wifiMac":
            suggest = "wifi_mac"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmDevicesWipeParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmDevicesWipeParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmDevicesWipeParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 pin: Optional[_builtins.int] = None,
                 serial: Optional[_builtins.str] = None,
                 wifi_mac: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The id of the device to be wiped.
        :param _builtins.int pin: The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
        :param _builtins.str serial: The serial of the device to be wiped.
        :param _builtins.str wifi_mac: The wifiMac of the device to be wiped.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pin is not None:
            pulumi.set(__self__, "pin", pin)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if wifi_mac is not None:
            pulumi.set(__self__, "wifi_mac", wifi_mac)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The id of the device to be wiped.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def pin(self) -> Optional[_builtins.int]:
        """
        The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
        """
        return pulumi.get(self, "pin")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        The serial of the device to be wiped.
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="wifiMac")
    def wifi_mac(self) -> Optional[_builtins.str]:
        """
        The wifiMac of the device to be wiped.
        """
        return pulumi.get(self, "wifi_mac")


@pulumi.output_type
class SnmpUser(dict):
    def __init__(__self__, *,
                 passphrase: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str passphrase: The passphrase for the SNMP user.
        :param _builtins.str username: The username for the SNMP user.
        """
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[_builtins.str]:
        """
        The passphrase for the SNMP user.
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username for the SNMP user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SplitItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultingNetworks":
            suggest = "resulting_networks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SplitItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SplitItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SplitItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resulting_networks: Optional[Sequence['outputs.SplitItemResultingNetwork']] = None):
        """
        :param Sequence['SplitItemResultingNetworkArgs'] resulting_networks: Networks after the split
        """
        if resulting_networks is not None:
            pulumi.set(__self__, "resulting_networks", resulting_networks)

    @_builtins.property
    @pulumi.getter(name="resultingNetworks")
    def resulting_networks(self) -> Optional[Sequence['outputs.SplitItemResultingNetwork']]:
        """
        Networks after the split
        """
        return pulumi.get(self, "resulting_networks")


@pulumi.output_type
class SplitItemResultingNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enrollmentString":
            suggest = "enrollment_string"
        elif key == "isBoundToConfigTemplate":
            suggest = "is_bound_to_config_template"
        elif key == "organizationId":
            suggest = "organization_id"
        elif key == "productTypes":
            suggest = "product_types"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SplitItemResultingNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SplitItemResultingNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SplitItemResultingNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enrollment_string: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 is_bound_to_config_template: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 notes: Optional[_builtins.str] = None,
                 organization_id: Optional[_builtins.str] = None,
                 product_types: Optional[Sequence[_builtins.str]] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 time_zone: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str enrollment_string: Enrollment string for the network
        :param _builtins.str id: Network ID
        :param _builtins.bool is_bound_to_config_template: If the network is bound to a config template
        :param _builtins.str name: Network name
        :param _builtins.str notes: Notes for the network
        :param _builtins.str organization_id: Organization ID
        :param Sequence[_builtins.str] product_types: List of the product types that the network supports
        :param Sequence[_builtins.str] tags: Network tags
        :param _builtins.str time_zone: Timezone of the network
        :param _builtins.str url: URL to the network Dashboard UI
        """
        if enrollment_string is not None:
            pulumi.set(__self__, "enrollment_string", enrollment_string)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_bound_to_config_template is not None:
            pulumi.set(__self__, "is_bound_to_config_template", is_bound_to_config_template)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)
        if product_types is not None:
            pulumi.set(__self__, "product_types", product_types)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="enrollmentString")
    def enrollment_string(self) -> Optional[_builtins.str]:
        """
        Enrollment string for the network
        """
        return pulumi.get(self, "enrollment_string")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Network ID
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isBoundToConfigTemplate")
    def is_bound_to_config_template(self) -> Optional[_builtins.bool]:
        """
        If the network is bound to a config template
        """
        return pulumi.get(self, "is_bound_to_config_template")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Network name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[_builtins.str]:
        """
        Notes for the network
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[_builtins.str]:
        """
        Organization ID
        """
        return pulumi.get(self, "organization_id")

    @_builtins.property
    @pulumi.getter(name="productTypes")
    def product_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of the product types that the network supports
        """
        return pulumi.get(self, "product_types")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Network tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        Timezone of the network
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL to the network Dashboard UI
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SwitchAccessControlListsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dstCidr":
            suggest = "dst_cidr"
        elif key == "dstPort":
            suggest = "dst_port"
        elif key == "ipVersion":
            suggest = "ip_version"
        elif key == "srcCidr":
            suggest = "src_cidr"
        elif key == "srcPort":
            suggest = "src_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchAccessControlListsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchAccessControlListsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchAccessControlListsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 dst_cidr: Optional[_builtins.str] = None,
                 dst_port: Optional[_builtins.str] = None,
                 ip_version: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 src_cidr: Optional[_builtins.str] = None,
                 src_port: Optional[_builtins.str] = None,
                 vlan: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dst_cidr: Destination IP address (in IP or CIDR notation)
        :param _builtins.str dst_port: Destination port
        :param _builtins.str ip_version: IP address version
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol
        :param _builtins.str src_cidr: Source IP address (in IP or CIDR notation)
        :param _builtins.str src_port: Source port
        :param _builtins.str vlan: ncoming traffic VLAN
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dst_cidr is not None:
            pulumi.set(__self__, "dst_cidr", dst_cidr)
        if dst_port is not None:
            pulumi.set(__self__, "dst_port", dst_port)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="dstCidr")
    def dst_cidr(self) -> Optional[_builtins.str]:
        """
        Destination IP address (in IP or CIDR notation)
        """
        return pulumi.get(self, "dst_cidr")

    @_builtins.property
    @pulumi.getter(name="dstPort")
    def dst_port(self) -> Optional[_builtins.str]:
        """
        Destination port
        """
        return pulumi.get(self, "dst_port")

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[_builtins.str]:
        """
        IP address version
        """
        return pulumi.get(self, "ip_version")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The type of protocol
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[_builtins.str]:
        """
        Source IP address (in IP or CIDR notation)
        """
        return pulumi.get(self, "src_cidr")

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[_builtins.str]:
        """
        Source port
        """
        return pulumi.get(self, "src_port")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[_builtins.str]:
        """
        ncoming traffic VLAN
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class SwitchAccessControlListsRulesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dstCidr":
            suggest = "dst_cidr"
        elif key == "dstPort":
            suggest = "dst_port"
        elif key == "ipVersion":
            suggest = "ip_version"
        elif key == "srcCidr":
            suggest = "src_cidr"
        elif key == "srcPort":
            suggest = "src_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchAccessControlListsRulesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchAccessControlListsRulesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchAccessControlListsRulesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 dst_cidr: Optional[_builtins.str] = None,
                 dst_port: Optional[_builtins.str] = None,
                 ip_version: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 src_cidr: Optional[_builtins.str] = None,
                 src_port: Optional[_builtins.str] = None,
                 vlan: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dst_cidr: Destination IP address (in IP or CIDR notation)
        :param _builtins.str dst_port: Destination port
        :param _builtins.str ip_version: IP address version
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol
        :param _builtins.str src_cidr: Source IP address (in IP or CIDR notation)
        :param _builtins.str src_port: Source port
        :param _builtins.str vlan: ncoming traffic VLAN
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dst_cidr is not None:
            pulumi.set(__self__, "dst_cidr", dst_cidr)
        if dst_port is not None:
            pulumi.set(__self__, "dst_port", dst_port)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="dstCidr")
    def dst_cidr(self) -> Optional[_builtins.str]:
        """
        Destination IP address (in IP or CIDR notation)
        """
        return pulumi.get(self, "dst_cidr")

    @_builtins.property
    @pulumi.getter(name="dstPort")
    def dst_port(self) -> Optional[_builtins.str]:
        """
        Destination port
        """
        return pulumi.get(self, "dst_port")

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[_builtins.str]:
        """
        IP address version
        """
        return pulumi.get(self, "ip_version")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The type of protocol
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[_builtins.str]:
        """
        Source IP address (in IP or CIDR notation)
        """
        return pulumi.get(self, "src_cidr")

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[_builtins.str]:
        """
        Source port
        """
        return pulumi.get(self, "src_port")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[_builtins.str]:
        """
        ncoming traffic VLAN
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class SwitchAccessPoliciesCounts(dict):
    def __init__(__self__, *,
                 ports: Optional['outputs.SwitchAccessPoliciesCountsPorts'] = None):
        """
        :param 'SwitchAccessPoliciesCountsPortsArgs' ports: Counts associated with ports
        """
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional['outputs.SwitchAccessPoliciesCountsPorts']:
        """
        Counts associated with ports
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class SwitchAccessPoliciesCountsPorts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "withThisPolicy":
            suggest = "with_this_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchAccessPoliciesCountsPorts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchAccessPoliciesCountsPorts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchAccessPoliciesCountsPorts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 with_this_policy: Optional[_builtins.int] = None):
        """
        :param _builtins.int with_this_policy: Number of ports in the network with this policy. For template networks, this is the number of template ports (not child ports) with this policy.
        """
        if with_this_policy is not None:
            pulumi.set(__self__, "with_this_policy", with_this_policy)

    @_builtins.property
    @pulumi.getter(name="withThisPolicy")
    def with_this_policy(self) -> Optional[_builtins.int]:
        """
        Number of ports in the network with this policy. For template networks, this is the number of template ports (not child ports) with this policy.
        """
        return pulumi.get(self, "with_this_policy")


@pulumi.output_type
class SwitchAccessPoliciesDot1x(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlDirection":
            suggest = "control_direction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchAccessPoliciesDot1x. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchAccessPoliciesDot1x.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchAccessPoliciesDot1x.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str control_direction: Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
        """
        if control_direction is not None:
            pulumi.set(__self__, "control_direction", control_direction)

    @_builtins.property
    @pulumi.getter(name="controlDirection")
    def control_direction(self) -> Optional[_builtins.str]:
        """
        Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
        """
        return pulumi.get(self, "control_direction")


@pulumi.output_type
class SwitchAccessPoliciesRadius(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "criticalAuth":
            suggest = "critical_auth"
        elif key == "failedAuthVlanId":
            suggest = "failed_auth_vlan_id"
        elif key == "reAuthenticationInterval":
            suggest = "re_authentication_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchAccessPoliciesRadius. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchAccessPoliciesRadius.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchAccessPoliciesRadius.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 critical_auth: Optional['outputs.SwitchAccessPoliciesRadiusCriticalAuth'] = None,
                 failed_auth_vlan_id: Optional[_builtins.int] = None,
                 re_authentication_interval: Optional[_builtins.int] = None):
        """
        :param 'SwitchAccessPoliciesRadiusCriticalAuthArgs' critical_auth: Critical auth settings for when authentication is rejected by the RADIUS server
        :param _builtins.int failed_auth_vlan_id: VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        :param _builtins.int re_authentication_interval: Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
        """
        if critical_auth is not None:
            pulumi.set(__self__, "critical_auth", critical_auth)
        if failed_auth_vlan_id is not None:
            pulumi.set(__self__, "failed_auth_vlan_id", failed_auth_vlan_id)
        if re_authentication_interval is not None:
            pulumi.set(__self__, "re_authentication_interval", re_authentication_interval)

    @_builtins.property
    @pulumi.getter(name="criticalAuth")
    def critical_auth(self) -> Optional['outputs.SwitchAccessPoliciesRadiusCriticalAuth']:
        """
        Critical auth settings for when authentication is rejected by the RADIUS server
        """
        return pulumi.get(self, "critical_auth")

    @_builtins.property
    @pulumi.getter(name="failedAuthVlanId")
    def failed_auth_vlan_id(self) -> Optional[_builtins.int]:
        """
        VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        return pulumi.get(self, "failed_auth_vlan_id")

    @_builtins.property
    @pulumi.getter(name="reAuthenticationInterval")
    def re_authentication_interval(self) -> Optional[_builtins.int]:
        """
        Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
        """
        return pulumi.get(self, "re_authentication_interval")


@pulumi.output_type
class SwitchAccessPoliciesRadiusAccountingServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Public IP address of the RADIUS accounting server
        :param _builtins.int port: UDP port that the RADIUS Accounting server listens on for access requests
        :param _builtins.str secret: RADIUS client shared secret
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Public IP address of the RADIUS accounting server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        UDP port that the RADIUS Accounting server listens on for access requests
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        RADIUS client shared secret
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class SwitchAccessPoliciesRadiusAccountingServersResponse(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Public IP address of the RADIUS accounting server
        :param _builtins.int port: UDP port that the RADIUS Accounting server listens on for access requests
        :param _builtins.str secret: RADIUS client shared secret
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Public IP address of the RADIUS accounting server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        UDP port that the RADIUS Accounting server listens on for access requests
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        RADIUS client shared secret
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class SwitchAccessPoliciesRadiusCriticalAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataVlanId":
            suggest = "data_vlan_id"
        elif key == "suspendPortBounce":
            suggest = "suspend_port_bounce"
        elif key == "voiceVlanId":
            suggest = "voice_vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchAccessPoliciesRadiusCriticalAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchAccessPoliciesRadiusCriticalAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchAccessPoliciesRadiusCriticalAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_vlan_id: Optional[_builtins.int] = None,
                 suspend_port_bounce: Optional[_builtins.bool] = None,
                 voice_vlan_id: Optional[_builtins.int] = None):
        """
        :param _builtins.int data_vlan_id: VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        :param _builtins.bool suspend_port_bounce: Enable to suspend port bounce when RADIUS servers are unreachable
        :param _builtins.int voice_vlan_id: VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        if data_vlan_id is not None:
            pulumi.set(__self__, "data_vlan_id", data_vlan_id)
        if suspend_port_bounce is not None:
            pulumi.set(__self__, "suspend_port_bounce", suspend_port_bounce)
        if voice_vlan_id is not None:
            pulumi.set(__self__, "voice_vlan_id", voice_vlan_id)

    @_builtins.property
    @pulumi.getter(name="dataVlanId")
    def data_vlan_id(self) -> Optional[_builtins.int]:
        """
        VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        return pulumi.get(self, "data_vlan_id")

    @_builtins.property
    @pulumi.getter(name="suspendPortBounce")
    def suspend_port_bounce(self) -> Optional[_builtins.bool]:
        """
        Enable to suspend port bounce when RADIUS servers are unreachable
        """
        return pulumi.get(self, "suspend_port_bounce")

    @_builtins.property
    @pulumi.getter(name="voiceVlanId")
    def voice_vlan_id(self) -> Optional[_builtins.int]:
        """
        VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        return pulumi.get(self, "voice_vlan_id")


@pulumi.output_type
class SwitchAccessPoliciesRadiusServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Public IP address of the RADIUS server
        :param _builtins.int port: UDP port that the RADIUS server listens on for access requests
        :param _builtins.str secret: RADIUS client shared secret
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Public IP address of the RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        UDP port that the RADIUS server listens on for access requests
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        RADIUS client shared secret
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class SwitchAccessPoliciesRadiusServersResponse(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Public IP address of the RADIUS server
        :param _builtins.int port: UDP port that the RADIUS server listens on for access requests
        :param _builtins.str secret: RADIUS client shared secret
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Public IP address of the RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        UDP port that the RADIUS server listens on for access requests
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        RADIUS client shared secret
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class SwitchAlternateManagementInterfaceSwitch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alternateManagementIp":
            suggest = "alternate_management_ip"
        elif key == "subnetMask":
            suggest = "subnet_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchAlternateManagementInterfaceSwitch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchAlternateManagementInterfaceSwitch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchAlternateManagementInterfaceSwitch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alternate_management_ip: Optional[_builtins.str] = None,
                 gateway: Optional[_builtins.str] = None,
                 serial: Optional[_builtins.str] = None,
                 subnet_mask: Optional[_builtins.str] = None):
        """
        :param _builtins.str alternate_management_ip: Switch alternative management IP. To remove a prior IP setting, provide an empty string
        :param _builtins.str gateway: Switch gateway must be in IP format. Only and must be specified for Polaris switches
        :param _builtins.str serial: Switch serial number
        :param _builtins.str subnet_mask: Switch subnet mask must be in IP format. Only and must be specified for Polaris switches
        """
        if alternate_management_ip is not None:
            pulumi.set(__self__, "alternate_management_ip", alternate_management_ip)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)

    @_builtins.property
    @pulumi.getter(name="alternateManagementIp")
    def alternate_management_ip(self) -> Optional[_builtins.str]:
        """
        Switch alternative management IP. To remove a prior IP setting, provide an empty string
        """
        return pulumi.get(self, "alternate_management_ip")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        Switch gateway must be in IP format. Only and must be specified for Polaris switches
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        Switch serial number
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[_builtins.str]:
        """
        Switch subnet mask must be in IP format. Only and must be specified for Polaris switches
        """
        return pulumi.get(self, "subnet_mask")


@pulumi.output_type
class SwitchDhcpServerPolicyAlerts(dict):
    def __init__(__self__, *,
                 email: Optional['outputs.SwitchDhcpServerPolicyAlertsEmail'] = None):
        """
        :param 'SwitchDhcpServerPolicyAlertsEmailArgs' email: Alert settings for DHCP servers
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional['outputs.SwitchDhcpServerPolicyAlertsEmail']:
        """
        Alert settings for DHCP servers
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class SwitchDhcpServerPolicyAlertsEmail(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: When enabled, send an email if a new DHCP server is seen. Default value is false.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        When enabled, send an email if a new DHCP server is seen. Default value is false.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SwitchDhcpServerPolicyArpInspection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unsupportedModels":
            suggest = "unsupported_models"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchDhcpServerPolicyArpInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchDhcpServerPolicyArpInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchDhcpServerPolicyArpInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 unsupported_models: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool enabled: Enable or disable Dynamic ARP Inspection on the network. Default value is false.
        :param Sequence[_builtins.str] unsupported_models: List of switch models that does not support dynamic ARP inspection
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if unsupported_models is not None:
            pulumi.set(__self__, "unsupported_models", unsupported_models)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable Dynamic ARP Inspection on the network. Default value is false.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="unsupportedModels")
    def unsupported_models(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of switch models that does not support dynamic ARP inspection
        """
        return pulumi.get(self, "unsupported_models")


@pulumi.output_type
class SwitchDhcpServerPolicyArpInspectionTrustedServersIpv4(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: IPv4 address of the trusted server.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        IPv4 address of the trusted server.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class SwitchDscpToCosMappingsMapping(dict):
    def __init__(__self__, *,
                 cos: Optional[_builtins.int] = None,
                 dscp: Optional[_builtins.int] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.int cos: The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
        :param _builtins.int dscp: The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
        :param _builtins.str title: Label for the mapping (optional).
        """
        if cos is not None:
            pulumi.set(__self__, "cos", cos)
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def cos(self) -> Optional[_builtins.int]:
        """
        The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
        """
        return pulumi.get(self, "cos")

    @_builtins.property
    @pulumi.getter
    def dscp(self) -> Optional[_builtins.int]:
        """
        The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
        """
        return pulumi.get(self, "dscp")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Label for the mapping (optional).
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class SwitchLinkAggregationsSwitchPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portId":
            suggest = "port_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchLinkAggregationsSwitchPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchLinkAggregationsSwitchPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchLinkAggregationsSwitchPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_id: Optional[_builtins.str] = None,
                 serial: Optional[_builtins.str] = None):
        """
        :param _builtins.str port_id: Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
        :param _builtins.str serial: Serial number of the switch.
        """
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[_builtins.str]:
        """
        Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
        """
        return pulumi.get(self, "port_id")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        Serial number of the switch.
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class SwitchLinkAggregationsSwitchProfilePort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portId":
            suggest = "port_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchLinkAggregationsSwitchProfilePort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchLinkAggregationsSwitchProfilePort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchLinkAggregationsSwitchProfilePort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_id: Optional[_builtins.str] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str port_id: Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
        :param _builtins.str profile: Profile identifier.
        """
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[_builtins.str]:
        """
        Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
        """
        return pulumi.get(self, "port_id")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        Profile identifier.
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class SwitchMtuOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mtuSize":
            suggest = "mtu_size"
        elif key == "switchProfiles":
            suggest = "switch_profiles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchMtuOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchMtuOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchMtuOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mtu_size: Optional[_builtins.int] = None,
                 switch_profiles: Optional[Sequence[_builtins.str]] = None,
                 switches: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int mtu_size: MTU size for the switches or switch templates.
        :param Sequence[_builtins.str] switch_profiles: List of switch template IDs. Applicable only for template network.
        :param Sequence[_builtins.str] switches: List of switch serials. Applicable only for switch network.
        """
        if mtu_size is not None:
            pulumi.set(__self__, "mtu_size", mtu_size)
        if switch_profiles is not None:
            pulumi.set(__self__, "switch_profiles", switch_profiles)
        if switches is not None:
            pulumi.set(__self__, "switches", switches)

    @_builtins.property
    @pulumi.getter(name="mtuSize")
    def mtu_size(self) -> Optional[_builtins.int]:
        """
        MTU size for the switches or switch templates.
        """
        return pulumi.get(self, "mtu_size")

    @_builtins.property
    @pulumi.getter(name="switchProfiles")
    def switch_profiles(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of switch template IDs. Applicable only for template network.
        """
        return pulumi.get(self, "switch_profiles")

    @_builtins.property
    @pulumi.getter
    def switches(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of switch serials. Applicable only for switch network.
        """
        return pulumi.get(self, "switches")


@pulumi.output_type
class SwitchPortSchedulesPortSchedule(dict):
    def __init__(__self__, *,
                 friday: Optional['outputs.SwitchPortSchedulesPortScheduleFriday'] = None,
                 monday: Optional['outputs.SwitchPortSchedulesPortScheduleMonday'] = None,
                 saturday: Optional['outputs.SwitchPortSchedulesPortScheduleSaturday'] = None,
                 sunday: Optional['outputs.SwitchPortSchedulesPortScheduleSunday'] = None,
                 thursday: Optional['outputs.SwitchPortSchedulesPortScheduleThursday'] = None,
                 tuesday: Optional['outputs.SwitchPortSchedulesPortScheduleTuesday'] = None,
                 wednesday: Optional['outputs.SwitchPortSchedulesPortScheduleWednesday'] = None):
        """
        :param 'SwitchPortSchedulesPortScheduleFridayArgs' friday: The schedule object for Friday.
        :param 'SwitchPortSchedulesPortScheduleMondayArgs' monday: The schedule object for Monday.
        :param 'SwitchPortSchedulesPortScheduleSaturdayArgs' saturday: The schedule object for Saturday.
        :param 'SwitchPortSchedulesPortScheduleSundayArgs' sunday: The schedule object for Sunday.
        :param 'SwitchPortSchedulesPortScheduleThursdayArgs' thursday: The schedule object for Thursday.
        :param 'SwitchPortSchedulesPortScheduleTuesdayArgs' tuesday: The schedule object for Tuesday.
        :param 'SwitchPortSchedulesPortScheduleWednesdayArgs' wednesday: The schedule object for Wednesday.
        """
        if friday is not None:
            pulumi.set(__self__, "friday", friday)
        if monday is not None:
            pulumi.set(__self__, "monday", monday)
        if saturday is not None:
            pulumi.set(__self__, "saturday", saturday)
        if sunday is not None:
            pulumi.set(__self__, "sunday", sunday)
        if thursday is not None:
            pulumi.set(__self__, "thursday", thursday)
        if tuesday is not None:
            pulumi.set(__self__, "tuesday", tuesday)
        if wednesday is not None:
            pulumi.set(__self__, "wednesday", wednesday)

    @_builtins.property
    @pulumi.getter
    def friday(self) -> Optional['outputs.SwitchPortSchedulesPortScheduleFriday']:
        """
        The schedule object for Friday.
        """
        return pulumi.get(self, "friday")

    @_builtins.property
    @pulumi.getter
    def monday(self) -> Optional['outputs.SwitchPortSchedulesPortScheduleMonday']:
        """
        The schedule object for Monday.
        """
        return pulumi.get(self, "monday")

    @_builtins.property
    @pulumi.getter
    def saturday(self) -> Optional['outputs.SwitchPortSchedulesPortScheduleSaturday']:
        """
        The schedule object for Saturday.
        """
        return pulumi.get(self, "saturday")

    @_builtins.property
    @pulumi.getter
    def sunday(self) -> Optional['outputs.SwitchPortSchedulesPortScheduleSunday']:
        """
        The schedule object for Sunday.
        """
        return pulumi.get(self, "sunday")

    @_builtins.property
    @pulumi.getter
    def thursday(self) -> Optional['outputs.SwitchPortSchedulesPortScheduleThursday']:
        """
        The schedule object for Thursday.
        """
        return pulumi.get(self, "thursday")

    @_builtins.property
    @pulumi.getter
    def tuesday(self) -> Optional['outputs.SwitchPortSchedulesPortScheduleTuesday']:
        """
        The schedule object for Tuesday.
        """
        return pulumi.get(self, "tuesday")

    @_builtins.property
    @pulumi.getter
    def wednesday(self) -> Optional['outputs.SwitchPortSchedulesPortScheduleWednesday']:
        """
        The schedule object for Wednesday.
        """
        return pulumi.get(self, "wednesday")


@pulumi.output_type
class SwitchPortSchedulesPortScheduleFriday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortSchedulesPortScheduleFriday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortSchedulesPortScheduleFriday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortSchedulesPortScheduleFriday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class SwitchPortSchedulesPortScheduleMonday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortSchedulesPortScheduleMonday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortSchedulesPortScheduleMonday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortSchedulesPortScheduleMonday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class SwitchPortSchedulesPortScheduleSaturday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortSchedulesPortScheduleSaturday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortSchedulesPortScheduleSaturday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortSchedulesPortScheduleSaturday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class SwitchPortSchedulesPortScheduleSunday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortSchedulesPortScheduleSunday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortSchedulesPortScheduleSunday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortSchedulesPortScheduleSunday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class SwitchPortSchedulesPortScheduleThursday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortSchedulesPortScheduleThursday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortSchedulesPortScheduleThursday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortSchedulesPortScheduleThursday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class SwitchPortSchedulesPortScheduleTuesday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortSchedulesPortScheduleTuesday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortSchedulesPortScheduleTuesday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortSchedulesPortScheduleTuesday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class SwitchPortSchedulesPortScheduleWednesday(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortSchedulesPortScheduleWednesday. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortSchedulesPortScheduleWednesday.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortSchedulesPortScheduleWednesday.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 to: Optional[_builtins.str] = None):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.str]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class SwitchRoutingMulticastDefaultSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "floodUnknownMulticastTrafficEnabled":
            suggest = "flood_unknown_multicast_traffic_enabled"
        elif key == "igmpSnoopingEnabled":
            suggest = "igmp_snooping_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchRoutingMulticastDefaultSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchRoutingMulticastDefaultSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchRoutingMulticastDefaultSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flood_unknown_multicast_traffic_enabled: Optional[_builtins.bool] = None,
                 igmp_snooping_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool flood_unknown_multicast_traffic_enabled: Flood unknown multicast traffic enabled for the entire network
        :param _builtins.bool igmp_snooping_enabled: IGMP snooping enabled for the entire network
        """
        if flood_unknown_multicast_traffic_enabled is not None:
            pulumi.set(__self__, "flood_unknown_multicast_traffic_enabled", flood_unknown_multicast_traffic_enabled)
        if igmp_snooping_enabled is not None:
            pulumi.set(__self__, "igmp_snooping_enabled", igmp_snooping_enabled)

    @_builtins.property
    @pulumi.getter(name="floodUnknownMulticastTrafficEnabled")
    def flood_unknown_multicast_traffic_enabled(self) -> Optional[_builtins.bool]:
        """
        Flood unknown multicast traffic enabled for the entire network
        """
        return pulumi.get(self, "flood_unknown_multicast_traffic_enabled")

    @_builtins.property
    @pulumi.getter(name="igmpSnoopingEnabled")
    def igmp_snooping_enabled(self) -> Optional[_builtins.bool]:
        """
        IGMP snooping enabled for the entire network
        """
        return pulumi.get(self, "igmp_snooping_enabled")


@pulumi.output_type
class SwitchRoutingMulticastOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "floodUnknownMulticastTrafficEnabled":
            suggest = "flood_unknown_multicast_traffic_enabled"
        elif key == "igmpSnoopingEnabled":
            suggest = "igmp_snooping_enabled"
        elif key == "switchProfiles":
            suggest = "switch_profiles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchRoutingMulticastOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchRoutingMulticastOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchRoutingMulticastOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flood_unknown_multicast_traffic_enabled: Optional[_builtins.bool] = None,
                 igmp_snooping_enabled: Optional[_builtins.bool] = None,
                 stacks: Optional[Sequence[_builtins.str]] = None,
                 switch_profiles: Optional[Sequence[_builtins.str]] = None,
                 switches: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool flood_unknown_multicast_traffic_enabled: Flood unknown multicast traffic enabled for switches, switch stacks or switch templates
        :param _builtins.bool igmp_snooping_enabled: IGMP snooping enabled for switches, switch stacks or switch templates
        :param Sequence[_builtins.str] stacks: (optional) List of switch stack ids for non-template network
        :param Sequence[_builtins.str] switch_profiles: (optional) List of switch templates ids for template network
        :param Sequence[_builtins.str] switches: (optional) List of switch serials for non-template network
        """
        if flood_unknown_multicast_traffic_enabled is not None:
            pulumi.set(__self__, "flood_unknown_multicast_traffic_enabled", flood_unknown_multicast_traffic_enabled)
        if igmp_snooping_enabled is not None:
            pulumi.set(__self__, "igmp_snooping_enabled", igmp_snooping_enabled)
        if stacks is not None:
            pulumi.set(__self__, "stacks", stacks)
        if switch_profiles is not None:
            pulumi.set(__self__, "switch_profiles", switch_profiles)
        if switches is not None:
            pulumi.set(__self__, "switches", switches)

    @_builtins.property
    @pulumi.getter(name="floodUnknownMulticastTrafficEnabled")
    def flood_unknown_multicast_traffic_enabled(self) -> Optional[_builtins.bool]:
        """
        Flood unknown multicast traffic enabled for switches, switch stacks or switch templates
        """
        return pulumi.get(self, "flood_unknown_multicast_traffic_enabled")

    @_builtins.property
    @pulumi.getter(name="igmpSnoopingEnabled")
    def igmp_snooping_enabled(self) -> Optional[_builtins.bool]:
        """
        IGMP snooping enabled for switches, switch stacks or switch templates
        """
        return pulumi.get(self, "igmp_snooping_enabled")

    @_builtins.property
    @pulumi.getter
    def stacks(self) -> Optional[Sequence[_builtins.str]]:
        """
        (optional) List of switch stack ids for non-template network
        """
        return pulumi.get(self, "stacks")

    @_builtins.property
    @pulumi.getter(name="switchProfiles")
    def switch_profiles(self) -> Optional[Sequence[_builtins.str]]:
        """
        (optional) List of switch templates ids for template network
        """
        return pulumi.get(self, "switch_profiles")

    @_builtins.property
    @pulumi.getter
    def switches(self) -> Optional[Sequence[_builtins.str]]:
        """
        (optional) List of switch serials for non-template network
        """
        return pulumi.get(self, "switches")


@pulumi.output_type
class SwitchRoutingOspfArea(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "areaId":
            suggest = "area_id"
        elif key == "areaName":
            suggest = "area_name"
        elif key == "areaType":
            suggest = "area_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchRoutingOspfArea. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchRoutingOspfArea.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchRoutingOspfArea.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area_id: Optional[_builtins.int] = None,
                 area_name: Optional[_builtins.str] = None,
                 area_type: Optional[_builtins.str] = None):
        """
        :param _builtins.int area_id: OSPF area ID
        :param _builtins.str area_name: Name of the OSPF area
        :param _builtins.str area_type: Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
        """
        if area_id is not None:
            pulumi.set(__self__, "area_id", area_id)
        if area_name is not None:
            pulumi.set(__self__, "area_name", area_name)
        if area_type is not None:
            pulumi.set(__self__, "area_type", area_type)

    @_builtins.property
    @pulumi.getter(name="areaId")
    def area_id(self) -> Optional[_builtins.int]:
        """
        OSPF area ID
        """
        return pulumi.get(self, "area_id")

    @_builtins.property
    @pulumi.getter(name="areaName")
    def area_name(self) -> Optional[_builtins.str]:
        """
        Name of the OSPF area
        """
        return pulumi.get(self, "area_name")

    @_builtins.property
    @pulumi.getter(name="areaType")
    def area_type(self) -> Optional[_builtins.str]:
        """
        Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
        """
        return pulumi.get(self, "area_type")


@pulumi.output_type
class SwitchRoutingOspfMd5AuthenticationKey(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.int] = None,
                 passphrase: Optional[_builtins.str] = None):
        """
        :param _builtins.int id: MD5 authentication key index. Key index must be between 1 to 255
        :param _builtins.str passphrase: MD5 authentication passphrase
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        MD5 authentication key index. Key index must be between 1 to 255
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[_builtins.str]:
        """
        MD5 authentication passphrase
        """
        return pulumi.get(self, "passphrase")


@pulumi.output_type
class SwitchRoutingOspfV3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deadTimerInSeconds":
            suggest = "dead_timer_in_seconds"
        elif key == "helloTimerInSeconds":
            suggest = "hello_timer_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchRoutingOspfV3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchRoutingOspfV3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchRoutingOspfV3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 areas: Optional[Sequence['outputs.SwitchRoutingOspfV3Area']] = None,
                 dead_timer_in_seconds: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 hello_timer_in_seconds: Optional[_builtins.int] = None):
        """
        :param Sequence['SwitchRoutingOspfV3AreaArgs'] areas: OSPF v3 areas
        :param _builtins.int dead_timer_in_seconds: Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535
        :param _builtins.bool enabled: Boolean value to enable or disable V3 OSPF routing. OSPF V3 routing is disabled by default.
        :param _builtins.int hello_timer_in_seconds: Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds.
        """
        if areas is not None:
            pulumi.set(__self__, "areas", areas)
        if dead_timer_in_seconds is not None:
            pulumi.set(__self__, "dead_timer_in_seconds", dead_timer_in_seconds)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hello_timer_in_seconds is not None:
            pulumi.set(__self__, "hello_timer_in_seconds", hello_timer_in_seconds)

    @_builtins.property
    @pulumi.getter
    def areas(self) -> Optional[Sequence['outputs.SwitchRoutingOspfV3Area']]:
        """
        OSPF v3 areas
        """
        return pulumi.get(self, "areas")

    @_builtins.property
    @pulumi.getter(name="deadTimerInSeconds")
    def dead_timer_in_seconds(self) -> Optional[_builtins.int]:
        """
        Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535
        """
        return pulumi.get(self, "dead_timer_in_seconds")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean value to enable or disable V3 OSPF routing. OSPF V3 routing is disabled by default.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="helloTimerInSeconds")
    def hello_timer_in_seconds(self) -> Optional[_builtins.int]:
        """
        Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds.
        """
        return pulumi.get(self, "hello_timer_in_seconds")


@pulumi.output_type
class SwitchRoutingOspfV3Area(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "areaId":
            suggest = "area_id"
        elif key == "areaName":
            suggest = "area_name"
        elif key == "areaType":
            suggest = "area_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchRoutingOspfV3Area. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchRoutingOspfV3Area.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchRoutingOspfV3Area.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area_id: Optional[_builtins.int] = None,
                 area_name: Optional[_builtins.str] = None,
                 area_type: Optional[_builtins.str] = None):
        """
        :param _builtins.int area_id: OSPF area ID
        :param _builtins.str area_name: Name of the OSPF area
        :param _builtins.str area_type: Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
        """
        if area_id is not None:
            pulumi.set(__self__, "area_id", area_id)
        if area_name is not None:
            pulumi.set(__self__, "area_name", area_name)
        if area_type is not None:
            pulumi.set(__self__, "area_type", area_type)

    @_builtins.property
    @pulumi.getter(name="areaId")
    def area_id(self) -> Optional[_builtins.int]:
        """
        OSPF area ID
        """
        return pulumi.get(self, "area_id")

    @_builtins.property
    @pulumi.getter(name="areaName")
    def area_name(self) -> Optional[_builtins.str]:
        """
        Name of the OSPF area
        """
        return pulumi.get(self, "area_name")

    @_builtins.property
    @pulumi.getter(name="areaType")
    def area_type(self) -> Optional[_builtins.str]:
        """
        Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
        """
        return pulumi.get(self, "area_type")


@pulumi.output_type
class SwitchSettingsMacBlocklist(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enable MAC blocklist for switches in the network
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable MAC blocklist for switches in the network
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SwitchSettingsPowerException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "powerType":
            suggest = "power_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSettingsPowerException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSettingsPowerException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSettingsPowerException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 power_type: Optional[_builtins.str] = None,
                 serial: Optional[_builtins.str] = None):
        """
        :param _builtins.str power_type: Per switch exception (combined, redundant, useNetworkSetting)
        :param _builtins.str serial: Serial number of the switch
        """
        if power_type is not None:
            pulumi.set(__self__, "power_type", power_type)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter(name="powerType")
    def power_type(self) -> Optional[_builtins.str]:
        """
        Per switch exception (combined, redundant, useNetworkSetting)
        """
        return pulumi.get(self, "power_type")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        Serial number of the switch
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class SwitchSettingsUplinkClientSampling(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enable client sampling on uplink
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable client sampling on uplink
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SwitchStacksAddItem(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 serials: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str id: ID of the Switch stack
        :param _builtins.str name: Name of the Switch stack
        :param Sequence[_builtins.str] serials: Serials of the switches in the switch stack
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Switch stack
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Switch stack
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        Serials of the switches in the switch stack
        """
        return pulumi.get(self, "serials")


@pulumi.output_type
class SwitchStacksAddParameters(dict):
    def __init__(__self__, *,
                 serial: Optional[_builtins.str] = None):
        """
        :param _builtins.str serial: The serial of the switch to be added
        """
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        The serial of the switch to be added
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class SwitchStacksRemoveItem(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 serials: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str id: ID of the Switch stack
        :param _builtins.str name: Name of the Switch stack
        :param Sequence[_builtins.str] serials: Serials of the switches in the switch stack
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Switch stack
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Switch stack
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        Serials of the switches in the switch stack
        """
        return pulumi.get(self, "serials")


@pulumi.output_type
class SwitchStacksRemoveParameters(dict):
    def __init__(__self__, *,
                 serial: Optional[_builtins.str] = None):
        """
        :param _builtins.str serial: The serial of the switch to be removed
        """
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        The serial of the switch to be removed
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class SwitchStacksRoutingInterfacesDhcpDhcpOption(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str code: The code for DHCP option which should be from 2 to 254
        :param _builtins.str type: The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
        :param _builtins.str value: The value of the DHCP option
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        The code for DHCP option which should be from 2 to 254
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the DHCP option
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SwitchStacksRoutingInterfacesDhcpFixedIpAssignment(dict):
    def __init__(__self__, *,
                 ip: Optional[_builtins.str] = None,
                 mac: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip: The IP address of the client which has fixed IP address assigned to it
        :param _builtins.str mac: The MAC address of the client which has fixed IP address
        :param _builtins.str name: The name of the client which has fixed IP address
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        The IP address of the client which has fixed IP address assigned to it
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[_builtins.str]:
        """
        The MAC address of the client which has fixed IP address
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the client which has fixed IP address
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SwitchStacksRoutingInterfacesDhcpReservedIpRange(dict):
    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 end: Optional[_builtins.str] = None,
                 start: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: The comment for the reserved IP range
        :param _builtins.str end: The ending IP address of the reserved IP range
        :param _builtins.str start: The starting IP address of the reserved IP range
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        The comment for the reserved IP range
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.str]:
        """
        The ending IP address of the reserved IP range
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.str]:
        """
        The starting IP address of the reserved IP range
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class SwitchStacksRoutingInterfacesIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignmentMode":
            suggest = "assignment_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchStacksRoutingInterfacesIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchStacksRoutingInterfacesIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchStacksRoutingInterfacesIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 assignment_mode: Optional[_builtins.str] = None,
                 gateway: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: IPv6 address
        :param _builtins.str assignment_mode: Assignment mode
        :param _builtins.str gateway: IPv6 gateway
        :param _builtins.str prefix: IPv6 subnet
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if assignment_mode is not None:
            pulumi.set(__self__, "assignment_mode", assignment_mode)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        IPv6 address
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="assignmentMode")
    def assignment_mode(self) -> Optional[_builtins.str]:
        """
        Assignment mode
        """
        return pulumi.get(self, "assignment_mode")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        IPv6 gateway
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        IPv6 subnet
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class SwitchStacksRoutingInterfacesOspfSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPassiveEnabled":
            suggest = "is_passive_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchStacksRoutingInterfacesOspfSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchStacksRoutingInterfacesOspfSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchStacksRoutingInterfacesOspfSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area: Optional[_builtins.str] = None,
                 cost: Optional[_builtins.int] = None,
                 is_passive_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str area: Area id
        :param _builtins.int cost: OSPF Cost
        :param _builtins.bool is_passive_enabled: Disable sending Hello packets on this interface's IPv4 area
        """
        if area is not None:
            pulumi.set(__self__, "area", area)
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if is_passive_enabled is not None:
            pulumi.set(__self__, "is_passive_enabled", is_passive_enabled)

    @_builtins.property
    @pulumi.getter
    def area(self) -> Optional[_builtins.str]:
        """
        Area id
        """
        return pulumi.get(self, "area")

    @_builtins.property
    @pulumi.getter
    def cost(self) -> Optional[_builtins.int]:
        """
        OSPF Cost
        """
        return pulumi.get(self, "cost")

    @_builtins.property
    @pulumi.getter(name="isPassiveEnabled")
    def is_passive_enabled(self) -> Optional[_builtins.bool]:
        """
        Disable sending Hello packets on this interface's IPv4 area
        """
        return pulumi.get(self, "is_passive_enabled")


@pulumi.output_type
class SwitchStacksRoutingInterfacesOspfV3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPassiveEnabled":
            suggest = "is_passive_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchStacksRoutingInterfacesOspfV3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchStacksRoutingInterfacesOspfV3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchStacksRoutingInterfacesOspfV3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area: Optional[_builtins.str] = None,
                 cost: Optional[_builtins.int] = None,
                 is_passive_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str area: Area id
        :param _builtins.int cost: OSPF Cost
        :param _builtins.bool is_passive_enabled: Disable sending Hello packets on this interface's IPv6 area
        """
        if area is not None:
            pulumi.set(__self__, "area", area)
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if is_passive_enabled is not None:
            pulumi.set(__self__, "is_passive_enabled", is_passive_enabled)

    @_builtins.property
    @pulumi.getter
    def area(self) -> Optional[_builtins.str]:
        """
        Area id
        """
        return pulumi.get(self, "area")

    @_builtins.property
    @pulumi.getter
    def cost(self) -> Optional[_builtins.int]:
        """
        OSPF Cost
        """
        return pulumi.get(self, "cost")

    @_builtins.property
    @pulumi.getter(name="isPassiveEnabled")
    def is_passive_enabled(self) -> Optional[_builtins.bool]:
        """
        Disable sending Hello packets on this interface's IPv6 area
        """
        return pulumi.get(self, "is_passive_enabled")


@pulumi.output_type
class SwitchStpStpBridgePriority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stpPriority":
            suggest = "stp_priority"
        elif key == "switchProfiles":
            suggest = "switch_profiles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchStpStpBridgePriority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchStpStpBridgePriority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchStpStpBridgePriority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stacks: Optional[Sequence[_builtins.str]] = None,
                 stp_priority: Optional[_builtins.int] = None,
                 switch_profiles: Optional[Sequence[_builtins.str]] = None,
                 switches: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] stacks: List of stack IDs
        :param _builtins.int stp_priority: STP priority for switch, stacks, or switch profiles
        :param Sequence[_builtins.str] switch_profiles: List of switch profile IDs
        :param Sequence[_builtins.str] switches: List of switch serial numbers
        """
        if stacks is not None:
            pulumi.set(__self__, "stacks", stacks)
        if stp_priority is not None:
            pulumi.set(__self__, "stp_priority", stp_priority)
        if switch_profiles is not None:
            pulumi.set(__self__, "switch_profiles", switch_profiles)
        if switches is not None:
            pulumi.set(__self__, "switches", switches)

    @_builtins.property
    @pulumi.getter
    def stacks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of stack IDs
        """
        return pulumi.get(self, "stacks")

    @_builtins.property
    @pulumi.getter(name="stpPriority")
    def stp_priority(self) -> Optional[_builtins.int]:
        """
        STP priority for switch, stacks, or switch profiles
        """
        return pulumi.get(self, "stp_priority")

    @_builtins.property
    @pulumi.getter(name="switchProfiles")
    def switch_profiles(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of switch profile IDs
        """
        return pulumi.get(self, "switch_profiles")

    @_builtins.property
    @pulumi.getter
    def switches(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of switch serial numbers
        """
        return pulumi.get(self, "switches")


@pulumi.output_type
class SwitchStpStpBridgePriorityResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stpPriority":
            suggest = "stp_priority"
        elif key == "switchProfiles":
            suggest = "switch_profiles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchStpStpBridgePriorityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchStpStpBridgePriorityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchStpStpBridgePriorityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stacks: Optional[Sequence[_builtins.str]] = None,
                 stp_priority: Optional[_builtins.int] = None,
                 switch_profiles: Optional[Sequence[_builtins.str]] = None,
                 switches: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] stacks: List of stack IDs
        :param _builtins.int stp_priority: STP priority for switch, stacks, or switch templates
        :param Sequence[_builtins.str] switch_profiles: List of switch template IDs
        :param Sequence[_builtins.str] switches: List of switch serial numbers
        """
        if stacks is not None:
            pulumi.set(__self__, "stacks", stacks)
        if stp_priority is not None:
            pulumi.set(__self__, "stp_priority", stp_priority)
        if switch_profiles is not None:
            pulumi.set(__self__, "switch_profiles", switch_profiles)
        if switches is not None:
            pulumi.set(__self__, "switches", switches)

    @_builtins.property
    @pulumi.getter
    def stacks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of stack IDs
        """
        return pulumi.get(self, "stacks")

    @_builtins.property
    @pulumi.getter(name="stpPriority")
    def stp_priority(self) -> Optional[_builtins.int]:
        """
        STP priority for switch, stacks, or switch templates
        """
        return pulumi.get(self, "stp_priority")

    @_builtins.property
    @pulumi.getter(name="switchProfiles")
    def switch_profiles(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of switch template IDs
        """
        return pulumi.get(self, "switch_profiles")

    @_builtins.property
    @pulumi.getter
    def switches(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of switch serial numbers
        """
        return pulumi.get(self, "switches")


@pulumi.output_type
class SyslogServersServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str host: The IP address of the syslog server
        :param _builtins.int port: The port of the syslog server
        :param Sequence[_builtins.str] roles: A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The IP address of the syslog server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port of the syslog server
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class TrafficAnalysisCustomPieChartItem(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the custom pie chart item.
        :param _builtins.str type: The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
        :param _builtins.str value: The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
               (see sample request/response for more details).
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the custom pie chart item.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
        (see sample request/response for more details).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class UnbindItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enrollmentString":
            suggest = "enrollment_string"
        elif key == "isBoundToConfigTemplate":
            suggest = "is_bound_to_config_template"
        elif key == "organizationId":
            suggest = "organization_id"
        elif key == "productTypes":
            suggest = "product_types"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UnbindItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UnbindItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UnbindItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enrollment_string: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 is_bound_to_config_template: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 notes: Optional[_builtins.str] = None,
                 organization_id: Optional[_builtins.str] = None,
                 product_types: Optional[Sequence[_builtins.str]] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 time_zone: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str enrollment_string: Enrollment string for the network
        :param _builtins.str id: Network ID
        :param _builtins.bool is_bound_to_config_template: If the network is bound to a config template
        :param _builtins.str name: Network name
        :param _builtins.str notes: Notes for the network
        :param _builtins.str organization_id: Organization ID
        :param Sequence[_builtins.str] product_types: List of the product types that the network supports
        :param Sequence[_builtins.str] tags: Network tags
        :param _builtins.str time_zone: Timezone of the network
        :param _builtins.str url: URL to the network Dashboard UI
        """
        if enrollment_string is not None:
            pulumi.set(__self__, "enrollment_string", enrollment_string)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_bound_to_config_template is not None:
            pulumi.set(__self__, "is_bound_to_config_template", is_bound_to_config_template)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)
        if product_types is not None:
            pulumi.set(__self__, "product_types", product_types)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="enrollmentString")
    def enrollment_string(self) -> Optional[_builtins.str]:
        """
        Enrollment string for the network
        """
        return pulumi.get(self, "enrollment_string")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Network ID
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isBoundToConfigTemplate")
    def is_bound_to_config_template(self) -> Optional[_builtins.bool]:
        """
        If the network is bound to a config template
        """
        return pulumi.get(self, "is_bound_to_config_template")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Network name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[_builtins.str]:
        """
        Notes for the network
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[_builtins.str]:
        """
        Organization ID
        """
        return pulumi.get(self, "organization_id")

    @_builtins.property
    @pulumi.getter(name="productTypes")
    def product_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of the product types that the network supports
        """
        return pulumi.get(self, "product_types")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Network tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        Timezone of the network
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL to the network Dashboard UI
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class UnbindParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retainConfigs":
            suggest = "retain_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UnbindParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UnbindParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UnbindParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retain_configs: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool retain_configs: Optional boolean to retain all the current configs given by the template.
        """
        if retain_configs is not None:
            pulumi.set(__self__, "retain_configs", retain_configs)

    @_builtins.property
    @pulumi.getter(name="retainConfigs")
    def retain_configs(self) -> Optional[_builtins.bool]:
        """
        Optional boolean to retain all the current configs given by the template.
        """
        return pulumi.get(self, "retain_configs")


@pulumi.output_type
class VlanProfilesAssignmentsReassignItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stackIds":
            suggest = "stack_ids"
        elif key == "vlanProfile":
            suggest = "vlan_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VlanProfilesAssignmentsReassignItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VlanProfilesAssignmentsReassignItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VlanProfilesAssignmentsReassignItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 serials: Optional[Sequence[_builtins.str]] = None,
                 stack_ids: Optional[Sequence[_builtins.str]] = None,
                 vlan_profile: Optional['outputs.VlanProfilesAssignmentsReassignItemVlanProfile'] = None):
        """
        :param Sequence[_builtins.str] serials: Array of Device Serials
        :param Sequence[_builtins.str] stack_ids: Array of Switch Stack IDs
        :param 'VlanProfilesAssignmentsReassignItemVlanProfileArgs' vlan_profile: The VLAN Profile
        """
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if stack_ids is not None:
            pulumi.set(__self__, "stack_ids", stack_ids)
        if vlan_profile is not None:
            pulumi.set(__self__, "vlan_profile", vlan_profile)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of Device Serials
        """
        return pulumi.get(self, "serials")

    @_builtins.property
    @pulumi.getter(name="stackIds")
    def stack_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of Switch Stack IDs
        """
        return pulumi.get(self, "stack_ids")

    @_builtins.property
    @pulumi.getter(name="vlanProfile")
    def vlan_profile(self) -> Optional['outputs.VlanProfilesAssignmentsReassignItemVlanProfile']:
        """
        The VLAN Profile
        """
        return pulumi.get(self, "vlan_profile")


@pulumi.output_type
class VlanProfilesAssignmentsReassignItemVlanProfile(dict):
    def __init__(__self__, *,
                 iname: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str iname: IName of the VLAN Profile
        :param _builtins.str name: Name of the VLAN Profile
        """
        if iname is not None:
            pulumi.set(__self__, "iname", iname)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def iname(self) -> Optional[_builtins.str]:
        """
        IName of the VLAN Profile
        """
        return pulumi.get(self, "iname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the VLAN Profile
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VlanProfilesAssignmentsReassignParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stackIds":
            suggest = "stack_ids"
        elif key == "vlanProfile":
            suggest = "vlan_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VlanProfilesAssignmentsReassignParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VlanProfilesAssignmentsReassignParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VlanProfilesAssignmentsReassignParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 serials: Optional[Sequence[_builtins.str]] = None,
                 stack_ids: Optional[Sequence[_builtins.str]] = None,
                 vlan_profile: Optional['outputs.VlanProfilesAssignmentsReassignParametersVlanProfile'] = None):
        """
        :param Sequence[_builtins.str] serials: Array of Device Serials
        :param Sequence[_builtins.str] stack_ids: Array of Switch Stack IDs
        :param 'VlanProfilesAssignmentsReassignParametersVlanProfileArgs' vlan_profile: The VLAN Profile
        """
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if stack_ids is not None:
            pulumi.set(__self__, "stack_ids", stack_ids)
        if vlan_profile is not None:
            pulumi.set(__self__, "vlan_profile", vlan_profile)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of Device Serials
        """
        return pulumi.get(self, "serials")

    @_builtins.property
    @pulumi.getter(name="stackIds")
    def stack_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of Switch Stack IDs
        """
        return pulumi.get(self, "stack_ids")

    @_builtins.property
    @pulumi.getter(name="vlanProfile")
    def vlan_profile(self) -> Optional['outputs.VlanProfilesAssignmentsReassignParametersVlanProfile']:
        """
        The VLAN Profile
        """
        return pulumi.get(self, "vlan_profile")


@pulumi.output_type
class VlanProfilesAssignmentsReassignParametersVlanProfile(dict):
    def __init__(__self__, *,
                 iname: Optional[_builtins.str] = None):
        """
        :param _builtins.str iname: IName of the VLAN Profile
        """
        if iname is not None:
            pulumi.set(__self__, "iname", iname)

    @_builtins.property
    @pulumi.getter
    def iname(self) -> Optional[_builtins.str]:
        """
        IName of the VLAN Profile
        """
        return pulumi.get(self, "iname")


@pulumi.output_type
class VlanProfilesVlanGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanIds":
            suggest = "vlan_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VlanProfilesVlanGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VlanProfilesVlanGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VlanProfilesVlanGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 vlan_ids: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the VLAN, string length must be from 1 to 32 characters
        :param _builtins.str vlan_ids: Comma-separated VLAN IDs or ID ranges
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the VLAN, string length must be from 1 to 32 characters
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[_builtins.str]:
        """
        Comma-separated VLAN IDs or ID ranges
        """
        return pulumi.get(self, "vlan_ids")


@pulumi.output_type
class VlanProfilesVlanName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adaptivePolicyGroup":
            suggest = "adaptive_policy_group"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VlanProfilesVlanName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VlanProfilesVlanName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VlanProfilesVlanName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adaptive_policy_group: Optional['outputs.VlanProfilesVlanNameAdaptivePolicyGroup'] = None,
                 name: Optional[_builtins.str] = None,
                 vlan_id: Optional[_builtins.str] = None):
        """
        :param 'VlanProfilesVlanNameAdaptivePolicyGroupArgs' adaptive_policy_group: Adaptive Policy Group assigned to Vlan ID
        :param _builtins.str name: Name of the VLAN, string length must be from 1 to 32 characters
        :param _builtins.str vlan_id: VLAN ID
        """
        if adaptive_policy_group is not None:
            pulumi.set(__self__, "adaptive_policy_group", adaptive_policy_group)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter(name="adaptivePolicyGroup")
    def adaptive_policy_group(self) -> Optional['outputs.VlanProfilesVlanNameAdaptivePolicyGroup']:
        """
        Adaptive Policy Group assigned to Vlan ID
        """
        return pulumi.get(self, "adaptive_policy_group")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the VLAN, string length must be from 1 to 32 characters
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        """
        VLAN ID
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class VlanProfilesVlanNameAdaptivePolicyGroup(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Adaptive Policy Group ID
        :param _builtins.str name: Adaptive Policy Group name
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Adaptive Policy Group ID
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Adaptive Policy Group name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebhooksHttpServersPayloadTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "payloadTemplateId":
            suggest = "payload_template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhooksHttpServersPayloadTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhooksHttpServersPayloadTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhooksHttpServersPayloadTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 payload_template_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the payload template.
        :param _builtins.str payload_template_id: The ID of the payload template.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if payload_template_id is not None:
            pulumi.set(__self__, "payload_template_id", payload_template_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the payload template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="payloadTemplateId")
    def payload_template_id(self) -> Optional[_builtins.str]:
        """
        The ID of the payload template.
        """
        return pulumi.get(self, "payload_template_id")


@pulumi.output_type
class WebhooksPayloadTemplatesHeader(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 template: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the header attribute
        :param _builtins.str template: The value returned in the header attribute, in liquid template
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the header attribute
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        The value returned in the header attribute, in liquid template
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class WebhooksPayloadTemplatesSharing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byNetwork":
            suggest = "by_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhooksPayloadTemplatesSharing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhooksPayloadTemplatesSharing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhooksPayloadTemplatesSharing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 by_network: Optional['outputs.WebhooksPayloadTemplatesSharingByNetwork'] = None):
        """
        :param 'WebhooksPayloadTemplatesSharingByNetworkArgs' by_network: Information on network access to the template
        """
        if by_network is not None:
            pulumi.set(__self__, "by_network", by_network)

    @_builtins.property
    @pulumi.getter(name="byNetwork")
    def by_network(self) -> Optional['outputs.WebhooksPayloadTemplatesSharingByNetwork']:
        """
        Information on network access to the template
        """
        return pulumi.get(self, "by_network")


@pulumi.output_type
class WebhooksPayloadTemplatesSharingByNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminsCanModify":
            suggest = "admins_can_modify"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhooksPayloadTemplatesSharingByNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhooksPayloadTemplatesSharingByNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhooksPayloadTemplatesSharingByNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admins_can_modify: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool admins_can_modify: Indicates whether network admins may modify this template
        """
        if admins_can_modify is not None:
            pulumi.set(__self__, "admins_can_modify", admins_can_modify)

    @_builtins.property
    @pulumi.getter(name="adminsCanModify")
    def admins_can_modify(self) -> Optional[_builtins.bool]:
        """
        Indicates whether network admins may modify this template
        """
        return pulumi.get(self, "admins_can_modify")


@pulumi.output_type
class WirelessAlternateManagementInterfaceAccessPoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alternateManagementIp":
            suggest = "alternate_management_ip"
        elif key == "subnetMask":
            suggest = "subnet_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessAlternateManagementInterfaceAccessPoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessAlternateManagementInterfaceAccessPoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessAlternateManagementInterfaceAccessPoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alternate_management_ip: Optional[_builtins.str] = None,
                 dns1: Optional[_builtins.str] = None,
                 dns2: Optional[_builtins.str] = None,
                 gateway: Optional[_builtins.str] = None,
                 serial: Optional[_builtins.str] = None,
                 subnet_mask: Optional[_builtins.str] = None):
        """
        :param _builtins.str alternate_management_ip: Wireless alternate management interface device IP. Provide an empty string to remove alternate management IP assignment
        :param _builtins.str dns1: Primary DNS must be in IP format
        :param _builtins.str dns2: Optional secondary DNS must be in IP format
        :param _builtins.str gateway: Gateway must be in IP format
        :param _builtins.str serial: Serial number of access point to be configured with alternate management IP
        :param _builtins.str subnet_mask: Subnet mask must be in IP format
        """
        if alternate_management_ip is not None:
            pulumi.set(__self__, "alternate_management_ip", alternate_management_ip)
        if dns1 is not None:
            pulumi.set(__self__, "dns1", dns1)
        if dns2 is not None:
            pulumi.set(__self__, "dns2", dns2)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)

    @_builtins.property
    @pulumi.getter(name="alternateManagementIp")
    def alternate_management_ip(self) -> Optional[_builtins.str]:
        """
        Wireless alternate management interface device IP. Provide an empty string to remove alternate management IP assignment
        """
        return pulumi.get(self, "alternate_management_ip")

    @_builtins.property
    @pulumi.getter
    def dns1(self) -> Optional[_builtins.str]:
        """
        Primary DNS must be in IP format
        """
        return pulumi.get(self, "dns1")

    @_builtins.property
    @pulumi.getter
    def dns2(self) -> Optional[_builtins.str]:
        """
        Optional secondary DNS must be in IP format
        """
        return pulumi.get(self, "dns2")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        Gateway must be in IP format
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        Serial number of access point to be configured with alternate management IP
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[_builtins.str]:
        """
        Subnet mask must be in IP format
        """
        return pulumi.get(self, "subnet_mask")


@pulumi.output_type
class WirelessBillingPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthLimits":
            suggest = "bandwidth_limits"
        elif key == "timeLimit":
            suggest = "time_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessBillingPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessBillingPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessBillingPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_limits: Optional['outputs.WirelessBillingPlanBandwidthLimits'] = None,
                 id: Optional[_builtins.str] = None,
                 price: Optional[_builtins.float] = None,
                 time_limit: Optional[_builtins.str] = None):
        """
        :param 'WirelessBillingPlanBandwidthLimitsArgs' bandwidth_limits: The uplink bandwidth settings for the pricing plan.
        :param _builtins.str id: The id of the pricing plan to update.
        :param _builtins.float price: The price of the billing plan.
        :param _builtins.str time_limit: The time limit of the pricing plan in minutes.
        """
        if bandwidth_limits is not None:
            pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if price is not None:
            pulumi.set(__self__, "price", price)
        if time_limit is not None:
            pulumi.set(__self__, "time_limit", time_limit)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> Optional['outputs.WirelessBillingPlanBandwidthLimits']:
        """
        The uplink bandwidth settings for the pricing plan.
        """
        return pulumi.get(self, "bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The id of the pricing plan to update.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def price(self) -> Optional[_builtins.float]:
        """
        The price of the billing plan.
        """
        return pulumi.get(self, "price")

    @_builtins.property
    @pulumi.getter(name="timeLimit")
    def time_limit(self) -> Optional[_builtins.str]:
        """
        The time limit of the pricing plan in minutes.
        """
        return pulumi.get(self, "time_limit")


@pulumi.output_type
class WirelessBillingPlanBandwidthLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitDown":
            suggest = "limit_down"
        elif key == "limitUp":
            suggest = "limit_up"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessBillingPlanBandwidthLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessBillingPlanBandwidthLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessBillingPlanBandwidthLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_down: Optional[_builtins.int] = None,
                 limit_up: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit_down: The maximum download limit (integer, in Kbps).
        :param _builtins.int limit_up: The maximum upload limit (integer, in Kbps).
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[_builtins.int]:
        """
        The maximum download limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[_builtins.int]:
        """
        The maximum upload limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class WirelessEthernetPortsProfilesAssignItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileId":
            suggest = "profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessEthernetPortsProfilesAssignItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessEthernetPortsProfilesAssignItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessEthernetPortsProfilesAssignItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 profile_id: Optional[_builtins.str] = None,
                 serials: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str profile_id: AP profile ID
        :param Sequence[_builtins.str] serials: List of updated AP serials
        """
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        AP profile ID
        """
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of updated AP serials
        """
        return pulumi.get(self, "serials")


@pulumi.output_type
class WirelessEthernetPortsProfilesAssignParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileId":
            suggest = "profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessEthernetPortsProfilesAssignParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessEthernetPortsProfilesAssignParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessEthernetPortsProfilesAssignParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 profile_id: Optional[_builtins.str] = None,
                 serials: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str profile_id: AP profile ID
        :param Sequence[_builtins.str] serials: List of AP serials
        """
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        AP profile ID
        """
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of AP serials
        """
        return pulumi.get(self, "serials")


@pulumi.output_type
class WirelessEthernetPortsProfilesPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pskGroupId":
            suggest = "psk_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessEthernetPortsProfilesPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessEthernetPortsProfilesPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessEthernetPortsProfilesPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 number: Optional[_builtins.int] = None,
                 psk_group_id: Optional[_builtins.str] = None,
                 ssid: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Enabled
        :param _builtins.str name: Name
        :param _builtins.int number: Number
        :param _builtins.str psk_group_id: PSK Group number
        :param _builtins.int ssid: Ssid number
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if psk_group_id is not None:
            pulumi.set(__self__, "psk_group_id", psk_group_id)
        if ssid is not None:
            pulumi.set(__self__, "ssid", ssid)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def number(self) -> Optional[_builtins.int]:
        """
        Number
        """
        return pulumi.get(self, "number")

    @_builtins.property
    @pulumi.getter(name="pskGroupId")
    def psk_group_id(self) -> Optional[_builtins.str]:
        """
        PSK Group number
        """
        return pulumi.get(self, "psk_group_id")

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> Optional[_builtins.int]:
        """
        Ssid number
        """
        return pulumi.get(self, "ssid")


@pulumi.output_type
class WirelessEthernetPortsProfilesSetDefaultItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileId":
            suggest = "profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessEthernetPortsProfilesSetDefaultItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessEthernetPortsProfilesSetDefaultItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessEthernetPortsProfilesSetDefaultItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 profile_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str profile_id: AP profile ID
        """
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        AP profile ID
        """
        return pulumi.get(self, "profile_id")


@pulumi.output_type
class WirelessEthernetPortsProfilesSetDefaultParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileId":
            suggest = "profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessEthernetPortsProfilesSetDefaultParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessEthernetPortsProfilesSetDefaultParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessEthernetPortsProfilesSetDefaultParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 profile_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str profile_id: AP profile ID
        """
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        AP profile ID
        """
        return pulumi.get(self, "profile_id")


@pulumi.output_type
class WirelessEthernetPortsProfilesUsbPort(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 ssid: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Enabled
        :param _builtins.str name: Name
        :param _builtins.int ssid: Ssid number
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ssid is not None:
            pulumi.set(__self__, "ssid", ssid)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> Optional[_builtins.int]:
        """
        Ssid number
        """
        return pulumi.get(self, "ssid")


@pulumi.output_type
class WirelessRfProfilesApBandSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesApBandSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesApBandSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesApBandSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesApBandSettingsBands'] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'. Defaults to dual.
        :param _builtins.bool band_steering_enabled: Steers client to most open band. Can be either true or false. Defaults to true.
        :param 'WirelessRfProfilesApBandSettingsBandsArgs' bands: Settings related to all bands
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'. Defaults to dual.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band. Can be either true or false. Defaults to true.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesApBandSettingsBands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")


@pulumi.output_type
class WirelessRfProfilesApBandSettingsBands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesFiveGhzSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelWidth":
            suggest = "channel_width"
        elif key == "maxPower":
            suggest = "max_power"
        elif key == "minBitrate":
            suggest = "min_bitrate"
        elif key == "minPower":
            suggest = "min_power"
        elif key == "validAutoChannels":
            suggest = "valid_auto_channels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesFiveGhzSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesFiveGhzSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesFiveGhzSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_width: Optional[_builtins.str] = None,
                 max_power: Optional[_builtins.int] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 min_power: Optional[_builtins.int] = None,
                 rxsop: Optional[_builtins.int] = None,
                 valid_auto_channels: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.str channel_width: Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
        :param _builtins.int max_power: Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        :param _builtins.int min_power: Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
        :param _builtins.int rxsop: The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        :param Sequence[_builtins.int] valid_auto_channels: Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165].
        """
        if channel_width is not None:
            pulumi.set(__self__, "channel_width", channel_width)
        if max_power is not None:
            pulumi.set(__self__, "max_power", max_power)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if min_power is not None:
            pulumi.set(__self__, "min_power", min_power)
        if rxsop is not None:
            pulumi.set(__self__, "rxsop", rxsop)
        if valid_auto_channels is not None:
            pulumi.set(__self__, "valid_auto_channels", valid_auto_channels)

    @_builtins.property
    @pulumi.getter(name="channelWidth")
    def channel_width(self) -> Optional[_builtins.str]:
        """
        Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
        """
        return pulumi.get(self, "channel_width")

    @_builtins.property
    @pulumi.getter(name="maxPower")
    def max_power(self) -> Optional[_builtins.int]:
        """
        Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
        """
        return pulumi.get(self, "max_power")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter(name="minPower")
    def min_power(self) -> Optional[_builtins.int]:
        """
        Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
        """
        return pulumi.get(self, "min_power")

    @_builtins.property
    @pulumi.getter
    def rxsop(self) -> Optional[_builtins.int]:
        """
        The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        """
        return pulumi.get(self, "rxsop")

    @_builtins.property
    @pulumi.getter(name="validAutoChannels")
    def valid_auto_channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165].
        """
        return pulumi.get(self, "valid_auto_channels")


@pulumi.output_type
class WirelessRfProfilesFlexRadios(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byModels":
            suggest = "by_models"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesFlexRadios. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesFlexRadios.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesFlexRadios.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 by_models: Optional[Sequence['outputs.WirelessRfProfilesFlexRadiosByModel']] = None):
        """
        :param Sequence['WirelessRfProfilesFlexRadiosByModelArgs'] by_models: Flex radios by model.
        """
        if by_models is not None:
            pulumi.set(__self__, "by_models", by_models)

    @_builtins.property
    @pulumi.getter(name="byModels")
    def by_models(self) -> Optional[Sequence['outputs.WirelessRfProfilesFlexRadiosByModel']]:
        """
        Flex radios by model.
        """
        return pulumi.get(self, "by_models")


@pulumi.output_type
class WirelessRfProfilesFlexRadiosByModel(dict):
    def __init__(__self__, *,
                 bands: Optional[Sequence[_builtins.str]] = None,
                 model: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] bands: Band to use for each flex radio. For example, ['6'] will set the AP's first flex radio to 6 GHz
        :param _builtins.str model: Model of the AP
        """
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[Sequence[_builtins.str]]:
        """
        Band to use for each flex radio. For example, ['6'] will set the AP's first flex radio to 6 GHz
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Model of the AP
        """
        return pulumi.get(self, "model")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettings(dict):
    def __init__(__self__, *,
                 status0: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus0'] = None,
                 status1: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus1'] = None,
                 status10: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus10'] = None,
                 status11: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus11'] = None,
                 status12: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus12'] = None,
                 status13: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus13'] = None,
                 status14: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus14'] = None,
                 status2: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus2'] = None,
                 status3: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus3'] = None,
                 status4: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus4'] = None,
                 status5: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus5'] = None,
                 status6: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus6'] = None,
                 status7: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus7'] = None,
                 status8: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus8'] = None,
                 status9: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus9'] = None):
        """
        :param 'WirelessRfProfilesPerSsidSettingsStatus0Args' status0: Settings for SSID 0
        :param 'WirelessRfProfilesPerSsidSettingsStatus1Args' status1: Settings for SSID 1
        :param 'WirelessRfProfilesPerSsidSettingsStatus10Args' status10: Settings for SSID 10
        :param 'WirelessRfProfilesPerSsidSettingsStatus11Args' status11: Settings for SSID 11
        :param 'WirelessRfProfilesPerSsidSettingsStatus12Args' status12: Settings for SSID 12
        :param 'WirelessRfProfilesPerSsidSettingsStatus13Args' status13: Settings for SSID 13
        :param 'WirelessRfProfilesPerSsidSettingsStatus14Args' status14: Settings for SSID 14
        :param 'WirelessRfProfilesPerSsidSettingsStatus2Args' status2: Settings for SSID 2
        :param 'WirelessRfProfilesPerSsidSettingsStatus3Args' status3: Settings for SSID 3
        :param 'WirelessRfProfilesPerSsidSettingsStatus4Args' status4: Settings for SSID 4
        :param 'WirelessRfProfilesPerSsidSettingsStatus5Args' status5: Settings for SSID 5
        :param 'WirelessRfProfilesPerSsidSettingsStatus6Args' status6: Settings for SSID 6
        :param 'WirelessRfProfilesPerSsidSettingsStatus7Args' status7: Settings for SSID 7
        :param 'WirelessRfProfilesPerSsidSettingsStatus8Args' status8: Settings for SSID 8
        :param 'WirelessRfProfilesPerSsidSettingsStatus9Args' status9: Settings for SSID 9
        """
        if status0 is not None:
            pulumi.set(__self__, "status0", status0)
        if status1 is not None:
            pulumi.set(__self__, "status1", status1)
        if status10 is not None:
            pulumi.set(__self__, "status10", status10)
        if status11 is not None:
            pulumi.set(__self__, "status11", status11)
        if status12 is not None:
            pulumi.set(__self__, "status12", status12)
        if status13 is not None:
            pulumi.set(__self__, "status13", status13)
        if status14 is not None:
            pulumi.set(__self__, "status14", status14)
        if status2 is not None:
            pulumi.set(__self__, "status2", status2)
        if status3 is not None:
            pulumi.set(__self__, "status3", status3)
        if status4 is not None:
            pulumi.set(__self__, "status4", status4)
        if status5 is not None:
            pulumi.set(__self__, "status5", status5)
        if status6 is not None:
            pulumi.set(__self__, "status6", status6)
        if status7 is not None:
            pulumi.set(__self__, "status7", status7)
        if status8 is not None:
            pulumi.set(__self__, "status8", status8)
        if status9 is not None:
            pulumi.set(__self__, "status9", status9)

    @_builtins.property
    @pulumi.getter
    def status0(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus0']:
        """
        Settings for SSID 0
        """
        return pulumi.get(self, "status0")

    @_builtins.property
    @pulumi.getter
    def status1(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus1']:
        """
        Settings for SSID 1
        """
        return pulumi.get(self, "status1")

    @_builtins.property
    @pulumi.getter
    def status10(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus10']:
        """
        Settings for SSID 10
        """
        return pulumi.get(self, "status10")

    @_builtins.property
    @pulumi.getter
    def status11(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus11']:
        """
        Settings for SSID 11
        """
        return pulumi.get(self, "status11")

    @_builtins.property
    @pulumi.getter
    def status12(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus12']:
        """
        Settings for SSID 12
        """
        return pulumi.get(self, "status12")

    @_builtins.property
    @pulumi.getter
    def status13(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus13']:
        """
        Settings for SSID 13
        """
        return pulumi.get(self, "status13")

    @_builtins.property
    @pulumi.getter
    def status14(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus14']:
        """
        Settings for SSID 14
        """
        return pulumi.get(self, "status14")

    @_builtins.property
    @pulumi.getter
    def status2(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus2']:
        """
        Settings for SSID 2
        """
        return pulumi.get(self, "status2")

    @_builtins.property
    @pulumi.getter
    def status3(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus3']:
        """
        Settings for SSID 3
        """
        return pulumi.get(self, "status3")

    @_builtins.property
    @pulumi.getter
    def status4(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus4']:
        """
        Settings for SSID 4
        """
        return pulumi.get(self, "status4")

    @_builtins.property
    @pulumi.getter
    def status5(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus5']:
        """
        Settings for SSID 5
        """
        return pulumi.get(self, "status5")

    @_builtins.property
    @pulumi.getter
    def status6(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus6']:
        """
        Settings for SSID 6
        """
        return pulumi.get(self, "status6")

    @_builtins.property
    @pulumi.getter
    def status7(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus7']:
        """
        Settings for SSID 7
        """
        return pulumi.get(self, "status7")

    @_builtins.property
    @pulumi.getter
    def status8(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus8']:
        """
        Settings for SSID 8
        """
        return pulumi.get(self, "status8")

    @_builtins.property
    @pulumi.getter
    def status9(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus9']:
        """
        Settings for SSID 9
        """
        return pulumi.get(self, "status9")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus0(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus0. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus0.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus0.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus0Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus0BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus0Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus0Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus10(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus10. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus10.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus10.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus10Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus10BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus10Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus10Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus11(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus11. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus11.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus11.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus11Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus11BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus11Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus11Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus12(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus12. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus12.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus12.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus12Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus12BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus12Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus12Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus13(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus13. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus13.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus13.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus13Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus13BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus13Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus13Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus14(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus14. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus14.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus14.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus14Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus14BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus14Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus14Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus1Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus1BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus1Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus1Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus2Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus2BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus2Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus2Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus3Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus3BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus3Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus3Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus4Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus4BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus4Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus4Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus5(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus5. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus5.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus5.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus5Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus5BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus5Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus5Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus6Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus6BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus6Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus6Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus7(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus7. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus7.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus7.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus7Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus7BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus7Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus7Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus8(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus8. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus8.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus8.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus8Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus8BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus8Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus8Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus9(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandOperationMode":
            suggest = "band_operation_mode"
        elif key == "bandSteeringEnabled":
            suggest = "band_steering_enabled"
        elif key == "minBitrate":
            suggest = "min_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesPerSsidSettingsStatus9. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus9.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesPerSsidSettingsStatus9.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 band_operation_mode: Optional[_builtins.str] = None,
                 band_steering_enabled: Optional[_builtins.bool] = None,
                 bands: Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus9Bands'] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'WirelessRfProfilesPerSsidSettingsStatus9BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[_builtins.str]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[_builtins.bool]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional['outputs.WirelessRfProfilesPerSsidSettingsStatus9Bands']:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessRfProfilesPerSsidSettingsStatus9Bands(dict):
    def __init__(__self__, *,
                 enableds: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class WirelessRfProfilesSixGhzSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelWidth":
            suggest = "channel_width"
        elif key == "maxPower":
            suggest = "max_power"
        elif key == "minBitrate":
            suggest = "min_bitrate"
        elif key == "minPower":
            suggest = "min_power"
        elif key == "validAutoChannels":
            suggest = "valid_auto_channels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesSixGhzSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesSixGhzSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesSixGhzSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_width: Optional[_builtins.str] = None,
                 max_power: Optional[_builtins.int] = None,
                 min_bitrate: Optional[_builtins.int] = None,
                 min_power: Optional[_builtins.int] = None,
                 rxsop: Optional[_builtins.int] = None,
                 valid_auto_channels: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.str channel_width: Sets channel width (MHz) for 6Ghz band. Can be one of '0', '20', '40', '80' or '160'. Defaults to auto.
        :param _builtins.int max_power: Sets max power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 30.
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of 6Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        :param _builtins.int min_power: Sets min power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 8.
        :param _builtins.int rxsop: The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        :param Sequence[_builtins.int] valid_auto_channels: Sets valid auto channels for 6Ghz band. Can be one of '1', '5', '9', '13', '17', '21', '25', '29', '33', '37', '41', '45', '49', '53', '57', '61', '65', '69', '73', '77', '81', '85', '89', '93', '97', '101', '105', '109', '113', '117', '121', '125', '129', '133', '137', '141', '145', '149', '153', '157', '161', '165', '169', '173', '177', '181', '185', '189', '193', '197', '201', '205', '209', '213', '217', '221', '225', '229' or '233'. Defaults to auto.
        """
        if channel_width is not None:
            pulumi.set(__self__, "channel_width", channel_width)
        if max_power is not None:
            pulumi.set(__self__, "max_power", max_power)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if min_power is not None:
            pulumi.set(__self__, "min_power", min_power)
        if rxsop is not None:
            pulumi.set(__self__, "rxsop", rxsop)
        if valid_auto_channels is not None:
            pulumi.set(__self__, "valid_auto_channels", valid_auto_channels)

    @_builtins.property
    @pulumi.getter(name="channelWidth")
    def channel_width(self) -> Optional[_builtins.str]:
        """
        Sets channel width (MHz) for 6Ghz band. Can be one of '0', '20', '40', '80' or '160'. Defaults to auto.
        """
        return pulumi.get(self, "channel_width")

    @_builtins.property
    @pulumi.getter(name="maxPower")
    def max_power(self) -> Optional[_builtins.int]:
        """
        Sets max power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 30.
        """
        return pulumi.get(self, "max_power")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.int]:
        """
        Sets min bitrate (Mbps) of 6Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter(name="minPower")
    def min_power(self) -> Optional[_builtins.int]:
        """
        Sets min power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 8.
        """
        return pulumi.get(self, "min_power")

    @_builtins.property
    @pulumi.getter
    def rxsop(self) -> Optional[_builtins.int]:
        """
        The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        """
        return pulumi.get(self, "rxsop")

    @_builtins.property
    @pulumi.getter(name="validAutoChannels")
    def valid_auto_channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        Sets valid auto channels for 6Ghz band. Can be one of '1', '5', '9', '13', '17', '21', '25', '29', '33', '37', '41', '45', '49', '53', '57', '61', '65', '69', '73', '77', '81', '85', '89', '93', '97', '101', '105', '109', '113', '117', '121', '125', '129', '133', '137', '141', '145', '149', '153', '157', '161', '165', '169', '173', '177', '181', '185', '189', '193', '197', '201', '205', '209', '213', '217', '221', '225', '229' or '233'. Defaults to auto.
        """
        return pulumi.get(self, "valid_auto_channels")


@pulumi.output_type
class WirelessRfProfilesTransmission(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Toggle for radio transmission. When false, radios will not transmit at all.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Toggle for radio transmission. When false, radios will not transmit at all.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WirelessRfProfilesTwoFourGhzSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axEnabled":
            suggest = "ax_enabled"
        elif key == "maxPower":
            suggest = "max_power"
        elif key == "minBitrate":
            suggest = "min_bitrate"
        elif key == "minPower":
            suggest = "min_power"
        elif key == "validAutoChannels":
            suggest = "valid_auto_channels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessRfProfilesTwoFourGhzSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessRfProfilesTwoFourGhzSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessRfProfilesTwoFourGhzSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ax_enabled: Optional[_builtins.bool] = None,
                 max_power: Optional[_builtins.int] = None,
                 min_bitrate: Optional[_builtins.float] = None,
                 min_power: Optional[_builtins.int] = None,
                 rxsop: Optional[_builtins.int] = None,
                 valid_auto_channels: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.bool ax_enabled: Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
        :param _builtins.int max_power: Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
        :param _builtins.float min_bitrate: Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
        :param _builtins.int min_power: Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
        :param _builtins.int rxsop: The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        :param Sequence[_builtins.int] valid_auto_channels: Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
        """
        if ax_enabled is not None:
            pulumi.set(__self__, "ax_enabled", ax_enabled)
        if max_power is not None:
            pulumi.set(__self__, "max_power", max_power)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if min_power is not None:
            pulumi.set(__self__, "min_power", min_power)
        if rxsop is not None:
            pulumi.set(__self__, "rxsop", rxsop)
        if valid_auto_channels is not None:
            pulumi.set(__self__, "valid_auto_channels", valid_auto_channels)

    @_builtins.property
    @pulumi.getter(name="axEnabled")
    def ax_enabled(self) -> Optional[_builtins.bool]:
        """
        Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
        """
        return pulumi.get(self, "ax_enabled")

    @_builtins.property
    @pulumi.getter(name="maxPower")
    def max_power(self) -> Optional[_builtins.int]:
        """
        Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
        """
        return pulumi.get(self, "max_power")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[_builtins.float]:
        """
        Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter(name="minPower")
    def min_power(self) -> Optional[_builtins.int]:
        """
        Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
        """
        return pulumi.get(self, "min_power")

    @_builtins.property
    @pulumi.getter
    def rxsop(self) -> Optional[_builtins.int]:
        """
        The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        """
        return pulumi.get(self, "rxsop")

    @_builtins.property
    @pulumi.getter(name="validAutoChannels")
    def valid_auto_channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
        """
        return pulumi.get(self, "valid_auto_channels")


@pulumi.output_type
class WirelessSettingsNamedVlans(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolDhcpMonitoring":
            suggest = "pool_dhcp_monitoring"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSettingsNamedVlans. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSettingsNamedVlans.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSettingsNamedVlans.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_dhcp_monitoring: Optional['outputs.WirelessSettingsNamedVlansPoolDhcpMonitoring'] = None):
        """
        :param 'WirelessSettingsNamedVlansPoolDhcpMonitoringArgs' pool_dhcp_monitoring: Named VLAN Pool DHCP Monitoring settings.
        """
        if pool_dhcp_monitoring is not None:
            pulumi.set(__self__, "pool_dhcp_monitoring", pool_dhcp_monitoring)

    @_builtins.property
    @pulumi.getter(name="poolDhcpMonitoring")
    def pool_dhcp_monitoring(self) -> Optional['outputs.WirelessSettingsNamedVlansPoolDhcpMonitoring']:
        """
        Named VLAN Pool DHCP Monitoring settings.
        """
        return pulumi.get(self, "pool_dhcp_monitoring")


@pulumi.output_type
class WirelessSettingsNamedVlansPoolDhcpMonitoring(dict):
    def __init__(__self__, *,
                 duration: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int duration: The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool.
        :param _builtins.bool enabled: Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.int]:
        """
        The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WirelessSettingsRegulatoryDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSettingsRegulatoryDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSettingsRegulatoryDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSettingsRegulatoryDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_code: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 permits6e: Optional[_builtins.bool] = None):
        """
        :param _builtins.str country_code: The country code of the regulatory domain.
        :param _builtins.str name: The name of the regulatory domain for this network.
        :param _builtins.bool permits6e: Whether or not the regulatory domain for this network permits Wifi 6E.
        """
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if permits6e is not None:
            pulumi.set(__self__, "permits6e", permits6e)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[_builtins.str]:
        """
        The country code of the regulatory domain.
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the regulatory domain for this network.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permits6e(self) -> Optional[_builtins.bool]:
        """
        Whether or not the regulatory domain for this network permits Wifi 6E.
        """
        return pulumi.get(self, "permits6e")


@pulumi.output_type
class WirelessSsidsActiveDirectory(dict):
    def __init__(__self__, *,
                 credentials: Optional['outputs.WirelessSsidsActiveDirectoryCredentials'] = None,
                 servers: Optional[Sequence['outputs.WirelessSsidsActiveDirectoryServer']] = None):
        """
        :param 'WirelessSsidsActiveDirectoryCredentialsArgs' credentials: (Optional) The credentials of the user account to be used by the AP to bind to your Active Directory server. The Active Directory account should have permissions on all your Active Directory servers. Only valid if the splashPage is 'Password-protected with Active Directory'.
        :param Sequence['WirelessSsidsActiveDirectoryServerArgs'] servers: The Active Directory servers to be used for authentication.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.WirelessSsidsActiveDirectoryCredentials']:
        """
        (Optional) The credentials of the user account to be used by the AP to bind to your Active Directory server. The Active Directory account should have permissions on all your Active Directory servers. Only valid if the splashPage is 'Password-protected with Active Directory'.
        """
        return pulumi.get(self, "credentials")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.WirelessSsidsActiveDirectoryServer']]:
        """
        The Active Directory servers to be used for authentication.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class WirelessSsidsActiveDirectoryCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logonName":
            suggest = "logon_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsActiveDirectoryCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsActiveDirectoryCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsActiveDirectoryCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logon_name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None):
        """
        :param _builtins.str logon_name: The logon name of the Active Directory account.
        :param _builtins.str password: The password to the Active Directory user account.
        """
        if logon_name is not None:
            pulumi.set(__self__, "logon_name", logon_name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="logonName")
    def logon_name(self) -> Optional[_builtins.str]:
        """
        The logon name of the Active Directory account.
        """
        return pulumi.get(self, "logon_name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to the Active Directory user account.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class WirelessSsidsActiveDirectoryServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.str host: IP address (or FQDN) of your Active Directory server.
        :param _builtins.int port: (Optional) UDP port the Active Directory server listens on. By default, uses port 3268.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        IP address (or FQDN) of your Active Directory server.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        (Optional) UDP port the Active Directory server listens on. By default, uses port 3268.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class WirelessSsidsApTagsAndVlanId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsApTagsAndVlanId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsApTagsAndVlanId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsApTagsAndVlanId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 vlan_id: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] tags: Array of AP tags
        :param _builtins.int vlan_id: Numerical identifier that is assigned to the VLAN
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of AP tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.int]:
        """
        Numerical identifier that is assigned to the VLAN
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class WirelessSsidsBonjourForwardingException(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If true, Bonjour forwarding exception is enabled on this SSID. Exception is required to enable L2 isolation and Bonjour forwarding to work together.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If true, Bonjour forwarding exception is enabled on this SSID. Exception is required to enable L2 isolation and Bonjour forwarding to work together.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WirelessSsidsBonjourForwardingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsBonjourForwardingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsBonjourForwardingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsBonjourForwardingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 services: Optional[Sequence[_builtins.str]] = None,
                 vlan_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Desctiption of the bonjour forwarding rule
        :param Sequence[_builtins.str] services: A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        :param _builtins.str vlan_id: The ID of the service VLAN. Required
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Desctiption of the bonjour forwarding rule
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        """
        The ID of the service VLAN. Required
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class WirelessSsidsDeviceTypeGroupPoliciesDeviceTypePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "devicePolicy":
            suggest = "device_policy"
        elif key == "deviceType":
            suggest = "device_type"
        elif key == "groupPolicyId":
            suggest = "group_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsDeviceTypeGroupPoliciesDeviceTypePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsDeviceTypeGroupPoliciesDeviceTypePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsDeviceTypeGroupPoliciesDeviceTypePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_policy: Optional[_builtins.str] = None,
                 device_type: Optional[_builtins.str] = None,
                 group_policy_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str device_policy: The device policy. Can be one of 'Allowed', 'Blocked' or 'Group policy'
        :param _builtins.str device_type: The device type. Can be one of 'Android', 'BlackBerry', 'Chrome OS', 'iPad', 'iPhone', 'iPod', 'Mac OS X', 'Windows', 'Windows Phone', 'B&N Nook' or 'Other OS'
        :param _builtins.int group_policy_id: ID of the group policy object.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[_builtins.str]:
        """
        The device policy. Can be one of 'Allowed', 'Blocked' or 'Group policy'
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[_builtins.str]:
        """
        The device type. Can be one of 'Android', 'BlackBerry', 'Chrome OS', 'iPad', 'iPhone', 'iPod', 'Mac OS X', 'Windows', 'Windows Phone', 'B&N Nook' or 'Other OS'
        """
        return pulumi.get(self, "device_type")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[_builtins.int]:
        """
        ID of the group policy object.
        """
        return pulumi.get(self, "group_policy_id")


@pulumi.output_type
class WirelessSsidsDnsRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsCustomNameservers":
            suggest = "dns_custom_nameservers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsDnsRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsDnsRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsDnsRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_custom_nameservers: Optional[Sequence[_builtins.str]] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] dns_custom_nameservers: User specified DNS servers (up to two servers)
        :param _builtins.bool enabled: Boolean indicating whether or not DNS server rewrite is enabled. If disabled, upstream DNS will be used
        """
        if dns_custom_nameservers is not None:
            pulumi.set(__self__, "dns_custom_nameservers", dns_custom_nameservers)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="dnsCustomNameservers")
    def dns_custom_nameservers(self) -> Optional[Sequence[_builtins.str]]:
        """
        User specified DNS servers (up to two servers)
        """
        return pulumi.get(self, "dns_custom_nameservers")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating whether or not DNS server rewrite is enabled. If disabled, upstream DNS will be used
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WirelessSsidsDot11r(dict):
    def __init__(__self__, *,
                 adaptive: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool adaptive: (Optional) Whether 802.11r is adaptive or not.
        :param _builtins.bool enabled: Whether 802.11r is enabled or not.
        """
        if adaptive is not None:
            pulumi.set(__self__, "adaptive", adaptive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def adaptive(self) -> Optional[_builtins.bool]:
        """
        (Optional) Whether 802.11r is adaptive or not.
        """
        return pulumi.get(self, "adaptive")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether 802.11r is enabled or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WirelessSsidsDot11w(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 required: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether 802.11w is enabled or not.
        :param _builtins.bool required: (Optional) Whether 802.11w is required or not.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether 802.11w is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        (Optional) Whether 802.11w is required or not.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class WirelessSsidsEapOverrideEapolKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeoutInMs":
            suggest = "timeout_in_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsEapOverrideEapolKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsEapOverrideEapolKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsEapOverrideEapolKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retries: Optional[_builtins.int] = None,
                 timeout_in_ms: Optional[_builtins.int] = None):
        """
        :param _builtins.int retries: Maximum number of EAPOL key retries.
        :param _builtins.int timeout_in_ms: EAPOL Key timeout in milliseconds.
        """
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if timeout_in_ms is not None:
            pulumi.set(__self__, "timeout_in_ms", timeout_in_ms)

    @_builtins.property
    @pulumi.getter
    def retries(self) -> Optional[_builtins.int]:
        """
        Maximum number of EAPOL key retries.
        """
        return pulumi.get(self, "retries")

    @_builtins.property
    @pulumi.getter(name="timeoutInMs")
    def timeout_in_ms(self) -> Optional[_builtins.int]:
        """
        EAPOL Key timeout in milliseconds.
        """
        return pulumi.get(self, "timeout_in_ms")


@pulumi.output_type
class WirelessSsidsEapOverrideIdentity(dict):
    def __init__(__self__, *,
                 retries: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.int retries: Maximum number of EAP retries.
        :param _builtins.int timeout: EAP timeout in seconds.
        """
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def retries(self) -> Optional[_builtins.int]:
        """
        Maximum number of EAP retries.
        """
        return pulumi.get(self, "retries")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        EAP timeout in seconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class WirelessSsidsFirewallL3FirewallRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destCidr":
            suggest = "dest_cidr"
        elif key == "destPort":
            suggest = "dest_port"
        elif key == "ipVer":
            suggest = "ip_ver"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsFirewallL3FirewallRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsFirewallL3FirewallRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsFirewallL3FirewallRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 dest_cidr: Optional[_builtins.str] = None,
                 dest_port: Optional[_builtins.str] = None,
                 ip_ver: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param _builtins.str dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.str ip_ver: Ip Ver
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if ip_ver is not None:
            pulumi.set(__self__, "ip_ver", ip_ver)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter(name="ipVer")
    def ip_ver(self) -> Optional[_builtins.str]:
        """
        Ip Ver
        """
        return pulumi.get(self, "ip_ver")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class WirelessSsidsFirewallL3FirewallRulesRulesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destCidr":
            suggest = "dest_cidr"
        elif key == "destPort":
            suggest = "dest_port"
        elif key == "ipVer":
            suggest = "ip_ver"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsFirewallL3FirewallRulesRulesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsFirewallL3FirewallRulesRulesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsFirewallL3FirewallRulesRulesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 dest_cidr: Optional[_builtins.str] = None,
                 dest_port: Optional[_builtins.str] = None,
                 ip_ver: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param _builtins.str dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.str ip_ver: Ip Version
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if ip_ver is not None:
            pulumi.set(__self__, "ip_ver", ip_ver)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter(name="ipVer")
    def ip_ver(self) -> Optional[_builtins.str]:
        """
        Ip Version
        """
        return pulumi.get(self, "ip_ver")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class WirelessSsidsFirewallL7FirewallRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueLists":
            suggest = "value_lists"
        elif key == "valueObj":
            suggest = "value_obj"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsFirewallL7FirewallRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsFirewallL7FirewallRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsFirewallL7FirewallRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None,
                 value_lists: Optional[Sequence[_builtins.str]] = None,
                 value_obj: Optional['outputs.WirelessSsidsFirewallL7FirewallRulesRuleValueObj'] = None):
        """
        :param _builtins.str policy: 'Deny' traffic specified by this rule
        :param _builtins.str type: Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        :param _builtins.str value: The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected.
        :param Sequence[_builtins.str] value_lists: The 'value_list' of what you want to block. Send a list in request
        :param 'WirelessSsidsFirewallL7FirewallRulesRuleValueObjArgs' value_obj: The 'value_obj' of what you want to block. Send a dict in request
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)
        if value_obj is not None:
            pulumi.set(__self__, "value_obj", value_obj)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        'Deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        The 'value_list' of what you want to block. Send a list in request
        """
        return pulumi.get(self, "value_lists")

    @_builtins.property
    @pulumi.getter(name="valueObj")
    def value_obj(self) -> Optional['outputs.WirelessSsidsFirewallL7FirewallRulesRuleValueObj']:
        """
        The 'value_obj' of what you want to block. Send a dict in request
        """
        return pulumi.get(self, "value_obj")


@pulumi.output_type
class WirelessSsidsFirewallL7FirewallRulesRuleValueObj(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessSsidsGre(dict):
    def __init__(__self__, *,
                 concentrator: Optional['outputs.WirelessSsidsGreConcentrator'] = None,
                 key: Optional[_builtins.int] = None):
        """
        :param 'WirelessSsidsGreConcentratorArgs' concentrator: The EoGRE concentrator's settings
        :param _builtins.int key: Optional numerical identifier that will add the GRE key field to the GRE header. Used to identify an individual traffic flow within a tunnel.
        """
        if concentrator is not None:
            pulumi.set(__self__, "concentrator", concentrator)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def concentrator(self) -> Optional['outputs.WirelessSsidsGreConcentrator']:
        """
        The EoGRE concentrator's settings
        """
        return pulumi.get(self, "concentrator")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.int]:
        """
        Optional numerical identifier that will add the GRE key field to the GRE header. Used to identify an individual traffic flow within a tunnel.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class WirelessSsidsGreConcentrator(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: The EoGRE concentrator's IP or FQDN. This param is required when ipAssignmentMode is 'Ethernet over GRE'.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The EoGRE concentrator's IP or FQDN. This param is required when ipAssignmentMode is 'Ethernet over GRE'.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class WirelessSsidsHotspot20MccMnc(dict):
    def __init__(__self__, *,
                 mcc: Optional[_builtins.str] = None,
                 mnc: Optional[_builtins.str] = None):
        """
        :param _builtins.str mcc: MCC value
        :param _builtins.str mnc: MNC value
        """
        if mcc is not None:
            pulumi.set(__self__, "mcc", mcc)
        if mnc is not None:
            pulumi.set(__self__, "mnc", mnc)

    @_builtins.property
    @pulumi.getter
    def mcc(self) -> Optional[_builtins.str]:
        """
        MCC value
        """
        return pulumi.get(self, "mcc")

    @_builtins.property
    @pulumi.getter
    def mnc(self) -> Optional[_builtins.str]:
        """
        MNC value
        """
        return pulumi.get(self, "mnc")


@pulumi.output_type
class WirelessSsidsHotspot20NaiRealm(dict):
    def __init__(__self__, *,
                 format: Optional[_builtins.str] = None,
                 methods: Optional[Sequence['outputs.WirelessSsidsHotspot20NaiRealmMethod']] = None,
                 name: Optional[_builtins.str] = None,
                 realm: Optional[_builtins.str] = None):
        """
        :param _builtins.str format: The format for the realm ('1' or '0')
        :param Sequence['WirelessSsidsHotspot20NaiRealmMethodArgs'] methods: An array of EAP methods for the realm.
        :param _builtins.str realm: The name of the realm
        """
        if format is not None:
            pulumi.set(__self__, "format", format)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        The format for the realm ('1' or '0')
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[Sequence['outputs.WirelessSsidsHotspot20NaiRealmMethod']]:
        """
        An array of EAP methods for the realm.
        """
        return pulumi.get(self, "methods")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def realm(self) -> Optional[_builtins.str]:
        """
        The name of the realm
        """
        return pulumi.get(self, "realm")


@pulumi.output_type
class WirelessSsidsHotspot20NaiRealmMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationTypes":
            suggest = "authentication_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsHotspot20NaiRealmMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsHotspot20NaiRealmMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsHotspot20NaiRealmMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_types: Optional['outputs.WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypes'] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param 'WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypesArgs' authentication_types: The authentication types for the method. These should be formatted as an object with the EAP method category in camelcase as the key and the list of types as the value (nonEapInnerAuthentication: Reserved, PAP, CHAP, MSCHAP, MSCHAPV2; eapInnerAuthentication: EAP-TLS, EAP-SIM, EAP-AKA, EAP-TTLS with MSCHAPv2; credentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, none, Reserved, Vendor Specific; tunneledEapMethodCredentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, Reserved, Anonymous, Vendor Specific)
        :param _builtins.str id: ID of method
        """
        if authentication_types is not None:
            pulumi.set(__self__, "authentication_types", authentication_types)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="authenticationTypes")
    def authentication_types(self) -> Optional['outputs.WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypes']:
        """
        The authentication types for the method. These should be formatted as an object with the EAP method category in camelcase as the key and the list of types as the value (nonEapInnerAuthentication: Reserved, PAP, CHAP, MSCHAP, MSCHAPV2; eapInnerAuthentication: EAP-TLS, EAP-SIM, EAP-AKA, EAP-TTLS with MSCHAPv2; credentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, none, Reserved, Vendor Specific; tunneledEapMethodCredentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, Reserved, Anonymous, Vendor Specific)
        """
        return pulumi.get(self, "authentication_types")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of method
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eapinnerAuthentications":
            suggest = "eapinner_authentications"
        elif key == "nonEapinnerAuthentications":
            suggest = "non_eapinner_authentications"
        elif key == "tunneledEapMethodCredentials":
            suggest = "tunneled_eap_method_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Optional[Sequence[_builtins.str]] = None,
                 eapinner_authentications: Optional[Sequence[_builtins.str]] = None,
                 non_eapinner_authentications: Optional[Sequence[_builtins.str]] = None,
                 tunneled_eap_method_credentials: Optional[Sequence[_builtins.str]] = None):
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if eapinner_authentications is not None:
            pulumi.set(__self__, "eapinner_authentications", eapinner_authentications)
        if non_eapinner_authentications is not None:
            pulumi.set(__self__, "non_eapinner_authentications", non_eapinner_authentications)
        if tunneled_eap_method_credentials is not None:
            pulumi.set(__self__, "tunneled_eap_method_credentials", tunneled_eap_method_credentials)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "credentials")

    @_builtins.property
    @pulumi.getter(name="eapinnerAuthentications")
    def eapinner_authentications(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "eapinner_authentications")

    @_builtins.property
    @pulumi.getter(name="nonEapinnerAuthentications")
    def non_eapinner_authentications(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "non_eapinner_authentications")

    @_builtins.property
    @pulumi.getter(name="tunneledEapMethodCredentials")
    def tunneled_eap_method_credentials(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "tunneled_eap_method_credentials")


@pulumi.output_type
class WirelessSsidsHotspot20Operator(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Operator name
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Operator name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessSsidsHotspot20Venue(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Venue name
        :param _builtins.str type: Venue type ('Unspecified', 'Unspecified Assembly', 'Arena', 'Stadium', 'Passenger Terminal', 'Amphitheater', 'Amusement Park', 'Place of Worship', 'Convention Center', 'Library', 'Museum', 'Restaurant', 'Theater', 'Bar', 'Coffee Shop', 'Zoo or Aquarium', 'Emergency Coordination Center', 'Unspecified Business', 'Doctor or Dentist office', 'Bank', 'Fire Station', 'Police Station', 'Post Office', 'Professional Office', 'Research and Development Facility', 'Attorney Office', 'Unspecified Educational', 'School, Primary', 'School, Secondary', 'University or College', 'Unspecified Factory and Industrial', 'Factory', 'Unspecified Institutional', 'Hospital', 'Long-Term Care Facility', 'Alcohol and Drug Rehabilitation Center', 'Group Home', 'Prison or Jail', 'Unspecified Mercantile', 'Retail Store', 'Grocery Market', 'Automotive Service Station', 'Shopping Mall', 'Gas Station', 'Unspecified Residential', 'Private Residence', 'Hotel or Motel', 'Dormitory', 'Boarding House', 'Unspecified Storage', 'Unspecified Utility and Miscellaneous', 'Unspecified Vehicular', 'Automobile or Truck', 'Airplane', 'Bus', 'Ferry', 'Ship or Boat', 'Train', 'Motor Bike', 'Unspecified Outdoor', 'Muni-mesh Network', 'City Park', 'Rest Area', 'Traffic Control', 'Bus Stop', 'Kiosk')
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Venue name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Venue type ('Unspecified', 'Unspecified Assembly', 'Arena', 'Stadium', 'Passenger Terminal', 'Amphitheater', 'Amusement Park', 'Place of Worship', 'Convention Center', 'Library', 'Museum', 'Restaurant', 'Theater', 'Bar', 'Coffee Shop', 'Zoo or Aquarium', 'Emergency Coordination Center', 'Unspecified Business', 'Doctor or Dentist office', 'Bank', 'Fire Station', 'Police Station', 'Post Office', 'Professional Office', 'Research and Development Facility', 'Attorney Office', 'Unspecified Educational', 'School, Primary', 'School, Secondary', 'University or College', 'Unspecified Factory and Industrial', 'Factory', 'Unspecified Institutional', 'Hospital', 'Long-Term Care Facility', 'Alcohol and Drug Rehabilitation Center', 'Group Home', 'Prison or Jail', 'Unspecified Mercantile', 'Retail Store', 'Grocery Market', 'Automotive Service Station', 'Shopping Mall', 'Gas Station', 'Unspecified Residential', 'Private Residence', 'Hotel or Motel', 'Dormitory', 'Boarding House', 'Unspecified Storage', 'Unspecified Utility and Miscellaneous', 'Unspecified Vehicular', 'Automobile or Truck', 'Airplane', 'Bus', 'Ferry', 'Ship or Boat', 'Train', 'Motor Bike', 'Unspecified Outdoor', 'Muni-mesh Network', 'City Park', 'Rest Area', 'Traffic Control', 'Bus Stop', 'Kiosk')
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WirelessSsidsLdap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseDistinguishedName":
            suggest = "base_distinguished_name"
        elif key == "serverCaCertificate":
            suggest = "server_ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsLdap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsLdap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsLdap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_distinguished_name: Optional[_builtins.str] = None,
                 credentials: Optional['outputs.WirelessSsidsLdapCredentials'] = None,
                 server_ca_certificate: Optional['outputs.WirelessSsidsLdapServerCaCertificate'] = None,
                 servers: Optional[Sequence['outputs.WirelessSsidsLdapServer']] = None):
        """
        :param _builtins.str base_distinguished_name: The base distinguished name of users on the LDAP server.
        :param 'WirelessSsidsLdapCredentialsArgs' credentials: (Optional) The credentials of the user account to be used by the AP to bind to your LDAP server. The LDAP account should have permissions on all your LDAP servers.
        :param 'WirelessSsidsLdapServerCaCertificateArgs' server_ca_certificate: The CA certificate used to sign the LDAP server's key.
        :param Sequence['WirelessSsidsLdapServerArgs'] servers: The LDAP servers to be used for authentication.
        """
        if base_distinguished_name is not None:
            pulumi.set(__self__, "base_distinguished_name", base_distinguished_name)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if server_ca_certificate is not None:
            pulumi.set(__self__, "server_ca_certificate", server_ca_certificate)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @_builtins.property
    @pulumi.getter(name="baseDistinguishedName")
    def base_distinguished_name(self) -> Optional[_builtins.str]:
        """
        The base distinguished name of users on the LDAP server.
        """
        return pulumi.get(self, "base_distinguished_name")

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.WirelessSsidsLdapCredentials']:
        """
        (Optional) The credentials of the user account to be used by the AP to bind to your LDAP server. The LDAP account should have permissions on all your LDAP servers.
        """
        return pulumi.get(self, "credentials")

    @_builtins.property
    @pulumi.getter(name="serverCaCertificate")
    def server_ca_certificate(self) -> Optional['outputs.WirelessSsidsLdapServerCaCertificate']:
        """
        The CA certificate used to sign the LDAP server's key.
        """
        return pulumi.get(self, "server_ca_certificate")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.WirelessSsidsLdapServer']]:
        """
        The LDAP servers to be used for authentication.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class WirelessSsidsLdapCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distinguishedName":
            suggest = "distinguished_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsLdapCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsLdapCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsLdapCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distinguished_name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None):
        """
        :param _builtins.str distinguished_name: The distinguished name of the LDAP user account (example: cn=user,dc=meraki,dc=com).
        :param _builtins.str password: The password of the LDAP user account.
        """
        if distinguished_name is not None:
            pulumi.set(__self__, "distinguished_name", distinguished_name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="distinguishedName")
    def distinguished_name(self) -> Optional[_builtins.str]:
        """
        The distinguished name of the LDAP user account (example: cn=user,dc=meraki,dc=com).
        """
        return pulumi.get(self, "distinguished_name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password of the LDAP user account.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class WirelessSsidsLdapServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.str host: IP address (or FQDN) of your LDAP server.
        :param _builtins.int port: UDP port the LDAP server listens on.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        IP address (or FQDN) of your LDAP server.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        UDP port the LDAP server listens on.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class WirelessSsidsLdapServerCaCertificate(dict):
    def __init__(__self__, *,
                 contents: Optional[_builtins.str] = None):
        """
        :param _builtins.str contents: The contents of the CA certificate. Must be in PEM or DER format.
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[_builtins.str]:
        """
        The contents of the CA certificate. Must be in PEM or DER format.
        """
        return pulumi.get(self, "contents")


@pulumi.output_type
class WirelessSsidsLocalRadius(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheTimeout":
            suggest = "cache_timeout"
        elif key == "certificateAuthentication":
            suggest = "certificate_authentication"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsLocalRadius. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsLocalRadius.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsLocalRadius.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_timeout: Optional[_builtins.int] = None,
                 certificate_authentication: Optional['outputs.WirelessSsidsLocalRadiusCertificateAuthentication'] = None,
                 password_authentication: Optional['outputs.WirelessSsidsLocalRadiusPasswordAuthentication'] = None):
        """
        :param _builtins.int cache_timeout: The duration (in seconds) for which LDAP and OCSP lookups are cached.
        :param 'WirelessSsidsLocalRadiusCertificateAuthenticationArgs' certificate_authentication: The current setting for certificate verification.
        :param 'WirelessSsidsLocalRadiusPasswordAuthenticationArgs' password_authentication: The current setting for password-based authentication.
        """
        if cache_timeout is not None:
            pulumi.set(__self__, "cache_timeout", cache_timeout)
        if certificate_authentication is not None:
            pulumi.set(__self__, "certificate_authentication", certificate_authentication)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)

    @_builtins.property
    @pulumi.getter(name="cacheTimeout")
    def cache_timeout(self) -> Optional[_builtins.int]:
        """
        The duration (in seconds) for which LDAP and OCSP lookups are cached.
        """
        return pulumi.get(self, "cache_timeout")

    @_builtins.property
    @pulumi.getter(name="certificateAuthentication")
    def certificate_authentication(self) -> Optional['outputs.WirelessSsidsLocalRadiusCertificateAuthentication']:
        """
        The current setting for certificate verification.
        """
        return pulumi.get(self, "certificate_authentication")

    @_builtins.property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.WirelessSsidsLocalRadiusPasswordAuthentication']:
        """
        The current setting for password-based authentication.
        """
        return pulumi.get(self, "password_authentication")


@pulumi.output_type
class WirelessSsidsLocalRadiusCertificateAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientRootCaCertificate":
            suggest = "client_root_ca_certificate"
        elif key == "ocspResponderUrl":
            suggest = "ocsp_responder_url"
        elif key == "useLdap":
            suggest = "use_ldap"
        elif key == "useOcsp":
            suggest = "use_ocsp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsLocalRadiusCertificateAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsLocalRadiusCertificateAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsLocalRadiusCertificateAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_root_ca_certificate: Optional['outputs.WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificate'] = None,
                 enabled: Optional[_builtins.bool] = None,
                 ocsp_responder_url: Optional[_builtins.str] = None,
                 use_ldap: Optional[_builtins.bool] = None,
                 use_ocsp: Optional[_builtins.bool] = None):
        """
        :param 'WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificateArgs' client_root_ca_certificate: The Client CA Certificate used to sign the client certificate.
        :param _builtins.bool enabled: Whether or not to use EAP-TLS certificate-based authentication to validate wireless clients.
        :param _builtins.str ocsp_responder_url: (Optional) The URL of the OCSP responder to verify client certificate status.
        :param _builtins.bool use_ldap: Whether or not to verify the certificate with LDAP.
        :param _builtins.bool use_ocsp: Whether or not to verify the certificate with OCSP.
        """
        if client_root_ca_certificate is not None:
            pulumi.set(__self__, "client_root_ca_certificate", client_root_ca_certificate)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if ocsp_responder_url is not None:
            pulumi.set(__self__, "ocsp_responder_url", ocsp_responder_url)
        if use_ldap is not None:
            pulumi.set(__self__, "use_ldap", use_ldap)
        if use_ocsp is not None:
            pulumi.set(__self__, "use_ocsp", use_ocsp)

    @_builtins.property
    @pulumi.getter(name="clientRootCaCertificate")
    def client_root_ca_certificate(self) -> Optional['outputs.WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificate']:
        """
        The Client CA Certificate used to sign the client certificate.
        """
        return pulumi.get(self, "client_root_ca_certificate")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether or not to use EAP-TLS certificate-based authentication to validate wireless clients.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="ocspResponderUrl")
    def ocsp_responder_url(self) -> Optional[_builtins.str]:
        """
        (Optional) The URL of the OCSP responder to verify client certificate status.
        """
        return pulumi.get(self, "ocsp_responder_url")

    @_builtins.property
    @pulumi.getter(name="useLdap")
    def use_ldap(self) -> Optional[_builtins.bool]:
        """
        Whether or not to verify the certificate with LDAP.
        """
        return pulumi.get(self, "use_ldap")

    @_builtins.property
    @pulumi.getter(name="useOcsp")
    def use_ocsp(self) -> Optional[_builtins.bool]:
        """
        Whether or not to verify the certificate with OCSP.
        """
        return pulumi.get(self, "use_ocsp")


@pulumi.output_type
class WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificate(dict):
    def __init__(__self__, *,
                 contents: Optional[_builtins.str] = None):
        """
        :param _builtins.str contents: The contents of the Client CA Certificate. Must be in PEM or DER format.
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[_builtins.str]:
        """
        The contents of the Client CA Certificate. Must be in PEM or DER format.
        """
        return pulumi.get(self, "contents")


@pulumi.output_type
class WirelessSsidsLocalRadiusPasswordAuthentication(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether or not to use EAP-TTLS/PAP or PEAP-GTC password-based authentication via LDAP lookup.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether or not to use EAP-TTLS/PAP or PEAP-GTC password-based authentication via LDAP lookup.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WirelessSsidsNamedVlans(dict):
    def __init__(__self__, *,
                 radius: Optional['outputs.WirelessSsidsNamedVlansRadius'] = None,
                 tagging: Optional['outputs.WirelessSsidsNamedVlansTagging'] = None):
        """
        :param 'WirelessSsidsNamedVlansRadiusArgs' radius: RADIUS settings. This param is only valid when authMode is 'open-with-radius' and ipAssignmentMode is not 'NAT mode'.
        :param 'WirelessSsidsNamedVlansTaggingArgs' tagging: VLAN tagging settings. This param is only valid when ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'.
        """
        if radius is not None:
            pulumi.set(__self__, "radius", radius)
        if tagging is not None:
            pulumi.set(__self__, "tagging", tagging)

    @_builtins.property
    @pulumi.getter
    def radius(self) -> Optional['outputs.WirelessSsidsNamedVlansRadius']:
        """
        RADIUS settings. This param is only valid when authMode is 'open-with-radius' and ipAssignmentMode is not 'NAT mode'.
        """
        return pulumi.get(self, "radius")

    @_builtins.property
    @pulumi.getter
    def tagging(self) -> Optional['outputs.WirelessSsidsNamedVlansTagging']:
        """
        VLAN tagging settings. This param is only valid when ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'.
        """
        return pulumi.get(self, "tagging")


@pulumi.output_type
class WirelessSsidsNamedVlansRadius(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guestVlan":
            suggest = "guest_vlan"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsNamedVlansRadius. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsNamedVlansRadius.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsNamedVlansRadius.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 guest_vlan: Optional['outputs.WirelessSsidsNamedVlansRadiusGuestVlan'] = None):
        """
        :param 'WirelessSsidsNamedVlansRadiusGuestVlanArgs' guest_vlan: Guest VLAN settings. Used to direct traffic to a guest VLAN when none of the RADIUS servers are reachable or a client receives access-reject from the RADIUS server.
        """
        if guest_vlan is not None:
            pulumi.set(__self__, "guest_vlan", guest_vlan)

    @_builtins.property
    @pulumi.getter(name="guestVlan")
    def guest_vlan(self) -> Optional['outputs.WirelessSsidsNamedVlansRadiusGuestVlan']:
        """
        Guest VLAN settings. Used to direct traffic to a guest VLAN when none of the RADIUS servers are reachable or a client receives access-reject from the RADIUS server.
        """
        return pulumi.get(self, "guest_vlan")


@pulumi.output_type
class WirelessSsidsNamedVlansRadiusGuestVlan(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Whether or not RADIUS guest named VLAN is enabled.
        :param _builtins.str name: RADIUS guest VLAN name.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether or not RADIUS guest named VLAN is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        RADIUS guest VLAN name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WirelessSsidsNamedVlansTagging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byApTags":
            suggest = "by_ap_tags"
        elif key == "defaultVlanName":
            suggest = "default_vlan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsNamedVlansTagging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsNamedVlansTagging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsNamedVlansTagging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 by_ap_tags: Optional[Sequence['outputs.WirelessSsidsNamedVlansTaggingByApTag']] = None,
                 default_vlan_name: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param Sequence['WirelessSsidsNamedVlansTaggingByApTagArgs'] by_ap_tags: The list of AP tags and VLAN names used for named VLAN tagging. If an AP has a tag matching one in the list, then traffic on this SSID will be directed to use the VLAN name associated to the tag.
        :param _builtins.str default_vlan_name: The default VLAN name used to tag traffic in the absence of a matching AP tag.
        :param _builtins.bool enabled: Whether or not traffic should be directed to use specific VLAN names.
        """
        if by_ap_tags is not None:
            pulumi.set(__self__, "by_ap_tags", by_ap_tags)
        if default_vlan_name is not None:
            pulumi.set(__self__, "default_vlan_name", default_vlan_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="byApTags")
    def by_ap_tags(self) -> Optional[Sequence['outputs.WirelessSsidsNamedVlansTaggingByApTag']]:
        """
        The list of AP tags and VLAN names used for named VLAN tagging. If an AP has a tag matching one in the list, then traffic on this SSID will be directed to use the VLAN name associated to the tag.
        """
        return pulumi.get(self, "by_ap_tags")

    @_builtins.property
    @pulumi.getter(name="defaultVlanName")
    def default_vlan_name(self) -> Optional[_builtins.str]:
        """
        The default VLAN name used to tag traffic in the absence of a matching AP tag.
        """
        return pulumi.get(self, "default_vlan_name")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether or not traffic should be directed to use specific VLAN names.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WirelessSsidsNamedVlansTaggingByApTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanName":
            suggest = "vlan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsNamedVlansTaggingByApTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsNamedVlansTaggingByApTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsNamedVlansTaggingByApTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 vlan_name: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] tags: List of AP tags.
        :param _builtins.str vlan_name: VLAN name that will be used to tag traffic.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of AP tags.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[_builtins.str]:
        """
        VLAN name that will be used to tag traffic.
        """
        return pulumi.get(self, "vlan_name")


@pulumi.output_type
class WirelessSsidsOauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedDomains":
            suggest = "allowed_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsOauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsOauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsOauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_domains: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] allowed_domains: (Optional) The list of domains allowed access to the network.
        """
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)

    @_builtins.property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The list of domains allowed access to the network.
        """
        return pulumi.get(self, "allowed_domains")


@pulumi.output_type
class WirelessSsidsRadiusAccountingServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "openRoamingCertificateId":
            suggest = "open_roaming_certificate_id"
        elif key == "radsecEnabled":
            suggest = "radsec_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsRadiusAccountingServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsRadiusAccountingServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsRadiusAccountingServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 open_roaming_certificate_id: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 radsec_enabled: Optional[_builtins.bool] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str ca_certificate: Certificate used for authorization for the RADSEC Server
        :param _builtins.str host: IP address (or FQDN) to which the APs will send RADIUS accounting messages
        :param _builtins.int open_roaming_certificate_id: The ID of the Openroaming Certificate attached to radius server
        :param _builtins.int port: Port on the RADIUS server that is listening for accounting messages
        :param _builtins.bool radsec_enabled: Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
        :param _builtins.str secret: Shared key used to authenticate messages between the APs and RADIUS server
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if open_roaming_certificate_id is not None:
            pulumi.set(__self__, "open_roaming_certificate_id", open_roaming_certificate_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if radsec_enabled is not None:
            pulumi.set(__self__, "radsec_enabled", radsec_enabled)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        """
        Certificate used for authorization for the RADSEC Server
        """
        return pulumi.get(self, "ca_certificate")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        IP address (or FQDN) to which the APs will send RADIUS accounting messages
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="openRoamingCertificateId")
    def open_roaming_certificate_id(self) -> Optional[_builtins.int]:
        """
        The ID of the Openroaming Certificate attached to radius server
        """
        return pulumi.get(self, "open_roaming_certificate_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port on the RADIUS server that is listening for accounting messages
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="radsecEnabled")
    def radsec_enabled(self) -> Optional[_builtins.bool]:
        """
        Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
        """
        return pulumi.get(self, "radsec_enabled")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Shared key used to authenticate messages between the APs and RADIUS server
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class WirelessSsidsRadiusAccountingServersResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "openRoamingCertificateId":
            suggest = "open_roaming_certificate_id"
        elif key == "radsecEnabled":
            suggest = "radsec_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsRadiusAccountingServersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsRadiusAccountingServersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsRadiusAccountingServersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 open_roaming_certificate_id: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 radsec_enabled: Optional[_builtins.bool] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str ca_certificate: Certificate used for authorization for the RADSEC Server
        :param _builtins.str host: IP address (or FQDN) to which the APs will send RADIUS accounting messages
        :param _builtins.int open_roaming_certificate_id: The ID of the Openroaming Certificate attached to radius server
        :param _builtins.int port: Port on the RADIUS server that is listening for accounting messages
        :param _builtins.bool radsec_enabled: Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
        :param _builtins.str secret: Shared key used to authenticate messages between the APs and RADIUS server
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if open_roaming_certificate_id is not None:
            pulumi.set(__self__, "open_roaming_certificate_id", open_roaming_certificate_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if radsec_enabled is not None:
            pulumi.set(__self__, "radsec_enabled", radsec_enabled)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        """
        Certificate used for authorization for the RADSEC Server
        """
        return pulumi.get(self, "ca_certificate")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        IP address (or FQDN) to which the APs will send RADIUS accounting messages
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="openRoamingCertificateId")
    def open_roaming_certificate_id(self) -> Optional[_builtins.int]:
        """
        The ID of the Openroaming Certificate attached to radius server
        """
        return pulumi.get(self, "open_roaming_certificate_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port on the RADIUS server that is listening for accounting messages
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="radsecEnabled")
    def radsec_enabled(self) -> Optional[_builtins.bool]:
        """
        Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
        """
        return pulumi.get(self, "radsec_enabled")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Shared key used to authenticate messages between the APs and RADIUS server
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class WirelessSsidsRadiusServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "openRoamingCertificateId":
            suggest = "open_roaming_certificate_id"
        elif key == "radsecEnabled":
            suggest = "radsec_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsRadiusServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsRadiusServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsRadiusServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 open_roaming_certificate_id: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 radsec_enabled: Optional[_builtins.bool] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str ca_certificate: Certificate used for authorization for the RADSEC Server
        :param _builtins.str host: IP address of your RADIUS server
        :param _builtins.int open_roaming_certificate_id: The ID of the Openroaming Certificate attached to radius server.
        :param _builtins.int port: UDP port the RADIUS server listens on for Access-requests
        :param _builtins.bool radsec_enabled: Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
        :param _builtins.str secret: RADIUS client shared secret
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if open_roaming_certificate_id is not None:
            pulumi.set(__self__, "open_roaming_certificate_id", open_roaming_certificate_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if radsec_enabled is not None:
            pulumi.set(__self__, "radsec_enabled", radsec_enabled)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        """
        Certificate used for authorization for the RADSEC Server
        """
        return pulumi.get(self, "ca_certificate")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        IP address of your RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="openRoamingCertificateId")
    def open_roaming_certificate_id(self) -> Optional[_builtins.int]:
        """
        The ID of the Openroaming Certificate attached to radius server.
        """
        return pulumi.get(self, "open_roaming_certificate_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        UDP port the RADIUS server listens on for Access-requests
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="radsecEnabled")
    def radsec_enabled(self) -> Optional[_builtins.bool]:
        """
        Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
        """
        return pulumi.get(self, "radsec_enabled")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        RADIUS client shared secret
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class WirelessSsidsRadiusServersResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "openRoamingCertificateId":
            suggest = "open_roaming_certificate_id"
        elif key == "radsecEnabled":
            suggest = "radsec_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsRadiusServersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsRadiusServersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsRadiusServersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 open_roaming_certificate_id: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 radsec_enabled: Optional[_builtins.bool] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str ca_certificate: Certificate used for authorization for the RADSEC Server
        :param _builtins.str host: IP address of your RADIUS server
        :param _builtins.int open_roaming_certificate_id: The ID of the Openroaming Certificate attached to radius server.
        :param _builtins.int port: UDP port the RADIUS server listens on for Access-requests
        :param _builtins.bool radsec_enabled: Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
        :param _builtins.str secret: RADIUS client shared secret
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if open_roaming_certificate_id is not None:
            pulumi.set(__self__, "open_roaming_certificate_id", open_roaming_certificate_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if radsec_enabled is not None:
            pulumi.set(__self__, "radsec_enabled", radsec_enabled)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        """
        Certificate used for authorization for the RADSEC Server
        """
        return pulumi.get(self, "ca_certificate")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        IP address of your RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="openRoamingCertificateId")
    def open_roaming_certificate_id(self) -> Optional[_builtins.int]:
        """
        The ID of the Openroaming Certificate attached to radius server.
        """
        return pulumi.get(self, "open_roaming_certificate_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        UDP port the RADIUS server listens on for Access-requests
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="radsecEnabled")
    def radsec_enabled(self) -> Optional[_builtins.bool]:
        """
        Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
        """
        return pulumi.get(self, "radsec_enabled")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        RADIUS client shared secret
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class WirelessSsidsSchedulesRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDay":
            suggest = "end_day"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startDay":
            suggest = "start_day"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsSchedulesRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsSchedulesRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsSchedulesRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_day: Optional[_builtins.str] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_day: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str end_day: Day of when the outage ends. Can be either full day name, or three letter abbreviation
        :param _builtins.str end_time: 24 hour time when the outage ends.
        :param _builtins.str start_day: Day of when the outage starts. Can be either full day name, or three letter abbreviation.
        :param _builtins.str start_time: 24 hour time when the outage starts.
        """
        if end_day is not None:
            pulumi.set(__self__, "end_day", end_day)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_day is not None:
            pulumi.set(__self__, "start_day", start_day)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endDay")
    def end_day(self) -> Optional[_builtins.str]:
        """
        Day of when the outage ends. Can be either full day name, or three letter abbreviation
        """
        return pulumi.get(self, "end_day")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        24 hour time when the outage ends.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startDay")
    def start_day(self) -> Optional[_builtins.str]:
        """
        Day of when the outage starts. Can be either full day name, or three letter abbreviation.
        """
        return pulumi.get(self, "start_day")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        24 hour time when the outage starts.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class WirelessSsidsSchedulesRangesInSecond(dict):
    def __init__(__self__, *,
                 end: Optional[_builtins.int] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param _builtins.int end: Seconds since Sunday at midnight when that outage range ends.
        :param _builtins.int start: Seconds since Sunday at midnight when the outage range starts.
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        Seconds since Sunday at midnight when that outage range ends.
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        Seconds since Sunday at midnight when the outage range starts.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class WirelessSsidsSpeedBurst(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Boolean indicating whether or not to allow users to temporarily exceed the bandwidth limit for short periods while still keeping them under the bandwidth limit over time.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating whether or not to allow users to temporarily exceed the bandwidth limit for short periods while still keeping them under the bandwidth limit over time.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WirelessSsidsSplashSettingsBilling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeAccess":
            suggest = "free_access"
        elif key == "prepaidAccessFastLoginEnabled":
            suggest = "prepaid_access_fast_login_enabled"
        elif key == "replyToEmailAddress":
            suggest = "reply_to_email_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsSplashSettingsBilling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsSplashSettingsBilling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsSplashSettingsBilling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_access: Optional['outputs.WirelessSsidsSplashSettingsBillingFreeAccess'] = None,
                 prepaid_access_fast_login_enabled: Optional[_builtins.bool] = None,
                 reply_to_email_address: Optional[_builtins.str] = None):
        """
        :param 'WirelessSsidsSplashSettingsBillingFreeAccessArgs' free_access: Details associated with a free access plan with limits
        :param _builtins.bool prepaid_access_fast_login_enabled: Whether or not billing uses the fast login prepaid access option.
        :param _builtins.str reply_to_email_address: The email address that reeceives replies from clients
        """
        if free_access is not None:
            pulumi.set(__self__, "free_access", free_access)
        if prepaid_access_fast_login_enabled is not None:
            pulumi.set(__self__, "prepaid_access_fast_login_enabled", prepaid_access_fast_login_enabled)
        if reply_to_email_address is not None:
            pulumi.set(__self__, "reply_to_email_address", reply_to_email_address)

    @_builtins.property
    @pulumi.getter(name="freeAccess")
    def free_access(self) -> Optional['outputs.WirelessSsidsSplashSettingsBillingFreeAccess']:
        """
        Details associated with a free access plan with limits
        """
        return pulumi.get(self, "free_access")

    @_builtins.property
    @pulumi.getter(name="prepaidAccessFastLoginEnabled")
    def prepaid_access_fast_login_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether or not billing uses the fast login prepaid access option.
        """
        return pulumi.get(self, "prepaid_access_fast_login_enabled")

    @_builtins.property
    @pulumi.getter(name="replyToEmailAddress")
    def reply_to_email_address(self) -> Optional[_builtins.str]:
        """
        The email address that reeceives replies from clients
        """
        return pulumi.get(self, "reply_to_email_address")


@pulumi.output_type
class WirelessSsidsSplashSettingsBillingFreeAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationInMinutes":
            suggest = "duration_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsSplashSettingsBillingFreeAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsSplashSettingsBillingFreeAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsSplashSettingsBillingFreeAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_in_minutes: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int duration_in_minutes: How long a device can use a network for free.
        :param _builtins.bool enabled: Whether or not free access is enabled.
        """
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[_builtins.int]:
        """
        How long a device can use a network for free.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether or not free access is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WirelessSsidsSplashSettingsGuestSponsorship(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationInMinutes":
            suggest = "duration_in_minutes"
        elif key == "guestCanRequestTimeframe":
            suggest = "guest_can_request_timeframe"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsSplashSettingsGuestSponsorship. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsSplashSettingsGuestSponsorship.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsSplashSettingsGuestSponsorship.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_in_minutes: Optional[_builtins.int] = None,
                 guest_can_request_timeframe: Optional[_builtins.bool] = None):
        """
        :param _builtins.int duration_in_minutes: Duration in minutes of sponsored guest authorization.
        :param _builtins.bool guest_can_request_timeframe: Whether or not guests can specify how much time they are requesting.
        """
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if guest_can_request_timeframe is not None:
            pulumi.set(__self__, "guest_can_request_timeframe", guest_can_request_timeframe)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[_builtins.int]:
        """
        Duration in minutes of sponsored guest authorization.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter(name="guestCanRequestTimeframe")
    def guest_can_request_timeframe(self) -> Optional[_builtins.bool]:
        """
        Whether or not guests can specify how much time they are requesting.
        """
        return pulumi.get(self, "guest_can_request_timeframe")


@pulumi.output_type
class WirelessSsidsSplashSettingsSelfRegistration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationType":
            suggest = "authorization_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsSplashSettingsSelfRegistration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsSplashSettingsSelfRegistration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsSplashSettingsSelfRegistration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_type: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str authorization_type: How created user accounts should be authorized.
        :param _builtins.bool enabled: Whether or not to allow users to create their own account on the network.
        """
        if authorization_type is not None:
            pulumi.set(__self__, "authorization_type", authorization_type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="authorizationType")
    def authorization_type(self) -> Optional[_builtins.str]:
        """
        How created user accounts should be authorized.
        """
        return pulumi.get(self, "authorization_type")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether or not to allow users to create their own account on the network.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WirelessSsidsSplashSettingsSentryEnrollment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enforcedSystems":
            suggest = "enforced_systems"
        elif key == "systemsManagerNetwork":
            suggest = "systems_manager_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsSplashSettingsSentryEnrollment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsSplashSettingsSentryEnrollment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsSplashSettingsSentryEnrollment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enforced_systems: Optional[Sequence[_builtins.str]] = None,
                 strength: Optional[_builtins.str] = None,
                 systems_manager_network: Optional['outputs.WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetwork'] = None):
        """
        :param Sequence[_builtins.str] enforced_systems: The system types that the Sentry enforces.
        :param _builtins.str strength: The strength of the enforcement of selected system types.
        :param 'WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetworkArgs' systems_manager_network: Systems Manager network targeted for sentry enrollment.
        """
        if enforced_systems is not None:
            pulumi.set(__self__, "enforced_systems", enforced_systems)
        if strength is not None:
            pulumi.set(__self__, "strength", strength)
        if systems_manager_network is not None:
            pulumi.set(__self__, "systems_manager_network", systems_manager_network)

    @_builtins.property
    @pulumi.getter(name="enforcedSystems")
    def enforced_systems(self) -> Optional[Sequence[_builtins.str]]:
        """
        The system types that the Sentry enforces.
        """
        return pulumi.get(self, "enforced_systems")

    @_builtins.property
    @pulumi.getter
    def strength(self) -> Optional[_builtins.str]:
        """
        The strength of the enforcement of selected system types.
        """
        return pulumi.get(self, "strength")

    @_builtins.property
    @pulumi.getter(name="systemsManagerNetwork")
    def systems_manager_network(self) -> Optional['outputs.WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetwork']:
        """
        Systems Manager network targeted for sentry enrollment.
        """
        return pulumi.get(self, "systems_manager_network")


@pulumi.output_type
class WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetwork(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The network ID of the Systems Manager network.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The network ID of the Systems Manager network.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class WirelessSsidsSplashSettingsSplashImage(dict):
    def __init__(__self__, *,
                 extension: Optional[_builtins.str] = None,
                 image: Optional['outputs.WirelessSsidsSplashSettingsSplashImageImage'] = None,
                 md5: Optional[_builtins.str] = None):
        """
        :param _builtins.str extension: The extension of the image file.
        :param 'WirelessSsidsSplashSettingsSplashImageImageArgs' image: Properties for setting a new image.
        :param _builtins.str md5: The MD5 value of the image file.
        """
        if extension is not None:
            pulumi.set(__self__, "extension", extension)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)

    @_builtins.property
    @pulumi.getter
    def extension(self) -> Optional[_builtins.str]:
        """
        The extension of the image file.
        """
        return pulumi.get(self, "extension")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.WirelessSsidsSplashSettingsSplashImageImage']:
        """
        Properties for setting a new image.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[_builtins.str]:
        """
        The MD5 value of the image file.
        """
        return pulumi.get(self, "md5")


@pulumi.output_type
class WirelessSsidsSplashSettingsSplashImageImage(dict):
    def __init__(__self__, *,
                 contents: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None):
        """
        :param _builtins.str contents: The file contents (a base 64 encoded string) of your new image.
        :param _builtins.str format: The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[_builtins.str]:
        """
        The file contents (a base 64 encoded string) of your new image.
        """
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class WirelessSsidsSplashSettingsSplashLogo(dict):
    def __init__(__self__, *,
                 extension: Optional[_builtins.str] = None,
                 image: Optional['outputs.WirelessSsidsSplashSettingsSplashLogoImage'] = None,
                 md5: Optional[_builtins.str] = None):
        """
        :param _builtins.str extension: The extension of the logo file.
        :param 'WirelessSsidsSplashSettingsSplashLogoImageArgs' image: Properties for setting a new image.
        :param _builtins.str md5: The MD5 value of the logo file.
        """
        if extension is not None:
            pulumi.set(__self__, "extension", extension)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)

    @_builtins.property
    @pulumi.getter
    def extension(self) -> Optional[_builtins.str]:
        """
        The extension of the logo file.
        """
        return pulumi.get(self, "extension")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.WirelessSsidsSplashSettingsSplashLogoImage']:
        """
        Properties for setting a new image.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[_builtins.str]:
        """
        The MD5 value of the logo file.
        """
        return pulumi.get(self, "md5")


@pulumi.output_type
class WirelessSsidsSplashSettingsSplashLogoImage(dict):
    def __init__(__self__, *,
                 contents: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None):
        """
        :param _builtins.str contents: The file contents (a base 64 encoded string) of your new logo.
        :param _builtins.str format: The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[_builtins.str]:
        """
        The file contents (a base 64 encoded string) of your new logo.
        """
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class WirelessSsidsSplashSettingsSplashPrepaidFront(dict):
    def __init__(__self__, *,
                 extension: Optional[_builtins.str] = None,
                 image: Optional['outputs.WirelessSsidsSplashSettingsSplashPrepaidFrontImage'] = None,
                 md5: Optional[_builtins.str] = None):
        """
        :param _builtins.str extension: The extension of the prepaid front image file.
        :param 'WirelessSsidsSplashSettingsSplashPrepaidFrontImageArgs' image: Properties for setting a new image.
        :param _builtins.str md5: The MD5 value of the prepaid front image file.
        """
        if extension is not None:
            pulumi.set(__self__, "extension", extension)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)

    @_builtins.property
    @pulumi.getter
    def extension(self) -> Optional[_builtins.str]:
        """
        The extension of the prepaid front image file.
        """
        return pulumi.get(self, "extension")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.WirelessSsidsSplashSettingsSplashPrepaidFrontImage']:
        """
        Properties for setting a new image.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[_builtins.str]:
        """
        The MD5 value of the prepaid front image file.
        """
        return pulumi.get(self, "md5")


@pulumi.output_type
class WirelessSsidsSplashSettingsSplashPrepaidFrontImage(dict):
    def __init__(__self__, *,
                 contents: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None):
        """
        :param _builtins.str contents: The file contents (a base 64 encoded string) of your new prepaid front.
        :param _builtins.str format: The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[_builtins.str]:
        """
        The file contents (a base 64 encoded string) of your new prepaid front.
        """
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class WirelessSsidsTrafficShapingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dscpTagValue":
            suggest = "dscp_tag_value"
        elif key == "pcpTagValue":
            suggest = "pcp_tag_value"
        elif key == "perClientBandwidthLimits":
            suggest = "per_client_bandwidth_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsTrafficShapingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsTrafficShapingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsTrafficShapingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definitions: Optional[Sequence['outputs.WirelessSsidsTrafficShapingRulesRuleDefinition']] = None,
                 dscp_tag_value: Optional[_builtins.int] = None,
                 pcp_tag_value: Optional[_builtins.int] = None,
                 per_client_bandwidth_limits: Optional['outputs.WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimits'] = None):
        """
        :param Sequence['WirelessSsidsTrafficShapingRulesRuleDefinitionArgs'] definitions: A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        :param _builtins.int dscp_tag_value: The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
               For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        :param _builtins.int pcp_tag_value: The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
               null means 'Do not set PCP tag'.
        :param 'WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsArgs' per_client_bandwidth_limits: An object describing the bandwidth settings for your rule.
        """
        if definitions is not None:
            pulumi.set(__self__, "definitions", definitions)
        if dscp_tag_value is not None:
            pulumi.set(__self__, "dscp_tag_value", dscp_tag_value)
        if pcp_tag_value is not None:
            pulumi.set(__self__, "pcp_tag_value", pcp_tag_value)
        if per_client_bandwidth_limits is not None:
            pulumi.set(__self__, "per_client_bandwidth_limits", per_client_bandwidth_limits)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> Optional[Sequence['outputs.WirelessSsidsTrafficShapingRulesRuleDefinition']]:
        """
        A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        """
        return pulumi.get(self, "definitions")

    @_builtins.property
    @pulumi.getter(name="dscpTagValue")
    def dscp_tag_value(self) -> Optional[_builtins.int]:
        """
        The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        """
        return pulumi.get(self, "dscp_tag_value")

    @_builtins.property
    @pulumi.getter(name="pcpTagValue")
    def pcp_tag_value(self) -> Optional[_builtins.int]:
        """
        The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
        null means 'Do not set PCP tag'.
        """
        return pulumi.get(self, "pcp_tag_value")

    @_builtins.property
    @pulumi.getter(name="perClientBandwidthLimits")
    def per_client_bandwidth_limits(self) -> Optional['outputs.WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimits']:
        """
        An object describing the bandwidth settings for your rule.
        """
        return pulumi.get(self, "per_client_bandwidth_limits")


@pulumi.output_type
class WirelessSsidsTrafficShapingRulesRuleDefinition(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        :param _builtins.str value: If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
               a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
               "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
               custom ports.
                If "type" is 'application' or 'applicationCategory', then "value" must be an object
               with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
               application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
               endpoint).
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
        a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
        "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
        custom ports.
         If "type" is 'application' or 'applicationCategory', then "value" must be an object
        with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
        application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
        endpoint).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthLimits":
            suggest = "bandwidth_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_limits: Optional['outputs.WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits'] = None,
                 settings: Optional[_builtins.str] = None):
        """
        :param 'WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs' bandwidth_limits: The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        :param _builtins.str settings: How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        if bandwidth_limits is not None:
            pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> Optional['outputs.WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits']:
        """
        The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[_builtins.str]:
        """
        How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitDown":
            suggest = "limit_down"
        elif key == "limitUp":
            suggest = "limit_up"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_down: Optional[_builtins.int] = None,
                 limit_up: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit_down: The maximum download limit (integer, in Kbps).
        :param _builtins.int limit_up: The maximum upload limit (integer, in Kbps).
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[_builtins.int]:
        """
        The maximum download limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[_builtins.int]:
        """
        The maximum upload limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class WirelessSsidsVpnConcentrator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsVpnConcentrator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsVpnConcentrator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsVpnConcentrator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 network_id: Optional[_builtins.str] = None,
                 vlan_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str network_id: The NAT ID of the concentrator that should be set.
        :param _builtins.int vlan_id: The VLAN that should be tagged for the concentrator.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[_builtins.str]:
        """
        The NAT ID of the concentrator that should be set.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.int]:
        """
        The VLAN that should be tagged for the concentrator.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class WirelessSsidsVpnFailover(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "heartbeatInterval":
            suggest = "heartbeat_interval"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "requestIp":
            suggest = "request_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsVpnFailover. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsVpnFailover.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsVpnFailover.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 heartbeat_interval: Optional[_builtins.int] = None,
                 idle_timeout: Optional[_builtins.int] = None,
                 request_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.int heartbeat_interval: Idle timer interval in seconds.
        :param _builtins.int idle_timeout: Idle timer timeout in seconds.
        :param _builtins.str request_ip: IP addressed reserved on DHCP server where SSID will terminate.
        """
        if heartbeat_interval is not None:
            pulumi.set(__self__, "heartbeat_interval", heartbeat_interval)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if request_ip is not None:
            pulumi.set(__self__, "request_ip", request_ip)

    @_builtins.property
    @pulumi.getter(name="heartbeatInterval")
    def heartbeat_interval(self) -> Optional[_builtins.int]:
        """
        Idle timer interval in seconds.
        """
        return pulumi.get(self, "heartbeat_interval")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[_builtins.int]:
        """
        Idle timer timeout in seconds.
        """
        return pulumi.get(self, "idle_timeout")

    @_builtins.property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional[_builtins.str]:
        """
        IP addressed reserved on DHCP server where SSID will terminate.
        """
        return pulumi.get(self, "request_ip")


@pulumi.output_type
class WirelessSsidsVpnSplitTunnel(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 rules: Optional[Sequence['outputs.WirelessSsidsVpnSplitTunnelRule']] = None):
        """
        :param _builtins.bool enabled: If true, VPN split tunnel is enabled.
        :param Sequence['WirelessSsidsVpnSplitTunnelRuleArgs'] rules: List of VPN split tunnel rules.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If true, VPN split tunnel is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.WirelessSsidsVpnSplitTunnelRule']]:
        """
        List of VPN split tunnel rules.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class WirelessSsidsVpnSplitTunnelRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destCidr":
            suggest = "dest_cidr"
        elif key == "destPort":
            suggest = "dest_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WirelessSsidsVpnSplitTunnelRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WirelessSsidsVpnSplitTunnelRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WirelessSsidsVpnSplitTunnelRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 dest_cidr: Optional[_builtins.str] = None,
                 dest_port: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: Description for this split tunnel rule (optional).
        :param _builtins.str dest_cidr: Destination for this split tunnel rule. IP address, fully-qualified domain names (FQDN) or 'any'.
        :param _builtins.str dest_port: Destination port for this split tunnel rule, (integer in the range 1-65535), or 'any'.
        :param _builtins.str policy: Traffic policy specified for this split tunnel rule, 'allow' or 'deny'.
        :param _builtins.str protocol: Protocol for this split tunnel rule.
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description for this split tunnel rule (optional).
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[_builtins.str]:
        """
        Destination for this split tunnel rule. IP address, fully-qualified domain names (FQDN) or 'any'.
        """
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[_builtins.str]:
        """
        Destination port for this split tunnel rule, (integer in the range 1-65535), or 'any'.
        """
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        Traffic policy specified for this split tunnel rule, 'allow' or 'deny'.
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Protocol for this split tunnel rule.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetAlertsHistoryItemResult(dict):
    def __init__(__self__, *,
                 alert_data: _builtins.str,
                 alert_type: _builtins.str,
                 alert_type_id: _builtins.str,
                 destinations: 'outputs.GetAlertsHistoryItemDestinationsResult',
                 device: 'outputs.GetAlertsHistoryItemDeviceResult',
                 occurred_at: _builtins.str):
        """
        :param _builtins.str alert_data: relevant data about the event that caused the alert
        :param _builtins.str alert_type: user friendly alert type
        :param _builtins.str alert_type_id: type of alert
        :param 'GetAlertsHistoryItemDestinationsArgs' destinations: the destinations this alert is configured to be delivered to
        :param 'GetAlertsHistoryItemDeviceArgs' device: info related to the device that caused the alert
        :param _builtins.str occurred_at: time when the event occurred
        """
        pulumi.set(__self__, "alert_data", alert_data)
        pulumi.set(__self__, "alert_type", alert_type)
        pulumi.set(__self__, "alert_type_id", alert_type_id)
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "occurred_at", occurred_at)

    @_builtins.property
    @pulumi.getter(name="alertData")
    def alert_data(self) -> _builtins.str:
        """
        relevant data about the event that caused the alert
        """
        return pulumi.get(self, "alert_data")

    @_builtins.property
    @pulumi.getter(name="alertType")
    def alert_type(self) -> _builtins.str:
        """
        user friendly alert type
        """
        return pulumi.get(self, "alert_type")

    @_builtins.property
    @pulumi.getter(name="alertTypeId")
    def alert_type_id(self) -> _builtins.str:
        """
        type of alert
        """
        return pulumi.get(self, "alert_type_id")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> 'outputs.GetAlertsHistoryItemDestinationsResult':
        """
        the destinations this alert is configured to be delivered to
        """
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def device(self) -> 'outputs.GetAlertsHistoryItemDeviceResult':
        """
        info related to the device that caused the alert
        """
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter(name="occurredAt")
    def occurred_at(self) -> _builtins.str:
        """
        time when the event occurred
        """
        return pulumi.get(self, "occurred_at")


@pulumi.output_type
class GetAlertsHistoryItemDestinationsResult(dict):
    def __init__(__self__, *,
                 email: 'outputs.GetAlertsHistoryItemDestinationsEmailResult',
                 push: 'outputs.GetAlertsHistoryItemDestinationsPushResult',
                 sms: 'outputs.GetAlertsHistoryItemDestinationsSmsResult',
                 webhook: 'outputs.GetAlertsHistoryItemDestinationsWebhookResult'):
        """
        :param 'GetAlertsHistoryItemDestinationsEmailArgs' email: email destinations for this alert
        :param 'GetAlertsHistoryItemDestinationsPushArgs' push: push destinations for this alert
        :param 'GetAlertsHistoryItemDestinationsSmsArgs' sms: sms destinations for this alert
        :param 'GetAlertsHistoryItemDestinationsWebhookArgs' webhook: webhook destinations for this alert
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "push", push)
        pulumi.set(__self__, "sms", sms)
        pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter
    def email(self) -> 'outputs.GetAlertsHistoryItemDestinationsEmailResult':
        """
        email destinations for this alert
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def push(self) -> 'outputs.GetAlertsHistoryItemDestinationsPushResult':
        """
        push destinations for this alert
        """
        return pulumi.get(self, "push")

    @_builtins.property
    @pulumi.getter
    def sms(self) -> 'outputs.GetAlertsHistoryItemDestinationsSmsResult':
        """
        sms destinations for this alert
        """
        return pulumi.get(self, "sms")

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> 'outputs.GetAlertsHistoryItemDestinationsWebhookResult':
        """
        webhook destinations for this alert
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class GetAlertsHistoryItemDestinationsEmailResult(dict):
    def __init__(__self__, *,
                 sent_at: _builtins.str):
        """
        :param _builtins.str sent_at: time when the alert was sent to the user(s) for this channel
        """
        pulumi.set(__self__, "sent_at", sent_at)

    @_builtins.property
    @pulumi.getter(name="sentAt")
    def sent_at(self) -> _builtins.str:
        """
        time when the alert was sent to the user(s) for this channel
        """
        return pulumi.get(self, "sent_at")


@pulumi.output_type
class GetAlertsHistoryItemDestinationsPushResult(dict):
    def __init__(__self__, *,
                 sent_at: _builtins.str):
        """
        :param _builtins.str sent_at: time when the alert was sent to the user(s) for this channel
        """
        pulumi.set(__self__, "sent_at", sent_at)

    @_builtins.property
    @pulumi.getter(name="sentAt")
    def sent_at(self) -> _builtins.str:
        """
        time when the alert was sent to the user(s) for this channel
        """
        return pulumi.get(self, "sent_at")


@pulumi.output_type
class GetAlertsHistoryItemDestinationsSmsResult(dict):
    def __init__(__self__, *,
                 sent_at: _builtins.str):
        """
        :param _builtins.str sent_at: time when the alert was sent to the user(s) for this channel
        """
        pulumi.set(__self__, "sent_at", sent_at)

    @_builtins.property
    @pulumi.getter(name="sentAt")
    def sent_at(self) -> _builtins.str:
        """
        time when the alert was sent to the user(s) for this channel
        """
        return pulumi.get(self, "sent_at")


@pulumi.output_type
class GetAlertsHistoryItemDestinationsWebhookResult(dict):
    def __init__(__self__, *,
                 sent_at: _builtins.str):
        """
        :param _builtins.str sent_at: time when the alert was sent to the user(s) for this channel
        """
        pulumi.set(__self__, "sent_at", sent_at)

    @_builtins.property
    @pulumi.getter(name="sentAt")
    def sent_at(self) -> _builtins.str:
        """
        time when the alert was sent to the user(s) for this channel
        """
        return pulumi.get(self, "sent_at")


@pulumi.output_type
class GetAlertsHistoryItemDeviceResult(dict):
    def __init__(__self__, *,
                 serial: _builtins.str):
        """
        :param _builtins.str serial: device serial
        """
        pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        device serial
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class GetAlertsSettingsItemResult(dict):
    def __init__(__self__, *,
                 alerts: Sequence['outputs.GetAlertsSettingsItemAlertResult'],
                 default_destinations: 'outputs.GetAlertsSettingsItemDefaultDestinationsResult'):
        pulumi.set(__self__, "alerts", alerts)
        pulumi.set(__self__, "default_destinations", default_destinations)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Sequence['outputs.GetAlertsSettingsItemAlertResult']:
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter(name="defaultDestinations")
    def default_destinations(self) -> 'outputs.GetAlertsSettingsItemDefaultDestinationsResult':
        return pulumi.get(self, "default_destinations")


@pulumi.output_type
class GetAlertsSettingsItemAlertResult(dict):
    def __init__(__self__, *,
                 alert_destinations: 'outputs.GetAlertsSettingsItemAlertAlertDestinationsResult',
                 enabled: _builtins.bool,
                 filters: 'outputs.GetAlertsSettingsItemAlertFiltersResult',
                 type: _builtins.str):
        pulumi.set(__self__, "alert_destinations", alert_destinations)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="alertDestinations")
    def alert_destinations(self) -> 'outputs.GetAlertsSettingsItemAlertAlertDestinationsResult':
        return pulumi.get(self, "alert_destinations")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> 'outputs.GetAlertsSettingsItemAlertFiltersResult':
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAlertsSettingsItemAlertAlertDestinationsResult(dict):
    def __init__(__self__, *,
                 all_admins: _builtins.bool,
                 emails: Sequence[_builtins.str],
                 http_server_ids: Sequence[_builtins.str],
                 snmp: _builtins.bool):
        pulumi.set(__self__, "all_admins", all_admins)
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "http_server_ids", http_server_ids)
        pulumi.set(__self__, "snmp", snmp)

    @_builtins.property
    @pulumi.getter(name="allAdmins")
    def all_admins(self) -> _builtins.bool:
        return pulumi.get(self, "all_admins")

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="httpServerIds")
    def http_server_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "http_server_ids")

    @_builtins.property
    @pulumi.getter
    def snmp(self) -> _builtins.bool:
        return pulumi.get(self, "snmp")


@pulumi.output_type
class GetAlertsSettingsItemAlertFiltersResult(dict):
    def __init__(__self__, *,
                 timeout: _builtins.int):
        pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class GetAlertsSettingsItemDefaultDestinationsResult(dict):
    def __init__(__self__, *,
                 all_admins: _builtins.bool,
                 emails: Sequence[_builtins.str],
                 http_server_ids: Sequence[_builtins.str],
                 snmp: _builtins.bool):
        pulumi.set(__self__, "all_admins", all_admins)
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "http_server_ids", http_server_ids)
        pulumi.set(__self__, "snmp", snmp)

    @_builtins.property
    @pulumi.getter(name="allAdmins")
    def all_admins(self) -> _builtins.bool:
        return pulumi.get(self, "all_admins")

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="httpServerIds")
    def http_server_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "http_server_ids")

    @_builtins.property
    @pulumi.getter
    def snmp(self) -> _builtins.bool:
        return pulumi.get(self, "snmp")


@pulumi.output_type
class GetApplianceConnectivityMonitoringDestinationsItemResult(dict):
    def __init__(__self__, *,
                 destinations: Sequence['outputs.GetApplianceConnectivityMonitoringDestinationsItemDestinationResult']):
        pulumi.set(__self__, "destinations", destinations)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Sequence['outputs.GetApplianceConnectivityMonitoringDestinationsItemDestinationResult']:
        return pulumi.get(self, "destinations")


@pulumi.output_type
class GetApplianceConnectivityMonitoringDestinationsItemDestinationResult(dict):
    def __init__(__self__, *,
                 default: _builtins.bool,
                 description: _builtins.str,
                 ip: _builtins.str):
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def default(self) -> _builtins.bool:
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetApplianceContentFilteringCategoriesItemResult(dict):
    def __init__(__self__, *,
                 categories: Sequence['outputs.GetApplianceContentFilteringCategoriesItemCategoryResult']):
        pulumi.set(__self__, "categories", categories)

    @_builtins.property
    @pulumi.getter
    def categories(self) -> Sequence['outputs.GetApplianceContentFilteringCategoriesItemCategoryResult']:
        return pulumi.get(self, "categories")


@pulumi.output_type
class GetApplianceContentFilteringCategoriesItemCategoryResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApplianceContentFilteringItemResult(dict):
    def __init__(__self__, *,
                 allowed_url_patterns: Sequence[_builtins.str],
                 blocked_url_categories: Sequence['outputs.GetApplianceContentFilteringItemBlockedUrlCategoryResult'],
                 blocked_url_patterns: Sequence[_builtins.str],
                 url_category_list_size: _builtins.str):
        pulumi.set(__self__, "allowed_url_patterns", allowed_url_patterns)
        pulumi.set(__self__, "blocked_url_categories", blocked_url_categories)
        pulumi.set(__self__, "blocked_url_patterns", blocked_url_patterns)
        pulumi.set(__self__, "url_category_list_size", url_category_list_size)

    @_builtins.property
    @pulumi.getter(name="allowedUrlPatterns")
    def allowed_url_patterns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_url_patterns")

    @_builtins.property
    @pulumi.getter(name="blockedUrlCategories")
    def blocked_url_categories(self) -> Sequence['outputs.GetApplianceContentFilteringItemBlockedUrlCategoryResult']:
        return pulumi.get(self, "blocked_url_categories")

    @_builtins.property
    @pulumi.getter(name="blockedUrlPatterns")
    def blocked_url_patterns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "blocked_url_patterns")

    @_builtins.property
    @pulumi.getter(name="urlCategoryListSize")
    def url_category_list_size(self) -> _builtins.str:
        return pulumi.get(self, "url_category_list_size")


@pulumi.output_type
class GetApplianceContentFilteringItemBlockedUrlCategoryResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApplianceFirewallCellularFirewallRulesItemResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetApplianceFirewallCellularFirewallRulesItemRuleResult']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetApplianceFirewallCellularFirewallRulesItemRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetApplianceFirewallCellularFirewallRulesItemRuleResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 dest_cidr: _builtins.str,
                 dest_port: _builtins.str,
                 policy: _builtins.str,
                 protocol: _builtins.str,
                 src_cidr: _builtins.str,
                 src_port: _builtins.str,
                 syslog_enabled: _builtins.bool):
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "dest_cidr", dest_cidr)
        pulumi.set(__self__, "dest_port", dest_port)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "src_cidr", src_cidr)
        pulumi.set(__self__, "src_port", src_port)
        pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> _builtins.str:
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> _builtins.str:
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> _builtins.str:
        return pulumi.get(self, "src_cidr")

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> _builtins.str:
        return pulumi.get(self, "src_port")

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "syslog_enabled")


@pulumi.output_type
class GetApplianceFirewallFirewalledServicesItemResult(dict):
    def __init__(__self__, *,
                 access: _builtins.str,
                 allowed_ips: Sequence[_builtins.str],
                 service: _builtins.str):
        """
        :param _builtins.str access: A string indicating the rule for which IPs are allowed to use the specified service
        :param Sequence[_builtins.str] allowed_ips: An array of allowed IPs that can access the service
        :param _builtins.str service: Appliance service name
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "allowed_ips", allowed_ips)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def access(self) -> _builtins.str:
        """
        A string indicating the rule for which IPs are allowed to use the specified service
        """
        return pulumi.get(self, "access")

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Sequence[_builtins.str]:
        """
        An array of allowed IPs that can access the service
        """
        return pulumi.get(self, "allowed_ips")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Appliance service name
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetApplianceFirewallInboundFirewallRulesItemResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetApplianceFirewallInboundFirewallRulesItemRuleResult'],
                 syslog_default_rule: _builtins.bool):
        """
        :param Sequence['GetApplianceFirewallInboundFirewallRulesItemRuleArgs'] rules: An ordered array of the firewall rules (not including the default rule)
        :param _builtins.bool syslog_default_rule: Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
        """
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "syslog_default_rule", syslog_default_rule)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetApplianceFirewallInboundFirewallRulesItemRuleResult']:
        """
        An ordered array of the firewall rules (not including the default rule)
        """
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter(name="syslogDefaultRule")
    def syslog_default_rule(self) -> _builtins.bool:
        """
        Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
        """
        return pulumi.get(self, "syslog_default_rule")


@pulumi.output_type
class GetApplianceFirewallInboundFirewallRulesItemRuleResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 dest_cidr: _builtins.str,
                 dest_port: _builtins.str,
                 policy: _builtins.str,
                 protocol: _builtins.str,
                 src_cidr: _builtins.str,
                 src_port: _builtins.str,
                 syslog_enabled: _builtins.bool):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param _builtins.str dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        :param _builtins.str src_cidr: Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        :param _builtins.str src_port: Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.bool syslog_enabled: Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "dest_cidr", dest_cidr)
        pulumi.set(__self__, "dest_port", dest_port)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "src_cidr", src_cidr)
        pulumi.set(__self__, "src_port", src_port)
        pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> _builtins.str:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> _builtins.str:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> _builtins.str:
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        return pulumi.get(self, "src_cidr")

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> _builtins.str:
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "src_port")

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> _builtins.bool:
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        return pulumi.get(self, "syslog_enabled")


@pulumi.output_type
class GetApplianceFirewallL3FirewallRulesItemResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetApplianceFirewallL3FirewallRulesItemRuleResult']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetApplianceFirewallL3FirewallRulesItemRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetApplianceFirewallL3FirewallRulesItemRuleResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 dest_cidr: _builtins.str,
                 dest_port: _builtins.str,
                 policy: _builtins.str,
                 protocol: _builtins.str,
                 src_cidr: _builtins.str,
                 src_port: _builtins.str,
                 syslog_enabled: _builtins.bool):
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "dest_cidr", dest_cidr)
        pulumi.set(__self__, "dest_port", dest_port)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "src_cidr", src_cidr)
        pulumi.set(__self__, "src_port", src_port)
        pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> _builtins.str:
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> _builtins.str:
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> _builtins.str:
        return pulumi.get(self, "src_cidr")

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> _builtins.str:
        return pulumi.get(self, "src_port")

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "syslog_enabled")


@pulumi.output_type
class GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemResult(dict):
    def __init__(__self__, *,
                 application_categories: Sequence['outputs.GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategoryResult']):
        """
        :param Sequence['GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategoryArgs'] application_categories: The L7 firewall application categories and their associated applications for an MX network
        """
        pulumi.set(__self__, "application_categories", application_categories)

    @_builtins.property
    @pulumi.getter(name="applicationCategories")
    def application_categories(self) -> Sequence['outputs.GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategoryResult']:
        """
        The L7 firewall application categories and their associated applications for an MX network
        """
        return pulumi.get(self, "application_categories")


@pulumi.output_type
class GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategoryResult(dict):
    def __init__(__self__, *,
                 applications: Sequence['outputs.GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategoryApplicationResult'],
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param Sequence['GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategoryApplicationArgs'] applications: Details of the associated applications
        :param _builtins.str id: The id of the category
        :param _builtins.str name: The name of the category
        """
        pulumi.set(__self__, "applications", applications)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> Sequence['outputs.GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategoryApplicationResult']:
        """
        Details of the associated applications
        """
        return pulumi.get(self, "applications")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the category
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the category
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategoryApplicationResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: The id of the application
        :param _builtins.str name: The name of the application
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the application
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the application
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApplianceFirewallL7FirewallRulesItemResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetApplianceFirewallL7FirewallRulesItemRuleResult']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetApplianceFirewallL7FirewallRulesItemRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetApplianceFirewallL7FirewallRulesItemRuleResult(dict):
    def __init__(__self__, *,
                 policy: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetApplianceFirewallOneToManyNatRulesItemResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetApplianceFirewallOneToManyNatRulesItemRuleResult']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetApplianceFirewallOneToManyNatRulesItemRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetApplianceFirewallOneToManyNatRulesItemRuleResult(dict):
    def __init__(__self__, *,
                 port_rules: Sequence['outputs.GetApplianceFirewallOneToManyNatRulesItemRulePortRuleResult'],
                 public_ip: _builtins.str,
                 uplink: _builtins.str):
        pulumi.set(__self__, "port_rules", port_rules)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "uplink", uplink)

    @_builtins.property
    @pulumi.getter(name="portRules")
    def port_rules(self) -> Sequence['outputs.GetApplianceFirewallOneToManyNatRulesItemRulePortRuleResult']:
        return pulumi.get(self, "port_rules")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> _builtins.str:
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def uplink(self) -> _builtins.str:
        return pulumi.get(self, "uplink")


@pulumi.output_type
class GetApplianceFirewallOneToManyNatRulesItemRulePortRuleResult(dict):
    def __init__(__self__, *,
                 allowed_ips: Sequence[_builtins.str],
                 local_ip: _builtins.str,
                 local_port: _builtins.str,
                 name: _builtins.str,
                 protocol: _builtins.str,
                 public_port: _builtins.str):
        pulumi.set(__self__, "allowed_ips", allowed_ips)
        pulumi.set(__self__, "local_ip", local_ip)
        pulumi.set(__self__, "local_port", local_port)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "public_port", public_port)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_ips")

    @_builtins.property
    @pulumi.getter(name="localIp")
    def local_ip(self) -> _builtins.str:
        return pulumi.get(self, "local_ip")

    @_builtins.property
    @pulumi.getter(name="localPort")
    def local_port(self) -> _builtins.str:
        return pulumi.get(self, "local_port")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="publicPort")
    def public_port(self) -> _builtins.str:
        return pulumi.get(self, "public_port")


@pulumi.output_type
class GetApplianceFirewallOneToOneNatRulesItemResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetApplianceFirewallOneToOneNatRulesItemRuleResult']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetApplianceFirewallOneToOneNatRulesItemRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetApplianceFirewallOneToOneNatRulesItemRuleResult(dict):
    def __init__(__self__, *,
                 allowed_inbounds: Sequence['outputs.GetApplianceFirewallOneToOneNatRulesItemRuleAllowedInboundResult'],
                 lan_ip: _builtins.str,
                 name: _builtins.str,
                 public_ip: _builtins.str,
                 uplink: _builtins.str):
        pulumi.set(__self__, "allowed_inbounds", allowed_inbounds)
        pulumi.set(__self__, "lan_ip", lan_ip)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "uplink", uplink)

    @_builtins.property
    @pulumi.getter(name="allowedInbounds")
    def allowed_inbounds(self) -> Sequence['outputs.GetApplianceFirewallOneToOneNatRulesItemRuleAllowedInboundResult']:
        return pulumi.get(self, "allowed_inbounds")

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> _builtins.str:
        return pulumi.get(self, "lan_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> _builtins.str:
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def uplink(self) -> _builtins.str:
        return pulumi.get(self, "uplink")


@pulumi.output_type
class GetApplianceFirewallOneToOneNatRulesItemRuleAllowedInboundResult(dict):
    def __init__(__self__, *,
                 allowed_ips: Sequence[_builtins.str],
                 destination_ports: Sequence[_builtins.str],
                 protocol: _builtins.str):
        pulumi.set(__self__, "allowed_ips", allowed_ips)
        pulumi.set(__self__, "destination_ports", destination_ports)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_ips")

    @_builtins.property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "destination_ports")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetApplianceFirewallPortForwardingRulesItemResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetApplianceFirewallPortForwardingRulesItemRuleResult']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetApplianceFirewallPortForwardingRulesItemRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetApplianceFirewallPortForwardingRulesItemRuleResult(dict):
    def __init__(__self__, *,
                 allowed_ips: Sequence[_builtins.str],
                 lan_ip: _builtins.str,
                 local_port: _builtins.str,
                 name: _builtins.str,
                 protocol: _builtins.str,
                 public_port: _builtins.str,
                 uplink: _builtins.str):
        pulumi.set(__self__, "allowed_ips", allowed_ips)
        pulumi.set(__self__, "lan_ip", lan_ip)
        pulumi.set(__self__, "local_port", local_port)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "public_port", public_port)
        pulumi.set(__self__, "uplink", uplink)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_ips")

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> _builtins.str:
        return pulumi.get(self, "lan_ip")

    @_builtins.property
    @pulumi.getter(name="localPort")
    def local_port(self) -> _builtins.str:
        return pulumi.get(self, "local_port")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="publicPort")
    def public_port(self) -> _builtins.str:
        return pulumi.get(self, "public_port")

    @_builtins.property
    @pulumi.getter
    def uplink(self) -> _builtins.str:
        return pulumi.get(self, "uplink")


@pulumi.output_type
class GetApplianceFirewallSettingsItemResult(dict):
    def __init__(__self__, *,
                 spoofing_protection: 'outputs.GetApplianceFirewallSettingsItemSpoofingProtectionResult'):
        pulumi.set(__self__, "spoofing_protection", spoofing_protection)

    @_builtins.property
    @pulumi.getter(name="spoofingProtection")
    def spoofing_protection(self) -> 'outputs.GetApplianceFirewallSettingsItemSpoofingProtectionResult':
        return pulumi.get(self, "spoofing_protection")


@pulumi.output_type
class GetApplianceFirewallSettingsItemSpoofingProtectionResult(dict):
    def __init__(__self__, *,
                 ip_source_guard: 'outputs.GetApplianceFirewallSettingsItemSpoofingProtectionIpSourceGuardResult'):
        pulumi.set(__self__, "ip_source_guard", ip_source_guard)

    @_builtins.property
    @pulumi.getter(name="ipSourceGuard")
    def ip_source_guard(self) -> 'outputs.GetApplianceFirewallSettingsItemSpoofingProtectionIpSourceGuardResult':
        return pulumi.get(self, "ip_source_guard")


@pulumi.output_type
class GetApplianceFirewallSettingsItemSpoofingProtectionIpSourceGuardResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetAppliancePortsItemResult(dict):
    def __init__(__self__, *,
                 access_policy: _builtins.str,
                 allowed_vlans: _builtins.str,
                 drop_untagged_traffic: _builtins.bool,
                 enabled: _builtins.bool,
                 number: _builtins.int,
                 type: _builtins.str,
                 vlan: _builtins.int):
        """
        :param _builtins.str access_policy: The name of the policy. Only applicable to Access ports.
        :param _builtins.str allowed_vlans: Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
        :param _builtins.bool drop_untagged_traffic: Whether the trunk port can drop all untagged traffic.
        :param _builtins.bool enabled: The status of the port
        :param _builtins.int number: Number of the port
        :param _builtins.str type: The type of the port: 'access' or 'trunk'.
        :param _builtins.int vlan: Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
        """
        pulumi.set(__self__, "access_policy", access_policy)
        pulumi.set(__self__, "allowed_vlans", allowed_vlans)
        pulumi.set(__self__, "drop_untagged_traffic", drop_untagged_traffic)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter(name="accessPolicy")
    def access_policy(self) -> _builtins.str:
        """
        The name of the policy. Only applicable to Access ports.
        """
        return pulumi.get(self, "access_policy")

    @_builtins.property
    @pulumi.getter(name="allowedVlans")
    def allowed_vlans(self) -> _builtins.str:
        """
        Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
        """
        return pulumi.get(self, "allowed_vlans")

    @_builtins.property
    @pulumi.getter(name="dropUntaggedTraffic")
    def drop_untagged_traffic(self) -> _builtins.bool:
        """
        Whether the trunk port can drop all untagged traffic.
        """
        return pulumi.get(self, "drop_untagged_traffic")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        The status of the port
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def number(self) -> _builtins.int:
        """
        Number of the port
        """
        return pulumi.get(self, "number")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the port: 'access' or 'trunk'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.int:
        """
        Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetAppliancePrefixesDelegatedStaticsItemResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 origin: 'outputs.GetAppliancePrefixesDelegatedStaticsItemOriginResult',
                 prefix: _builtins.str,
                 static_delegated_prefix_id: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: Prefix creation time.
        :param _builtins.str description: Identifying description for the prefix.
        :param 'GetAppliancePrefixesDelegatedStaticsItemOriginArgs' origin: WAN1/WAN2/Independent prefix.
        :param _builtins.str prefix: IPv6 prefix/prefix length.
        :param _builtins.str static_delegated_prefix_id: Static delegated prefix id.
        :param _builtins.str updated_at: Prefix Updated time.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "static_delegated_prefix_id", static_delegated_prefix_id)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Prefix creation time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Identifying description for the prefix.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> 'outputs.GetAppliancePrefixesDelegatedStaticsItemOriginResult':
        """
        WAN1/WAN2/Independent prefix.
        """
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        IPv6 prefix/prefix length.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter(name="staticDelegatedPrefixId")
    def static_delegated_prefix_id(self) -> _builtins.str:
        """
        Static delegated prefix id.
        """
        return pulumi.get(self, "static_delegated_prefix_id")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Prefix Updated time.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetAppliancePrefixesDelegatedStaticsItemOriginResult(dict):
    def __init__(__self__, *,
                 interfaces: Sequence[_builtins.str],
                 type: _builtins.str):
        """
        :param Sequence[_builtins.str] interfaces: Uplink provided or independent
        :param _builtins.str type: Origin type
        """
        pulumi.set(__self__, "interfaces", interfaces)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Sequence[_builtins.str]:
        """
        Uplink provided or independent
        """
        return pulumi.get(self, "interfaces")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Origin type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetApplianceRfProfilesItemResult(dict):
    def __init__(__self__, *,
                 five_ghz_settings: 'outputs.GetApplianceRfProfilesItemFiveGhzSettingsResult',
                 id: _builtins.str,
                 name: _builtins.str,
                 network_id: _builtins.str,
                 per_ssid_settings: 'outputs.GetApplianceRfProfilesItemPerSsidSettingsResult',
                 two_four_ghz_settings: 'outputs.GetApplianceRfProfilesItemTwoFourGhzSettingsResult'):
        """
        :param 'GetApplianceRfProfilesItemFiveGhzSettingsArgs' five_ghz_settings: Settings related to 5Ghz band.
        :param _builtins.str id: ID of the RF Profile.
        :param _builtins.str name: The name of the profile.
        :param _builtins.str network_id: ID of network this RF Profile belongs in.
        :param 'GetApplianceRfProfilesItemPerSsidSettingsArgs' per_ssid_settings: Per-SSID radio settings by number.
        :param 'GetApplianceRfProfilesItemTwoFourGhzSettingsArgs' two_four_ghz_settings: Settings related to 2.4Ghz band.
        """
        pulumi.set(__self__, "five_ghz_settings", five_ghz_settings)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "per_ssid_settings", per_ssid_settings)
        pulumi.set(__self__, "two_four_ghz_settings", two_four_ghz_settings)

    @_builtins.property
    @pulumi.getter(name="fiveGhzSettings")
    def five_ghz_settings(self) -> 'outputs.GetApplianceRfProfilesItemFiveGhzSettingsResult':
        """
        Settings related to 5Ghz band.
        """
        return pulumi.get(self, "five_ghz_settings")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the RF Profile.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the profile.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        ID of network this RF Profile belongs in.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="perSsidSettings")
    def per_ssid_settings(self) -> 'outputs.GetApplianceRfProfilesItemPerSsidSettingsResult':
        """
        Per-SSID radio settings by number.
        """
        return pulumi.get(self, "per_ssid_settings")

    @_builtins.property
    @pulumi.getter(name="twoFourGhzSettings")
    def two_four_ghz_settings(self) -> 'outputs.GetApplianceRfProfilesItemTwoFourGhzSettingsResult':
        """
        Settings related to 2.4Ghz band.
        """
        return pulumi.get(self, "two_four_ghz_settings")


@pulumi.output_type
class GetApplianceRfProfilesItemFiveGhzSettingsResult(dict):
    def __init__(__self__, *,
                 ax_enabled: _builtins.bool,
                 min_bitrate: _builtins.int):
        """
        :param _builtins.bool ax_enabled: Whether ax radio on 5Ghz band is on or off.
        :param _builtins.int min_bitrate: Min bitrate (Mbps) of 2.4Ghz band.
        """
        pulumi.set(__self__, "ax_enabled", ax_enabled)
        pulumi.set(__self__, "min_bitrate", min_bitrate)

    @_builtins.property
    @pulumi.getter(name="axEnabled")
    def ax_enabled(self) -> _builtins.bool:
        """
        Whether ax radio on 5Ghz band is on or off.
        """
        return pulumi.get(self, "ax_enabled")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Min bitrate (Mbps) of 2.4Ghz band.
        """
        return pulumi.get(self, "min_bitrate")


@pulumi.output_type
class GetApplianceRfProfilesItemPerSsidSettingsResult(dict):
    def __init__(__self__, *,
                 status1: 'outputs.GetApplianceRfProfilesItemPerSsidSettingsStatus1Result',
                 status2: 'outputs.GetApplianceRfProfilesItemPerSsidSettingsStatus2Result',
                 status3: 'outputs.GetApplianceRfProfilesItemPerSsidSettingsStatus3Result',
                 status4: 'outputs.GetApplianceRfProfilesItemPerSsidSettingsStatus4Result'):
        """
        :param 'GetApplianceRfProfilesItemPerSsidSettingsStatus1Args' status1: Settings for SSID 1.
        :param 'GetApplianceRfProfilesItemPerSsidSettingsStatus2Args' status2: Settings for SSID 2.
        :param 'GetApplianceRfProfilesItemPerSsidSettingsStatus3Args' status3: Settings for SSID 3.
        :param 'GetApplianceRfProfilesItemPerSsidSettingsStatus4Args' status4: Settings for SSID 4.
        """
        pulumi.set(__self__, "status1", status1)
        pulumi.set(__self__, "status2", status2)
        pulumi.set(__self__, "status3", status3)
        pulumi.set(__self__, "status4", status4)

    @_builtins.property
    @pulumi.getter
    def status1(self) -> 'outputs.GetApplianceRfProfilesItemPerSsidSettingsStatus1Result':
        """
        Settings for SSID 1.
        """
        return pulumi.get(self, "status1")

    @_builtins.property
    @pulumi.getter
    def status2(self) -> 'outputs.GetApplianceRfProfilesItemPerSsidSettingsStatus2Result':
        """
        Settings for SSID 2.
        """
        return pulumi.get(self, "status2")

    @_builtins.property
    @pulumi.getter
    def status3(self) -> 'outputs.GetApplianceRfProfilesItemPerSsidSettingsStatus3Result':
        """
        Settings for SSID 3.
        """
        return pulumi.get(self, "status3")

    @_builtins.property
    @pulumi.getter
    def status4(self) -> 'outputs.GetApplianceRfProfilesItemPerSsidSettingsStatus4Result':
        """
        Settings for SSID 4.
        """
        return pulumi.get(self, "status4")


@pulumi.output_type
class GetApplianceRfProfilesItemPerSsidSettingsStatus1Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool):
        """
        :param _builtins.str band_operation_mode: Band mode of this SSID
        :param _builtins.bool band_steering_enabled: Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Band mode of this SSID
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        return pulumi.get(self, "band_steering_enabled")


@pulumi.output_type
class GetApplianceRfProfilesItemPerSsidSettingsStatus2Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool):
        """
        :param _builtins.str band_operation_mode: Band mode of this SSID
        :param _builtins.bool band_steering_enabled: Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Band mode of this SSID
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        return pulumi.get(self, "band_steering_enabled")


@pulumi.output_type
class GetApplianceRfProfilesItemPerSsidSettingsStatus3Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool):
        """
        :param _builtins.str band_operation_mode: Band mode of this SSID
        :param _builtins.bool band_steering_enabled: Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Band mode of this SSID
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        return pulumi.get(self, "band_steering_enabled")


@pulumi.output_type
class GetApplianceRfProfilesItemPerSsidSettingsStatus4Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool):
        """
        :param _builtins.str band_operation_mode: Band mode of this SSID
        :param _builtins.bool band_steering_enabled: Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Band mode of this SSID
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        return pulumi.get(self, "band_steering_enabled")


@pulumi.output_type
class GetApplianceRfProfilesItemTwoFourGhzSettingsResult(dict):
    def __init__(__self__, *,
                 ax_enabled: _builtins.bool,
                 min_bitrate: _builtins.float):
        """
        :param _builtins.bool ax_enabled: Whether ax radio on 2.4Ghz band is on or off.
        :param _builtins.float min_bitrate: Min bitrate (Mbps) of 2.4Ghz band.
        """
        pulumi.set(__self__, "ax_enabled", ax_enabled)
        pulumi.set(__self__, "min_bitrate", min_bitrate)

    @_builtins.property
    @pulumi.getter(name="axEnabled")
    def ax_enabled(self) -> _builtins.bool:
        """
        Whether ax radio on 2.4Ghz band is on or off.
        """
        return pulumi.get(self, "ax_enabled")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.float:
        """
        Min bitrate (Mbps) of 2.4Ghz band.
        """
        return pulumi.get(self, "min_bitrate")


@pulumi.output_type
class GetApplianceSecurityIntrusionItemResult(dict):
    def __init__(__self__, *,
                 ids_rulesets: _builtins.str,
                 mode: _builtins.str,
                 protected_networks: 'outputs.GetApplianceSecurityIntrusionItemProtectedNetworksResult'):
        """
        :param _builtins.str ids_rulesets: Intrusion detection ruleset
        :param _builtins.str mode: Intrusion detection mode
        :param 'GetApplianceSecurityIntrusionItemProtectedNetworksArgs' protected_networks: Networks included in and excluded from the detection engine
        """
        pulumi.set(__self__, "ids_rulesets", ids_rulesets)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "protected_networks", protected_networks)

    @_builtins.property
    @pulumi.getter(name="idsRulesets")
    def ids_rulesets(self) -> _builtins.str:
        """
        Intrusion detection ruleset
        """
        return pulumi.get(self, "ids_rulesets")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Intrusion detection mode
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="protectedNetworks")
    def protected_networks(self) -> 'outputs.GetApplianceSecurityIntrusionItemProtectedNetworksResult':
        """
        Networks included in and excluded from the detection engine
        """
        return pulumi.get(self, "protected_networks")


@pulumi.output_type
class GetApplianceSecurityIntrusionItemProtectedNetworksResult(dict):
    def __init__(__self__, *,
                 excluded_cidrs: Sequence[_builtins.str],
                 included_cidrs: Sequence[_builtins.str],
                 use_default: _builtins.bool):
        """
        :param Sequence[_builtins.str] excluded_cidrs: List of IP addresses or subnets being excluded from protection
        :param Sequence[_builtins.str] included_cidrs: List of IP addresses or subnets being protected
        :param _builtins.bool use_default: Whether special IPv4 addresses should be used (see: https://tools.ietf.org/html/rfc5735)
        """
        pulumi.set(__self__, "excluded_cidrs", excluded_cidrs)
        pulumi.set(__self__, "included_cidrs", included_cidrs)
        pulumi.set(__self__, "use_default", use_default)

    @_builtins.property
    @pulumi.getter(name="excludedCidrs")
    def excluded_cidrs(self) -> Sequence[_builtins.str]:
        """
        List of IP addresses or subnets being excluded from protection
        """
        return pulumi.get(self, "excluded_cidrs")

    @_builtins.property
    @pulumi.getter(name="includedCidrs")
    def included_cidrs(self) -> Sequence[_builtins.str]:
        """
        List of IP addresses or subnets being protected
        """
        return pulumi.get(self, "included_cidrs")

    @_builtins.property
    @pulumi.getter(name="useDefault")
    def use_default(self) -> _builtins.bool:
        """
        Whether special IPv4 addresses should be used (see: https://tools.ietf.org/html/rfc5735)
        """
        return pulumi.get(self, "use_default")


@pulumi.output_type
class GetApplianceSecurityMalwareItemResult(dict):
    def __init__(__self__, *,
                 allowed_files: Sequence['outputs.GetApplianceSecurityMalwareItemAllowedFileResult'],
                 allowed_urls: Sequence['outputs.GetApplianceSecurityMalwareItemAllowedUrlResult'],
                 mode: _builtins.str):
        """
        :param Sequence['GetApplianceSecurityMalwareItemAllowedFileArgs'] allowed_files: Sha256 digests of files permitted by the malware detection engine
        :param Sequence['GetApplianceSecurityMalwareItemAllowedUrlArgs'] allowed_urls: URLs permitted by the malware detection engine
        :param _builtins.str mode: Current status of malware prevention
        """
        pulumi.set(__self__, "allowed_files", allowed_files)
        pulumi.set(__self__, "allowed_urls", allowed_urls)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="allowedFiles")
    def allowed_files(self) -> Sequence['outputs.GetApplianceSecurityMalwareItemAllowedFileResult']:
        """
        Sha256 digests of files permitted by the malware detection engine
        """
        return pulumi.get(self, "allowed_files")

    @_builtins.property
    @pulumi.getter(name="allowedUrls")
    def allowed_urls(self) -> Sequence['outputs.GetApplianceSecurityMalwareItemAllowedUrlResult']:
        """
        URLs permitted by the malware detection engine
        """
        return pulumi.get(self, "allowed_urls")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Current status of malware prevention
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetApplianceSecurityMalwareItemAllowedFileResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 sha256: _builtins.str):
        """
        :param _builtins.str comment: Comment about the allowed file
        :param _builtins.str sha256: The sha256 digest of allowed file
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        Comment about the allowed file
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> _builtins.str:
        """
        The sha256 digest of allowed file
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class GetApplianceSecurityMalwareItemAllowedUrlResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str comment: Comment about the allowed URL
        :param _builtins.str url: The allowed URL
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        Comment about the allowed URL
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The allowed URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetApplianceSettingsItemResult(dict):
    def __init__(__self__, *,
                 client_tracking_method: _builtins.str,
                 deployment_mode: _builtins.str,
                 dynamic_dns: 'outputs.GetApplianceSettingsItemDynamicDnsResult'):
        """
        :param _builtins.str client_tracking_method: Client tracking method of a network
        :param _builtins.str deployment_mode: Deployment mode of a network
        :param 'GetApplianceSettingsItemDynamicDnsArgs' dynamic_dns: Dynamic DNS settings for a network
        """
        pulumi.set(__self__, "client_tracking_method", client_tracking_method)
        pulumi.set(__self__, "deployment_mode", deployment_mode)
        pulumi.set(__self__, "dynamic_dns", dynamic_dns)

    @_builtins.property
    @pulumi.getter(name="clientTrackingMethod")
    def client_tracking_method(self) -> _builtins.str:
        """
        Client tracking method of a network
        """
        return pulumi.get(self, "client_tracking_method")

    @_builtins.property
    @pulumi.getter(name="deploymentMode")
    def deployment_mode(self) -> _builtins.str:
        """
        Deployment mode of a network
        """
        return pulumi.get(self, "deployment_mode")

    @_builtins.property
    @pulumi.getter(name="dynamicDns")
    def dynamic_dns(self) -> 'outputs.GetApplianceSettingsItemDynamicDnsResult':
        """
        Dynamic DNS settings for a network
        """
        return pulumi.get(self, "dynamic_dns")


@pulumi.output_type
class GetApplianceSettingsItemDynamicDnsResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 prefix: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.bool enabled: Dynamic DNS enabled
        :param _builtins.str prefix: Dynamic DNS url prefix. DDNS must be enabled to update
        :param _builtins.str url: Dynamic DNS url. DDNS must be enabled to update
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Dynamic DNS enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        Dynamic DNS url prefix. DDNS must be enabled to update
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Dynamic DNS url. DDNS must be enabled to update
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetApplianceSingleLanItemResult(dict):
    def __init__(__self__, *,
                 appliance_ip: _builtins.str,
                 ipv6: 'outputs.GetApplianceSingleLanItemIpv6Result',
                 mandatory_dhcp: 'outputs.GetApplianceSingleLanItemMandatoryDhcpResult',
                 subnet: _builtins.str):
        """
        :param _builtins.str appliance_ip: The local IP of the appliance on the single LAN
        :param 'GetApplianceSingleLanItemIpv6Args' ipv6: IPv6 configuration on the single LAN
        :param 'GetApplianceSingleLanItemMandatoryDhcpArgs' mandatory_dhcp: Mandatory DHCP will enforce that clients connecting to this single LAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
        :param _builtins.str subnet: The subnet of the single LAN
        """
        pulumi.set(__self__, "appliance_ip", appliance_ip)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "mandatory_dhcp", mandatory_dhcp)
        pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter(name="applianceIp")
    def appliance_ip(self) -> _builtins.str:
        """
        The local IP of the appliance on the single LAN
        """
        return pulumi.get(self, "appliance_ip")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> 'outputs.GetApplianceSingleLanItemIpv6Result':
        """
        IPv6 configuration on the single LAN
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="mandatoryDhcp")
    def mandatory_dhcp(self) -> 'outputs.GetApplianceSingleLanItemMandatoryDhcpResult':
        """
        Mandatory DHCP will enforce that clients connecting to this single LAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
        """
        return pulumi.get(self, "mandatory_dhcp")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        The subnet of the single LAN
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class GetApplianceSingleLanItemIpv6Result(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 prefix_assignments: Sequence['outputs.GetApplianceSingleLanItemIpv6PrefixAssignmentResult']):
        """
        :param _builtins.bool enabled: Enable IPv6 on single LAN
        :param Sequence['GetApplianceSingleLanItemIpv6PrefixAssignmentArgs'] prefix_assignments: Prefix assignments on the single LAN
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "prefix_assignments", prefix_assignments)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable IPv6 on single LAN
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="prefixAssignments")
    def prefix_assignments(self) -> Sequence['outputs.GetApplianceSingleLanItemIpv6PrefixAssignmentResult']:
        """
        Prefix assignments on the single LAN
        """
        return pulumi.get(self, "prefix_assignments")


@pulumi.output_type
class GetApplianceSingleLanItemIpv6PrefixAssignmentResult(dict):
    def __init__(__self__, *,
                 autonomous: _builtins.bool,
                 origin: 'outputs.GetApplianceSingleLanItemIpv6PrefixAssignmentOriginResult',
                 static_appliance_ip6: _builtins.str,
                 static_prefix: _builtins.str):
        """
        :param _builtins.bool autonomous: Auto assign a /64 prefix from the origin to the single LAN
        :param 'GetApplianceSingleLanItemIpv6PrefixAssignmentOriginArgs' origin: The origin of the prefix
        :param _builtins.str static_appliance_ip6: Manual configuration of the IPv6 Appliance IP
        :param _builtins.str static_prefix: Manual configuration of a /64 prefix on the single LAN
        """
        pulumi.set(__self__, "autonomous", autonomous)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "static_appliance_ip6", static_appliance_ip6)
        pulumi.set(__self__, "static_prefix", static_prefix)

    @_builtins.property
    @pulumi.getter
    def autonomous(self) -> _builtins.bool:
        """
        Auto assign a /64 prefix from the origin to the single LAN
        """
        return pulumi.get(self, "autonomous")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> 'outputs.GetApplianceSingleLanItemIpv6PrefixAssignmentOriginResult':
        """
        The origin of the prefix
        """
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="staticApplianceIp6")
    def static_appliance_ip6(self) -> _builtins.str:
        """
        Manual configuration of the IPv6 Appliance IP
        """
        return pulumi.get(self, "static_appliance_ip6")

    @_builtins.property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> _builtins.str:
        """
        Manual configuration of a /64 prefix on the single LAN
        """
        return pulumi.get(self, "static_prefix")


@pulumi.output_type
class GetApplianceSingleLanItemIpv6PrefixAssignmentOriginResult(dict):
    def __init__(__self__, *,
                 interfaces: Sequence[_builtins.str],
                 type: _builtins.str):
        """
        :param Sequence[_builtins.str] interfaces: Interfaces associated with the prefix
        :param _builtins.str type: Type of the origin
        """
        pulumi.set(__self__, "interfaces", interfaces)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Sequence[_builtins.str]:
        """
        Interfaces associated with the prefix
        """
        return pulumi.get(self, "interfaces")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the origin
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetApplianceSingleLanItemMandatoryDhcpResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Enable Mandatory DHCP on single LAN.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable Mandatory DHCP on single LAN.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetApplianceSsidsItemResult(dict):
    def __init__(__self__, *,
                 auth_mode: _builtins.str,
                 default_vlan_id: _builtins.int,
                 enabled: _builtins.bool,
                 encryption_mode: _builtins.str,
                 name: _builtins.str,
                 number: _builtins.int,
                 radius_servers: Sequence['outputs.GetApplianceSsidsItemRadiusServerResult'],
                 visible: _builtins.bool,
                 wpa_encryption_mode: _builtins.str):
        """
        :param _builtins.str auth_mode: The association control method for the SSID.
        :param _builtins.int default_vlan_id: The VLAN ID of the VLAN associated to this SSID.
        :param _builtins.bool enabled: Whether or not the SSID is enabled.
        :param _builtins.str encryption_mode: The psk encryption mode for the SSID.
        :param _builtins.str name: The name of the SSID.
        :param _builtins.int number: The number of the SSID.
        :param Sequence['GetApplianceSsidsItemRadiusServerArgs'] radius_servers: The RADIUS 802.1x servers to be used for authentication.
        :param _builtins.bool visible: Boolean indicating whether the MX should advertise or hide this SSID.
        :param _builtins.str wpa_encryption_mode: WPA encryption mode for the SSID.
        """
        pulumi.set(__self__, "auth_mode", auth_mode)
        pulumi.set(__self__, "default_vlan_id", default_vlan_id)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "encryption_mode", encryption_mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "radius_servers", radius_servers)
        pulumi.set(__self__, "visible", visible)
        pulumi.set(__self__, "wpa_encryption_mode", wpa_encryption_mode)

    @_builtins.property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> _builtins.str:
        """
        The association control method for the SSID.
        """
        return pulumi.get(self, "auth_mode")

    @_builtins.property
    @pulumi.getter(name="defaultVlanId")
    def default_vlan_id(self) -> _builtins.int:
        """
        The VLAN ID of the VLAN associated to this SSID.
        """
        return pulumi.get(self, "default_vlan_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether or not the SSID is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="encryptionMode")
    def encryption_mode(self) -> _builtins.str:
        """
        The psk encryption mode for the SSID.
        """
        return pulumi.get(self, "encryption_mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the SSID.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def number(self) -> _builtins.int:
        """
        The number of the SSID.
        """
        return pulumi.get(self, "number")

    @_builtins.property
    @pulumi.getter(name="radiusServers")
    def radius_servers(self) -> Sequence['outputs.GetApplianceSsidsItemRadiusServerResult']:
        """
        The RADIUS 802.1x servers to be used for authentication.
        """
        return pulumi.get(self, "radius_servers")

    @_builtins.property
    @pulumi.getter
    def visible(self) -> _builtins.bool:
        """
        Boolean indicating whether the MX should advertise or hide this SSID.
        """
        return pulumi.get(self, "visible")

    @_builtins.property
    @pulumi.getter(name="wpaEncryptionMode")
    def wpa_encryption_mode(self) -> _builtins.str:
        """
        WPA encryption mode for the SSID.
        """
        return pulumi.get(self, "wpa_encryption_mode")


@pulumi.output_type
class GetApplianceSsidsItemRadiusServerResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str host: The IP address of your RADIUS server.
        :param _builtins.int port: The UDP port your RADIUS servers listens on for Access-requests.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The IP address of your RADIUS server.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The UDP port your RADIUS servers listens on for Access-requests.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetApplianceTrafficShapingItemResult(dict):
    def __init__(__self__, *,
                 global_bandwidth_limits: 'outputs.GetApplianceTrafficShapingItemGlobalBandwidthLimitsResult'):
        pulumi.set(__self__, "global_bandwidth_limits", global_bandwidth_limits)

    @_builtins.property
    @pulumi.getter(name="globalBandwidthLimits")
    def global_bandwidth_limits(self) -> 'outputs.GetApplianceTrafficShapingItemGlobalBandwidthLimitsResult':
        return pulumi.get(self, "global_bandwidth_limits")


@pulumi.output_type
class GetApplianceTrafficShapingItemGlobalBandwidthLimitsResult(dict):
    def __init__(__self__, *,
                 limit_down: _builtins.int,
                 limit_up: _builtins.int):
        pulumi.set(__self__, "limit_down", limit_down)
        pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> _builtins.int:
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> _builtins.int:
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class GetApplianceTrafficShapingRulesItemResult(dict):
    def __init__(__self__, *,
                 default_rules_enabled: _builtins.bool,
                 rules: Sequence['outputs.GetApplianceTrafficShapingRulesItemRuleResult']):
        pulumi.set(__self__, "default_rules_enabled", default_rules_enabled)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="defaultRulesEnabled")
    def default_rules_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "default_rules_enabled")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetApplianceTrafficShapingRulesItemRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetApplianceTrafficShapingRulesItemRuleResult(dict):
    def __init__(__self__, *,
                 definitions: Sequence['outputs.GetApplianceTrafficShapingRulesItemRuleDefinitionResult'],
                 dscp_tag_value: _builtins.int,
                 per_client_bandwidth_limits: 'outputs.GetApplianceTrafficShapingRulesItemRulePerClientBandwidthLimitsResult',
                 priority: _builtins.str):
        pulumi.set(__self__, "definitions", definitions)
        pulumi.set(__self__, "dscp_tag_value", dscp_tag_value)
        pulumi.set(__self__, "per_client_bandwidth_limits", per_client_bandwidth_limits)
        pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> Sequence['outputs.GetApplianceTrafficShapingRulesItemRuleDefinitionResult']:
        return pulumi.get(self, "definitions")

    @_builtins.property
    @pulumi.getter(name="dscpTagValue")
    def dscp_tag_value(self) -> _builtins.int:
        return pulumi.get(self, "dscp_tag_value")

    @_builtins.property
    @pulumi.getter(name="perClientBandwidthLimits")
    def per_client_bandwidth_limits(self) -> 'outputs.GetApplianceTrafficShapingRulesItemRulePerClientBandwidthLimitsResult':
        return pulumi.get(self, "per_client_bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.str:
        return pulumi.get(self, "priority")


@pulumi.output_type
class GetApplianceTrafficShapingRulesItemRuleDefinitionResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetApplianceTrafficShapingRulesItemRulePerClientBandwidthLimitsResult(dict):
    def __init__(__self__, *,
                 bandwidth_limits: 'outputs.GetApplianceTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimitsResult',
                 settings: _builtins.str):
        pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> 'outputs.GetApplianceTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimitsResult':
        return pulumi.get(self, "bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> _builtins.str:
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetApplianceTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimitsResult(dict):
    def __init__(__self__, *,
                 limit_down: _builtins.int,
                 limit_up: _builtins.int):
        pulumi.set(__self__, "limit_down", limit_down)
        pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> _builtins.int:
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> _builtins.int:
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkBandwidthItemResult(dict):
    def __init__(__self__, *,
                 bandwidth_limits: 'outputs.GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsResult'):
        """
        :param 'GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsArgs' bandwidth_limits: A hash uplink keys and their configured settings for the Appliance
        """
        pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> 'outputs.GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsResult':
        """
        A hash uplink keys and their configured settings for the Appliance
        """
        return pulumi.get(self, "bandwidth_limits")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsResult(dict):
    def __init__(__self__, *,
                 cellular: 'outputs.GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsCellularResult',
                 wan1: 'outputs.GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan1Result',
                 wan2: 'outputs.GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan2Result'):
        """
        :param 'GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsCellularArgs' cellular: uplink cellular configured limits [optional]
        :param 'GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan1Args' wan1: uplink wan1 configured limits [optional]
        :param 'GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan2Args' wan2: uplink wan2 configured limits [optional]
        """
        pulumi.set(__self__, "cellular", cellular)
        pulumi.set(__self__, "wan1", wan1)
        pulumi.set(__self__, "wan2", wan2)

    @_builtins.property
    @pulumi.getter
    def cellular(self) -> 'outputs.GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsCellularResult':
        """
        uplink cellular configured limits [optional]
        """
        return pulumi.get(self, "cellular")

    @_builtins.property
    @pulumi.getter
    def wan1(self) -> 'outputs.GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan1Result':
        """
        uplink wan1 configured limits [optional]
        """
        return pulumi.get(self, "wan1")

    @_builtins.property
    @pulumi.getter
    def wan2(self) -> 'outputs.GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan2Result':
        """
        uplink wan2 configured limits [optional]
        """
        return pulumi.get(self, "wan2")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsCellularResult(dict):
    def __init__(__self__, *,
                 limit_down: _builtins.int,
                 limit_up: _builtins.int):
        """
        :param _builtins.int limit_down: configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        :param _builtins.int limit_up: configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        pulumi.set(__self__, "limit_down", limit_down)
        pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> _builtins.int:
        """
        configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> _builtins.int:
        """
        configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan1Result(dict):
    def __init__(__self__, *,
                 limit_down: _builtins.int,
                 limit_up: _builtins.int):
        """
        :param _builtins.int limit_down: configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        :param _builtins.int limit_up: configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        pulumi.set(__self__, "limit_down", limit_down)
        pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> _builtins.int:
        """
        configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> _builtins.int:
        """
        configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan2Result(dict):
    def __init__(__self__, *,
                 limit_down: _builtins.int,
                 limit_up: _builtins.int):
        """
        :param _builtins.int limit_down: configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        :param _builtins.int limit_up: configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        pulumi.set(__self__, "limit_down", limit_down)
        pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> _builtins.int:
        """
        configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> _builtins.int:
        """
        configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemResult(dict):
    def __init__(__self__, *,
                 active_active_auto_vpn_enabled: _builtins.bool,
                 default_uplink: _builtins.str,
                 failover_and_failback: 'outputs.GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailbackResult',
                 load_balancing_enabled: _builtins.bool,
                 vpn_traffic_uplink_preferences: Sequence['outputs.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceResult'],
                 wan_traffic_uplink_preferences: Sequence['outputs.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceResult']):
        """
        :param _builtins.bool active_active_auto_vpn_enabled: Whether active-active AutoVPN is enabled
        :param _builtins.str default_uplink: The default uplink. Must be one of: 'wan1' or 'wan2'
        :param 'GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailbackArgs' failover_and_failback: WAN failover and failback
        :param _builtins.bool load_balancing_enabled: Whether load balancing is enabled
        :param Sequence['GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceArgs'] vpn_traffic_uplink_preferences: Uplink preference rules for VPN traffic
        :param Sequence['GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceArgs'] wan_traffic_uplink_preferences: Uplink preference rules for WAN traffic
        """
        pulumi.set(__self__, "active_active_auto_vpn_enabled", active_active_auto_vpn_enabled)
        pulumi.set(__self__, "default_uplink", default_uplink)
        pulumi.set(__self__, "failover_and_failback", failover_and_failback)
        pulumi.set(__self__, "load_balancing_enabled", load_balancing_enabled)
        pulumi.set(__self__, "vpn_traffic_uplink_preferences", vpn_traffic_uplink_preferences)
        pulumi.set(__self__, "wan_traffic_uplink_preferences", wan_traffic_uplink_preferences)

    @_builtins.property
    @pulumi.getter(name="activeActiveAutoVpnEnabled")
    def active_active_auto_vpn_enabled(self) -> _builtins.bool:
        """
        Whether active-active AutoVPN is enabled
        """
        return pulumi.get(self, "active_active_auto_vpn_enabled")

    @_builtins.property
    @pulumi.getter(name="defaultUplink")
    def default_uplink(self) -> _builtins.str:
        """
        The default uplink. Must be one of: 'wan1' or 'wan2'
        """
        return pulumi.get(self, "default_uplink")

    @_builtins.property
    @pulumi.getter(name="failoverAndFailback")
    def failover_and_failback(self) -> 'outputs.GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailbackResult':
        """
        WAN failover and failback
        """
        return pulumi.get(self, "failover_and_failback")

    @_builtins.property
    @pulumi.getter(name="loadBalancingEnabled")
    def load_balancing_enabled(self) -> _builtins.bool:
        """
        Whether load balancing is enabled
        """
        return pulumi.get(self, "load_balancing_enabled")

    @_builtins.property
    @pulumi.getter(name="vpnTrafficUplinkPreferences")
    def vpn_traffic_uplink_preferences(self) -> Sequence['outputs.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceResult']:
        """
        Uplink preference rules for VPN traffic
        """
        return pulumi.get(self, "vpn_traffic_uplink_preferences")

    @_builtins.property
    @pulumi.getter(name="wanTrafficUplinkPreferences")
    def wan_traffic_uplink_preferences(self) -> Sequence['outputs.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceResult']:
        """
        Uplink preference rules for WAN traffic
        """
        return pulumi.get(self, "wan_traffic_uplink_preferences")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailbackResult(dict):
    def __init__(__self__, *,
                 immediate: 'outputs.GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailbackImmediateResult'):
        """
        :param 'GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailbackImmediateArgs' immediate: Immediate WAN failover and failback
        """
        pulumi.set(__self__, "immediate", immediate)

    @_builtins.property
    @pulumi.getter
    def immediate(self) -> 'outputs.GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailbackImmediateResult':
        """
        Immediate WAN failover and failback
        """
        return pulumi.get(self, "immediate")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailbackImmediateResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Whether immediate WAN failover and failback is enabled
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether immediate WAN failover and failback is enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceResult(dict):
    def __init__(__self__, *,
                 fail_over_criterion: _builtins.str,
                 performance_class: 'outputs.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferencePerformanceClassResult',
                 preferred_uplink: _builtins.str,
                 traffic_filters: Sequence['outputs.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterResult']):
        """
        :param _builtins.str fail_over_criterion: Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
        :param 'GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferencePerformanceClassArgs' performance_class: Performance class setting for uplink preference rule
        :param _builtins.str preferred_uplink: Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
        :param Sequence['GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterArgs'] traffic_filters: Traffic filters
        """
        pulumi.set(__self__, "fail_over_criterion", fail_over_criterion)
        pulumi.set(__self__, "performance_class", performance_class)
        pulumi.set(__self__, "preferred_uplink", preferred_uplink)
        pulumi.set(__self__, "traffic_filters", traffic_filters)

    @_builtins.property
    @pulumi.getter(name="failOverCriterion")
    def fail_over_criterion(self) -> _builtins.str:
        """
        Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
        """
        return pulumi.get(self, "fail_over_criterion")

    @_builtins.property
    @pulumi.getter(name="performanceClass")
    def performance_class(self) -> 'outputs.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferencePerformanceClassResult':
        """
        Performance class setting for uplink preference rule
        """
        return pulumi.get(self, "performance_class")

    @_builtins.property
    @pulumi.getter(name="preferredUplink")
    def preferred_uplink(self) -> _builtins.str:
        """
        Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
        """
        return pulumi.get(self, "preferred_uplink")

    @_builtins.property
    @pulumi.getter(name="trafficFilters")
    def traffic_filters(self) -> Sequence['outputs.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterResult']:
        """
        Traffic filters
        """
        return pulumi.get(self, "traffic_filters")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferencePerformanceClassResult(dict):
    def __init__(__self__, *,
                 builtin_performance_class_name: _builtins.str,
                 custom_performance_class_id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str builtin_performance_class_name: Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'
        :param _builtins.str custom_performance_class_id: ID of created custom performance class, must be present when performanceClass type is "custom"
        :param _builtins.str type: Type of this performance class. Must be one of: 'builtin' or 'custom'
        """
        pulumi.set(__self__, "builtin_performance_class_name", builtin_performance_class_name)
        pulumi.set(__self__, "custom_performance_class_id", custom_performance_class_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="builtinPerformanceClassName")
    def builtin_performance_class_name(self) -> _builtins.str:
        """
        Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'
        """
        return pulumi.get(self, "builtin_performance_class_name")

    @_builtins.property
    @pulumi.getter(name="customPerformanceClassId")
    def custom_performance_class_id(self) -> _builtins.str:
        """
        ID of created custom performance class, must be present when performanceClass type is "custom"
        """
        return pulumi.get(self, "custom_performance_class_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of this performance class. Must be one of: 'builtin' or 'custom'
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: 'outputs.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueResult'):
        """
        :param _builtins.str type: Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
        :param 'GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueArgs' value: Value of traffic filter
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueResult':
        """
        Value of traffic filter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueResult(dict):
    def __init__(__self__, *,
                 destination: 'outputs.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueDestinationResult',
                 id: _builtins.str,
                 protocol: _builtins.str,
                 source: 'outputs.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueSourceResult'):
        """
        :param 'GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueDestinationArgs' destination: Destination of 'custom' type traffic filter
        :param _builtins.str id: ID of 'applicationCategory' or 'application' type traffic filter
        :param _builtins.str protocol: Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
        :param 'GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueSourceArgs' source: Source of 'custom' type traffic filter
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> 'outputs.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueDestinationResult':
        """
        Destination of 'custom' type traffic filter
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of 'applicationCategory' or 'application' type traffic filter
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def source(self) -> 'outputs.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueSourceResult':
        """
        Source of 'custom' type traffic filter
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueDestinationResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 fqdn: _builtins.str,
                 host: _builtins.int,
                 network: _builtins.str,
                 port: _builtins.str,
                 vlan: _builtins.int):
        """
        :param _builtins.str cidr: CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property
        :param _builtins.str fqdn: FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com"
        :param _builtins.int host: Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        :param _builtins.str network: Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        :param _builtins.str port: E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        :param _builtins.int vlan: VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com"
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.int:
        """
        Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.int:
        """
        VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueSourceResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 host: _builtins.int,
                 network: _builtins.str,
                 port: _builtins.str,
                 vlan: _builtins.int):
        """
        :param _builtins.str cidr: CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        :param _builtins.int host: Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        :param _builtins.str network: Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        :param _builtins.str port: E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        :param _builtins.int vlan: VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.int:
        """
        Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.int:
        """
        VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceResult(dict):
    def __init__(__self__, *,
                 preferred_uplink: _builtins.str,
                 traffic_filters: Sequence['outputs.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterResult']):
        """
        :param _builtins.str preferred_uplink: Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
        :param Sequence['GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterArgs'] traffic_filters: Traffic filters
        """
        pulumi.set(__self__, "preferred_uplink", preferred_uplink)
        pulumi.set(__self__, "traffic_filters", traffic_filters)

    @_builtins.property
    @pulumi.getter(name="preferredUplink")
    def preferred_uplink(self) -> _builtins.str:
        """
        Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
        """
        return pulumi.get(self, "preferred_uplink")

    @_builtins.property
    @pulumi.getter(name="trafficFilters")
    def traffic_filters(self) -> Sequence['outputs.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterResult']:
        """
        Traffic filters
        """
        return pulumi.get(self, "traffic_filters")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: 'outputs.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueResult'):
        """
        :param _builtins.str type: Traffic filter type. Must be "custom"
        :param 'GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueArgs' value: Value of traffic filter
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Traffic filter type. Must be "custom"
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueResult':
        """
        Value of traffic filter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueResult(dict):
    def __init__(__self__, *,
                 destination: 'outputs.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueDestinationResult',
                 protocol: _builtins.str,
                 source: 'outputs.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueSourceResult'):
        """
        :param 'GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueDestinationArgs' destination: Destination of 'custom' type traffic filter
        :param _builtins.str protocol: Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
        :param 'GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueSourceArgs' source: Source of 'custom' type traffic filter
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> 'outputs.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueDestinationResult':
        """
        Destination of 'custom' type traffic filter
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def source(self) -> 'outputs.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueSourceResult':
        """
        Source of 'custom' type traffic filter
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueDestinationResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 port: _builtins.str):
        """
        :param _builtins.str cidr: CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any"
        :param _builtins.str port: E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any"
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueSourceResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 host: _builtins.int,
                 port: _builtins.str,
                 vlan: _builtins.int):
        """
        :param _builtins.str cidr: CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        :param _builtins.int host: Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        :param _builtins.str port: E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        :param _builtins.int vlan: VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.int:
        """
        Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.int:
        """
        VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetApplianceVlansItemResult(dict):
    def __init__(__self__, *,
                 appliance_ip: _builtins.str,
                 cidr: _builtins.str,
                 dhcp_boot_filename: _builtins.str,
                 dhcp_boot_next_server: _builtins.str,
                 dhcp_boot_options_enabled: _builtins.bool,
                 dhcp_handling: _builtins.str,
                 dhcp_lease_time: _builtins.str,
                 dhcp_options: Sequence['outputs.GetApplianceVlansItemDhcpOptionResult'],
                 dhcp_relay_server_ips: Sequence[_builtins.str],
                 dns_nameservers: _builtins.str,
                 fixed_ip_assignments: _builtins.str,
                 group_policy_id: _builtins.str,
                 id: _builtins.int,
                 interface_id: _builtins.str,
                 ipv6: 'outputs.GetApplianceVlansItemIpv6Result',
                 mandatory_dhcp: 'outputs.GetApplianceVlansItemMandatoryDhcpResult',
                 mask: _builtins.int,
                 name: _builtins.str,
                 reserved_ip_ranges: Sequence['outputs.GetApplianceVlansItemReservedIpRangeResult'],
                 subnet: _builtins.str,
                 template_vlan_type: _builtins.str,
                 vpn_nat_subnet: _builtins.str):
        """
        :param _builtins.str appliance_ip: The local IP of the appliance on the VLAN
        :param _builtins.str cidr: CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
        :param _builtins.str dhcp_boot_filename: DHCP boot option for boot filename
        :param _builtins.str dhcp_boot_next_server: DHCP boot option to direct boot clients to the server to load the boot file from
        :param _builtins.bool dhcp_boot_options_enabled: Use DHCP boot options specified in other properties
        :param _builtins.str dhcp_handling: The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
        :param _builtins.str dhcp_lease_time: The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
        :param Sequence['GetApplianceVlansItemDhcpOptionArgs'] dhcp_options: The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
        :param Sequence[_builtins.str] dhcp_relay_server_ips: The IPs of the DHCP servers that DHCP requests should be relayed to
        :param _builtins.str dns_nameservers: The DNS nameservers used for DHCP responses, either "upstream*dns", "google*dns", "opendns", or a newline seperated string of IP addresses or domain names
        :param _builtins.str fixed_ip_assignments: The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
        :param _builtins.str group_policy_id: The id of the desired group policy to apply to the VLAN
        :param _builtins.int id: The VLAN ID of the VLAN
        :param _builtins.str interface_id: The interface ID of the VLAN
        :param 'GetApplianceVlansItemIpv6Args' ipv6: IPv6 configuration on the VLAN
        :param 'GetApplianceVlansItemMandatoryDhcpArgs' mandatory_dhcp: Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
        :param _builtins.int mask: Mask used for the subnet of all bound to the template networks. Applicable only for template network.
        :param _builtins.str name: The name of the VLAN
        :param Sequence['GetApplianceVlansItemReservedIpRangeArgs'] reserved_ip_ranges: The DHCP reserved IP ranges on the VLAN
        :param _builtins.str subnet: The subnet of the VLAN
        :param _builtins.str template_vlan_type: Type of subnetting of the VLAN. Applicable only for template network.
        :param _builtins.str vpn_nat_subnet: The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
        """
        pulumi.set(__self__, "appliance_ip", appliance_ip)
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "dhcp_boot_filename", dhcp_boot_filename)
        pulumi.set(__self__, "dhcp_boot_next_server", dhcp_boot_next_server)
        pulumi.set(__self__, "dhcp_boot_options_enabled", dhcp_boot_options_enabled)
        pulumi.set(__self__, "dhcp_handling", dhcp_handling)
        pulumi.set(__self__, "dhcp_lease_time", dhcp_lease_time)
        pulumi.set(__self__, "dhcp_options", dhcp_options)
        pulumi.set(__self__, "dhcp_relay_server_ips", dhcp_relay_server_ips)
        pulumi.set(__self__, "dns_nameservers", dns_nameservers)
        pulumi.set(__self__, "fixed_ip_assignments", fixed_ip_assignments)
        pulumi.set(__self__, "group_policy_id", group_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "interface_id", interface_id)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "mandatory_dhcp", mandatory_dhcp)
        pulumi.set(__self__, "mask", mask)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "reserved_ip_ranges", reserved_ip_ranges)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "template_vlan_type", template_vlan_type)
        pulumi.set(__self__, "vpn_nat_subnet", vpn_nat_subnet)

    @_builtins.property
    @pulumi.getter(name="applianceIp")
    def appliance_ip(self) -> _builtins.str:
        """
        The local IP of the appliance on the VLAN
        """
        return pulumi.get(self, "appliance_ip")

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        """
        CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter(name="dhcpBootFilename")
    def dhcp_boot_filename(self) -> _builtins.str:
        """
        DHCP boot option for boot filename
        """
        return pulumi.get(self, "dhcp_boot_filename")

    @_builtins.property
    @pulumi.getter(name="dhcpBootNextServer")
    def dhcp_boot_next_server(self) -> _builtins.str:
        """
        DHCP boot option to direct boot clients to the server to load the boot file from
        """
        return pulumi.get(self, "dhcp_boot_next_server")

    @_builtins.property
    @pulumi.getter(name="dhcpBootOptionsEnabled")
    def dhcp_boot_options_enabled(self) -> _builtins.bool:
        """
        Use DHCP boot options specified in other properties
        """
        return pulumi.get(self, "dhcp_boot_options_enabled")

    @_builtins.property
    @pulumi.getter(name="dhcpHandling")
    def dhcp_handling(self) -> _builtins.str:
        """
        The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
        """
        return pulumi.get(self, "dhcp_handling")

    @_builtins.property
    @pulumi.getter(name="dhcpLeaseTime")
    def dhcp_lease_time(self) -> _builtins.str:
        """
        The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
        """
        return pulumi.get(self, "dhcp_lease_time")

    @_builtins.property
    @pulumi.getter(name="dhcpOptions")
    def dhcp_options(self) -> Sequence['outputs.GetApplianceVlansItemDhcpOptionResult']:
        """
        The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
        """
        return pulumi.get(self, "dhcp_options")

    @_builtins.property
    @pulumi.getter(name="dhcpRelayServerIps")
    def dhcp_relay_server_ips(self) -> Sequence[_builtins.str]:
        """
        The IPs of the DHCP servers that DHCP requests should be relayed to
        """
        return pulumi.get(self, "dhcp_relay_server_ips")

    @_builtins.property
    @pulumi.getter(name="dnsNameservers")
    def dns_nameservers(self) -> _builtins.str:
        """
        The DNS nameservers used for DHCP responses, either "upstream*dns", "google*dns", "opendns", or a newline seperated string of IP addresses or domain names
        """
        return pulumi.get(self, "dns_nameservers")

    @_builtins.property
    @pulumi.getter(name="fixedIpAssignments")
    def fixed_ip_assignments(self) -> _builtins.str:
        """
        The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
        """
        return pulumi.get(self, "fixed_ip_assignments")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> _builtins.str:
        """
        The id of the desired group policy to apply to the VLAN
        """
        return pulumi.get(self, "group_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The VLAN ID of the VLAN
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> _builtins.str:
        """
        The interface ID of the VLAN
        """
        return pulumi.get(self, "interface_id")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> 'outputs.GetApplianceVlansItemIpv6Result':
        """
        IPv6 configuration on the VLAN
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="mandatoryDhcp")
    def mandatory_dhcp(self) -> 'outputs.GetApplianceVlansItemMandatoryDhcpResult':
        """
        Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
        """
        return pulumi.get(self, "mandatory_dhcp")

    @_builtins.property
    @pulumi.getter
    def mask(self) -> _builtins.int:
        """
        Mask used for the subnet of all bound to the template networks. Applicable only for template network.
        """
        return pulumi.get(self, "mask")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the VLAN
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="reservedIpRanges")
    def reserved_ip_ranges(self) -> Sequence['outputs.GetApplianceVlansItemReservedIpRangeResult']:
        """
        The DHCP reserved IP ranges on the VLAN
        """
        return pulumi.get(self, "reserved_ip_ranges")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        The subnet of the VLAN
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="templateVlanType")
    def template_vlan_type(self) -> _builtins.str:
        """
        Type of subnetting of the VLAN. Applicable only for template network.
        """
        return pulumi.get(self, "template_vlan_type")

    @_builtins.property
    @pulumi.getter(name="vpnNatSubnet")
    def vpn_nat_subnet(self) -> _builtins.str:
        """
        The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
        """
        return pulumi.get(self, "vpn_nat_subnet")


@pulumi.output_type
class GetApplianceVlansItemDhcpOptionResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str code: The code for the DHCP option. This should be an integer between 2 and 254.
        :param _builtins.str type: The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
        :param _builtins.str value: The value for the DHCP option
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        The code for the DHCP option. This should be an integer between 2 and 254.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value for the DHCP option
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetApplianceVlansItemIpv6Result(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 prefix_assignments: Sequence['outputs.GetApplianceVlansItemIpv6PrefixAssignmentResult']):
        """
        :param _builtins.bool enabled: Enable IPv6 on VLAN
        :param Sequence['GetApplianceVlansItemIpv6PrefixAssignmentArgs'] prefix_assignments: Prefix assignments on the VLAN
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "prefix_assignments", prefix_assignments)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable IPv6 on VLAN
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="prefixAssignments")
    def prefix_assignments(self) -> Sequence['outputs.GetApplianceVlansItemIpv6PrefixAssignmentResult']:
        """
        Prefix assignments on the VLAN
        """
        return pulumi.get(self, "prefix_assignments")


@pulumi.output_type
class GetApplianceVlansItemIpv6PrefixAssignmentResult(dict):
    def __init__(__self__, *,
                 autonomous: _builtins.bool,
                 origin: 'outputs.GetApplianceVlansItemIpv6PrefixAssignmentOriginResult',
                 static_appliance_ip6: _builtins.str,
                 static_prefix: _builtins.str):
        """
        :param _builtins.bool autonomous: Auto assign a /64 prefix from the origin to the VLAN
        :param 'GetApplianceVlansItemIpv6PrefixAssignmentOriginArgs' origin: The origin of the prefix
        :param _builtins.str static_appliance_ip6: Manual configuration of the IPv6 Appliance IP
        :param _builtins.str static_prefix: Manual configuration of a /64 prefix on the VLAN
        """
        pulumi.set(__self__, "autonomous", autonomous)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "static_appliance_ip6", static_appliance_ip6)
        pulumi.set(__self__, "static_prefix", static_prefix)

    @_builtins.property
    @pulumi.getter
    def autonomous(self) -> _builtins.bool:
        """
        Auto assign a /64 prefix from the origin to the VLAN
        """
        return pulumi.get(self, "autonomous")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> 'outputs.GetApplianceVlansItemIpv6PrefixAssignmentOriginResult':
        """
        The origin of the prefix
        """
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="staticApplianceIp6")
    def static_appliance_ip6(self) -> _builtins.str:
        """
        Manual configuration of the IPv6 Appliance IP
        """
        return pulumi.get(self, "static_appliance_ip6")

    @_builtins.property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> _builtins.str:
        """
        Manual configuration of a /64 prefix on the VLAN
        """
        return pulumi.get(self, "static_prefix")


@pulumi.output_type
class GetApplianceVlansItemIpv6PrefixAssignmentOriginResult(dict):
    def __init__(__self__, *,
                 interfaces: Sequence[_builtins.str],
                 type: _builtins.str):
        """
        :param Sequence[_builtins.str] interfaces: Interfaces associated with the prefix
        :param _builtins.str type: Type of the origin
        """
        pulumi.set(__self__, "interfaces", interfaces)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Sequence[_builtins.str]:
        """
        Interfaces associated with the prefix
        """
        return pulumi.get(self, "interfaces")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the origin
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetApplianceVlansItemMandatoryDhcpResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Enable Mandatory DHCP on VLAN.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable Mandatory DHCP on VLAN.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetApplianceVlansItemReservedIpRangeResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 end: _builtins.str,
                 start: _builtins.str):
        """
        :param _builtins.str comment: A text comment for the reserved range
        :param _builtins.str end: The last IP in the reserved range
        :param _builtins.str start: The first IP in the reserved range
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        A text comment for the reserved range
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        """
        The last IP in the reserved range
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        """
        The first IP in the reserved range
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class GetApplianceVlansSettingsItemResult(dict):
    def __init__(__self__, *,
                 vlans_enabled: _builtins.bool):
        """
        :param _builtins.bool vlans_enabled: Boolean indicating whether VLANs are enabled (true) or disabled (false) for the network
        """
        pulumi.set(__self__, "vlans_enabled", vlans_enabled)

    @_builtins.property
    @pulumi.getter(name="vlansEnabled")
    def vlans_enabled(self) -> _builtins.bool:
        """
        Boolean indicating whether VLANs are enabled (true) or disabled (false) for the network
        """
        return pulumi.get(self, "vlans_enabled")


@pulumi.output_type
class GetApplianceVpnBgpItemResult(dict):
    def __init__(__self__, *,
                 as_number: _builtins.int,
                 enabled: _builtins.bool,
                 ibgp_hold_timer: _builtins.int,
                 neighbors: Sequence['outputs.GetApplianceVpnBgpItemNeighborResult']):
        pulumi.set(__self__, "as_number", as_number)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "ibgp_hold_timer", ibgp_hold_timer)
        pulumi.set(__self__, "neighbors", neighbors)

    @_builtins.property
    @pulumi.getter(name="asNumber")
    def as_number(self) -> _builtins.int:
        return pulumi.get(self, "as_number")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="ibgpHoldTimer")
    def ibgp_hold_timer(self) -> _builtins.int:
        return pulumi.get(self, "ibgp_hold_timer")

    @_builtins.property
    @pulumi.getter
    def neighbors(self) -> Sequence['outputs.GetApplianceVpnBgpItemNeighborResult']:
        return pulumi.get(self, "neighbors")


@pulumi.output_type
class GetApplianceVpnBgpItemNeighborResult(dict):
    def __init__(__self__, *,
                 allow_transit: _builtins.bool,
                 ebgp_hold_timer: _builtins.int,
                 ebgp_multihop: _builtins.int,
                 ip: _builtins.str,
                 receive_limit: _builtins.int,
                 remote_as_number: _builtins.int):
        pulumi.set(__self__, "allow_transit", allow_transit)
        pulumi.set(__self__, "ebgp_hold_timer", ebgp_hold_timer)
        pulumi.set(__self__, "ebgp_multihop", ebgp_multihop)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "receive_limit", receive_limit)
        pulumi.set(__self__, "remote_as_number", remote_as_number)

    @_builtins.property
    @pulumi.getter(name="allowTransit")
    def allow_transit(self) -> _builtins.bool:
        return pulumi.get(self, "allow_transit")

    @_builtins.property
    @pulumi.getter(name="ebgpHoldTimer")
    def ebgp_hold_timer(self) -> _builtins.int:
        return pulumi.get(self, "ebgp_hold_timer")

    @_builtins.property
    @pulumi.getter(name="ebgpMultihop")
    def ebgp_multihop(self) -> _builtins.int:
        return pulumi.get(self, "ebgp_multihop")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="receiveLimit")
    def receive_limit(self) -> _builtins.int:
        return pulumi.get(self, "receive_limit")

    @_builtins.property
    @pulumi.getter(name="remoteAsNumber")
    def remote_as_number(self) -> _builtins.int:
        return pulumi.get(self, "remote_as_number")


@pulumi.output_type
class GetApplianceVpnSiteToSiteVpnItemResult(dict):
    def __init__(__self__, *,
                 hubs: Sequence['outputs.GetApplianceVpnSiteToSiteVpnItemHubResult'],
                 mode: _builtins.str,
                 subnets: Sequence['outputs.GetApplianceVpnSiteToSiteVpnItemSubnetResult']):
        """
        :param Sequence['GetApplianceVpnSiteToSiteVpnItemHubArgs'] hubs: The list of VPN hubs, in order of preference.
        :param _builtins.str mode: The site-to-site VPN mode.
        :param Sequence['GetApplianceVpnSiteToSiteVpnItemSubnetArgs'] subnets: The list of subnets and their VPN presence.
        """
        pulumi.set(__self__, "hubs", hubs)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter
    def hubs(self) -> Sequence['outputs.GetApplianceVpnSiteToSiteVpnItemHubResult']:
        """
        The list of VPN hubs, in order of preference.
        """
        return pulumi.get(self, "hubs")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The site-to-site VPN mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetApplianceVpnSiteToSiteVpnItemSubnetResult']:
        """
        The list of subnets and their VPN presence.
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class GetApplianceVpnSiteToSiteVpnItemHubResult(dict):
    def __init__(__self__, *,
                 hub_id: _builtins.str,
                 use_default_route: _builtins.bool):
        """
        :param _builtins.str hub_id: The network ID of the hub.
        :param _builtins.bool use_default_route: Indicates whether default route traffic should be sent to this hub.
        """
        pulumi.set(__self__, "hub_id", hub_id)
        pulumi.set(__self__, "use_default_route", use_default_route)

    @_builtins.property
    @pulumi.getter(name="hubId")
    def hub_id(self) -> _builtins.str:
        """
        The network ID of the hub.
        """
        return pulumi.get(self, "hub_id")

    @_builtins.property
    @pulumi.getter(name="useDefaultRoute")
    def use_default_route(self) -> _builtins.bool:
        """
        Indicates whether default route traffic should be sent to this hub.
        """
        return pulumi.get(self, "use_default_route")


@pulumi.output_type
class GetApplianceVpnSiteToSiteVpnItemSubnetResult(dict):
    def __init__(__self__, *,
                 local_subnet: _builtins.str,
                 use_vpn: _builtins.bool):
        """
        :param _builtins.str local_subnet: The CIDR notation subnet used within the VPN
        :param _builtins.bool use_vpn: Indicates the presence of the subnet in the VPN
        """
        pulumi.set(__self__, "local_subnet", local_subnet)
        pulumi.set(__self__, "use_vpn", use_vpn)

    @_builtins.property
    @pulumi.getter(name="localSubnet")
    def local_subnet(self) -> _builtins.str:
        """
        The CIDR notation subnet used within the VPN
        """
        return pulumi.get(self, "local_subnet")

    @_builtins.property
    @pulumi.getter(name="useVpn")
    def use_vpn(self) -> _builtins.bool:
        """
        Indicates the presence of the subnet in the VPN
        """
        return pulumi.get(self, "use_vpn")


@pulumi.output_type
class GetApplianceWarmSpareItemResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 primary_serial: _builtins.str,
                 spare_serial: _builtins.str,
                 uplink_mode: _builtins.str,
                 wan1: 'outputs.GetApplianceWarmSpareItemWan1Result',
                 wan2: 'outputs.GetApplianceWarmSpareItemWan2Result'):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "primary_serial", primary_serial)
        pulumi.set(__self__, "spare_serial", spare_serial)
        pulumi.set(__self__, "uplink_mode", uplink_mode)
        pulumi.set(__self__, "wan1", wan1)
        pulumi.set(__self__, "wan2", wan2)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="primarySerial")
    def primary_serial(self) -> _builtins.str:
        return pulumi.get(self, "primary_serial")

    @_builtins.property
    @pulumi.getter(name="spareSerial")
    def spare_serial(self) -> _builtins.str:
        return pulumi.get(self, "spare_serial")

    @_builtins.property
    @pulumi.getter(name="uplinkMode")
    def uplink_mode(self) -> _builtins.str:
        return pulumi.get(self, "uplink_mode")

    @_builtins.property
    @pulumi.getter
    def wan1(self) -> 'outputs.GetApplianceWarmSpareItemWan1Result':
        return pulumi.get(self, "wan1")

    @_builtins.property
    @pulumi.getter
    def wan2(self) -> 'outputs.GetApplianceWarmSpareItemWan2Result':
        return pulumi.get(self, "wan2")


@pulumi.output_type
class GetApplianceWarmSpareItemWan1Result(dict):
    def __init__(__self__, *,
                 ip: _builtins.str,
                 subnet: _builtins.str):
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        return pulumi.get(self, "subnet")


@pulumi.output_type
class GetApplianceWarmSpareItemWan2Result(dict):
    def __init__(__self__, *,
                 ip: _builtins.str,
                 subnet: _builtins.str):
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        return pulumi.get(self, "subnet")


@pulumi.output_type
class GetBluetoothClientsItemResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 id: _builtins.str,
                 in_sight_alert: _builtins.bool,
                 last_seen: _builtins.int,
                 mac: _builtins.str,
                 manufacturer: _builtins.str,
                 name: _builtins.str,
                 network_id: _builtins.str,
                 out_of_sight_alert: _builtins.bool,
                 seen_by_device_mac: _builtins.str,
                 tags: Sequence[_builtins.str]):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "in_sight_alert", in_sight_alert)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "out_of_sight_alert", out_of_sight_alert)
        pulumi.set(__self__, "seen_by_device_mac", seen_by_device_mac)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inSightAlert")
    def in_sight_alert(self) -> _builtins.bool:
        return pulumi.get(self, "in_sight_alert")

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> _builtins.int:
        return pulumi.get(self, "last_seen")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def manufacturer(self) -> _builtins.str:
        return pulumi.get(self, "manufacturer")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="outOfSightAlert")
    def out_of_sight_alert(self) -> _builtins.bool:
        return pulumi.get(self, "out_of_sight_alert")

    @_builtins.property
    @pulumi.getter(name="seenByDeviceMac")
    def seen_by_device_mac(self) -> _builtins.str:
        return pulumi.get(self, "seen_by_device_mac")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCameraQualityRetentionProfilesItemResult(dict):
    def __init__(__self__, *,
                 audio_recording_enabled: _builtins.bool,
                 cloud_archive_enabled: _builtins.bool,
                 id: _builtins.str,
                 max_retention_days: _builtins.int,
                 motion_based_retention_enabled: _builtins.bool,
                 motion_detector_version: _builtins.int,
                 name: _builtins.str,
                 network_id: _builtins.str,
                 restricted_bandwidth_mode_enabled: _builtins.bool,
                 schedule_id: _builtins.str,
                 video_settings: 'outputs.GetCameraQualityRetentionProfilesItemVideoSettingsResult'):
        pulumi.set(__self__, "audio_recording_enabled", audio_recording_enabled)
        pulumi.set(__self__, "cloud_archive_enabled", cloud_archive_enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "max_retention_days", max_retention_days)
        pulumi.set(__self__, "motion_based_retention_enabled", motion_based_retention_enabled)
        pulumi.set(__self__, "motion_detector_version", motion_detector_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "restricted_bandwidth_mode_enabled", restricted_bandwidth_mode_enabled)
        pulumi.set(__self__, "schedule_id", schedule_id)
        pulumi.set(__self__, "video_settings", video_settings)

    @_builtins.property
    @pulumi.getter(name="audioRecordingEnabled")
    def audio_recording_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "audio_recording_enabled")

    @_builtins.property
    @pulumi.getter(name="cloudArchiveEnabled")
    def cloud_archive_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "cloud_archive_enabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="maxRetentionDays")
    def max_retention_days(self) -> _builtins.int:
        return pulumi.get(self, "max_retention_days")

    @_builtins.property
    @pulumi.getter(name="motionBasedRetentionEnabled")
    def motion_based_retention_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "motion_based_retention_enabled")

    @_builtins.property
    @pulumi.getter(name="motionDetectorVersion")
    def motion_detector_version(self) -> _builtins.int:
        return pulumi.get(self, "motion_detector_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="restrictedBandwidthModeEnabled")
    def restricted_bandwidth_mode_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "restricted_bandwidth_mode_enabled")

    @_builtins.property
    @pulumi.getter(name="scheduleId")
    def schedule_id(self) -> _builtins.str:
        return pulumi.get(self, "schedule_id")

    @_builtins.property
    @pulumi.getter(name="videoSettings")
    def video_settings(self) -> 'outputs.GetCameraQualityRetentionProfilesItemVideoSettingsResult':
        return pulumi.get(self, "video_settings")


@pulumi.output_type
class GetCameraQualityRetentionProfilesItemVideoSettingsResult(dict):
    def __init__(__self__, *,
                 m_v12_mv22_mv72: 'outputs.GetCameraQualityRetentionProfilesItemVideoSettingsMV12MV22MV72Result',
                 m_v12_we: 'outputs.GetCameraQualityRetentionProfilesItemVideoSettingsMV12WeResult',
                 m_v21_mv71: 'outputs.GetCameraQualityRetentionProfilesItemVideoSettingsMV21MV71Result',
                 m_v32: 'outputs.GetCameraQualityRetentionProfilesItemVideoSettingsMV32Result'):
        pulumi.set(__self__, "m_v12_mv22_mv72", m_v12_mv22_mv72)
        pulumi.set(__self__, "m_v12_we", m_v12_we)
        pulumi.set(__self__, "m_v21_mv71", m_v21_mv71)
        pulumi.set(__self__, "m_v32", m_v32)

    @_builtins.property
    @pulumi.getter(name="mV12MV22MV72")
    def m_v12_mv22_mv72(self) -> 'outputs.GetCameraQualityRetentionProfilesItemVideoSettingsMV12MV22MV72Result':
        return pulumi.get(self, "m_v12_mv22_mv72")

    @_builtins.property
    @pulumi.getter(name="mV12We")
    def m_v12_we(self) -> 'outputs.GetCameraQualityRetentionProfilesItemVideoSettingsMV12WeResult':
        return pulumi.get(self, "m_v12_we")

    @_builtins.property
    @pulumi.getter(name="mV21MV71")
    def m_v21_mv71(self) -> 'outputs.GetCameraQualityRetentionProfilesItemVideoSettingsMV21MV71Result':
        return pulumi.get(self, "m_v21_mv71")

    @_builtins.property
    @pulumi.getter(name="mV32")
    def m_v32(self) -> 'outputs.GetCameraQualityRetentionProfilesItemVideoSettingsMV32Result':
        return pulumi.get(self, "m_v32")


@pulumi.output_type
class GetCameraQualityRetentionProfilesItemVideoSettingsMV12MV22MV72Result(dict):
    def __init__(__self__, *,
                 quality: _builtins.str,
                 resolution: _builtins.str):
        pulumi.set(__self__, "quality", quality)
        pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> _builtins.str:
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> _builtins.str:
        return pulumi.get(self, "resolution")


@pulumi.output_type
class GetCameraQualityRetentionProfilesItemVideoSettingsMV12WeResult(dict):
    def __init__(__self__, *,
                 quality: _builtins.str,
                 resolution: _builtins.str):
        pulumi.set(__self__, "quality", quality)
        pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> _builtins.str:
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> _builtins.str:
        return pulumi.get(self, "resolution")


@pulumi.output_type
class GetCameraQualityRetentionProfilesItemVideoSettingsMV21MV71Result(dict):
    def __init__(__self__, *,
                 quality: _builtins.str,
                 resolution: _builtins.str):
        pulumi.set(__self__, "quality", quality)
        pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> _builtins.str:
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> _builtins.str:
        return pulumi.get(self, "resolution")


@pulumi.output_type
class GetCameraQualityRetentionProfilesItemVideoSettingsMV32Result(dict):
    def __init__(__self__, *,
                 quality: _builtins.str,
                 resolution: _builtins.str):
        pulumi.set(__self__, "quality", quality)
        pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> _builtins.str:
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> _builtins.str:
        return pulumi.get(self, "resolution")


@pulumi.output_type
class GetCameraWirelessProfilesItemResult(dict):
    def __init__(__self__, *,
                 applied_device_count: _builtins.int,
                 id: _builtins.str,
                 identity: 'outputs.GetCameraWirelessProfilesItemIdentityResult',
                 name: _builtins.str,
                 ssid: 'outputs.GetCameraWirelessProfilesItemSsidResult'):
        pulumi.set(__self__, "applied_device_count", applied_device_count)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity", identity)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ssid", ssid)

    @_builtins.property
    @pulumi.getter(name="appliedDeviceCount")
    def applied_device_count(self) -> _builtins.int:
        return pulumi.get(self, "applied_device_count")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> 'outputs.GetCameraWirelessProfilesItemIdentityResult':
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> 'outputs.GetCameraWirelessProfilesItemSsidResult':
        return pulumi.get(self, "ssid")


@pulumi.output_type
class GetCameraWirelessProfilesItemIdentityResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetCameraWirelessProfilesItemSsidResult(dict):
    def __init__(__self__, *,
                 auth_mode: _builtins.str,
                 encryption_mode: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "auth_mode", auth_mode)
        pulumi.set(__self__, "encryption_mode", encryption_mode)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> _builtins.str:
        return pulumi.get(self, "auth_mode")

    @_builtins.property
    @pulumi.getter(name="encryptionMode")
    def encryption_mode(self) -> _builtins.str:
        return pulumi.get(self, "encryption_mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCellularGatewayConnectivityMonitoringDestinationsItemResult(dict):
    def __init__(__self__, *,
                 destinations: Sequence['outputs.GetCellularGatewayConnectivityMonitoringDestinationsItemDestinationResult']):
        pulumi.set(__self__, "destinations", destinations)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Sequence['outputs.GetCellularGatewayConnectivityMonitoringDestinationsItemDestinationResult']:
        return pulumi.get(self, "destinations")


@pulumi.output_type
class GetCellularGatewayConnectivityMonitoringDestinationsItemDestinationResult(dict):
    def __init__(__self__, *,
                 default: _builtins.bool,
                 description: _builtins.str,
                 ip: _builtins.str):
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def default(self) -> _builtins.bool:
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetCellularGatewayDhcpItemResult(dict):
    def __init__(__self__, *,
                 dhcp_lease_time: _builtins.str,
                 dns_custom_nameservers: Sequence[_builtins.str],
                 dns_nameservers: _builtins.str):
        """
        :param _builtins.str dhcp_lease_time: DHCP Lease time for all MG in the network.
        :param Sequence[_builtins.str] dns_custom_nameservers: List of fixed IPs representing the the DNS Name servers when the mode is 'custom'.
        :param _builtins.str dns_nameservers: DNS name servers mode for all MG in the network.
        """
        pulumi.set(__self__, "dhcp_lease_time", dhcp_lease_time)
        pulumi.set(__self__, "dns_custom_nameservers", dns_custom_nameservers)
        pulumi.set(__self__, "dns_nameservers", dns_nameservers)

    @_builtins.property
    @pulumi.getter(name="dhcpLeaseTime")
    def dhcp_lease_time(self) -> _builtins.str:
        """
        DHCP Lease time for all MG in the network.
        """
        return pulumi.get(self, "dhcp_lease_time")

    @_builtins.property
    @pulumi.getter(name="dnsCustomNameservers")
    def dns_custom_nameservers(self) -> Sequence[_builtins.str]:
        """
        List of fixed IPs representing the the DNS Name servers when the mode is 'custom'.
        """
        return pulumi.get(self, "dns_custom_nameservers")

    @_builtins.property
    @pulumi.getter(name="dnsNameservers")
    def dns_nameservers(self) -> _builtins.str:
        """
        DNS name servers mode for all MG in the network.
        """
        return pulumi.get(self, "dns_nameservers")


@pulumi.output_type
class GetCellularGatewaySubnetPoolItemResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 deployment_mode: _builtins.str,
                 mask: _builtins.int,
                 subnets: Sequence['outputs.GetCellularGatewaySubnetPoolItemSubnetResult']):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "deployment_mode", deployment_mode)
        pulumi.set(__self__, "mask", mask)
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter(name="deploymentMode")
    def deployment_mode(self) -> _builtins.str:
        return pulumi.get(self, "deployment_mode")

    @_builtins.property
    @pulumi.getter
    def mask(self) -> _builtins.int:
        return pulumi.get(self, "mask")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetCellularGatewaySubnetPoolItemSubnetResult']:
        return pulumi.get(self, "subnets")


@pulumi.output_type
class GetCellularGatewaySubnetPoolItemSubnetResult(dict):
    def __init__(__self__, *,
                 appliance_ip: _builtins.str,
                 name: _builtins.str,
                 serial: _builtins.str,
                 subnet: _builtins.str):
        pulumi.set(__self__, "appliance_ip", appliance_ip)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter(name="applianceIp")
    def appliance_ip(self) -> _builtins.str:
        return pulumi.get(self, "appliance_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        return pulumi.get(self, "subnet")


@pulumi.output_type
class GetCellularGatewayUplinkItemResult(dict):
    def __init__(__self__, *,
                 bandwidth_limits: 'outputs.GetCellularGatewayUplinkItemBandwidthLimitsResult'):
        """
        :param 'GetCellularGatewayUplinkItemBandwidthLimitsArgs' bandwidth_limits: The bandwidth settings for the 'cellular' uplink
        """
        pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> 'outputs.GetCellularGatewayUplinkItemBandwidthLimitsResult':
        """
        The bandwidth settings for the 'cellular' uplink
        """
        return pulumi.get(self, "bandwidth_limits")


@pulumi.output_type
class GetCellularGatewayUplinkItemBandwidthLimitsResult(dict):
    def __init__(__self__, *,
                 limit_down: _builtins.int,
                 limit_up: _builtins.int):
        """
        :param _builtins.int limit_down: The maximum download limit (integer, in Kbps). 'null' indicates no limit.
        :param _builtins.int limit_up: The maximum upload limit (integer, in Kbps). 'null' indicates no limit.
        """
        pulumi.set(__self__, "limit_down", limit_down)
        pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> _builtins.int:
        """
        The maximum download limit (integer, in Kbps). 'null' indicates no limit.
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> _builtins.int:
        """
        The maximum upload limit (integer, in Kbps). 'null' indicates no limit.
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class GetClientsItemResult(dict):
    def __init__(__self__, *,
                 cdps: Sequence['outputs.GetClientsItemCdpResult'],
                 client_vpn_connections: Sequence['outputs.GetClientsItemClientVpnConnectionResult'],
                 description: _builtins.str,
                 first_seen: _builtins.int,
                 id: _builtins.str,
                 ip: _builtins.str,
                 ip6: _builtins.str,
                 last_seen: _builtins.int,
                 lldps: Sequence['outputs.GetClientsItemLldpResult'],
                 mac: _builtins.str,
                 manufacturer: _builtins.str,
                 os: _builtins.str,
                 recent_device_mac: _builtins.str,
                 sm_installed: _builtins.bool,
                 ssid: _builtins.str,
                 status: _builtins.str,
                 switchport: _builtins.str,
                 user: _builtins.str,
                 vlan: _builtins.str,
                 wireless_capabilities: _builtins.str):
        """
        :param Sequence['GetClientsItemCdpArgs'] cdps: The Cisco discover protocol settings for the client
        :param Sequence['GetClientsItemClientVpnConnectionArgs'] client_vpn_connections: VPN connections associated with the client
        :param _builtins.str description: Short description of the client
        :param _builtins.int first_seen: Timestamp client was first seen in the network
        :param _builtins.str id: The ID of the client
        :param _builtins.str ip: The IP address of the client
        :param _builtins.str ip6: The IPv6 address of the client
        :param _builtins.int last_seen: Timestamp client was last seen in the network
        :param Sequence['GetClientsItemLldpArgs'] lldps: The link layer discover protocol settings for the client
        :param _builtins.str mac: The MAC address of the client
        :param _builtins.str manufacturer: Manufacturer of the client
        :param _builtins.str os: The operating system of the client
        :param _builtins.str recent_device_mac: The MAC address of the node that the device was last connected to
        :param _builtins.bool sm_installed: Status of SM for the client
        :param _builtins.str ssid: The name of the SSID that the client is connected to
        :param _builtins.str status: The connection status of the client
        :param _builtins.str switchport: The switch port that the client is connected to
        :param _builtins.str user: The username of the user of the client
        :param _builtins.str vlan: The name of the VLAN that the client is connected to
        :param _builtins.str wireless_capabilities: Wireless capabilities of the client
        """
        pulumi.set(__self__, "cdps", cdps)
        pulumi.set(__self__, "client_vpn_connections", client_vpn_connections)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "first_seen", first_seen)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip6", ip6)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "lldps", lldps)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "os", os)
        pulumi.set(__self__, "recent_device_mac", recent_device_mac)
        pulumi.set(__self__, "sm_installed", sm_installed)
        pulumi.set(__self__, "ssid", ssid)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "switchport", switchport)
        pulumi.set(__self__, "user", user)
        pulumi.set(__self__, "vlan", vlan)
        pulumi.set(__self__, "wireless_capabilities", wireless_capabilities)

    @_builtins.property
    @pulumi.getter
    def cdps(self) -> Sequence['outputs.GetClientsItemCdpResult']:
        """
        The Cisco discover protocol settings for the client
        """
        return pulumi.get(self, "cdps")

    @_builtins.property
    @pulumi.getter(name="clientVpnConnections")
    def client_vpn_connections(self) -> Sequence['outputs.GetClientsItemClientVpnConnectionResult']:
        """
        VPN connections associated with the client
        """
        return pulumi.get(self, "client_vpn_connections")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Short description of the client
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="firstSeen")
    def first_seen(self) -> _builtins.int:
        """
        Timestamp client was first seen in the network
        """
        return pulumi.get(self, "first_seen")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the client
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        The IP address of the client
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> _builtins.str:
        """
        The IPv6 address of the client
        """
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> _builtins.int:
        """
        Timestamp client was last seen in the network
        """
        return pulumi.get(self, "last_seen")

    @_builtins.property
    @pulumi.getter
    def lldps(self) -> Sequence['outputs.GetClientsItemLldpResult']:
        """
        The link layer discover protocol settings for the client
        """
        return pulumi.get(self, "lldps")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        The MAC address of the client
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def manufacturer(self) -> _builtins.str:
        """
        Manufacturer of the client
        """
        return pulumi.get(self, "manufacturer")

    @_builtins.property
    @pulumi.getter
    def os(self) -> _builtins.str:
        """
        The operating system of the client
        """
        return pulumi.get(self, "os")

    @_builtins.property
    @pulumi.getter(name="recentDeviceMac")
    def recent_device_mac(self) -> _builtins.str:
        """
        The MAC address of the node that the device was last connected to
        """
        return pulumi.get(self, "recent_device_mac")

    @_builtins.property
    @pulumi.getter(name="smInstalled")
    def sm_installed(self) -> _builtins.bool:
        """
        Status of SM for the client
        """
        return pulumi.get(self, "sm_installed")

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> _builtins.str:
        """
        The name of the SSID that the client is connected to
        """
        return pulumi.get(self, "ssid")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The connection status of the client
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def switchport(self) -> _builtins.str:
        """
        The switch port that the client is connected to
        """
        return pulumi.get(self, "switchport")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        """
        The username of the user of the client
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.str:
        """
        The name of the VLAN that the client is connected to
        """
        return pulumi.get(self, "vlan")

    @_builtins.property
    @pulumi.getter(name="wirelessCapabilities")
    def wireless_capabilities(self) -> _builtins.str:
        """
        Wireless capabilities of the client
        """
        return pulumi.get(self, "wireless_capabilities")


@pulumi.output_type
class GetClientsItemCdpResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClientsItemClientVpnConnectionResult(dict):
    def __init__(__self__, *,
                 connected_at: _builtins.int,
                 disconnected_at: _builtins.int,
                 remote_ip: _builtins.str):
        """
        :param _builtins.int connected_at: The time the client last connected to the VPN
        :param _builtins.int disconnected_at: The time the client last disconnectd from the VPN
        :param _builtins.str remote_ip: The IP address of the VPN the client last connected to
        """
        pulumi.set(__self__, "connected_at", connected_at)
        pulumi.set(__self__, "disconnected_at", disconnected_at)
        pulumi.set(__self__, "remote_ip", remote_ip)

    @_builtins.property
    @pulumi.getter(name="connectedAt")
    def connected_at(self) -> _builtins.int:
        """
        The time the client last connected to the VPN
        """
        return pulumi.get(self, "connected_at")

    @_builtins.property
    @pulumi.getter(name="disconnectedAt")
    def disconnected_at(self) -> _builtins.int:
        """
        The time the client last disconnectd from the VPN
        """
        return pulumi.get(self, "disconnected_at")

    @_builtins.property
    @pulumi.getter(name="remoteIp")
    def remote_ip(self) -> _builtins.str:
        """
        The IP address of the VPN the client last connected to
        """
        return pulumi.get(self, "remote_ip")


@pulumi.output_type
class GetClientsItemLldpResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClientsOverviewItemResult(dict):
    def __init__(__self__, *,
                 counts: 'outputs.GetClientsOverviewItemCountsResult',
                 usages: 'outputs.GetClientsOverviewItemUsagesResult'):
        """
        :param 'GetClientsOverviewItemCountsArgs' counts: The number of clients on a network over a given time range
        :param 'GetClientsOverviewItemUsagesArgs' usages: The average usage of the clients on a network over a given time range
        """
        pulumi.set(__self__, "counts", counts)
        pulumi.set(__self__, "usages", usages)

    @_builtins.property
    @pulumi.getter
    def counts(self) -> 'outputs.GetClientsOverviewItemCountsResult':
        """
        The number of clients on a network over a given time range
        """
        return pulumi.get(self, "counts")

    @_builtins.property
    @pulumi.getter
    def usages(self) -> 'outputs.GetClientsOverviewItemUsagesResult':
        """
        The average usage of the clients on a network over a given time range
        """
        return pulumi.get(self, "usages")


@pulumi.output_type
class GetClientsOverviewItemCountsResult(dict):
    def __init__(__self__, *,
                 total: _builtins.int,
                 with_heavy_usage: _builtins.int):
        """
        :param _builtins.int total: The total number of clients on a network
        :param _builtins.int with_heavy_usage: The total number of clients with heavy usage on a network
        """
        pulumi.set(__self__, "total", total)
        pulumi.set(__self__, "with_heavy_usage", with_heavy_usage)

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        The total number of clients on a network
        """
        return pulumi.get(self, "total")

    @_builtins.property
    @pulumi.getter(name="withHeavyUsage")
    def with_heavy_usage(self) -> _builtins.int:
        """
        The total number of clients with heavy usage on a network
        """
        return pulumi.get(self, "with_heavy_usage")


@pulumi.output_type
class GetClientsOverviewItemUsagesResult(dict):
    def __init__(__self__, *,
                 average: _builtins.int,
                 with_heavy_usage_average: _builtins.int):
        """
        :param _builtins.int average: The average usage of all clients on a network
        :param _builtins.int with_heavy_usage_average: The average usage of all clients with heavy usage on a network
        """
        pulumi.set(__self__, "average", average)
        pulumi.set(__self__, "with_heavy_usage_average", with_heavy_usage_average)

    @_builtins.property
    @pulumi.getter
    def average(self) -> _builtins.int:
        """
        The average usage of all clients on a network
        """
        return pulumi.get(self, "average")

    @_builtins.property
    @pulumi.getter(name="withHeavyUsageAverage")
    def with_heavy_usage_average(self) -> _builtins.int:
        """
        The average usage of all clients with heavy usage on a network
        """
        return pulumi.get(self, "with_heavy_usage_average")


@pulumi.output_type
class GetClientsPolicyItemResult(dict):
    def __init__(__self__, *,
                 device_policy: _builtins.str,
                 group_policy_id: _builtins.str,
                 mac: _builtins.str):
        """
        :param _builtins.str device_policy: The name of the client's policy
        :param _builtins.str group_policy_id: The group policy identifier of the client
        :param _builtins.str mac: The MAC address of the client
        """
        pulumi.set(__self__, "device_policy", device_policy)
        pulumi.set(__self__, "group_policy_id", group_policy_id)
        pulumi.set(__self__, "mac", mac)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> _builtins.str:
        """
        The name of the client's policy
        """
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> _builtins.str:
        """
        The group policy identifier of the client
        """
        return pulumi.get(self, "group_policy_id")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        The MAC address of the client
        """
        return pulumi.get(self, "mac")


@pulumi.output_type
class GetClientsSplashAuthorizationStatusItemResult(dict):
    def __init__(__self__, *,
                 ssids: 'outputs.GetClientsSplashAuthorizationStatusItemSsidsResult'):
        pulumi.set(__self__, "ssids", ssids)

    @_builtins.property
    @pulumi.getter
    def ssids(self) -> 'outputs.GetClientsSplashAuthorizationStatusItemSsidsResult':
        return pulumi.get(self, "ssids")


@pulumi.output_type
class GetClientsSplashAuthorizationStatusItemSsidsResult(dict):
    def __init__(__self__, *,
                 status0: 'outputs.GetClientsSplashAuthorizationStatusItemSsidsStatus0Result',
                 status2: 'outputs.GetClientsSplashAuthorizationStatusItemSsidsStatus2Result'):
        pulumi.set(__self__, "status0", status0)
        pulumi.set(__self__, "status2", status2)

    @_builtins.property
    @pulumi.getter
    def status0(self) -> 'outputs.GetClientsSplashAuthorizationStatusItemSsidsStatus0Result':
        return pulumi.get(self, "status0")

    @_builtins.property
    @pulumi.getter
    def status2(self) -> 'outputs.GetClientsSplashAuthorizationStatusItemSsidsStatus2Result':
        return pulumi.get(self, "status2")


@pulumi.output_type
class GetClientsSplashAuthorizationStatusItemSsidsStatus0Result(dict):
    def __init__(__self__, *,
                 authorized_at: _builtins.str,
                 expires_at: _builtins.str,
                 is_authorized: _builtins.bool):
        pulumi.set(__self__, "authorized_at", authorized_at)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="authorizedAt")
    def authorized_at(self) -> _builtins.str:
        return pulumi.get(self, "authorized_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> _builtins.bool:
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class GetClientsSplashAuthorizationStatusItemSsidsStatus2Result(dict):
    def __init__(__self__, *,
                 is_authorized: _builtins.bool):
        pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> _builtins.bool:
        return pulumi.get(self, "is_authorized")


@pulumi.output_type
class GetEventsEventTypesItemResult(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 description: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str category: Event category
        :param _builtins.str description: Description of the event
        :param _builtins.str type: Event type
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        Event category
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the event
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Event type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEventsItemResult(dict):
    def __init__(__self__, *,
                 events: Sequence['outputs.GetEventsItemEventResult'],
                 message: _builtins.str,
                 page_end_at: _builtins.str,
                 page_start_at: _builtins.str):
        """
        :param Sequence['GetEventsItemEventArgs'] events: An array of events that took place in the network.
        :param _builtins.str message: A message regarding the events sent. Usually 'null' unless there are no events
        :param _builtins.str page_end_at: An UTC ISO8601 string of the latest occured at time of the listed events of the page.
        :param _builtins.str page_start_at: An UTC ISO8601 string of the earliest occured at time of the listed events of the page.
        """
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "page_end_at", page_end_at)
        pulumi.set(__self__, "page_start_at", page_start_at)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Sequence['outputs.GetEventsItemEventResult']:
        """
        An array of events that took place in the network.
        """
        return pulumi.get(self, "events")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        A message regarding the events sent. Usually 'null' unless there are no events
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="pageEndAt")
    def page_end_at(self) -> _builtins.str:
        """
        An UTC ISO8601 string of the latest occured at time of the listed events of the page.
        """
        return pulumi.get(self, "page_end_at")

    @_builtins.property
    @pulumi.getter(name="pageStartAt")
    def page_start_at(self) -> _builtins.str:
        """
        An UTC ISO8601 string of the earliest occured at time of the listed events of the page.
        """
        return pulumi.get(self, "page_start_at")


@pulumi.output_type
class GetEventsItemEventResult(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 client_description: _builtins.str,
                 client_id: _builtins.str,
                 client_mac: _builtins.str,
                 description: _builtins.str,
                 device_name: _builtins.str,
                 device_serial: _builtins.str,
                 event_data: 'outputs.GetEventsItemEventEventDataResult',
                 network_id: _builtins.str,
                 occurred_at: _builtins.str,
                 ssid_number: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.str category: The category that the event type belongs to
        :param _builtins.str client_description: A description of the client. This is usually the client's device name.
        :param _builtins.str client_id: A string identifying the client. This could be a client's MAC or IP address
        :param _builtins.str client_mac: The client's MAC address.
        :param _builtins.str description: A description of the event the happened.
        :param _builtins.str device_name: The name of the device. Only shown if the device is an access point.
        :param _builtins.str device_serial: The serial number of the device. Only shown if the device is an access point.
        :param 'GetEventsItemEventEventDataArgs' event_data: An object containing more data related to the event.
        :param _builtins.str network_id: The ID of the network.
        :param _builtins.str occurred_at: An UTC ISO8601 string of the time the event occurred at.
        :param _builtins.int ssid_number: The SSID number of the device.
        :param _builtins.str type: The type of event being listed.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "client_description", client_description)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_mac", client_mac)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "device_serial", device_serial)
        pulumi.set(__self__, "event_data", event_data)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "occurred_at", occurred_at)
        pulumi.set(__self__, "ssid_number", ssid_number)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        The category that the event type belongs to
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter(name="clientDescription")
    def client_description(self) -> _builtins.str:
        """
        A description of the client. This is usually the client's device name.
        """
        return pulumi.get(self, "client_description")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        A string identifying the client. This could be a client's MAC or IP address
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientMac")
    def client_mac(self) -> _builtins.str:
        """
        The client's MAC address.
        """
        return pulumi.get(self, "client_mac")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A description of the event the happened.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        The name of the device. Only shown if the device is an access point.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deviceSerial")
    def device_serial(self) -> _builtins.str:
        """
        The serial number of the device. Only shown if the device is an access point.
        """
        return pulumi.get(self, "device_serial")

    @_builtins.property
    @pulumi.getter(name="eventData")
    def event_data(self) -> 'outputs.GetEventsItemEventEventDataResult':
        """
        An object containing more data related to the event.
        """
        return pulumi.get(self, "event_data")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        The ID of the network.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="occurredAt")
    def occurred_at(self) -> _builtins.str:
        """
        An UTC ISO8601 string of the time the event occurred at.
        """
        return pulumi.get(self, "occurred_at")

    @_builtins.property
    @pulumi.getter(name="ssidNumber")
    def ssid_number(self) -> _builtins.int:
        """
        The SSID number of the device.
        """
        return pulumi.get(self, "ssid_number")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of event being listed.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEventsItemEventEventDataResult(dict):
    def __init__(__self__, *,
                 aid: _builtins.str,
                 channel: _builtins.str,
                 client_ip: _builtins.str,
                 client_mac: _builtins.str,
                 radio: _builtins.str,
                 rssi: _builtins.str,
                 vap: _builtins.str):
        """
        :param _builtins.str aid: The association ID of the client.
        :param _builtins.str channel: The radio channel the client is connecting to.
        :param _builtins.str client_ip: The client's IP address
        :param _builtins.str client_mac: The client's MAC address
        :param _builtins.str radio: The radio band number the client is trying to connect to.
        :param _builtins.str rssi: The current received signal strength indication (RSSI) of the client connected to an AP.
        :param _builtins.str vap: The virtual access point (VAP) number the client is connecting to.
        """
        pulumi.set(__self__, "aid", aid)
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "client_ip", client_ip)
        pulumi.set(__self__, "client_mac", client_mac)
        pulumi.set(__self__, "radio", radio)
        pulumi.set(__self__, "rssi", rssi)
        pulumi.set(__self__, "vap", vap)

    @_builtins.property
    @pulumi.getter
    def aid(self) -> _builtins.str:
        """
        The association ID of the client.
        """
        return pulumi.get(self, "aid")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The radio channel the client is connecting to.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter(name="clientIp")
    def client_ip(self) -> _builtins.str:
        """
        The client's IP address
        """
        return pulumi.get(self, "client_ip")

    @_builtins.property
    @pulumi.getter(name="clientMac")
    def client_mac(self) -> _builtins.str:
        """
        The client's MAC address
        """
        return pulumi.get(self, "client_mac")

    @_builtins.property
    @pulumi.getter
    def radio(self) -> _builtins.str:
        """
        The radio band number the client is trying to connect to.
        """
        return pulumi.get(self, "radio")

    @_builtins.property
    @pulumi.getter
    def rssi(self) -> _builtins.str:
        """
        The current received signal strength indication (RSSI) of the client connected to an AP.
        """
        return pulumi.get(self, "rssi")

    @_builtins.property
    @pulumi.getter
    def vap(self) -> _builtins.str:
        """
        The virtual access point (VAP) number the client is connecting to.
        """
        return pulumi.get(self, "vap")


@pulumi.output_type
class GetFirmwareUpgradesItemResult(dict):
    def __init__(__self__, *,
                 products: 'outputs.GetFirmwareUpgradesItemProductsResult',
                 timezone: _builtins.str,
                 upgrade_window: 'outputs.GetFirmwareUpgradesItemUpgradeWindowResult'):
        """
        :param 'GetFirmwareUpgradesItemProductsArgs' products: The network devices to be updated
        :param _builtins.str timezone: The timezone for the network
        :param 'GetFirmwareUpgradesItemUpgradeWindowArgs' upgrade_window: Upgrade window for devices in network
        """
        pulumi.set(__self__, "products", products)
        pulumi.set(__self__, "timezone", timezone)
        pulumi.set(__self__, "upgrade_window", upgrade_window)

    @_builtins.property
    @pulumi.getter
    def products(self) -> 'outputs.GetFirmwareUpgradesItemProductsResult':
        """
        The network devices to be updated
        """
        return pulumi.get(self, "products")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> _builtins.str:
        """
        The timezone for the network
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter(name="upgradeWindow")
    def upgrade_window(self) -> 'outputs.GetFirmwareUpgradesItemUpgradeWindowResult':
        """
        Upgrade window for devices in network
        """
        return pulumi.get(self, "upgrade_window")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsResult(dict):
    def __init__(__self__, *,
                 appliance: 'outputs.GetFirmwareUpgradesItemProductsApplianceResult',
                 camera: 'outputs.GetFirmwareUpgradesItemProductsCameraResult',
                 cellular_gateway: 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayResult',
                 sensor: 'outputs.GetFirmwareUpgradesItemProductsSensorResult',
                 switch: 'outputs.GetFirmwareUpgradesItemProductsSwitchResult',
                 wireless: 'outputs.GetFirmwareUpgradesItemProductsWirelessResult'):
        """
        :param 'GetFirmwareUpgradesItemProductsApplianceArgs' appliance: The network device to be updated
        :param 'GetFirmwareUpgradesItemProductsCameraArgs' camera: The network device to be updated
        :param 'GetFirmwareUpgradesItemProductsCellularGatewayArgs' cellular_gateway: The network device to be updated
        :param 'GetFirmwareUpgradesItemProductsSensorArgs' sensor: The network device to be updated
        :param 'GetFirmwareUpgradesItemProductsSwitchArgs' switch: The network device to be updated
        :param 'GetFirmwareUpgradesItemProductsWirelessArgs' wireless: The network device to be updated
        """
        pulumi.set(__self__, "appliance", appliance)
        pulumi.set(__self__, "camera", camera)
        pulumi.set(__self__, "cellular_gateway", cellular_gateway)
        pulumi.set(__self__, "sensor", sensor)
        pulumi.set(__self__, "switch", switch)
        pulumi.set(__self__, "wireless", wireless)

    @_builtins.property
    @pulumi.getter
    def appliance(self) -> 'outputs.GetFirmwareUpgradesItemProductsApplianceResult':
        """
        The network device to be updated
        """
        return pulumi.get(self, "appliance")

    @_builtins.property
    @pulumi.getter
    def camera(self) -> 'outputs.GetFirmwareUpgradesItemProductsCameraResult':
        """
        The network device to be updated
        """
        return pulumi.get(self, "camera")

    @_builtins.property
    @pulumi.getter(name="cellularGateway")
    def cellular_gateway(self) -> 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayResult':
        """
        The network device to be updated
        """
        return pulumi.get(self, "cellular_gateway")

    @_builtins.property
    @pulumi.getter
    def sensor(self) -> 'outputs.GetFirmwareUpgradesItemProductsSensorResult':
        """
        The network device to be updated
        """
        return pulumi.get(self, "sensor")

    @_builtins.property
    @pulumi.getter
    def switch(self) -> 'outputs.GetFirmwareUpgradesItemProductsSwitchResult':
        """
        The network device to be updated
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter
    def wireless(self) -> 'outputs.GetFirmwareUpgradesItemProductsWirelessResult':
        """
        The network device to be updated
        """
        return pulumi.get(self, "wireless")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsApplianceResult(dict):
    def __init__(__self__, *,
                 available_versions: Sequence['outputs.GetFirmwareUpgradesItemProductsApplianceAvailableVersionResult'],
                 current_version: 'outputs.GetFirmwareUpgradesItemProductsApplianceCurrentVersionResult',
                 last_upgrade: 'outputs.GetFirmwareUpgradesItemProductsApplianceLastUpgradeResult',
                 next_upgrade: 'outputs.GetFirmwareUpgradesItemProductsApplianceNextUpgradeResult',
                 participate_in_next_beta_release: _builtins.bool):
        """
        :param Sequence['GetFirmwareUpgradesItemProductsApplianceAvailableVersionArgs'] available_versions: Firmware versions available for upgrade
        :param 'GetFirmwareUpgradesItemProductsApplianceCurrentVersionArgs' current_version: Details of the current version on the device
        :param 'GetFirmwareUpgradesItemProductsApplianceLastUpgradeArgs' last_upgrade: Details of the last firmware upgrade on the device
        :param 'GetFirmwareUpgradesItemProductsApplianceNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade on the device
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        pulumi.set(__self__, "available_versions", available_versions)
        pulumi.set(__self__, "current_version", current_version)
        pulumi.set(__self__, "last_upgrade", last_upgrade)
        pulumi.set(__self__, "next_upgrade", next_upgrade)
        pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Sequence['outputs.GetFirmwareUpgradesItemProductsApplianceAvailableVersionResult']:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsApplianceCurrentVersionResult':
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> 'outputs.GetFirmwareUpgradesItemProductsApplianceLastUpgradeResult':
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> 'outputs.GetFirmwareUpgradesItemProductsApplianceNextUpgradeResult':
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> _builtins.bool:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsApplianceAvailableVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsApplianceCurrentVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsApplianceLastUpgradeResult(dict):
    def __init__(__self__, *,
                 from_version: 'outputs.GetFirmwareUpgradesItemProductsApplianceLastUpgradeFromVersionResult',
                 time: _builtins.str,
                 to_version: 'outputs.GetFirmwareUpgradesItemProductsApplianceLastUpgradeToVersionResult'):
        """
        :param 'GetFirmwareUpgradesItemProductsApplianceLastUpgradeFromVersionArgs' from_version: Details of the version the device upgraded from
        :param _builtins.str time: Timestamp of the last successful firmware upgrade
        :param 'GetFirmwareUpgradesItemProductsApplianceLastUpgradeToVersionArgs' to_version: Details of the version the device upgraded to
        """
        pulumi.set(__self__, "from_version", from_version)
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsApplianceLastUpgradeFromVersionResult':
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsApplianceLastUpgradeToVersionResult':
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsApplianceLastUpgradeFromVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsApplianceLastUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsApplianceNextUpgradeResult(dict):
    def __init__(__self__, *,
                 time: _builtins.str,
                 to_version: 'outputs.GetFirmwareUpgradesItemProductsApplianceNextUpgradeToVersionResult'):
        """
        :param _builtins.str time: Timestamp of the next scheduled firmware upgrade
        :param 'GetFirmwareUpgradesItemProductsApplianceNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to if it exists
        """
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsApplianceNextUpgradeToVersionResult':
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsApplianceNextUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCameraResult(dict):
    def __init__(__self__, *,
                 available_versions: Sequence['outputs.GetFirmwareUpgradesItemProductsCameraAvailableVersionResult'],
                 current_version: 'outputs.GetFirmwareUpgradesItemProductsCameraCurrentVersionResult',
                 last_upgrade: 'outputs.GetFirmwareUpgradesItemProductsCameraLastUpgradeResult',
                 next_upgrade: 'outputs.GetFirmwareUpgradesItemProductsCameraNextUpgradeResult',
                 participate_in_next_beta_release: _builtins.bool):
        """
        :param Sequence['GetFirmwareUpgradesItemProductsCameraAvailableVersionArgs'] available_versions: Firmware versions available for upgrade
        :param 'GetFirmwareUpgradesItemProductsCameraCurrentVersionArgs' current_version: Details of the current version on the device
        :param 'GetFirmwareUpgradesItemProductsCameraLastUpgradeArgs' last_upgrade: Details of the last firmware upgrade on the device
        :param 'GetFirmwareUpgradesItemProductsCameraNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade on the device
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        pulumi.set(__self__, "available_versions", available_versions)
        pulumi.set(__self__, "current_version", current_version)
        pulumi.set(__self__, "last_upgrade", last_upgrade)
        pulumi.set(__self__, "next_upgrade", next_upgrade)
        pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Sequence['outputs.GetFirmwareUpgradesItemProductsCameraAvailableVersionResult']:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsCameraCurrentVersionResult':
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> 'outputs.GetFirmwareUpgradesItemProductsCameraLastUpgradeResult':
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> 'outputs.GetFirmwareUpgradesItemProductsCameraNextUpgradeResult':
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> _builtins.bool:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCameraAvailableVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCameraCurrentVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCameraLastUpgradeResult(dict):
    def __init__(__self__, *,
                 from_version: 'outputs.GetFirmwareUpgradesItemProductsCameraLastUpgradeFromVersionResult',
                 time: _builtins.str,
                 to_version: 'outputs.GetFirmwareUpgradesItemProductsCameraLastUpgradeToVersionResult'):
        """
        :param 'GetFirmwareUpgradesItemProductsCameraLastUpgradeFromVersionArgs' from_version: Details of the version the device upgraded from
        :param _builtins.str time: Timestamp of the last successful firmware upgrade
        :param 'GetFirmwareUpgradesItemProductsCameraLastUpgradeToVersionArgs' to_version: Details of the version the device upgraded to
        """
        pulumi.set(__self__, "from_version", from_version)
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsCameraLastUpgradeFromVersionResult':
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsCameraLastUpgradeToVersionResult':
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCameraLastUpgradeFromVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCameraLastUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCameraNextUpgradeResult(dict):
    def __init__(__self__, *,
                 time: _builtins.str,
                 to_version: 'outputs.GetFirmwareUpgradesItemProductsCameraNextUpgradeToVersionResult'):
        """
        :param _builtins.str time: Timestamp of the next scheduled firmware upgrade
        :param 'GetFirmwareUpgradesItemProductsCameraNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to if it exists
        """
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsCameraNextUpgradeToVersionResult':
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCameraNextUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCellularGatewayResult(dict):
    def __init__(__self__, *,
                 available_versions: Sequence['outputs.GetFirmwareUpgradesItemProductsCellularGatewayAvailableVersionResult'],
                 current_version: 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayCurrentVersionResult',
                 last_upgrade: 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeResult',
                 next_upgrade: 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayNextUpgradeResult',
                 participate_in_next_beta_release: _builtins.bool):
        """
        :param Sequence['GetFirmwareUpgradesItemProductsCellularGatewayAvailableVersionArgs'] available_versions: Firmware versions available for upgrade
        :param 'GetFirmwareUpgradesItemProductsCellularGatewayCurrentVersionArgs' current_version: Details of the current version on the device
        :param 'GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeArgs' last_upgrade: Details of the last firmware upgrade on the device
        :param 'GetFirmwareUpgradesItemProductsCellularGatewayNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade on the device
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        pulumi.set(__self__, "available_versions", available_versions)
        pulumi.set(__self__, "current_version", current_version)
        pulumi.set(__self__, "last_upgrade", last_upgrade)
        pulumi.set(__self__, "next_upgrade", next_upgrade)
        pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Sequence['outputs.GetFirmwareUpgradesItemProductsCellularGatewayAvailableVersionResult']:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayCurrentVersionResult':
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeResult':
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayNextUpgradeResult':
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> _builtins.bool:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCellularGatewayAvailableVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCellularGatewayCurrentVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeResult(dict):
    def __init__(__self__, *,
                 from_version: 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeFromVersionResult',
                 time: _builtins.str,
                 to_version: 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeToVersionResult'):
        """
        :param 'GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeFromVersionArgs' from_version: Details of the version the device upgraded from
        :param _builtins.str time: Timestamp of the last successful firmware upgrade
        :param 'GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeToVersionArgs' to_version: Details of the version the device upgraded to
        """
        pulumi.set(__self__, "from_version", from_version)
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeFromVersionResult':
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeToVersionResult':
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeFromVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCellularGatewayNextUpgradeResult(dict):
    def __init__(__self__, *,
                 time: _builtins.str,
                 to_version: 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayNextUpgradeToVersionResult'):
        """
        :param _builtins.str time: Timestamp of the next scheduled firmware upgrade
        :param 'GetFirmwareUpgradesItemProductsCellularGatewayNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to if it exists
        """
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsCellularGatewayNextUpgradeToVersionResult':
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsCellularGatewayNextUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSensorResult(dict):
    def __init__(__self__, *,
                 available_versions: Sequence['outputs.GetFirmwareUpgradesItemProductsSensorAvailableVersionResult'],
                 current_version: 'outputs.GetFirmwareUpgradesItemProductsSensorCurrentVersionResult',
                 last_upgrade: 'outputs.GetFirmwareUpgradesItemProductsSensorLastUpgradeResult',
                 next_upgrade: 'outputs.GetFirmwareUpgradesItemProductsSensorNextUpgradeResult',
                 participate_in_next_beta_release: _builtins.bool):
        """
        :param Sequence['GetFirmwareUpgradesItemProductsSensorAvailableVersionArgs'] available_versions: Firmware versions available for upgrade
        :param 'GetFirmwareUpgradesItemProductsSensorCurrentVersionArgs' current_version: Details of the current version on the device
        :param 'GetFirmwareUpgradesItemProductsSensorLastUpgradeArgs' last_upgrade: Details of the last firmware upgrade on the device
        :param 'GetFirmwareUpgradesItemProductsSensorNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade on the device
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        pulumi.set(__self__, "available_versions", available_versions)
        pulumi.set(__self__, "current_version", current_version)
        pulumi.set(__self__, "last_upgrade", last_upgrade)
        pulumi.set(__self__, "next_upgrade", next_upgrade)
        pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Sequence['outputs.GetFirmwareUpgradesItemProductsSensorAvailableVersionResult']:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsSensorCurrentVersionResult':
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> 'outputs.GetFirmwareUpgradesItemProductsSensorLastUpgradeResult':
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> 'outputs.GetFirmwareUpgradesItemProductsSensorNextUpgradeResult':
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> _builtins.bool:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSensorAvailableVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSensorCurrentVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSensorLastUpgradeResult(dict):
    def __init__(__self__, *,
                 from_version: 'outputs.GetFirmwareUpgradesItemProductsSensorLastUpgradeFromVersionResult',
                 time: _builtins.str,
                 to_version: 'outputs.GetFirmwareUpgradesItemProductsSensorLastUpgradeToVersionResult'):
        """
        :param 'GetFirmwareUpgradesItemProductsSensorLastUpgradeFromVersionArgs' from_version: Details of the version the device upgraded from
        :param _builtins.str time: Timestamp of the last successful firmware upgrade
        :param 'GetFirmwareUpgradesItemProductsSensorLastUpgradeToVersionArgs' to_version: Details of the version the device upgraded to
        """
        pulumi.set(__self__, "from_version", from_version)
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsSensorLastUpgradeFromVersionResult':
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsSensorLastUpgradeToVersionResult':
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSensorLastUpgradeFromVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSensorLastUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSensorNextUpgradeResult(dict):
    def __init__(__self__, *,
                 time: _builtins.str,
                 to_version: 'outputs.GetFirmwareUpgradesItemProductsSensorNextUpgradeToVersionResult'):
        """
        :param _builtins.str time: Timestamp of the next scheduled firmware upgrade
        :param 'GetFirmwareUpgradesItemProductsSensorNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to if it exists
        """
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsSensorNextUpgradeToVersionResult':
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSensorNextUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSwitchResult(dict):
    def __init__(__self__, *,
                 available_versions: Sequence['outputs.GetFirmwareUpgradesItemProductsSwitchAvailableVersionResult'],
                 current_version: 'outputs.GetFirmwareUpgradesItemProductsSwitchCurrentVersionResult',
                 last_upgrade: 'outputs.GetFirmwareUpgradesItemProductsSwitchLastUpgradeResult',
                 next_upgrade: 'outputs.GetFirmwareUpgradesItemProductsSwitchNextUpgradeResult',
                 participate_in_next_beta_release: _builtins.bool):
        """
        :param Sequence['GetFirmwareUpgradesItemProductsSwitchAvailableVersionArgs'] available_versions: Firmware versions available for upgrade
        :param 'GetFirmwareUpgradesItemProductsSwitchCurrentVersionArgs' current_version: Details of the current version on the device
        :param 'GetFirmwareUpgradesItemProductsSwitchLastUpgradeArgs' last_upgrade: Details of the last firmware upgrade on the device
        :param 'GetFirmwareUpgradesItemProductsSwitchNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade on the device
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        pulumi.set(__self__, "available_versions", available_versions)
        pulumi.set(__self__, "current_version", current_version)
        pulumi.set(__self__, "last_upgrade", last_upgrade)
        pulumi.set(__self__, "next_upgrade", next_upgrade)
        pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Sequence['outputs.GetFirmwareUpgradesItemProductsSwitchAvailableVersionResult']:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsSwitchCurrentVersionResult':
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> 'outputs.GetFirmwareUpgradesItemProductsSwitchLastUpgradeResult':
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> 'outputs.GetFirmwareUpgradesItemProductsSwitchNextUpgradeResult':
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> _builtins.bool:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSwitchAvailableVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSwitchCurrentVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSwitchLastUpgradeResult(dict):
    def __init__(__self__, *,
                 from_version: 'outputs.GetFirmwareUpgradesItemProductsSwitchLastUpgradeFromVersionResult',
                 time: _builtins.str,
                 to_version: 'outputs.GetFirmwareUpgradesItemProductsSwitchLastUpgradeToVersionResult'):
        """
        :param 'GetFirmwareUpgradesItemProductsSwitchLastUpgradeFromVersionArgs' from_version: Details of the version the device upgraded from
        :param _builtins.str time: Timestamp of the last successful firmware upgrade
        :param 'GetFirmwareUpgradesItemProductsSwitchLastUpgradeToVersionArgs' to_version: Details of the version the device upgraded to
        """
        pulumi.set(__self__, "from_version", from_version)
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsSwitchLastUpgradeFromVersionResult':
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsSwitchLastUpgradeToVersionResult':
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSwitchLastUpgradeFromVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSwitchLastUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSwitchNextUpgradeResult(dict):
    def __init__(__self__, *,
                 time: _builtins.str,
                 to_version: 'outputs.GetFirmwareUpgradesItemProductsSwitchNextUpgradeToVersionResult'):
        """
        :param _builtins.str time: Timestamp of the next scheduled firmware upgrade
        :param 'GetFirmwareUpgradesItemProductsSwitchNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to if it exists
        """
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsSwitchNextUpgradeToVersionResult':
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsSwitchNextUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsWirelessResult(dict):
    def __init__(__self__, *,
                 available_versions: Sequence['outputs.GetFirmwareUpgradesItemProductsWirelessAvailableVersionResult'],
                 current_version: 'outputs.GetFirmwareUpgradesItemProductsWirelessCurrentVersionResult',
                 last_upgrade: 'outputs.GetFirmwareUpgradesItemProductsWirelessLastUpgradeResult',
                 next_upgrade: 'outputs.GetFirmwareUpgradesItemProductsWirelessNextUpgradeResult',
                 participate_in_next_beta_release: _builtins.bool):
        """
        :param Sequence['GetFirmwareUpgradesItemProductsWirelessAvailableVersionArgs'] available_versions: Firmware versions available for upgrade
        :param 'GetFirmwareUpgradesItemProductsWirelessCurrentVersionArgs' current_version: Details of the current version on the device
        :param 'GetFirmwareUpgradesItemProductsWirelessLastUpgradeArgs' last_upgrade: Details of the last firmware upgrade on the device
        :param 'GetFirmwareUpgradesItemProductsWirelessNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade on the device
        :param _builtins.bool participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        pulumi.set(__self__, "available_versions", available_versions)
        pulumi.set(__self__, "current_version", current_version)
        pulumi.set(__self__, "last_upgrade", last_upgrade)
        pulumi.set(__self__, "next_upgrade", next_upgrade)
        pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Sequence['outputs.GetFirmwareUpgradesItemProductsWirelessAvailableVersionResult']:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsWirelessCurrentVersionResult':
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> 'outputs.GetFirmwareUpgradesItemProductsWirelessLastUpgradeResult':
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> 'outputs.GetFirmwareUpgradesItemProductsWirelessNextUpgradeResult':
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> _builtins.bool:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsWirelessAvailableVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsWirelessCurrentVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsWirelessLastUpgradeResult(dict):
    def __init__(__self__, *,
                 from_version: 'outputs.GetFirmwareUpgradesItemProductsWirelessLastUpgradeFromVersionResult',
                 time: _builtins.str,
                 to_version: 'outputs.GetFirmwareUpgradesItemProductsWirelessLastUpgradeToVersionResult'):
        """
        :param 'GetFirmwareUpgradesItemProductsWirelessLastUpgradeFromVersionArgs' from_version: Details of the version the device upgraded from
        :param _builtins.str time: Timestamp of the last successful firmware upgrade
        :param 'GetFirmwareUpgradesItemProductsWirelessLastUpgradeToVersionArgs' to_version: Details of the version the device upgraded to
        """
        pulumi.set(__self__, "from_version", from_version)
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsWirelessLastUpgradeFromVersionResult':
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsWirelessLastUpgradeToVersionResult':
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsWirelessLastUpgradeFromVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsWirelessLastUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsWirelessNextUpgradeResult(dict):
    def __init__(__self__, *,
                 time: _builtins.str,
                 to_version: 'outputs.GetFirmwareUpgradesItemProductsWirelessNextUpgradeToVersionResult'):
        """
        :param _builtins.str time: Timestamp of the next scheduled firmware upgrade
        :param 'GetFirmwareUpgradesItemProductsWirelessNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to if it exists
        """
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesItemProductsWirelessNextUpgradeToVersionResult':
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesItemProductsWirelessNextUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 firmware: _builtins.str,
                 id: _builtins.str,
                 release_date: _builtins.str,
                 release_type: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str firmware: Name of the firmware version
        :param _builtins.str id: Firmware version identifier
        :param _builtins.str release_date: Release date of the firmware version
        :param _builtins.str release_type: Release type of the firmware version
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "release_type", release_type)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> _builtins.str:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesItemUpgradeWindowResult(dict):
    def __init__(__self__, *,
                 day_of_week: _builtins.str,
                 hour_of_day: _builtins.str):
        """
        :param _builtins.str day_of_week: Day of the week
        :param _builtins.str hour_of_day: Hour of the day
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "hour_of_day", hour_of_day)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> _builtins.str:
        """
        Day of the week
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> _builtins.str:
        """
        Hour of the day
        """
        return pulumi.get(self, "hour_of_day")


@pulumi.output_type
class GetFirmwareUpgradesStagedEventsItemResult(dict):
    def __init__(__self__, *,
                 products: 'outputs.GetFirmwareUpgradesStagedEventsItemProductsResult',
                 reasons: Sequence['outputs.GetFirmwareUpgradesStagedEventsItemReasonResult'],
                 stages: Sequence['outputs.GetFirmwareUpgradesStagedEventsItemStageResult']):
        """
        :param 'GetFirmwareUpgradesStagedEventsItemProductsArgs' products: The network devices to be updated
        :param Sequence['GetFirmwareUpgradesStagedEventsItemReasonArgs'] reasons: Reasons for the rollback
        :param Sequence['GetFirmwareUpgradesStagedEventsItemStageArgs'] stages: The ordered stages in the network
        """
        pulumi.set(__self__, "products", products)
        pulumi.set(__self__, "reasons", reasons)
        pulumi.set(__self__, "stages", stages)

    @_builtins.property
    @pulumi.getter
    def products(self) -> 'outputs.GetFirmwareUpgradesStagedEventsItemProductsResult':
        """
        The network devices to be updated
        """
        return pulumi.get(self, "products")

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Sequence['outputs.GetFirmwareUpgradesStagedEventsItemReasonResult']:
        """
        Reasons for the rollback
        """
        return pulumi.get(self, "reasons")

    @_builtins.property
    @pulumi.getter
    def stages(self) -> Sequence['outputs.GetFirmwareUpgradesStagedEventsItemStageResult']:
        """
        The ordered stages in the network
        """
        return pulumi.get(self, "stages")


@pulumi.output_type
class GetFirmwareUpgradesStagedEventsItemProductsResult(dict):
    def __init__(__self__, *,
                 switch: 'outputs.GetFirmwareUpgradesStagedEventsItemProductsSwitchResult'):
        """
        :param 'GetFirmwareUpgradesStagedEventsItemProductsSwitchArgs' switch: The Switch network to be updated
        """
        pulumi.set(__self__, "switch", switch)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> 'outputs.GetFirmwareUpgradesStagedEventsItemProductsSwitchResult':
        """
        The Switch network to be updated
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class GetFirmwareUpgradesStagedEventsItemProductsSwitchResult(dict):
    def __init__(__self__, *,
                 next_upgrade: 'outputs.GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgradeResult'):
        """
        :param 'GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgradeArgs' next_upgrade: Details of the next firmware upgrade
        """
        pulumi.set(__self__, "next_upgrade", next_upgrade)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> 'outputs.GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgradeResult':
        """
        Details of the next firmware upgrade
        """
        return pulumi.get(self, "next_upgrade")


@pulumi.output_type
class GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgradeResult(dict):
    def __init__(__self__, *,
                 to_version: 'outputs.GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgradeToVersionResult'):
        """
        :param 'GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgradeToVersionArgs' to_version: Details of the version the device will upgrade to
        """
        pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> 'outputs.GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgradeToVersionResult':
        """
        Details of the version the device will upgrade to
        """
        return pulumi.get(self, "to_version")


@pulumi.output_type
class GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgradeToVersionResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 short_name: _builtins.str):
        """
        :param _builtins.str id: Id of the Version being upgraded to
        :param _builtins.str short_name: Firmware version short name
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the Version being upgraded to
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> _builtins.str:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")


@pulumi.output_type
class GetFirmwareUpgradesStagedEventsItemReasonResult(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 comment: _builtins.str):
        """
        :param _builtins.str category: Reason for the rollback
        :param _builtins.str comment: Additional comment about the rollback
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class GetFirmwareUpgradesStagedEventsItemStageResult(dict):
    def __init__(__self__, *,
                 group: 'outputs.GetFirmwareUpgradesStagedEventsItemStageGroupResult',
                 milestones: 'outputs.GetFirmwareUpgradesStagedEventsItemStageMilestonesResult',
                 status: _builtins.str):
        """
        :param 'GetFirmwareUpgradesStagedEventsItemStageGroupArgs' group: The staged upgrade group
        :param 'GetFirmwareUpgradesStagedEventsItemStageMilestonesArgs' milestones: The Staged Upgrade Milestones for the stage
        :param _builtins.str status: Current upgrade status of the group
        """
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "milestones", milestones)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def group(self) -> 'outputs.GetFirmwareUpgradesStagedEventsItemStageGroupResult':
        """
        The staged upgrade group
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def milestones(self) -> 'outputs.GetFirmwareUpgradesStagedEventsItemStageMilestonesResult':
        """
        The Staged Upgrade Milestones for the stage
        """
        return pulumi.get(self, "milestones")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Current upgrade status of the group
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetFirmwareUpgradesStagedEventsItemStageGroupResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str description: Description of the Staged Upgrade Group
        :param _builtins.str id: Id of the Staged Upgrade Group
        :param _builtins.str name: Name of the Staged Upgrade Group
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the Staged Upgrade Group
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Staged Upgrade Group
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFirmwareUpgradesStagedEventsItemStageMilestonesResult(dict):
    def __init__(__self__, *,
                 canceled_at: _builtins.str,
                 completed_at: _builtins.str,
                 scheduled_for: _builtins.str,
                 started_at: _builtins.str):
        """
        :param _builtins.str canceled_at: Time that the group was canceled
        :param _builtins.str completed_at: Finish time for the group
        :param _builtins.str scheduled_for: Scheduled start time for the group
        :param _builtins.str started_at: Start time for the group
        """
        pulumi.set(__self__, "canceled_at", canceled_at)
        pulumi.set(__self__, "completed_at", completed_at)
        pulumi.set(__self__, "scheduled_for", scheduled_for)
        pulumi.set(__self__, "started_at", started_at)

    @_builtins.property
    @pulumi.getter(name="canceledAt")
    def canceled_at(self) -> _builtins.str:
        """
        Time that the group was canceled
        """
        return pulumi.get(self, "canceled_at")

    @_builtins.property
    @pulumi.getter(name="completedAt")
    def completed_at(self) -> _builtins.str:
        """
        Finish time for the group
        """
        return pulumi.get(self, "completed_at")

    @_builtins.property
    @pulumi.getter(name="scheduledFor")
    def scheduled_for(self) -> _builtins.str:
        """
        Scheduled start time for the group
        """
        return pulumi.get(self, "scheduled_for")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Start time for the group
        """
        return pulumi.get(self, "started_at")


@pulumi.output_type
class GetFirmwareUpgradesStagedGroupsItemResult(dict):
    def __init__(__self__, *,
                 assigned_devices: 'outputs.GetFirmwareUpgradesStagedGroupsItemAssignedDevicesResult',
                 description: _builtins.str,
                 group_id: _builtins.str,
                 is_default: _builtins.bool,
                 name: _builtins.str):
        """
        :param 'GetFirmwareUpgradesStagedGroupsItemAssignedDevicesArgs' assigned_devices: The devices and Switch Stacks assigned to the Group
        :param _builtins.str description: Description of the Staged Upgrade Group
        :param _builtins.str group_id: Id of staged upgrade group
        :param _builtins.bool is_default: Boolean indicating the default Group. Any device that does not have a group explicitly assigned will upgrade with this group
        :param _builtins.str name: Name of the Staged Upgrade Group
        """
        pulumi.set(__self__, "assigned_devices", assigned_devices)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="assignedDevices")
    def assigned_devices(self) -> 'outputs.GetFirmwareUpgradesStagedGroupsItemAssignedDevicesResult':
        """
        The devices and Switch Stacks assigned to the Group
        """
        return pulumi.get(self, "assigned_devices")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the Staged Upgrade Group
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        Id of staged upgrade group
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> _builtins.bool:
        """
        Boolean indicating the default Group. Any device that does not have a group explicitly assigned will upgrade with this group
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Staged Upgrade Group
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFirmwareUpgradesStagedGroupsItemAssignedDevicesResult(dict):
    def __init__(__self__, *,
                 devices: Sequence['outputs.GetFirmwareUpgradesStagedGroupsItemAssignedDevicesDeviceResult'],
                 switch_stacks: Sequence['outputs.GetFirmwareUpgradesStagedGroupsItemAssignedDevicesSwitchStackResult']):
        """
        :param Sequence['GetFirmwareUpgradesStagedGroupsItemAssignedDevicesDeviceArgs'] devices: Data Array of Devices containing the name and serial
        :param Sequence['GetFirmwareUpgradesStagedGroupsItemAssignedDevicesSwitchStackArgs'] switch_stacks: Data Array of Switch Stacks containing the name and id
        """
        pulumi.set(__self__, "devices", devices)
        pulumi.set(__self__, "switch_stacks", switch_stacks)

    @_builtins.property
    @pulumi.getter
    def devices(self) -> Sequence['outputs.GetFirmwareUpgradesStagedGroupsItemAssignedDevicesDeviceResult']:
        """
        Data Array of Devices containing the name and serial
        """
        return pulumi.get(self, "devices")

    @_builtins.property
    @pulumi.getter(name="switchStacks")
    def switch_stacks(self) -> Sequence['outputs.GetFirmwareUpgradesStagedGroupsItemAssignedDevicesSwitchStackResult']:
        """
        Data Array of Switch Stacks containing the name and id
        """
        return pulumi.get(self, "switch_stacks")


@pulumi.output_type
class GetFirmwareUpgradesStagedGroupsItemAssignedDevicesDeviceResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 serial: _builtins.str):
        """
        :param _builtins.str name: Name of the device
        :param _builtins.str serial: Serial of the device
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the device
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Serial of the device
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class GetFirmwareUpgradesStagedGroupsItemAssignedDevicesSwitchStackResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: ID of the Switch Stack
        :param _builtins.str name: Name of the Switch Stack
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the Switch Stack
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Switch Stack
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFirmwareUpgradesStagedStagesItemResult(dict):
    def __init__(__self__, *,
                 group: 'outputs.GetFirmwareUpgradesStagedStagesItemGroupResult'):
        """
        :param 'GetFirmwareUpgradesStagedStagesItemGroupArgs' group: The Staged Upgrade Group
        """
        pulumi.set(__self__, "group", group)

    @_builtins.property
    @pulumi.getter
    def group(self) -> 'outputs.GetFirmwareUpgradesStagedStagesItemGroupResult':
        """
        The Staged Upgrade Group
        """
        return pulumi.get(self, "group")


@pulumi.output_type
class GetFirmwareUpgradesStagedStagesItemGroupResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str description: Description of the Staged Upgrade Group
        :param _builtins.str id: Id of the Staged Upgrade Group
        :param _builtins.str name: Name of the Staged Upgrade Group
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the Staged Upgrade Group
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Staged Upgrade Group
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFloorPlansItemResult(dict):
    def __init__(__self__, *,
                 bottom_left_corner: 'outputs.GetFloorPlansItemBottomLeftCornerResult',
                 bottom_right_corner: 'outputs.GetFloorPlansItemBottomRightCornerResult',
                 center: 'outputs.GetFloorPlansItemCenterResult',
                 devices: Sequence['outputs.GetFloorPlansItemDeviceResult'],
                 floor_plan_id: _builtins.str,
                 height: _builtins.float,
                 image_extension: _builtins.str,
                 image_md5: _builtins.str,
                 image_url: _builtins.str,
                 image_url_expires_at: _builtins.str,
                 name: _builtins.str,
                 top_left_corner: 'outputs.GetFloorPlansItemTopLeftCornerResult',
                 top_right_corner: 'outputs.GetFloorPlansItemTopRightCornerResult',
                 width: _builtins.float):
        """
        :param 'GetFloorPlansItemBottomLeftCornerArgs' bottom_left_corner: The longitude and latitude of the bottom left corner of your floor plan.
        :param 'GetFloorPlansItemBottomRightCornerArgs' bottom_right_corner: The longitude and latitude of the bottom right corner of your floor plan.
        :param 'GetFloorPlansItemCenterArgs' center: The longitude and latitude of the center of your floor plan. The 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
        :param Sequence['GetFloorPlansItemDeviceArgs'] devices: List of devices for the floorplan
        :param _builtins.str floor_plan_id: Floor plan ID
        :param _builtins.float height: The height of your floor plan.
        :param _builtins.str image_extension: The format type of the image.
        :param _builtins.str image_md5: The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image.
        :param _builtins.str image_url: The url link for the floor plan image.
        :param _builtins.str image_url_expires_at: The time the image url link will expire.
        :param _builtins.str name: The name of your floor plan.
        :param 'GetFloorPlansItemTopLeftCornerArgs' top_left_corner: The longitude and latitude of the top left corner of your floor plan.
        :param 'GetFloorPlansItemTopRightCornerArgs' top_right_corner: The longitude and latitude of the top right corner of your floor plan.
        :param _builtins.float width: The width of your floor plan.
        """
        pulumi.set(__self__, "bottom_left_corner", bottom_left_corner)
        pulumi.set(__self__, "bottom_right_corner", bottom_right_corner)
        pulumi.set(__self__, "center", center)
        pulumi.set(__self__, "devices", devices)
        pulumi.set(__self__, "floor_plan_id", floor_plan_id)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "image_extension", image_extension)
        pulumi.set(__self__, "image_md5", image_md5)
        pulumi.set(__self__, "image_url", image_url)
        pulumi.set(__self__, "image_url_expires_at", image_url_expires_at)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "top_left_corner", top_left_corner)
        pulumi.set(__self__, "top_right_corner", top_right_corner)
        pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter(name="bottomLeftCorner")
    def bottom_left_corner(self) -> 'outputs.GetFloorPlansItemBottomLeftCornerResult':
        """
        The longitude and latitude of the bottom left corner of your floor plan.
        """
        return pulumi.get(self, "bottom_left_corner")

    @_builtins.property
    @pulumi.getter(name="bottomRightCorner")
    def bottom_right_corner(self) -> 'outputs.GetFloorPlansItemBottomRightCornerResult':
        """
        The longitude and latitude of the bottom right corner of your floor plan.
        """
        return pulumi.get(self, "bottom_right_corner")

    @_builtins.property
    @pulumi.getter
    def center(self) -> 'outputs.GetFloorPlansItemCenterResult':
        """
        The longitude and latitude of the center of your floor plan. The 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
        """
        return pulumi.get(self, "center")

    @_builtins.property
    @pulumi.getter
    def devices(self) -> Sequence['outputs.GetFloorPlansItemDeviceResult']:
        """
        List of devices for the floorplan
        """
        return pulumi.get(self, "devices")

    @_builtins.property
    @pulumi.getter(name="floorPlanId")
    def floor_plan_id(self) -> _builtins.str:
        """
        Floor plan ID
        """
        return pulumi.get(self, "floor_plan_id")

    @_builtins.property
    @pulumi.getter
    def height(self) -> _builtins.float:
        """
        The height of your floor plan.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="imageExtension")
    def image_extension(self) -> _builtins.str:
        """
        The format type of the image.
        """
        return pulumi.get(self, "image_extension")

    @_builtins.property
    @pulumi.getter(name="imageMd5")
    def image_md5(self) -> _builtins.str:
        """
        The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image.
        """
        return pulumi.get(self, "image_md5")

    @_builtins.property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> _builtins.str:
        """
        The url link for the floor plan image.
        """
        return pulumi.get(self, "image_url")

    @_builtins.property
    @pulumi.getter(name="imageUrlExpiresAt")
    def image_url_expires_at(self) -> _builtins.str:
        """
        The time the image url link will expire.
        """
        return pulumi.get(self, "image_url_expires_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of your floor plan.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="topLeftCorner")
    def top_left_corner(self) -> 'outputs.GetFloorPlansItemTopLeftCornerResult':
        """
        The longitude and latitude of the top left corner of your floor plan.
        """
        return pulumi.get(self, "top_left_corner")

    @_builtins.property
    @pulumi.getter(name="topRightCorner")
    def top_right_corner(self) -> 'outputs.GetFloorPlansItemTopRightCornerResult':
        """
        The longitude and latitude of the top right corner of your floor plan.
        """
        return pulumi.get(self, "top_right_corner")

    @_builtins.property
    @pulumi.getter
    def width(self) -> _builtins.float:
        """
        The width of your floor plan.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class GetFloorPlansItemBottomLeftCornerResult(dict):
    def __init__(__self__, *,
                 lat: _builtins.float,
                 lng: _builtins.float):
        """
        :param _builtins.float lat: Latitude
        :param _builtins.float lng: Longitude
        """
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> _builtins.float:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> _builtins.float:
        """
        Longitude
        """
        return pulumi.get(self, "lng")


@pulumi.output_type
class GetFloorPlansItemBottomRightCornerResult(dict):
    def __init__(__self__, *,
                 lat: _builtins.float,
                 lng: _builtins.float):
        """
        :param _builtins.float lat: Latitude
        :param _builtins.float lng: Longitude
        """
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> _builtins.float:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> _builtins.float:
        """
        Longitude
        """
        return pulumi.get(self, "lng")


@pulumi.output_type
class GetFloorPlansItemCenterResult(dict):
    def __init__(__self__, *,
                 lat: _builtins.float,
                 lng: _builtins.float):
        """
        :param _builtins.float lat: Latitude
        :param _builtins.float lng: Longitude
        """
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> _builtins.float:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> _builtins.float:
        """
        Longitude
        """
        return pulumi.get(self, "lng")


@pulumi.output_type
class GetFloorPlansItemDeviceResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 details: Sequence['outputs.GetFloorPlansItemDeviceDetailResult'],
                 firmware: _builtins.str,
                 imei: _builtins.str,
                 lan_ip: _builtins.str,
                 lat: _builtins.float,
                 lng: _builtins.float,
                 mac: _builtins.str,
                 model: _builtins.str,
                 name: _builtins.str,
                 network_id: _builtins.str,
                 notes: _builtins.str,
                 product_type: _builtins.str,
                 serial: _builtins.str,
                 tags: Sequence[_builtins.str]):
        """
        :param _builtins.str address: Physical address of the device
        :param Sequence['GetFloorPlansItemDeviceDetailArgs'] details: Additional device information
        :param _builtins.str firmware: Firmware version of the device
        :param _builtins.str imei: IMEI of the device, if applicable
        :param _builtins.str lan_ip: LAN IP address of the device
        :param _builtins.float lat: Latitude of the device
        :param _builtins.float lng: Longitude of the device
        :param _builtins.str mac: MAC address of the device
        :param _builtins.str model: Model of the device
        :param _builtins.str name: Name of the device
        :param _builtins.str network_id: ID of the network the device belongs to
        :param _builtins.str notes: Notes for the device, limited to 255 characters
        :param _builtins.str product_type: Product type of the device
        :param _builtins.str serial: Serial number of the device
        :param Sequence[_builtins.str] tags: List of tags assigned to the device
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "firmware", firmware)
        pulumi.set(__self__, "imei", imei)
        pulumi.set(__self__, "lan_ip", lan_ip)
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "notes", notes)
        pulumi.set(__self__, "product_type", product_type)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Physical address of the device
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetFloorPlansItemDeviceDetailResult']:
        """
        Additional device information
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> _builtins.str:
        """
        Firmware version of the device
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter
    def imei(self) -> _builtins.str:
        """
        IMEI of the device, if applicable
        """
        return pulumi.get(self, "imei")

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> _builtins.str:
        """
        LAN IP address of the device
        """
        return pulumi.get(self, "lan_ip")

    @_builtins.property
    @pulumi.getter
    def lat(self) -> _builtins.float:
        """
        Latitude of the device
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> _builtins.float:
        """
        Longitude of the device
        """
        return pulumi.get(self, "lng")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        MAC address of the device
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Model of the device
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the device
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        ID of the network the device belongs to
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> _builtins.str:
        """
        Notes for the device, limited to 255 characters
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> _builtins.str:
        """
        Product type of the device
        """
        return pulumi.get(self, "product_type")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Serial number of the device
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        List of tags assigned to the device
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetFloorPlansItemDeviceDetailResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Additional property name
        :param _builtins.str value: Additional property value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Additional property name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Additional property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFloorPlansItemTopLeftCornerResult(dict):
    def __init__(__self__, *,
                 lat: _builtins.float,
                 lng: _builtins.float):
        """
        :param _builtins.float lat: Latitude
        :param _builtins.float lng: Longitude
        """
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> _builtins.float:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> _builtins.float:
        """
        Longitude
        """
        return pulumi.get(self, "lng")


@pulumi.output_type
class GetFloorPlansItemTopRightCornerResult(dict):
    def __init__(__self__, *,
                 lat: _builtins.float,
                 lng: _builtins.float):
        """
        :param _builtins.float lat: Latitude
        :param _builtins.float lng: Longitude
        """
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> _builtins.float:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> _builtins.float:
        """
        Longitude
        """
        return pulumi.get(self, "lng")


@pulumi.output_type
class GetGroupPoliciesItemResult(dict):
    def __init__(__self__, *,
                 bandwidth: 'outputs.GetGroupPoliciesItemBandwidthResult',
                 bonjour_forwarding: 'outputs.GetGroupPoliciesItemBonjourForwardingResult',
                 content_filtering: 'outputs.GetGroupPoliciesItemContentFilteringResult',
                 firewall_and_traffic_shaping: 'outputs.GetGroupPoliciesItemFirewallAndTrafficShapingResult',
                 group_policy_id: _builtins.str,
                 scheduling: 'outputs.GetGroupPoliciesItemSchedulingResult',
                 splash_auth_settings: _builtins.str,
                 vlan_tagging: 'outputs.GetGroupPoliciesItemVlanTaggingResult'):
        """
        :param 'GetGroupPoliciesItemBandwidthArgs' bandwidth: The bandwidth settings for clients bound to your group policy.
        :param 'GetGroupPoliciesItemBonjourForwardingArgs' bonjour_forwarding: The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
        :param 'GetGroupPoliciesItemContentFilteringArgs' content_filtering: The content filtering settings for your group policy
        :param 'GetGroupPoliciesItemFirewallAndTrafficShapingArgs' firewall_and_traffic_shaping: The firewall and traffic shaping rules and settings for your policy.
        :param _builtins.str group_policy_id: The ID of the group policy
        :param 'GetGroupPoliciesItemSchedulingArgs' scheduling: The schedule for the group policy. Schedules are applied to days of the week.
        :param _builtins.str splash_auth_settings: Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
        :param 'GetGroupPoliciesItemVlanTaggingArgs' vlan_tagging: The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "bonjour_forwarding", bonjour_forwarding)
        pulumi.set(__self__, "content_filtering", content_filtering)
        pulumi.set(__self__, "firewall_and_traffic_shaping", firewall_and_traffic_shaping)
        pulumi.set(__self__, "group_policy_id", group_policy_id)
        pulumi.set(__self__, "scheduling", scheduling)
        pulumi.set(__self__, "splash_auth_settings", splash_auth_settings)
        pulumi.set(__self__, "vlan_tagging", vlan_tagging)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> 'outputs.GetGroupPoliciesItemBandwidthResult':
        """
        The bandwidth settings for clients bound to your group policy.
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter(name="bonjourForwarding")
    def bonjour_forwarding(self) -> 'outputs.GetGroupPoliciesItemBonjourForwardingResult':
        """
        The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
        """
        return pulumi.get(self, "bonjour_forwarding")

    @_builtins.property
    @pulumi.getter(name="contentFiltering")
    def content_filtering(self) -> 'outputs.GetGroupPoliciesItemContentFilteringResult':
        """
        The content filtering settings for your group policy
        """
        return pulumi.get(self, "content_filtering")

    @_builtins.property
    @pulumi.getter(name="firewallAndTrafficShaping")
    def firewall_and_traffic_shaping(self) -> 'outputs.GetGroupPoliciesItemFirewallAndTrafficShapingResult':
        """
        The firewall and traffic shaping rules and settings for your policy.
        """
        return pulumi.get(self, "firewall_and_traffic_shaping")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> _builtins.str:
        """
        The ID of the group policy
        """
        return pulumi.get(self, "group_policy_id")

    @_builtins.property
    @pulumi.getter
    def scheduling(self) -> 'outputs.GetGroupPoliciesItemSchedulingResult':
        """
        The schedule for the group policy. Schedules are applied to days of the week.
        """
        return pulumi.get(self, "scheduling")

    @_builtins.property
    @pulumi.getter(name="splashAuthSettings")
    def splash_auth_settings(self) -> _builtins.str:
        """
        Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
        """
        return pulumi.get(self, "splash_auth_settings")

    @_builtins.property
    @pulumi.getter(name="vlanTagging")
    def vlan_tagging(self) -> 'outputs.GetGroupPoliciesItemVlanTaggingResult':
        """
        The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
        """
        return pulumi.get(self, "vlan_tagging")


@pulumi.output_type
class GetGroupPoliciesItemBandwidthResult(dict):
    def __init__(__self__, *,
                 bandwidth_limits: 'outputs.GetGroupPoliciesItemBandwidthBandwidthLimitsResult',
                 settings: _builtins.str):
        """
        :param 'GetGroupPoliciesItemBandwidthBandwidthLimitsArgs' bandwidth_limits: The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
        :param _builtins.str settings: How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
        """
        pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> 'outputs.GetGroupPoliciesItemBandwidthBandwidthLimitsResult':
        """
        The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> _builtins.str:
        """
        How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetGroupPoliciesItemBandwidthBandwidthLimitsResult(dict):
    def __init__(__self__, *,
                 limit_down: _builtins.int,
                 limit_up: _builtins.int):
        """
        :param _builtins.int limit_down: The maximum download limit (integer, in Kbps). null indicates no limit
        :param _builtins.int limit_up: The maximum upload limit (integer, in Kbps). null indicates no limit
        """
        pulumi.set(__self__, "limit_down", limit_down)
        pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> _builtins.int:
        """
        The maximum download limit (integer, in Kbps). null indicates no limit
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> _builtins.int:
        """
        The maximum upload limit (integer, in Kbps). null indicates no limit
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class GetGroupPoliciesItemBonjourForwardingResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetGroupPoliciesItemBonjourForwardingRuleResult'],
                 settings: _builtins.str):
        """
        :param Sequence['GetGroupPoliciesItemBonjourForwardingRuleArgs'] rules: A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
        :param _builtins.str settings: How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
        """
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetGroupPoliciesItemBonjourForwardingRuleResult']:
        """
        A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
        """
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> _builtins.str:
        """
        How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetGroupPoliciesItemBonjourForwardingRuleResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 services: Sequence[_builtins.str],
                 vlan_id: _builtins.str):
        """
        :param _builtins.str description: A description for your Bonjour forwarding rule. Optional.
        :param Sequence[_builtins.str] services: A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        :param _builtins.str vlan_id: The ID of the service VLAN. Required.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A description for your Bonjour forwarding rule. Optional.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Sequence[_builtins.str]:
        """
        A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        """
        The ID of the service VLAN. Required.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetGroupPoliciesItemContentFilteringResult(dict):
    def __init__(__self__, *,
                 allowed_url_patterns: 'outputs.GetGroupPoliciesItemContentFilteringAllowedUrlPatternsResult',
                 blocked_url_categories: 'outputs.GetGroupPoliciesItemContentFilteringBlockedUrlCategoriesResult',
                 blocked_url_patterns: 'outputs.GetGroupPoliciesItemContentFilteringBlockedUrlPatternsResult'):
        """
        :param 'GetGroupPoliciesItemContentFilteringAllowedUrlPatternsArgs' allowed_url_patterns: Settings for allowed URL patterns
        :param 'GetGroupPoliciesItemContentFilteringBlockedUrlCategoriesArgs' blocked_url_categories: Settings for blocked URL categories
        :param 'GetGroupPoliciesItemContentFilteringBlockedUrlPatternsArgs' blocked_url_patterns: Settings for blocked URL patterns
        """
        pulumi.set(__self__, "allowed_url_patterns", allowed_url_patterns)
        pulumi.set(__self__, "blocked_url_categories", blocked_url_categories)
        pulumi.set(__self__, "blocked_url_patterns", blocked_url_patterns)

    @_builtins.property
    @pulumi.getter(name="allowedUrlPatterns")
    def allowed_url_patterns(self) -> 'outputs.GetGroupPoliciesItemContentFilteringAllowedUrlPatternsResult':
        """
        Settings for allowed URL patterns
        """
        return pulumi.get(self, "allowed_url_patterns")

    @_builtins.property
    @pulumi.getter(name="blockedUrlCategories")
    def blocked_url_categories(self) -> 'outputs.GetGroupPoliciesItemContentFilteringBlockedUrlCategoriesResult':
        """
        Settings for blocked URL categories
        """
        return pulumi.get(self, "blocked_url_categories")

    @_builtins.property
    @pulumi.getter(name="blockedUrlPatterns")
    def blocked_url_patterns(self) -> 'outputs.GetGroupPoliciesItemContentFilteringBlockedUrlPatternsResult':
        """
        Settings for blocked URL patterns
        """
        return pulumi.get(self, "blocked_url_patterns")


@pulumi.output_type
class GetGroupPoliciesItemContentFilteringAllowedUrlPatternsResult(dict):
    def __init__(__self__, *,
                 patterns: Sequence[_builtins.str],
                 settings: _builtins.str):
        """
        :param Sequence[_builtins.str] patterns: A list of URL patterns that are allowed
        :param _builtins.str settings: How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
        pulumi.set(__self__, "patterns", patterns)
        pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def patterns(self) -> Sequence[_builtins.str]:
        """
        A list of URL patterns that are allowed
        """
        return pulumi.get(self, "patterns")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> _builtins.str:
        """
        How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetGroupPoliciesItemContentFilteringBlockedUrlCategoriesResult(dict):
    def __init__(__self__, *,
                 categories: Sequence[_builtins.str],
                 settings: _builtins.str):
        """
        :param Sequence[_builtins.str] categories: A list of URL categories to block
        :param _builtins.str settings: How URL categories are applied. Can be 'network default', 'append' or 'override'.
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def categories(self) -> Sequence[_builtins.str]:
        """
        A list of URL categories to block
        """
        return pulumi.get(self, "categories")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> _builtins.str:
        """
        How URL categories are applied. Can be 'network default', 'append' or 'override'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetGroupPoliciesItemContentFilteringBlockedUrlPatternsResult(dict):
    def __init__(__self__, *,
                 patterns: Sequence[_builtins.str],
                 settings: _builtins.str):
        """
        :param Sequence[_builtins.str] patterns: A list of URL patterns that are blocked
        :param _builtins.str settings: How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
        pulumi.set(__self__, "patterns", patterns)
        pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def patterns(self) -> Sequence[_builtins.str]:
        """
        A list of URL patterns that are blocked
        """
        return pulumi.get(self, "patterns")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> _builtins.str:
        """
        How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetGroupPoliciesItemFirewallAndTrafficShapingResult(dict):
    def __init__(__self__, *,
                 l3_firewall_rules: Sequence['outputs.GetGroupPoliciesItemFirewallAndTrafficShapingL3FirewallRuleResult'],
                 l7_firewall_rules: Sequence['outputs.GetGroupPoliciesItemFirewallAndTrafficShapingL7FirewallRuleResult'],
                 settings: _builtins.str,
                 traffic_shaping_rules: Sequence['outputs.GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRuleResult']):
        """
        :param Sequence['GetGroupPoliciesItemFirewallAndTrafficShapingL3FirewallRuleArgs'] l3_firewall_rules: An ordered array of the L3 firewall rules
        :param Sequence['GetGroupPoliciesItemFirewallAndTrafficShapingL7FirewallRuleArgs'] l7_firewall_rules: An ordered array of L7 firewall rules
        :param _builtins.str settings: How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
        :param Sequence['GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRuleArgs'] traffic_shaping_rules: An array of traffic shaping rules. Rules are applied in the order that
               they are specified in. An empty list (or null) means no rules. Note that
               you are allowed a maximum of 8 rules.
        """
        pulumi.set(__self__, "l3_firewall_rules", l3_firewall_rules)
        pulumi.set(__self__, "l7_firewall_rules", l7_firewall_rules)
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "traffic_shaping_rules", traffic_shaping_rules)

    @_builtins.property
    @pulumi.getter(name="l3FirewallRules")
    def l3_firewall_rules(self) -> Sequence['outputs.GetGroupPoliciesItemFirewallAndTrafficShapingL3FirewallRuleResult']:
        """
        An ordered array of the L3 firewall rules
        """
        return pulumi.get(self, "l3_firewall_rules")

    @_builtins.property
    @pulumi.getter(name="l7FirewallRules")
    def l7_firewall_rules(self) -> Sequence['outputs.GetGroupPoliciesItemFirewallAndTrafficShapingL7FirewallRuleResult']:
        """
        An ordered array of L7 firewall rules
        """
        return pulumi.get(self, "l7_firewall_rules")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> _builtins.str:
        """
        How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter(name="trafficShapingRules")
    def traffic_shaping_rules(self) -> Sequence['outputs.GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRuleResult']:
        """
        An array of traffic shaping rules. Rules are applied in the order that
        they are specified in. An empty list (or null) means no rules. Note that
        you are allowed a maximum of 8 rules.
        """
        return pulumi.get(self, "traffic_shaping_rules")


@pulumi.output_type
class GetGroupPoliciesItemFirewallAndTrafficShapingL3FirewallRuleResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 dest_cidr: _builtins.str,
                 dest_port: _builtins.str,
                 policy: _builtins.str,
                 protocol: _builtins.str):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dest_cidr: Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
        :param _builtins.str dest_port: Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "dest_cidr", dest_cidr)
        pulumi.set(__self__, "dest_port", dest_port)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> _builtins.str:
        """
        Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
        """
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> _builtins.str:
        """
        Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetGroupPoliciesItemFirewallAndTrafficShapingL7FirewallRuleResult(dict):
    def __init__(__self__, *,
                 policy: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str policy: The policy applied to matching traffic. Must be 'deny'.
        :param _builtins.str type: Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
        :param _builtins.str value: The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        The policy applied to matching traffic. Must be 'deny'.
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRuleResult(dict):
    def __init__(__self__, *,
                 definitions: Sequence['outputs.GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRuleDefinitionResult'],
                 dscp_tag_value: _builtins.int,
                 pcp_tag_value: _builtins.int,
                 per_client_bandwidth_limits: 'outputs.GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsResult',
                 priority: _builtins.str):
        """
        :param Sequence['GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRuleDefinitionArgs'] definitions: A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        :param _builtins.int dscp_tag_value: The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
               For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        :param _builtins.int pcp_tag_value: The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
               null means 'Do not set PCP tag'.
        :param 'GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsArgs' per_client_bandwidth_limits: An object describing the bandwidth settings for your rule.
        :param _builtins.str priority: A string, indicating the priority level for packets bound to your rule.
               Can be 'low', 'normal' or 'high'.
        """
        pulumi.set(__self__, "definitions", definitions)
        pulumi.set(__self__, "dscp_tag_value", dscp_tag_value)
        pulumi.set(__self__, "pcp_tag_value", pcp_tag_value)
        pulumi.set(__self__, "per_client_bandwidth_limits", per_client_bandwidth_limits)
        pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> Sequence['outputs.GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRuleDefinitionResult']:
        """
        A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        """
        return pulumi.get(self, "definitions")

    @_builtins.property
    @pulumi.getter(name="dscpTagValue")
    def dscp_tag_value(self) -> _builtins.int:
        """
        The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        """
        return pulumi.get(self, "dscp_tag_value")

    @_builtins.property
    @pulumi.getter(name="pcpTagValue")
    def pcp_tag_value(self) -> _builtins.int:
        """
        The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
        null means 'Do not set PCP tag'.
        """
        return pulumi.get(self, "pcp_tag_value")

    @_builtins.property
    @pulumi.getter(name="perClientBandwidthLimits")
    def per_client_bandwidth_limits(self) -> 'outputs.GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsResult':
        """
        An object describing the bandwidth settings for your rule.
        """
        return pulumi.get(self, "per_client_bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.str:
        """
        A string, indicating the priority level for packets bound to your rule.
        Can be 'low', 'normal' or 'high'.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRuleDefinitionResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str type: The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        :param _builtins.str value: If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
                   a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
                   "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
                   custom ports.
                    If "type" is 'application' or 'applicationCategory', then "value" must be an object
                   with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
                   application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
                   endpoint).
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
            a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
            "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
            custom ports.
             If "type" is 'application' or 'applicationCategory', then "value" must be an object
            with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
            application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
            endpoint).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsResult(dict):
    def __init__(__self__, *,
                 bandwidth_limits: 'outputs.GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsResult',
                 settings: _builtins.str):
        """
        :param 'GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsArgs' bandwidth_limits: The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        :param _builtins.str settings: How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> 'outputs.GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsResult':
        """
        The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> _builtins.str:
        """
        How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsResult(dict):
    def __init__(__self__, *,
                 limit_down: _builtins.int,
                 limit_up: _builtins.int):
        """
        :param _builtins.int limit_down: The maximum download limit (integer, in Kbps).
        :param _builtins.int limit_up: The maximum upload limit (integer, in Kbps).
        """
        pulumi.set(__self__, "limit_down", limit_down)
        pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> _builtins.int:
        """
        The maximum download limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> _builtins.int:
        """
        The maximum upload limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class GetGroupPoliciesItemSchedulingResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 friday: 'outputs.GetGroupPoliciesItemSchedulingFridayResult',
                 monday: 'outputs.GetGroupPoliciesItemSchedulingMondayResult',
                 saturday: 'outputs.GetGroupPoliciesItemSchedulingSaturdayResult',
                 sunday: 'outputs.GetGroupPoliciesItemSchedulingSundayResult',
                 thursday: 'outputs.GetGroupPoliciesItemSchedulingThursdayResult',
                 tuesday: 'outputs.GetGroupPoliciesItemSchedulingTuesdayResult',
                 wednesday: 'outputs.GetGroupPoliciesItemSchedulingWednesdayResult'):
        """
        :param _builtins.bool enabled: Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
        :param 'GetGroupPoliciesItemSchedulingFridayArgs' friday: The schedule object for Friday.
        :param 'GetGroupPoliciesItemSchedulingMondayArgs' monday: The schedule object for Monday.
        :param 'GetGroupPoliciesItemSchedulingSaturdayArgs' saturday: The schedule object for Saturday.
        :param 'GetGroupPoliciesItemSchedulingSundayArgs' sunday: The schedule object for Sunday.
        :param 'GetGroupPoliciesItemSchedulingThursdayArgs' thursday: The schedule object for Thursday.
        :param 'GetGroupPoliciesItemSchedulingTuesdayArgs' tuesday: The schedule object for Tuesday.
        :param 'GetGroupPoliciesItemSchedulingWednesdayArgs' wednesday: The schedule object for Wednesday.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "friday", friday)
        pulumi.set(__self__, "monday", monday)
        pulumi.set(__self__, "saturday", saturday)
        pulumi.set(__self__, "sunday", sunday)
        pulumi.set(__self__, "thursday", thursday)
        pulumi.set(__self__, "tuesday", tuesday)
        pulumi.set(__self__, "wednesday", wednesday)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def friday(self) -> 'outputs.GetGroupPoliciesItemSchedulingFridayResult':
        """
        The schedule object for Friday.
        """
        return pulumi.get(self, "friday")

    @_builtins.property
    @pulumi.getter
    def monday(self) -> 'outputs.GetGroupPoliciesItemSchedulingMondayResult':
        """
        The schedule object for Monday.
        """
        return pulumi.get(self, "monday")

    @_builtins.property
    @pulumi.getter
    def saturday(self) -> 'outputs.GetGroupPoliciesItemSchedulingSaturdayResult':
        """
        The schedule object for Saturday.
        """
        return pulumi.get(self, "saturday")

    @_builtins.property
    @pulumi.getter
    def sunday(self) -> 'outputs.GetGroupPoliciesItemSchedulingSundayResult':
        """
        The schedule object for Sunday.
        """
        return pulumi.get(self, "sunday")

    @_builtins.property
    @pulumi.getter
    def thursday(self) -> 'outputs.GetGroupPoliciesItemSchedulingThursdayResult':
        """
        The schedule object for Thursday.
        """
        return pulumi.get(self, "thursday")

    @_builtins.property
    @pulumi.getter
    def tuesday(self) -> 'outputs.GetGroupPoliciesItemSchedulingTuesdayResult':
        """
        The schedule object for Tuesday.
        """
        return pulumi.get(self, "tuesday")

    @_builtins.property
    @pulumi.getter
    def wednesday(self) -> 'outputs.GetGroupPoliciesItemSchedulingWednesdayResult':
        """
        The schedule object for Wednesday.
        """
        return pulumi.get(self, "wednesday")


@pulumi.output_type
class GetGroupPoliciesItemSchedulingFridayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetGroupPoliciesItemSchedulingMondayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetGroupPoliciesItemSchedulingSaturdayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetGroupPoliciesItemSchedulingSundayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetGroupPoliciesItemSchedulingThursdayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetGroupPoliciesItemSchedulingTuesdayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetGroupPoliciesItemSchedulingWednesdayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param _builtins.str from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param _builtins.str to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetGroupPoliciesItemVlanTaggingResult(dict):
    def __init__(__self__, *,
                 settings: _builtins.str,
                 vlan_id: _builtins.str):
        """
        :param _builtins.str settings: How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
        :param _builtins.str vlan_id: The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
        """
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> _builtins.str:
        """
        How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        """
        The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetHealthAlertsItemResult(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 id: _builtins.str,
                 scope: 'outputs.GetHealthAlertsItemScopeResult',
                 severity: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str category: Category of the alert
        :param _builtins.str id: Alert identifier. Value can be empty
        :param 'GetHealthAlertsItemScopeArgs' scope: The scope of the alert
        :param _builtins.str severity: Severity of the alert
        :param _builtins.str type: Alert type
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "severity", severity)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        Category of the alert
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Alert identifier. Value can be empty
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> 'outputs.GetHealthAlertsItemScopeResult':
        """
        The scope of the alert
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> _builtins.str:
        """
        Severity of the alert
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Alert type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetHealthAlertsItemScopeResult(dict):
    def __init__(__self__, *,
                 applications: Sequence['outputs.GetHealthAlertsItemScopeApplicationResult'],
                 devices: Sequence['outputs.GetHealthAlertsItemScopeDeviceResult'],
                 peers: Sequence['outputs.GetHealthAlertsItemScopePeerResult']):
        """
        :param Sequence['GetHealthAlertsItemScopeApplicationArgs'] applications: Applications related to the alert
        :param Sequence['GetHealthAlertsItemScopeDeviceArgs'] devices: Devices related to the alert
        :param Sequence['GetHealthAlertsItemScopePeerArgs'] peers: Peers related to the alert
        """
        pulumi.set(__self__, "applications", applications)
        pulumi.set(__self__, "devices", devices)
        pulumi.set(__self__, "peers", peers)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> Sequence['outputs.GetHealthAlertsItemScopeApplicationResult']:
        """
        Applications related to the alert
        """
        return pulumi.get(self, "applications")

    @_builtins.property
    @pulumi.getter
    def devices(self) -> Sequence['outputs.GetHealthAlertsItemScopeDeviceResult']:
        """
        Devices related to the alert
        """
        return pulumi.get(self, "devices")

    @_builtins.property
    @pulumi.getter
    def peers(self) -> Sequence['outputs.GetHealthAlertsItemScopePeerResult']:
        """
        Peers related to the alert
        """
        return pulumi.get(self, "peers")


@pulumi.output_type
class GetHealthAlertsItemScopeApplicationResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str name: Name of the application
        :param _builtins.str url: URL to the application
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the application
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL to the application
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetHealthAlertsItemScopeDeviceResult(dict):
    def __init__(__self__, *,
                 clients: Sequence['outputs.GetHealthAlertsItemScopeDeviceClientResult'],
                 lldp: 'outputs.GetHealthAlertsItemScopeDeviceLldpResult',
                 mac: _builtins.str,
                 name: _builtins.str,
                 product_type: _builtins.str,
                 serial: _builtins.str,
                 url: _builtins.str):
        """
        :param Sequence['GetHealthAlertsItemScopeDeviceClientArgs'] clients: Clients related to the device
        :param 'GetHealthAlertsItemScopeDeviceLldpArgs' lldp: Lldp information
        :param _builtins.str mac: The mac address of the device
        :param _builtins.str name: Name of the device
        :param _builtins.str product_type: Product type of the device
        :param _builtins.str serial: Serial number of the device
        :param _builtins.str url: URL to the device
        """
        pulumi.set(__self__, "clients", clients)
        pulumi.set(__self__, "lldp", lldp)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product_type", product_type)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Sequence['outputs.GetHealthAlertsItemScopeDeviceClientResult']:
        """
        Clients related to the device
        """
        return pulumi.get(self, "clients")

    @_builtins.property
    @pulumi.getter
    def lldp(self) -> 'outputs.GetHealthAlertsItemScopeDeviceLldpResult':
        """
        Lldp information
        """
        return pulumi.get(self, "lldp")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        The mac address of the device
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the device
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> _builtins.str:
        """
        Product type of the device
        """
        return pulumi.get(self, "product_type")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Serial number of the device
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL to the device
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetHealthAlertsItemScopeDeviceClientResult(dict):
    def __init__(__self__, *,
                 mac: _builtins.str):
        """
        :param _builtins.str mac: Mac address of the client
        """
        pulumi.set(__self__, "mac", mac)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Mac address of the client
        """
        return pulumi.get(self, "mac")


@pulumi.output_type
class GetHealthAlertsItemScopeDeviceLldpResult(dict):
    def __init__(__self__, *,
                 port_id: _builtins.str):
        """
        :param _builtins.str port_id: Port Id
        """
        pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        """
        Port Id
        """
        return pulumi.get(self, "port_id")


@pulumi.output_type
class GetHealthAlertsItemScopePeerResult(dict):
    def __init__(__self__, *,
                 network: 'outputs.GetHealthAlertsItemScopePeerNetworkResult',
                 url: _builtins.str):
        """
        :param 'GetHealthAlertsItemScopePeerNetworkArgs' network: Network of the peer
        :param _builtins.str url: URL to the peer
        """
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def network(self) -> 'outputs.GetHealthAlertsItemScopePeerNetworkResult':
        """
        Network of the peer
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL to the peer
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetHealthAlertsItemScopePeerNetworkResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: Id of the network
        :param _builtins.str name: Name of the network
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the network
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the network
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInsightApplicationsHealthByTimeItemResult(dict):
    def __init__(__self__, *,
                 end_ts: _builtins.str,
                 lan_goodput: _builtins.int,
                 lan_latency_ms: _builtins.float,
                 lan_loss_percent: _builtins.float,
                 num_clients: _builtins.int,
                 recv: _builtins.int,
                 response_duration: _builtins.int,
                 sent: _builtins.int,
                 start_ts: _builtins.str,
                 wan_goodput: _builtins.int,
                 wan_latency_ms: _builtins.float,
                 wan_loss_percent: _builtins.float):
        """
        :param _builtins.str end_ts: The end time of the query range
        :param _builtins.int lan_goodput: LAN goodput (Number of useful information bits delivered over a LAN per unit of time)
        :param _builtins.float lan_latency_ms: LAN latency in milliseconds
        :param _builtins.float lan_loss_percent: LAN loss percentage
        :param _builtins.int num_clients: Number of clients
        :param _builtins.int recv: Received kilobytes-per-second
        :param _builtins.int response_duration: Duration of the response, in milliseconds
        :param _builtins.int sent: Sent kilobytes-per-second
        :param _builtins.str start_ts: The start time of the query range
        :param _builtins.int wan_goodput: WAN goodput (Number of useful information bits delivered over a WAN per unit of time)
        :param _builtins.float wan_latency_ms: WAN latency in milliseconds
        :param _builtins.float wan_loss_percent: WAN loss percentage
        """
        pulumi.set(__self__, "end_ts", end_ts)
        pulumi.set(__self__, "lan_goodput", lan_goodput)
        pulumi.set(__self__, "lan_latency_ms", lan_latency_ms)
        pulumi.set(__self__, "lan_loss_percent", lan_loss_percent)
        pulumi.set(__self__, "num_clients", num_clients)
        pulumi.set(__self__, "recv", recv)
        pulumi.set(__self__, "response_duration", response_duration)
        pulumi.set(__self__, "sent", sent)
        pulumi.set(__self__, "start_ts", start_ts)
        pulumi.set(__self__, "wan_goodput", wan_goodput)
        pulumi.set(__self__, "wan_latency_ms", wan_latency_ms)
        pulumi.set(__self__, "wan_loss_percent", wan_loss_percent)

    @_builtins.property
    @pulumi.getter(name="endTs")
    def end_ts(self) -> _builtins.str:
        """
        The end time of the query range
        """
        return pulumi.get(self, "end_ts")

    @_builtins.property
    @pulumi.getter(name="lanGoodput")
    def lan_goodput(self) -> _builtins.int:
        """
        LAN goodput (Number of useful information bits delivered over a LAN per unit of time)
        """
        return pulumi.get(self, "lan_goodput")

    @_builtins.property
    @pulumi.getter(name="lanLatencyMs")
    def lan_latency_ms(self) -> _builtins.float:
        """
        LAN latency in milliseconds
        """
        return pulumi.get(self, "lan_latency_ms")

    @_builtins.property
    @pulumi.getter(name="lanLossPercent")
    def lan_loss_percent(self) -> _builtins.float:
        """
        LAN loss percentage
        """
        return pulumi.get(self, "lan_loss_percent")

    @_builtins.property
    @pulumi.getter(name="numClients")
    def num_clients(self) -> _builtins.int:
        """
        Number of clients
        """
        return pulumi.get(self, "num_clients")

    @_builtins.property
    @pulumi.getter
    def recv(self) -> _builtins.int:
        """
        Received kilobytes-per-second
        """
        return pulumi.get(self, "recv")

    @_builtins.property
    @pulumi.getter(name="responseDuration")
    def response_duration(self) -> _builtins.int:
        """
        Duration of the response, in milliseconds
        """
        return pulumi.get(self, "response_duration")

    @_builtins.property
    @pulumi.getter
    def sent(self) -> _builtins.int:
        """
        Sent kilobytes-per-second
        """
        return pulumi.get(self, "sent")

    @_builtins.property
    @pulumi.getter(name="startTs")
    def start_ts(self) -> _builtins.str:
        """
        The start time of the query range
        """
        return pulumi.get(self, "start_ts")

    @_builtins.property
    @pulumi.getter(name="wanGoodput")
    def wan_goodput(self) -> _builtins.int:
        """
        WAN goodput (Number of useful information bits delivered over a WAN per unit of time)
        """
        return pulumi.get(self, "wan_goodput")

    @_builtins.property
    @pulumi.getter(name="wanLatencyMs")
    def wan_latency_ms(self) -> _builtins.float:
        """
        WAN latency in milliseconds
        """
        return pulumi.get(self, "wan_latency_ms")

    @_builtins.property
    @pulumi.getter(name="wanLossPercent")
    def wan_loss_percent(self) -> _builtins.float:
        """
        WAN loss percentage
        """
        return pulumi.get(self, "wan_loss_percent")


@pulumi.output_type
class GetMerakiAuthUsersItemResult(dict):
    def __init__(__self__, *,
                 account_type: _builtins.str,
                 authorizations: Sequence['outputs.GetMerakiAuthUsersItemAuthorizationResult'],
                 created_at: _builtins.str,
                 email: _builtins.str,
                 id: _builtins.str,
                 is_admin: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.str account_type: Authorization type for user.
        :param Sequence['GetMerakiAuthUsersItemAuthorizationArgs'] authorizations: User authorization info
        :param _builtins.str created_at: Creation time of the user
        :param _builtins.str email: Email address of the user
        :param _builtins.str id: Meraki auth user id
        :param _builtins.bool is_admin: Whether or not the user is a Dashboard administrator
        :param _builtins.str name: Name of the user
        """
        pulumi.set(__self__, "account_type", account_type)
        pulumi.set(__self__, "authorizations", authorizations)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_admin", is_admin)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="accountType")
    def account_type(self) -> _builtins.str:
        """
        Authorization type for user.
        """
        return pulumi.get(self, "account_type")

    @_builtins.property
    @pulumi.getter
    def authorizations(self) -> Sequence['outputs.GetMerakiAuthUsersItemAuthorizationResult']:
        """
        User authorization info
        """
        return pulumi.get(self, "authorizations")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Creation time of the user
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        Email address of the user
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Meraki auth user id
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isAdmin")
    def is_admin(self) -> _builtins.bool:
        """
        Whether or not the user is a Dashboard administrator
        """
        return pulumi.get(self, "is_admin")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the user
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMerakiAuthUsersItemAuthorizationResult(dict):
    def __init__(__self__, *,
                 authorized_by_email: _builtins.str,
                 authorized_by_name: _builtins.str,
                 authorized_zone: _builtins.str,
                 expires_at: _builtins.str,
                 ssid_number: _builtins.int):
        """
        :param _builtins.str authorized_by_email: User is authorized by the account email address
        :param _builtins.str authorized_by_name: User is authorized by the account name
        :param _builtins.str authorized_zone: Authorized zone of the user
        :param _builtins.str expires_at: Authorization expiration time
        :param _builtins.int ssid_number: SSID number
        """
        pulumi.set(__self__, "authorized_by_email", authorized_by_email)
        pulumi.set(__self__, "authorized_by_name", authorized_by_name)
        pulumi.set(__self__, "authorized_zone", authorized_zone)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "ssid_number", ssid_number)

    @_builtins.property
    @pulumi.getter(name="authorizedByEmail")
    def authorized_by_email(self) -> _builtins.str:
        """
        User is authorized by the account email address
        """
        return pulumi.get(self, "authorized_by_email")

    @_builtins.property
    @pulumi.getter(name="authorizedByName")
    def authorized_by_name(self) -> _builtins.str:
        """
        User is authorized by the account name
        """
        return pulumi.get(self, "authorized_by_name")

    @_builtins.property
    @pulumi.getter(name="authorizedZone")
    def authorized_zone(self) -> _builtins.str:
        """
        Authorized zone of the user
        """
        return pulumi.get(self, "authorized_zone")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        Authorization expiration time
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="ssidNumber")
    def ssid_number(self) -> _builtins.int:
        """
        SSID number
        """
        return pulumi.get(self, "ssid_number")


@pulumi.output_type
class GetNetflowItemResult(dict):
    def __init__(__self__, *,
                 collector_ip: _builtins.str,
                 collector_port: _builtins.int,
                 eta_dst_port: _builtins.int,
                 eta_enabled: _builtins.bool,
                 reporting_enabled: _builtins.bool):
        """
        :param _builtins.str collector_ip: The IPv4 address of the NetFlow collector.
        :param _builtins.int collector_port: The port that the NetFlow collector will be listening on.
        :param _builtins.int eta_dst_port: The port that the Encrypted Traffic Analytics collector will be listening on.
        :param _builtins.bool eta_enabled: Boolean indicating whether Encrypted Traffic Analytics is enabled (true) or disabled (false).
        :param _builtins.bool reporting_enabled: Boolean indicating whether NetFlow traffic reporting is enabled (true) or disabled (false).
        """
        pulumi.set(__self__, "collector_ip", collector_ip)
        pulumi.set(__self__, "collector_port", collector_port)
        pulumi.set(__self__, "eta_dst_port", eta_dst_port)
        pulumi.set(__self__, "eta_enabled", eta_enabled)
        pulumi.set(__self__, "reporting_enabled", reporting_enabled)

    @_builtins.property
    @pulumi.getter(name="collectorIp")
    def collector_ip(self) -> _builtins.str:
        """
        The IPv4 address of the NetFlow collector.
        """
        return pulumi.get(self, "collector_ip")

    @_builtins.property
    @pulumi.getter(name="collectorPort")
    def collector_port(self) -> _builtins.int:
        """
        The port that the NetFlow collector will be listening on.
        """
        return pulumi.get(self, "collector_port")

    @_builtins.property
    @pulumi.getter(name="etaDstPort")
    def eta_dst_port(self) -> _builtins.int:
        """
        The port that the Encrypted Traffic Analytics collector will be listening on.
        """
        return pulumi.get(self, "eta_dst_port")

    @_builtins.property
    @pulumi.getter(name="etaEnabled")
    def eta_enabled(self) -> _builtins.bool:
        """
        Boolean indicating whether Encrypted Traffic Analytics is enabled (true) or disabled (false).
        """
        return pulumi.get(self, "eta_enabled")

    @_builtins.property
    @pulumi.getter(name="reportingEnabled")
    def reporting_enabled(self) -> _builtins.bool:
        """
        Boolean indicating whether NetFlow traffic reporting is enabled (true) or disabled (false).
        """
        return pulumi.get(self, "reporting_enabled")


@pulumi.output_type
class GetPiiPiiKeysItemResult(dict):
    def __init__(__self__, *,
                 n1234: 'outputs.GetPiiPiiKeysItemN1234Result'):
        pulumi.set(__self__, "n1234", n1234)

    @_builtins.property
    @pulumi.getter
    def n1234(self) -> 'outputs.GetPiiPiiKeysItemN1234Result':
        return pulumi.get(self, "n1234")


@pulumi.output_type
class GetPiiPiiKeysItemN1234Result(dict):
    def __init__(__self__, *,
                 bluetooth_macs: Sequence[_builtins.str],
                 emails: Sequence[_builtins.str],
                 imeis: Sequence[_builtins.str],
                 macs: Sequence[_builtins.str],
                 serials: Sequence[_builtins.str],
                 usernames: Sequence[_builtins.str]):
        pulumi.set(__self__, "bluetooth_macs", bluetooth_macs)
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "imeis", imeis)
        pulumi.set(__self__, "macs", macs)
        pulumi.set(__self__, "serials", serials)
        pulumi.set(__self__, "usernames", usernames)

    @_builtins.property
    @pulumi.getter(name="bluetoothMacs")
    def bluetooth_macs(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "bluetooth_macs")

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter
    def imeis(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "imeis")

    @_builtins.property
    @pulumi.getter
    def macs(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "macs")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "serials")

    @_builtins.property
    @pulumi.getter
    def usernames(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "usernames")


@pulumi.output_type
class GetPiiRequestsItemResult(dict):
    def __init__(__self__, *,
                 completed_at: _builtins.int,
                 created_at: _builtins.int,
                 datasets: _builtins.str,
                 id: _builtins.str,
                 mac: _builtins.str,
                 network_id: _builtins.str,
                 organization_wide: _builtins.bool,
                 status: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.int completed_at: The request's completion time
        :param _builtins.int created_at: The request's creation time
        :param _builtins.str datasets: The stringified array of datasets related to the provided key that should be deleted.
        :param _builtins.str id: The network or organization identifier
        :param _builtins.str mac: The MAC address of the PII request
        :param _builtins.str network_id: The network identifier
        :param _builtins.bool organization_wide: If the data returned is organization-wide. False indicates the data is network-wide.
        :param _builtins.str status: The status of the PII request
        :param _builtins.str type: The type of PII request
        """
        pulumi.set(__self__, "completed_at", completed_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "datasets", datasets)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "organization_wide", organization_wide)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="completedAt")
    def completed_at(self) -> _builtins.int:
        """
        The request's completion time
        """
        return pulumi.get(self, "completed_at")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.int:
        """
        The request's creation time
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def datasets(self) -> _builtins.str:
        """
        The stringified array of datasets related to the provided key that should be deleted.
        """
        return pulumi.get(self, "datasets")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The network or organization identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        The MAC address of the PII request
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        The network identifier
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="organizationWide")
    def organization_wide(self) -> _builtins.bool:
        """
        If the data returned is organization-wide. False indicates the data is network-wide.
        """
        return pulumi.get(self, "organization_wide")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the PII request
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of PII request
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPiiSmDevicesForKeyItemResult(dict):
    def __init__(__self__, *,
                 n1234s: Sequence[_builtins.str]):
        pulumi.set(__self__, "n1234s", n1234s)

    @_builtins.property
    @pulumi.getter
    def n1234s(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "n1234s")


@pulumi.output_type
class GetPiiSmOwnersForKeyItemResult(dict):
    def __init__(__self__, *,
                 n1234s: Sequence[_builtins.str]):
        pulumi.set(__self__, "n1234s", n1234s)

    @_builtins.property
    @pulumi.getter
    def n1234s(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "n1234s")


@pulumi.output_type
class GetPoliciesByClientItemResult(dict):
    def __init__(__self__, *,
                 assigneds: Sequence['outputs.GetPoliciesByClientItemAssignedResult'],
                 client_id: _builtins.str,
                 name: _builtins.str):
        """
        :param Sequence['GetPoliciesByClientItemAssignedArgs'] assigneds: Assigned policies
        :param _builtins.str client_id: ID of client
        :param _builtins.str name: Name of client
        """
        pulumi.set(__self__, "assigneds", assigneds)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def assigneds(self) -> Sequence['outputs.GetPoliciesByClientItemAssignedResult']:
        """
        Assigned policies
        """
        return pulumi.get(self, "assigneds")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        ID of client
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of client
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPoliciesByClientItemAssignedResult(dict):
    def __init__(__self__, *,
                 group_policy_id: _builtins.str,
                 name: _builtins.str,
                 ssids: Sequence['outputs.GetPoliciesByClientItemAssignedSsidResult'],
                 type: _builtins.str):
        """
        :param _builtins.str group_policy_id: id of policy
        :param _builtins.str name: name of policy
        :param Sequence['GetPoliciesByClientItemAssignedSsidArgs'] ssids: ssid
        :param _builtins.str type: type of policy
        """
        pulumi.set(__self__, "group_policy_id", group_policy_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ssids", ssids)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> _builtins.str:
        """
        id of policy
        """
        return pulumi.get(self, "group_policy_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        name of policy
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def ssids(self) -> Sequence['outputs.GetPoliciesByClientItemAssignedSsidResult']:
        """
        ssid
        """
        return pulumi.get(self, "ssids")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        type of policy
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPoliciesByClientItemAssignedSsidResult(dict):
    def __init__(__self__, *,
                 ssid_number: _builtins.int):
        """
        :param _builtins.int ssid_number: number of ssid
        """
        pulumi.set(__self__, "ssid_number", ssid_number)

    @_builtins.property
    @pulumi.getter(name="ssidNumber")
    def ssid_number(self) -> _builtins.int:
        """
        number of ssid
        """
        return pulumi.get(self, "ssid_number")


@pulumi.output_type
class GetSensorAlertsCurrentOverviewByMetricItemResult(dict):
    def __init__(__self__, *,
                 counts: 'outputs.GetSensorAlertsCurrentOverviewByMetricItemCountsResult',
                 supported_metrics: Sequence[_builtins.str]):
        """
        :param 'GetSensorAlertsCurrentOverviewByMetricItemCountsArgs' counts: Counts of currently alerting sensors, aggregated by alerting metric
        :param Sequence[_builtins.str] supported_metrics: List of metrics that are supported for alerts, based on available sensor devices in the network
        """
        pulumi.set(__self__, "counts", counts)
        pulumi.set(__self__, "supported_metrics", supported_metrics)

    @_builtins.property
    @pulumi.getter
    def counts(self) -> 'outputs.GetSensorAlertsCurrentOverviewByMetricItemCountsResult':
        """
        Counts of currently alerting sensors, aggregated by alerting metric
        """
        return pulumi.get(self, "counts")

    @_builtins.property
    @pulumi.getter(name="supportedMetrics")
    def supported_metrics(self) -> Sequence[_builtins.str]:
        """
        List of metrics that are supported for alerts, based on available sensor devices in the network
        """
        return pulumi.get(self, "supported_metrics")


@pulumi.output_type
class GetSensorAlertsCurrentOverviewByMetricItemCountsResult(dict):
    def __init__(__self__, *,
                 apparent_power: _builtins.int,
                 co2: _builtins.int,
                 current: _builtins.int,
                 door: _builtins.int,
                 frequency: _builtins.int,
                 humidity: _builtins.int,
                 indoor_air_quality: _builtins.int,
                 noise: 'outputs.GetSensorAlertsCurrentOverviewByMetricItemCountsNoiseResult',
                 pm25: _builtins.int,
                 power_factor: _builtins.int,
                 real_power: _builtins.int,
                 temperature: _builtins.int,
                 tvoc: _builtins.int,
                 upstream_power: _builtins.int,
                 voltage: _builtins.int,
                 water: _builtins.int):
        """
        :param _builtins.int apparent_power: Number of sensors that are currently alerting due to apparent power readings
        :param _builtins.int co2: Number of sensors that are currently alerting due to CO2 readings
        :param _builtins.int current: Number of sensors that are currently alerting due to electrical current readings
        :param _builtins.int door: Number of sensors that are currently alerting due to an open door
        :param _builtins.int frequency: Number of sensors that are currently alerting due to frequency readings
        :param _builtins.int humidity: Number of sensors that are currently alerting due to humidity readings
        :param _builtins.int indoor_air_quality: Number of sensors that are currently alerting due to indoor air quality readings
        :param 'GetSensorAlertsCurrentOverviewByMetricItemCountsNoiseArgs' noise: Object containing the number of sensors that are currently alerting due to noise readings
        :param _builtins.int pm25: Number of sensors that are currently alerting due to PM2.5 readings
        :param _builtins.int power_factor: Number of sensors that are currently alerting due to power factor readings
        :param _builtins.int real_power: Number of sensors that are currently alerting due to real power readings
        :param _builtins.int temperature: Number of sensors that are currently alerting due to temperature readings
        :param _builtins.int tvoc: Number of sensors that are currently alerting due to TVOC readings
        :param _builtins.int upstream_power: Number of sensors that are currently alerting due to an upstream power outage
        :param _builtins.int voltage: Number of sensors that are currently alerting due to voltage readings
        :param _builtins.int water: Number of sensors that are currently alerting due to the presence of water
        """
        pulumi.set(__self__, "apparent_power", apparent_power)
        pulumi.set(__self__, "co2", co2)
        pulumi.set(__self__, "current", current)
        pulumi.set(__self__, "door", door)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "humidity", humidity)
        pulumi.set(__self__, "indoor_air_quality", indoor_air_quality)
        pulumi.set(__self__, "noise", noise)
        pulumi.set(__self__, "pm25", pm25)
        pulumi.set(__self__, "power_factor", power_factor)
        pulumi.set(__self__, "real_power", real_power)
        pulumi.set(__self__, "temperature", temperature)
        pulumi.set(__self__, "tvoc", tvoc)
        pulumi.set(__self__, "upstream_power", upstream_power)
        pulumi.set(__self__, "voltage", voltage)
        pulumi.set(__self__, "water", water)

    @_builtins.property
    @pulumi.getter(name="apparentPower")
    def apparent_power(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to apparent power readings
        """
        return pulumi.get(self, "apparent_power")

    @_builtins.property
    @pulumi.getter
    def co2(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to CO2 readings
        """
        return pulumi.get(self, "co2")

    @_builtins.property
    @pulumi.getter
    def current(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to electrical current readings
        """
        return pulumi.get(self, "current")

    @_builtins.property
    @pulumi.getter
    def door(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to an open door
        """
        return pulumi.get(self, "door")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to frequency readings
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter
    def humidity(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to humidity readings
        """
        return pulumi.get(self, "humidity")

    @_builtins.property
    @pulumi.getter(name="indoorAirQuality")
    def indoor_air_quality(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to indoor air quality readings
        """
        return pulumi.get(self, "indoor_air_quality")

    @_builtins.property
    @pulumi.getter
    def noise(self) -> 'outputs.GetSensorAlertsCurrentOverviewByMetricItemCountsNoiseResult':
        """
        Object containing the number of sensors that are currently alerting due to noise readings
        """
        return pulumi.get(self, "noise")

    @_builtins.property
    @pulumi.getter
    def pm25(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to PM2.5 readings
        """
        return pulumi.get(self, "pm25")

    @_builtins.property
    @pulumi.getter(name="powerFactor")
    def power_factor(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to power factor readings
        """
        return pulumi.get(self, "power_factor")

    @_builtins.property
    @pulumi.getter(name="realPower")
    def real_power(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to real power readings
        """
        return pulumi.get(self, "real_power")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to temperature readings
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter
    def tvoc(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to TVOC readings
        """
        return pulumi.get(self, "tvoc")

    @_builtins.property
    @pulumi.getter(name="upstreamPower")
    def upstream_power(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to an upstream power outage
        """
        return pulumi.get(self, "upstream_power")

    @_builtins.property
    @pulumi.getter
    def voltage(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to voltage readings
        """
        return pulumi.get(self, "voltage")

    @_builtins.property
    @pulumi.getter
    def water(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to the presence of water
        """
        return pulumi.get(self, "water")


@pulumi.output_type
class GetSensorAlertsCurrentOverviewByMetricItemCountsNoiseResult(dict):
    def __init__(__self__, *,
                 ambient: _builtins.int):
        """
        :param _builtins.int ambient: Number of sensors that are currently alerting due to ambient noise readings
        """
        pulumi.set(__self__, "ambient", ambient)

    @_builtins.property
    @pulumi.getter
    def ambient(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to ambient noise readings
        """
        return pulumi.get(self, "ambient")


@pulumi.output_type
class GetSensorAlertsOverviewByMetricItemResult(dict):
    def __init__(__self__, *,
                 counts: 'outputs.GetSensorAlertsOverviewByMetricItemCountsResult',
                 end_ts: _builtins.str,
                 start_ts: _builtins.str):
        """
        :param 'GetSensorAlertsOverviewByMetricItemCountsArgs' counts: Counts of sensor alerts over the timespan, by reading metric
        :param _builtins.str end_ts: End of the timespan over which sensor alerts are counted
        :param _builtins.str start_ts: Start of the timespan over which sensor alerts are counted
        """
        pulumi.set(__self__, "counts", counts)
        pulumi.set(__self__, "end_ts", end_ts)
        pulumi.set(__self__, "start_ts", start_ts)

    @_builtins.property
    @pulumi.getter
    def counts(self) -> 'outputs.GetSensorAlertsOverviewByMetricItemCountsResult':
        """
        Counts of sensor alerts over the timespan, by reading metric
        """
        return pulumi.get(self, "counts")

    @_builtins.property
    @pulumi.getter(name="endTs")
    def end_ts(self) -> _builtins.str:
        """
        End of the timespan over which sensor alerts are counted
        """
        return pulumi.get(self, "end_ts")

    @_builtins.property
    @pulumi.getter(name="startTs")
    def start_ts(self) -> _builtins.str:
        """
        Start of the timespan over which sensor alerts are counted
        """
        return pulumi.get(self, "start_ts")


@pulumi.output_type
class GetSensorAlertsOverviewByMetricItemCountsResult(dict):
    def __init__(__self__, *,
                 apparent_power: _builtins.int,
                 co2: _builtins.int,
                 current: _builtins.int,
                 door: _builtins.int,
                 frequency: _builtins.int,
                 humidity: _builtins.int,
                 indoor_air_quality: _builtins.int,
                 noise: 'outputs.GetSensorAlertsOverviewByMetricItemCountsNoiseResult',
                 pm25: _builtins.int,
                 power_factor: _builtins.int,
                 real_power: _builtins.int,
                 temperature: _builtins.int,
                 tvoc: _builtins.int,
                 upstream_power: _builtins.int,
                 voltage: _builtins.int,
                 water: _builtins.int):
        """
        :param _builtins.int apparent_power: Number of sensor alerts that occurred due to apparent power readings
        :param _builtins.int co2: Number of sensors that are currently alerting due to CO2 readings
        :param _builtins.int current: Number of sensor alerts that occurred due to electrical current readings
        :param _builtins.int door: Number of sensor alerts that occurred due to an open door
        :param _builtins.int frequency: Number of sensor alerts that occurred due to frequency readings
        :param _builtins.int humidity: Number of sensor alerts that occurred due to humidity readings
        :param _builtins.int indoor_air_quality: Number of sensor alerts that occurred due to indoor air quality readings
        :param 'GetSensorAlertsOverviewByMetricItemCountsNoiseArgs' noise: Object containing the number of sensor alerts that occurred due to noise readings
        :param _builtins.int pm25: Number of sensor alerts that occurred due to PM2.5 readings
        :param _builtins.int power_factor: Number of sensor alerts that occurred due to power factor readings
        :param _builtins.int real_power: Number of sensor alerts that occurred due to real power readings
        :param _builtins.int temperature: Number of sensor alerts that occurred due to temperature readings
        :param _builtins.int tvoc: Number of sensor alerts that occurred due to TVOC readings
        :param _builtins.int upstream_power: Number of sensor alerts that occurred due to upstream power outages
        :param _builtins.int voltage: Number of sensor alerts that occurred due to voltage readings
        :param _builtins.int water: Number of sensor alerts that occurred due to the presence of water
        """
        pulumi.set(__self__, "apparent_power", apparent_power)
        pulumi.set(__self__, "co2", co2)
        pulumi.set(__self__, "current", current)
        pulumi.set(__self__, "door", door)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "humidity", humidity)
        pulumi.set(__self__, "indoor_air_quality", indoor_air_quality)
        pulumi.set(__self__, "noise", noise)
        pulumi.set(__self__, "pm25", pm25)
        pulumi.set(__self__, "power_factor", power_factor)
        pulumi.set(__self__, "real_power", real_power)
        pulumi.set(__self__, "temperature", temperature)
        pulumi.set(__self__, "tvoc", tvoc)
        pulumi.set(__self__, "upstream_power", upstream_power)
        pulumi.set(__self__, "voltage", voltage)
        pulumi.set(__self__, "water", water)

    @_builtins.property
    @pulumi.getter(name="apparentPower")
    def apparent_power(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to apparent power readings
        """
        return pulumi.get(self, "apparent_power")

    @_builtins.property
    @pulumi.getter
    def co2(self) -> _builtins.int:
        """
        Number of sensors that are currently alerting due to CO2 readings
        """
        return pulumi.get(self, "co2")

    @_builtins.property
    @pulumi.getter
    def current(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to electrical current readings
        """
        return pulumi.get(self, "current")

    @_builtins.property
    @pulumi.getter
    def door(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to an open door
        """
        return pulumi.get(self, "door")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to frequency readings
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter
    def humidity(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to humidity readings
        """
        return pulumi.get(self, "humidity")

    @_builtins.property
    @pulumi.getter(name="indoorAirQuality")
    def indoor_air_quality(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to indoor air quality readings
        """
        return pulumi.get(self, "indoor_air_quality")

    @_builtins.property
    @pulumi.getter
    def noise(self) -> 'outputs.GetSensorAlertsOverviewByMetricItemCountsNoiseResult':
        """
        Object containing the number of sensor alerts that occurred due to noise readings
        """
        return pulumi.get(self, "noise")

    @_builtins.property
    @pulumi.getter
    def pm25(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to PM2.5 readings
        """
        return pulumi.get(self, "pm25")

    @_builtins.property
    @pulumi.getter(name="powerFactor")
    def power_factor(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to power factor readings
        """
        return pulumi.get(self, "power_factor")

    @_builtins.property
    @pulumi.getter(name="realPower")
    def real_power(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to real power readings
        """
        return pulumi.get(self, "real_power")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to temperature readings
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter
    def tvoc(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to TVOC readings
        """
        return pulumi.get(self, "tvoc")

    @_builtins.property
    @pulumi.getter(name="upstreamPower")
    def upstream_power(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to upstream power outages
        """
        return pulumi.get(self, "upstream_power")

    @_builtins.property
    @pulumi.getter
    def voltage(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to voltage readings
        """
        return pulumi.get(self, "voltage")

    @_builtins.property
    @pulumi.getter
    def water(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to the presence of water
        """
        return pulumi.get(self, "water")


@pulumi.output_type
class GetSensorAlertsOverviewByMetricItemCountsNoiseResult(dict):
    def __init__(__self__, *,
                 ambient: _builtins.int):
        """
        :param _builtins.int ambient: Number of sensor alerts that occurred due to ambient noise readings
        """
        pulumi.set(__self__, "ambient", ambient)

    @_builtins.property
    @pulumi.getter
    def ambient(self) -> _builtins.int:
        """
        Number of sensor alerts that occurred due to ambient noise readings
        """
        return pulumi.get(self, "ambient")


@pulumi.output_type
class GetSensorAlertsProfilesItemResult(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.GetSensorAlertsProfilesItemConditionResult'],
                 name: _builtins.str,
                 profile_id: _builtins.str,
                 recipients: 'outputs.GetSensorAlertsProfilesItemRecipientsResult',
                 schedule: 'outputs.GetSensorAlertsProfilesItemScheduleResult',
                 serials: Sequence[_builtins.str]):
        """
        :param Sequence['GetSensorAlertsProfilesItemConditionArgs'] conditions: List of conditions that will cause the profile to send an alert.
        :param _builtins.str name: Name of the sensor alert profile.
        :param _builtins.str profile_id: ID of the sensor alert profile.
        :param 'GetSensorAlertsProfilesItemRecipientsArgs' recipients: List of recipients that will receive the alert.
        :param 'GetSensorAlertsProfilesItemScheduleArgs' schedule: The sensor schedule to use with the alert profile.
        :param Sequence[_builtins.str] serials: List of device serials assigned to this sensor alert profile.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "profile_id", profile_id)
        pulumi.set(__self__, "recipients", recipients)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetSensorAlertsProfilesItemConditionResult']:
        """
        List of conditions that will cause the profile to send an alert.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the sensor alert profile.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> _builtins.str:
        """
        ID of the sensor alert profile.
        """
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter
    def recipients(self) -> 'outputs.GetSensorAlertsProfilesItemRecipientsResult':
        """
        List of recipients that will receive the alert.
        """
        return pulumi.get(self, "recipients")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> 'outputs.GetSensorAlertsProfilesItemScheduleResult':
        """
        The sensor schedule to use with the alert profile.
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Sequence[_builtins.str]:
        """
        List of device serials assigned to this sensor alert profile.
        """
        return pulumi.get(self, "serials")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionResult(dict):
    def __init__(__self__, *,
                 direction: _builtins.str,
                 duration: _builtins.int,
                 metric: _builtins.str,
                 threshold: 'outputs.GetSensorAlertsProfilesItemConditionThresholdResult'):
        """
        :param _builtins.str direction: If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
        :param _builtins.int duration: Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
        :param _builtins.str metric: The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
        :param 'GetSensorAlertsProfilesItemConditionThresholdArgs' threshold: Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        """
        If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.int:
        """
        Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdResult':
        """
        Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdResult(dict):
    def __init__(__self__, *,
                 apparent_power: 'outputs.GetSensorAlertsProfilesItemConditionThresholdApparentPowerResult',
                 current: 'outputs.GetSensorAlertsProfilesItemConditionThresholdCurrentResult',
                 door: 'outputs.GetSensorAlertsProfilesItemConditionThresholdDoorResult',
                 frequency: 'outputs.GetSensorAlertsProfilesItemConditionThresholdFrequencyResult',
                 humidity: 'outputs.GetSensorAlertsProfilesItemConditionThresholdHumidityResult',
                 indoor_air_quality: 'outputs.GetSensorAlertsProfilesItemConditionThresholdIndoorAirQualityResult',
                 noise: 'outputs.GetSensorAlertsProfilesItemConditionThresholdNoiseResult',
                 pm25: 'outputs.GetSensorAlertsProfilesItemConditionThresholdPm25Result',
                 power_factor: 'outputs.GetSensorAlertsProfilesItemConditionThresholdPowerFactorResult',
                 real_power: 'outputs.GetSensorAlertsProfilesItemConditionThresholdRealPowerResult',
                 temperature: 'outputs.GetSensorAlertsProfilesItemConditionThresholdTemperatureResult',
                 tvoc: 'outputs.GetSensorAlertsProfilesItemConditionThresholdTvocResult',
                 upstream_power: 'outputs.GetSensorAlertsProfilesItemConditionThresholdUpstreamPowerResult',
                 voltage: 'outputs.GetSensorAlertsProfilesItemConditionThresholdVoltageResult',
                 water: 'outputs.GetSensorAlertsProfilesItemConditionThresholdWaterResult'):
        """
        :param 'GetSensorAlertsProfilesItemConditionThresholdApparentPowerArgs' apparent_power: Apparent power threshold. 'draw' must be provided.
        :param 'GetSensorAlertsProfilesItemConditionThresholdCurrentArgs' current: Electrical current threshold. 'level' must be provided.
        :param 'GetSensorAlertsProfilesItemConditionThresholdDoorArgs' door: Door open threshold. 'open' must be provided and set to true.
        :param 'GetSensorAlertsProfilesItemConditionThresholdFrequencyArgs' frequency: Electrical frequency threshold. 'level' must be provided.
        :param 'GetSensorAlertsProfilesItemConditionThresholdHumidityArgs' humidity: Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
        :param 'GetSensorAlertsProfilesItemConditionThresholdIndoorAirQualityArgs' indoor_air_quality: Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
        :param 'GetSensorAlertsProfilesItemConditionThresholdNoiseArgs' noise: Noise threshold. 'ambient' must be provided.
        :param 'GetSensorAlertsProfilesItemConditionThresholdPm25Args' pm25: PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
        :param 'GetSensorAlertsProfilesItemConditionThresholdPowerFactorArgs' power_factor: Power factor threshold. 'percentage' must be provided.
        :param 'GetSensorAlertsProfilesItemConditionThresholdRealPowerArgs' real_power: Real power threshold. 'draw' must be provided.
        :param 'GetSensorAlertsProfilesItemConditionThresholdTemperatureArgs' temperature: Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
        :param 'GetSensorAlertsProfilesItemConditionThresholdTvocArgs' tvoc: TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
        :param 'GetSensorAlertsProfilesItemConditionThresholdUpstreamPowerArgs' upstream_power: Upstream power threshold. 'outageDetected' must be provided and set to true.
        :param 'GetSensorAlertsProfilesItemConditionThresholdVoltageArgs' voltage: Voltage threshold. 'level' must be provided.
        :param 'GetSensorAlertsProfilesItemConditionThresholdWaterArgs' water: Water detection threshold. 'present' must be provided and set to true.
        """
        pulumi.set(__self__, "apparent_power", apparent_power)
        pulumi.set(__self__, "current", current)
        pulumi.set(__self__, "door", door)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "humidity", humidity)
        pulumi.set(__self__, "indoor_air_quality", indoor_air_quality)
        pulumi.set(__self__, "noise", noise)
        pulumi.set(__self__, "pm25", pm25)
        pulumi.set(__self__, "power_factor", power_factor)
        pulumi.set(__self__, "real_power", real_power)
        pulumi.set(__self__, "temperature", temperature)
        pulumi.set(__self__, "tvoc", tvoc)
        pulumi.set(__self__, "upstream_power", upstream_power)
        pulumi.set(__self__, "voltage", voltage)
        pulumi.set(__self__, "water", water)

    @_builtins.property
    @pulumi.getter(name="apparentPower")
    def apparent_power(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdApparentPowerResult':
        """
        Apparent power threshold. 'draw' must be provided.
        """
        return pulumi.get(self, "apparent_power")

    @_builtins.property
    @pulumi.getter
    def current(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdCurrentResult':
        """
        Electrical current threshold. 'level' must be provided.
        """
        return pulumi.get(self, "current")

    @_builtins.property
    @pulumi.getter
    def door(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdDoorResult':
        """
        Door open threshold. 'open' must be provided and set to true.
        """
        return pulumi.get(self, "door")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdFrequencyResult':
        """
        Electrical frequency threshold. 'level' must be provided.
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter
    def humidity(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdHumidityResult':
        """
        Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
        """
        return pulumi.get(self, "humidity")

    @_builtins.property
    @pulumi.getter(name="indoorAirQuality")
    def indoor_air_quality(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdIndoorAirQualityResult':
        """
        Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
        """
        return pulumi.get(self, "indoor_air_quality")

    @_builtins.property
    @pulumi.getter
    def noise(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdNoiseResult':
        """
        Noise threshold. 'ambient' must be provided.
        """
        return pulumi.get(self, "noise")

    @_builtins.property
    @pulumi.getter
    def pm25(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdPm25Result':
        """
        PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        return pulumi.get(self, "pm25")

    @_builtins.property
    @pulumi.getter(name="powerFactor")
    def power_factor(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdPowerFactorResult':
        """
        Power factor threshold. 'percentage' must be provided.
        """
        return pulumi.get(self, "power_factor")

    @_builtins.property
    @pulumi.getter(name="realPower")
    def real_power(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdRealPowerResult':
        """
        Real power threshold. 'draw' must be provided.
        """
        return pulumi.get(self, "real_power")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdTemperatureResult':
        """
        Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter
    def tvoc(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdTvocResult':
        """
        TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        return pulumi.get(self, "tvoc")

    @_builtins.property
    @pulumi.getter(name="upstreamPower")
    def upstream_power(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdUpstreamPowerResult':
        """
        Upstream power threshold. 'outageDetected' must be provided and set to true.
        """
        return pulumi.get(self, "upstream_power")

    @_builtins.property
    @pulumi.getter
    def voltage(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdVoltageResult':
        """
        Voltage threshold. 'level' must be provided.
        """
        return pulumi.get(self, "voltage")

    @_builtins.property
    @pulumi.getter
    def water(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdWaterResult':
        """
        Water detection threshold. 'present' must be provided and set to true.
        """
        return pulumi.get(self, "water")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdApparentPowerResult(dict):
    def __init__(__self__, *,
                 draw: _builtins.float):
        """
        :param _builtins.float draw: Alerting threshold in volt-amps. Must be between 0 and 3750.
        """
        pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> _builtins.float:
        """
        Alerting threshold in volt-amps. Must be between 0 and 3750.
        """
        return pulumi.get(self, "draw")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdCurrentResult(dict):
    def __init__(__self__, *,
                 draw: _builtins.float):
        """
        :param _builtins.float draw: Alerting threshold in amps. Must be between 0 and 15.
        """
        pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> _builtins.float:
        """
        Alerting threshold in amps. Must be between 0 and 15.
        """
        return pulumi.get(self, "draw")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdDoorResult(dict):
    def __init__(__self__, *,
                 open: _builtins.bool):
        """
        :param _builtins.bool open: Alerting threshold for a door open event. Must be set to true.
        """
        pulumi.set(__self__, "open", open)

    @_builtins.property
    @pulumi.getter
    def open(self) -> _builtins.bool:
        """
        Alerting threshold for a door open event. Must be set to true.
        """
        return pulumi.get(self, "open")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdFrequencyResult(dict):
    def __init__(__self__, *,
                 level: _builtins.float):
        """
        :param _builtins.float level: Alerting threshold in hertz. Must be between 0 and 60.
        """
        pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.float:
        """
        Alerting threshold in hertz. Must be between 0 and 60.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdHumidityResult(dict):
    def __init__(__self__, *,
                 quality: _builtins.str,
                 relative_percentage: _builtins.int):
        """
        :param _builtins.str quality: Alerting threshold as a qualitative humidity level.
        :param _builtins.int relative_percentage: Alerting threshold in %RH.
        """
        pulumi.set(__self__, "quality", quality)
        pulumi.set(__self__, "relative_percentage", relative_percentage)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> _builtins.str:
        """
        Alerting threshold as a qualitative humidity level.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter(name="relativePercentage")
    def relative_percentage(self) -> _builtins.int:
        """
        Alerting threshold in %RH.
        """
        return pulumi.get(self, "relative_percentage")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdIndoorAirQualityResult(dict):
    def __init__(__self__, *,
                 quality: _builtins.str,
                 score: _builtins.int):
        """
        :param _builtins.str quality: Alerting threshold as a qualitative indoor air quality level.
        :param _builtins.int score: Alerting threshold as indoor air quality score.
        """
        pulumi.set(__self__, "quality", quality)
        pulumi.set(__self__, "score", score)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> _builtins.str:
        """
        Alerting threshold as a qualitative indoor air quality level.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter
    def score(self) -> _builtins.int:
        """
        Alerting threshold as indoor air quality score.
        """
        return pulumi.get(self, "score")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdNoiseResult(dict):
    def __init__(__self__, *,
                 ambient: 'outputs.GetSensorAlertsProfilesItemConditionThresholdNoiseAmbientResult'):
        """
        :param 'GetSensorAlertsProfilesItemConditionThresholdNoiseAmbientArgs' ambient: Ambient noise threshold. One of 'level' or 'quality' must be provided.
        """
        pulumi.set(__self__, "ambient", ambient)

    @_builtins.property
    @pulumi.getter
    def ambient(self) -> 'outputs.GetSensorAlertsProfilesItemConditionThresholdNoiseAmbientResult':
        """
        Ambient noise threshold. One of 'level' or 'quality' must be provided.
        """
        return pulumi.get(self, "ambient")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdNoiseAmbientResult(dict):
    def __init__(__self__, *,
                 level: _builtins.int,
                 quality: _builtins.str):
        """
        :param _builtins.int level: Alerting threshold as adjusted decibels.
        :param _builtins.str quality: Alerting threshold as a qualitative ambient noise level.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.int:
        """
        Alerting threshold as adjusted decibels.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> _builtins.str:
        """
        Alerting threshold as a qualitative ambient noise level.
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdPm25Result(dict):
    def __init__(__self__, *,
                 concentration: _builtins.int,
                 quality: _builtins.str):
        """
        :param _builtins.int concentration: Alerting threshold as PM2.5 parts per million.
        :param _builtins.str quality: Alerting threshold as a qualitative PM2.5 level.
        """
        pulumi.set(__self__, "concentration", concentration)
        pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def concentration(self) -> _builtins.int:
        """
        Alerting threshold as PM2.5 parts per million.
        """
        return pulumi.get(self, "concentration")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> _builtins.str:
        """
        Alerting threshold as a qualitative PM2.5 level.
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdPowerFactorResult(dict):
    def __init__(__self__, *,
                 percentage: _builtins.int):
        """
        :param _builtins.int percentage: Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
        """
        pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> _builtins.int:
        """
        Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdRealPowerResult(dict):
    def __init__(__self__, *,
                 draw: _builtins.float):
        """
        :param _builtins.float draw: Alerting threshold in watts. Must be between 0 and 3750.
        """
        pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> _builtins.float:
        """
        Alerting threshold in watts. Must be between 0 and 3750.
        """
        return pulumi.get(self, "draw")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdTemperatureResult(dict):
    def __init__(__self__, *,
                 celsius: _builtins.float,
                 fahrenheit: _builtins.float,
                 quality: _builtins.str):
        """
        :param _builtins.float celsius: Alerting threshold in degrees Celsius.
        :param _builtins.float fahrenheit: Alerting threshold in degrees Fahrenheit.
        :param _builtins.str quality: Alerting threshold as a qualitative temperature level.
        """
        pulumi.set(__self__, "celsius", celsius)
        pulumi.set(__self__, "fahrenheit", fahrenheit)
        pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def celsius(self) -> _builtins.float:
        """
        Alerting threshold in degrees Celsius.
        """
        return pulumi.get(self, "celsius")

    @_builtins.property
    @pulumi.getter
    def fahrenheit(self) -> _builtins.float:
        """
        Alerting threshold in degrees Fahrenheit.
        """
        return pulumi.get(self, "fahrenheit")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> _builtins.str:
        """
        Alerting threshold as a qualitative temperature level.
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdTvocResult(dict):
    def __init__(__self__, *,
                 concentration: _builtins.int,
                 quality: _builtins.str):
        """
        :param _builtins.int concentration: Alerting threshold as TVOC micrograms per cubic meter.
        :param _builtins.str quality: Alerting threshold as a qualitative TVOC level.
        """
        pulumi.set(__self__, "concentration", concentration)
        pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def concentration(self) -> _builtins.int:
        """
        Alerting threshold as TVOC micrograms per cubic meter.
        """
        return pulumi.get(self, "concentration")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> _builtins.str:
        """
        Alerting threshold as a qualitative TVOC level.
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdUpstreamPowerResult(dict):
    def __init__(__self__, *,
                 outage_detected: _builtins.bool):
        """
        :param _builtins.bool outage_detected: Alerting threshold for an upstream power event. Must be set to true.
        """
        pulumi.set(__self__, "outage_detected", outage_detected)

    @_builtins.property
    @pulumi.getter(name="outageDetected")
    def outage_detected(self) -> _builtins.bool:
        """
        Alerting threshold for an upstream power event. Must be set to true.
        """
        return pulumi.get(self, "outage_detected")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdVoltageResult(dict):
    def __init__(__self__, *,
                 level: _builtins.float):
        """
        :param _builtins.float level: Alerting threshold in volts. Must be between 0 and 250.
        """
        pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.float:
        """
        Alerting threshold in volts. Must be between 0 and 250.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class GetSensorAlertsProfilesItemConditionThresholdWaterResult(dict):
    def __init__(__self__, *,
                 present: _builtins.bool):
        """
        :param _builtins.bool present: Alerting threshold for a water detection event. Must be set to true.
        """
        pulumi.set(__self__, "present", present)

    @_builtins.property
    @pulumi.getter
    def present(self) -> _builtins.bool:
        """
        Alerting threshold for a water detection event. Must be set to true.
        """
        return pulumi.get(self, "present")


@pulumi.output_type
class GetSensorAlertsProfilesItemRecipientsResult(dict):
    def __init__(__self__, *,
                 emails: Sequence[_builtins.str],
                 http_server_ids: Sequence[_builtins.str],
                 sms_numbers: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] emails: A list of emails that will receive information about the alert.
        :param Sequence[_builtins.str] http_server_ids: A list of webhook endpoint IDs that will receive information about the alert.
        :param Sequence[_builtins.str] sms_numbers: A list of SMS numbers that will receive information about the alert.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "http_server_ids", http_server_ids)
        pulumi.set(__self__, "sms_numbers", sms_numbers)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Sequence[_builtins.str]:
        """
        A list of emails that will receive information about the alert.
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="httpServerIds")
    def http_server_ids(self) -> Sequence[_builtins.str]:
        """
        A list of webhook endpoint IDs that will receive information about the alert.
        """
        return pulumi.get(self, "http_server_ids")

    @_builtins.property
    @pulumi.getter(name="smsNumbers")
    def sms_numbers(self) -> Sequence[_builtins.str]:
        """
        A list of SMS numbers that will receive information about the alert.
        """
        return pulumi.get(self, "sms_numbers")


@pulumi.output_type
class GetSensorAlertsProfilesItemScheduleResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
        :param _builtins.str name: Name of the sensor schedule to use with the alert profile.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the sensor schedule to use with the alert profile.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSensorMqttBrokersItemResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 mqtt_broker_id: _builtins.str):
        """
        :param _builtins.bool enabled: Specifies whether the broker is enabled for sensor data. Currently, only a single broker may be enabled for sensor data.
        :param _builtins.str mqtt_broker_id: ID of the MQTT Broker.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "mqtt_broker_id", mqtt_broker_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether the broker is enabled for sensor data. Currently, only a single broker may be enabled for sensor data.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="mqttBrokerId")
    def mqtt_broker_id(self) -> _builtins.str:
        """
        ID of the MQTT Broker.
        """
        return pulumi.get(self, "mqtt_broker_id")


@pulumi.output_type
class GetSensorRelationshipsItemResult(dict):
    def __init__(__self__, *,
                 device: 'outputs.GetSensorRelationshipsItemDeviceResult',
                 relationships: 'outputs.GetSensorRelationshipsItemRelationshipsResult'):
        """
        :param 'GetSensorRelationshipsItemDeviceArgs' device: A sensor or gateway device in the network
        :param 'GetSensorRelationshipsItemRelationshipsArgs' relationships: An object describing the relationships defined between the device and other devices
        """
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "relationships", relationships)

    @_builtins.property
    @pulumi.getter
    def device(self) -> 'outputs.GetSensorRelationshipsItemDeviceResult':
        """
        A sensor or gateway device in the network
        """
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter
    def relationships(self) -> 'outputs.GetSensorRelationshipsItemRelationshipsResult':
        """
        An object describing the relationships defined between the device and other devices
        """
        return pulumi.get(self, "relationships")


@pulumi.output_type
class GetSensorRelationshipsItemDeviceResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 product_type: _builtins.str,
                 serial: _builtins.str):
        """
        :param _builtins.str name: The name of the device
        :param _builtins.str product_type: The product type of the device
        :param _builtins.str serial: The serial of the device
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product_type", product_type)
        pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the device
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> _builtins.str:
        """
        The product type of the device
        """
        return pulumi.get(self, "product_type")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        The serial of the device
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class GetSensorRelationshipsItemRelationshipsResult(dict):
    def __init__(__self__, *,
                 livestream: 'outputs.GetSensorRelationshipsItemRelationshipsLivestreamResult'):
        """
        :param 'GetSensorRelationshipsItemRelationshipsLivestreamArgs' livestream: A role defined between an MT sensor and an MV camera that adds the camera's livestream to the sensor's details page. Snapshots from the camera will also appear in alert notifications that the sensor triggers.
        """
        pulumi.set(__self__, "livestream", livestream)

    @_builtins.property
    @pulumi.getter
    def livestream(self) -> 'outputs.GetSensorRelationshipsItemRelationshipsLivestreamResult':
        """
        A role defined between an MT sensor and an MV camera that adds the camera's livestream to the sensor's details page. Snapshots from the camera will also appear in alert notifications that the sensor triggers.
        """
        return pulumi.get(self, "livestream")


@pulumi.output_type
class GetSensorRelationshipsItemRelationshipsLivestreamResult(dict):
    def __init__(__self__, *,
                 related_devices: Sequence['outputs.GetSensorRelationshipsItemRelationshipsLivestreamRelatedDeviceResult']):
        """
        :param Sequence['GetSensorRelationshipsItemRelationshipsLivestreamRelatedDeviceArgs'] related_devices: An array of the related devices for the role
        """
        pulumi.set(__self__, "related_devices", related_devices)

    @_builtins.property
    @pulumi.getter(name="relatedDevices")
    def related_devices(self) -> Sequence['outputs.GetSensorRelationshipsItemRelationshipsLivestreamRelatedDeviceResult']:
        """
        An array of the related devices for the role
        """
        return pulumi.get(self, "related_devices")


@pulumi.output_type
class GetSensorRelationshipsItemRelationshipsLivestreamRelatedDeviceResult(dict):
    def __init__(__self__, *,
                 product_type: _builtins.str,
                 serial: _builtins.str):
        """
        :param _builtins.str product_type: The product type of the related device
        :param _builtins.str serial: The serial of the related device
        """
        pulumi.set(__self__, "product_type", product_type)
        pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> _builtins.str:
        """
        The product type of the related device
        """
        return pulumi.get(self, "product_type")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        The serial of the related device
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class GetSettingsItemResult(dict):
    def __init__(__self__, *,
                 fips: 'outputs.GetSettingsItemFipsResult',
                 local_status_page: 'outputs.GetSettingsItemLocalStatusPageResult',
                 local_status_page_enabled: _builtins.bool,
                 named_vlans: 'outputs.GetSettingsItemNamedVlansResult',
                 remote_status_page_enabled: _builtins.bool,
                 secure_port: 'outputs.GetSettingsItemSecurePortResult'):
        """
        :param 'GetSettingsItemFipsArgs' fips: A hash of FIPS options applied to the Network
        :param 'GetSettingsItemLocalStatusPageArgs' local_status_page: A hash of Local Status page(s)' authentication options applied to the Network.
        :param _builtins.bool local_status_page_enabled: Enables / disables the local device status pages (\\n\\nmy.meraki.com, \\n\\n\\n\\nap.meraki.com, \\n\\n\\n\\nswitch.meraki.com, \\n\\n\\n\\nwired.meraki.com\\n\\n). Optional (defaults to false)
        :param 'GetSettingsItemNamedVlansArgs' named_vlans: A hash of Named VLANs options applied to the Network.
        :param _builtins.bool remote_status_page_enabled: Enables / disables access to the device status page (\\n\\nhttp://[device's LAN IP])\\n\\n. Optional. Can only be set if localStatusPageEnabled is set to true
        :param 'GetSettingsItemSecurePortArgs' secure_port: A hash of SecureConnect options applied to the Network.
        """
        pulumi.set(__self__, "fips", fips)
        pulumi.set(__self__, "local_status_page", local_status_page)
        pulumi.set(__self__, "local_status_page_enabled", local_status_page_enabled)
        pulumi.set(__self__, "named_vlans", named_vlans)
        pulumi.set(__self__, "remote_status_page_enabled", remote_status_page_enabled)
        pulumi.set(__self__, "secure_port", secure_port)

    @_builtins.property
    @pulumi.getter
    def fips(self) -> 'outputs.GetSettingsItemFipsResult':
        """
        A hash of FIPS options applied to the Network
        """
        return pulumi.get(self, "fips")

    @_builtins.property
    @pulumi.getter(name="localStatusPage")
    def local_status_page(self) -> 'outputs.GetSettingsItemLocalStatusPageResult':
        """
        A hash of Local Status page(s)' authentication options applied to the Network.
        """
        return pulumi.get(self, "local_status_page")

    @_builtins.property
    @pulumi.getter(name="localStatusPageEnabled")
    def local_status_page_enabled(self) -> _builtins.bool:
        """
        Enables / disables the local device status pages (\\n\\nmy.meraki.com, \\n\\n\\n\\nap.meraki.com, \\n\\n\\n\\nswitch.meraki.com, \\n\\n\\n\\nwired.meraki.com\\n\\n). Optional (defaults to false)
        """
        return pulumi.get(self, "local_status_page_enabled")

    @_builtins.property
    @pulumi.getter(name="namedVlans")
    def named_vlans(self) -> 'outputs.GetSettingsItemNamedVlansResult':
        """
        A hash of Named VLANs options applied to the Network.
        """
        return pulumi.get(self, "named_vlans")

    @_builtins.property
    @pulumi.getter(name="remoteStatusPageEnabled")
    def remote_status_page_enabled(self) -> _builtins.bool:
        """
        Enables / disables access to the device status page (\\n\\nhttp://[device's LAN IP])\\n\\n. Optional. Can only be set if localStatusPageEnabled is set to true
        """
        return pulumi.get(self, "remote_status_page_enabled")

    @_builtins.property
    @pulumi.getter(name="securePort")
    def secure_port(self) -> 'outputs.GetSettingsItemSecurePortResult':
        """
        A hash of SecureConnect options applied to the Network.
        """
        return pulumi.get(self, "secure_port")


@pulumi.output_type
class GetSettingsItemFipsResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Enables / disables FIPS on the network.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enables / disables FIPS on the network.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetSettingsItemLocalStatusPageResult(dict):
    def __init__(__self__, *,
                 authentication: 'outputs.GetSettingsItemLocalStatusPageAuthenticationResult'):
        """
        :param 'GetSettingsItemLocalStatusPageAuthenticationArgs' authentication: A hash of Local Status page(s)' authentication options applied to the Network.
        """
        pulumi.set(__self__, "authentication", authentication)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.GetSettingsItemLocalStatusPageAuthenticationResult':
        """
        A hash of Local Status page(s)' authentication options applied to the Network.
        """
        return pulumi.get(self, "authentication")


@pulumi.output_type
class GetSettingsItemLocalStatusPageAuthenticationResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 username: _builtins.str):
        """
        :param _builtins.bool enabled: Enables / disables the authentication on Local Status page(s).
        :param _builtins.str username: The username used for Local Status Page(s).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enables / disables the authentication on Local Status page(s).
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username used for Local Status Page(s).
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetSettingsItemNamedVlansResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Enables / disables Named VLANs on the Network.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enables / disables Named VLANs on the Network.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetSettingsItemSecurePortResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Enables / disables SecureConnect on the network. Optional.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enables / disables SecureConnect on the network. Optional.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetSmBypassActivationLockAttemptsItemResult(dict):
    def __init__(__self__, *,
                 data: 'outputs.GetSmBypassActivationLockAttemptsItemDataResult',
                 id: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def data(self) -> 'outputs.GetSmBypassActivationLockAttemptsItemDataResult':
        return pulumi.get(self, "data")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetSmBypassActivationLockAttemptsItemDataResult(dict):
    def __init__(__self__, *,
                 status2090938209: 'outputs.GetSmBypassActivationLockAttemptsItemDataStatus2090938209Result',
                 status38290139892: 'outputs.GetSmBypassActivationLockAttemptsItemDataStatus38290139892Result'):
        pulumi.set(__self__, "status2090938209", status2090938209)
        pulumi.set(__self__, "status38290139892", status38290139892)

    @_builtins.property
    @pulumi.getter
    def status2090938209(self) -> 'outputs.GetSmBypassActivationLockAttemptsItemDataStatus2090938209Result':
        return pulumi.get(self, "status2090938209")

    @_builtins.property
    @pulumi.getter
    def status38290139892(self) -> 'outputs.GetSmBypassActivationLockAttemptsItemDataStatus38290139892Result':
        return pulumi.get(self, "status38290139892")


@pulumi.output_type
class GetSmBypassActivationLockAttemptsItemDataStatus2090938209Result(dict):
    def __init__(__self__, *,
                 errors: Sequence[_builtins.str],
                 success: _builtins.bool):
        pulumi.set(__self__, "errors", errors)
        pulumi.set(__self__, "success", success)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "errors")

    @_builtins.property
    @pulumi.getter
    def success(self) -> _builtins.bool:
        return pulumi.get(self, "success")


@pulumi.output_type
class GetSmBypassActivationLockAttemptsItemDataStatus38290139892Result(dict):
    def __init__(__self__, *,
                 success: _builtins.bool):
        pulumi.set(__self__, "success", success)

    @_builtins.property
    @pulumi.getter
    def success(self) -> _builtins.bool:
        return pulumi.get(self, "success")


@pulumi.output_type
class GetSmDevicesCellularUsageHistoryItemResult(dict):
    def __init__(__self__, *,
                 received: _builtins.float,
                 sent: _builtins.float,
                 ts: _builtins.str):
        """
        :param _builtins.float received: The amount of cellular data received by the device.
        :param _builtins.float sent: The amount of cellular sent received by the device.
        :param _builtins.str ts: When the cellular usage data was collected.
        """
        pulumi.set(__self__, "received", received)
        pulumi.set(__self__, "sent", sent)
        pulumi.set(__self__, "ts", ts)

    @_builtins.property
    @pulumi.getter
    def received(self) -> _builtins.float:
        """
        The amount of cellular data received by the device.
        """
        return pulumi.get(self, "received")

    @_builtins.property
    @pulumi.getter
    def sent(self) -> _builtins.float:
        """
        The amount of cellular sent received by the device.
        """
        return pulumi.get(self, "sent")

    @_builtins.property
    @pulumi.getter
    def ts(self) -> _builtins.str:
        """
        When the cellular usage data was collected.
        """
        return pulumi.get(self, "ts")


@pulumi.output_type
class GetSmDevicesCertsItemResult(dict):
    def __init__(__self__, *,
                 cert_pem: _builtins.str,
                 device_id: _builtins.str,
                 id: _builtins.str,
                 issuer: _builtins.str,
                 name: _builtins.str,
                 not_valid_after: _builtins.str,
                 not_valid_before: _builtins.str,
                 subject: _builtins.str):
        """
        :param _builtins.str cert_pem: The PEM of the certificate.
        :param _builtins.str device_id: The Meraki managed device Id.
        :param _builtins.str id: The Meraki Id of the certificate record.
        :param _builtins.str issuer: The certificate issuer.
        :param _builtins.str name: The name of the certificate.
        :param _builtins.str not_valid_after: The date after which the certificate is no longer valid.
        :param _builtins.str not_valid_before: The date before which the certificate is not valid.
        :param _builtins.str subject: The subject of the certificate.
        """
        pulumi.set(__self__, "cert_pem", cert_pem)
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "not_valid_after", not_valid_after)
        pulumi.set(__self__, "not_valid_before", not_valid_before)
        pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter(name="certPem")
    def cert_pem(self) -> _builtins.str:
        """
        The PEM of the certificate.
        """
        return pulumi.get(self, "cert_pem")

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> _builtins.str:
        """
        The Meraki managed device Id.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The Meraki Id of the certificate record.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> _builtins.str:
        """
        The certificate issuer.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the certificate.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notValidAfter")
    def not_valid_after(self) -> _builtins.str:
        """
        The date after which the certificate is no longer valid.
        """
        return pulumi.get(self, "not_valid_after")

    @_builtins.property
    @pulumi.getter(name="notValidBefore")
    def not_valid_before(self) -> _builtins.str:
        """
        The date before which the certificate is not valid.
        """
        return pulumi.get(self, "not_valid_before")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        """
        The subject of the certificate.
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class GetSmDevicesConnectivityItemResult(dict):
    def __init__(__self__, *,
                 first_seen_at: _builtins.str,
                 last_seen_at: _builtins.str):
        """
        :param _builtins.str first_seen_at: When the device was first seen as connected to the internet in each connection.
        :param _builtins.str last_seen_at: When the device was last seen as connected to the internet in each connection.
        """
        pulumi.set(__self__, "first_seen_at", first_seen_at)
        pulumi.set(__self__, "last_seen_at", last_seen_at)

    @_builtins.property
    @pulumi.getter(name="firstSeenAt")
    def first_seen_at(self) -> _builtins.str:
        """
        When the device was first seen as connected to the internet in each connection.
        """
        return pulumi.get(self, "first_seen_at")

    @_builtins.property
    @pulumi.getter(name="lastSeenAt")
    def last_seen_at(self) -> _builtins.str:
        """
        When the device was last seen as connected to the internet in each connection.
        """
        return pulumi.get(self, "last_seen_at")


@pulumi.output_type
class GetSmDevicesDesktopLogsItemResult(dict):
    def __init__(__self__, *,
                 dhcp_server: _builtins.str,
                 dns_server: _builtins.str,
                 gateway: _builtins.str,
                 ip: _builtins.str,
                 measured_at: _builtins.str,
                 network_device: _builtins.str,
                 network_driver: _builtins.str,
                 network_mtu: _builtins.str,
                 public_ip: _builtins.str,
                 subnet: _builtins.str,
                 ts: _builtins.str,
                 user: _builtins.str,
                 wifi_auth: _builtins.str,
                 wifi_bssid: _builtins.str,
                 wifi_channel: _builtins.str,
                 wifi_noise: _builtins.str,
                 wifi_rssi: _builtins.str,
                 wifi_ssid: _builtins.str):
        """
        :param _builtins.str dhcp_server: The IP address of the DCHP Server.
        :param _builtins.str dns_server: The DNS Server during the connection.
        :param _builtins.str gateway: The gateway IP the device was connected to.
        :param _builtins.str ip: The IP of the device during connection.
        :param _builtins.str measured_at: The time the data was measured at.
        :param _builtins.str network_device: The network device for the device used for connection.
        :param _builtins.str network_driver: The network driver for the device.
        :param _builtins.str network_mtu: The network max transmission unit.
        :param _builtins.str public_ip: The public IP address of the device.
        :param _builtins.str subnet: The subnet of the device connection.
        :param _builtins.str ts: The time the connection was logged.
        :param _builtins.str user: The user during connection.
        :param _builtins.str wifi_auth: The type of authentication used by the SSID.
        :param _builtins.str wifi_bssid: The MAC of the access point the device is connected to.
        :param _builtins.str wifi_channel: Channel through which the connection is routing.
        :param _builtins.str wifi_noise: The wireless signal power level received by the device.
        :param _builtins.str wifi_rssi: The Received Signal Strength Indicator for the device.
        :param _builtins.str wifi_ssid: The name of the network the device is connected to.
        """
        pulumi.set(__self__, "dhcp_server", dhcp_server)
        pulumi.set(__self__, "dns_server", dns_server)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "measured_at", measured_at)
        pulumi.set(__self__, "network_device", network_device)
        pulumi.set(__self__, "network_driver", network_driver)
        pulumi.set(__self__, "network_mtu", network_mtu)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "ts", ts)
        pulumi.set(__self__, "user", user)
        pulumi.set(__self__, "wifi_auth", wifi_auth)
        pulumi.set(__self__, "wifi_bssid", wifi_bssid)
        pulumi.set(__self__, "wifi_channel", wifi_channel)
        pulumi.set(__self__, "wifi_noise", wifi_noise)
        pulumi.set(__self__, "wifi_rssi", wifi_rssi)
        pulumi.set(__self__, "wifi_ssid", wifi_ssid)

    @_builtins.property
    @pulumi.getter(name="dhcpServer")
    def dhcp_server(self) -> _builtins.str:
        """
        The IP address of the DCHP Server.
        """
        return pulumi.get(self, "dhcp_server")

    @_builtins.property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> _builtins.str:
        """
        The DNS Server during the connection.
        """
        return pulumi.get(self, "dns_server")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        The gateway IP the device was connected to.
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        The IP of the device during connection.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="measuredAt")
    def measured_at(self) -> _builtins.str:
        """
        The time the data was measured at.
        """
        return pulumi.get(self, "measured_at")

    @_builtins.property
    @pulumi.getter(name="networkDevice")
    def network_device(self) -> _builtins.str:
        """
        The network device for the device used for connection.
        """
        return pulumi.get(self, "network_device")

    @_builtins.property
    @pulumi.getter(name="networkDriver")
    def network_driver(self) -> _builtins.str:
        """
        The network driver for the device.
        """
        return pulumi.get(self, "network_driver")

    @_builtins.property
    @pulumi.getter(name="networkMtu")
    def network_mtu(self) -> _builtins.str:
        """
        The network max transmission unit.
        """
        return pulumi.get(self, "network_mtu")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> _builtins.str:
        """
        The public IP address of the device.
        """
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        The subnet of the device connection.
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def ts(self) -> _builtins.str:
        """
        The time the connection was logged.
        """
        return pulumi.get(self, "ts")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        """
        The user during connection.
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="wifiAuth")
    def wifi_auth(self) -> _builtins.str:
        """
        The type of authentication used by the SSID.
        """
        return pulumi.get(self, "wifi_auth")

    @_builtins.property
    @pulumi.getter(name="wifiBssid")
    def wifi_bssid(self) -> _builtins.str:
        """
        The MAC of the access point the device is connected to.
        """
        return pulumi.get(self, "wifi_bssid")

    @_builtins.property
    @pulumi.getter(name="wifiChannel")
    def wifi_channel(self) -> _builtins.str:
        """
        Channel through which the connection is routing.
        """
        return pulumi.get(self, "wifi_channel")

    @_builtins.property
    @pulumi.getter(name="wifiNoise")
    def wifi_noise(self) -> _builtins.str:
        """
        The wireless signal power level received by the device.
        """
        return pulumi.get(self, "wifi_noise")

    @_builtins.property
    @pulumi.getter(name="wifiRssi")
    def wifi_rssi(self) -> _builtins.str:
        """
        The Received Signal Strength Indicator for the device.
        """
        return pulumi.get(self, "wifi_rssi")

    @_builtins.property
    @pulumi.getter(name="wifiSsid")
    def wifi_ssid(self) -> _builtins.str:
        """
        The name of the network the device is connected to.
        """
        return pulumi.get(self, "wifi_ssid")


@pulumi.output_type
class GetSmDevicesDeviceCommandLogsItemResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 dashboard_user: _builtins.str,
                 details: _builtins.str,
                 name: _builtins.str,
                 ts: _builtins.str):
        """
        :param _builtins.str action: The type of command sent to the device.
        :param _builtins.str dashboard_user: The Meraki dashboard user who initiated the command.
        :param _builtins.str details: A JSON string object containing command details.
        :param _builtins.str name: The name of the device to which the command is sent.
        :param _builtins.str ts: The time the command was sent to the device.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "dashboard_user", dashboard_user)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ts", ts)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The type of command sent to the device.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="dashboardUser")
    def dashboard_user(self) -> _builtins.str:
        """
        The Meraki dashboard user who initiated the command.
        """
        return pulumi.get(self, "dashboard_user")

    @_builtins.property
    @pulumi.getter
    def details(self) -> _builtins.str:
        """
        A JSON string object containing command details.
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the device to which the command is sent.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def ts(self) -> _builtins.str:
        """
        The time the command was sent to the device.
        """
        return pulumi.get(self, "ts")


@pulumi.output_type
class GetSmDevicesDeviceProfilesItemResult(dict):
    def __init__(__self__, *,
                 device_id: _builtins.str,
                 id: _builtins.str,
                 is_encrypted: _builtins.bool,
                 is_managed: _builtins.bool,
                 name: _builtins.str,
                 profile_data: _builtins.str,
                 profile_identifier: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str device_id: The Meraki managed device Id.
        :param _builtins.str id: The numerical Meraki Id of the profile.
        :param _builtins.bool is_encrypted: A boolean indicating if the profile is encrypted.
        :param _builtins.bool is_managed: Whether or not the profile is managed by Meraki.
        :param _builtins.str name: The name of the profile.
        :param _builtins.str profile_data: A string containing a JSON object with the profile data.
        :param _builtins.str profile_identifier: The identifier of the profile.
        :param _builtins.str version: The verison of the profile.
        """
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_encrypted", is_encrypted)
        pulumi.set(__self__, "is_managed", is_managed)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "profile_data", profile_data)
        pulumi.set(__self__, "profile_identifier", profile_identifier)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> _builtins.str:
        """
        The Meraki managed device Id.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The numerical Meraki Id of the profile.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isEncrypted")
    def is_encrypted(self) -> _builtins.bool:
        """
        A boolean indicating if the profile is encrypted.
        """
        return pulumi.get(self, "is_encrypted")

    @_builtins.property
    @pulumi.getter(name="isManaged")
    def is_managed(self) -> _builtins.bool:
        """
        Whether or not the profile is managed by Meraki.
        """
        return pulumi.get(self, "is_managed")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the profile.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="profileData")
    def profile_data(self) -> _builtins.str:
        """
        A string containing a JSON object with the profile data.
        """
        return pulumi.get(self, "profile_data")

    @_builtins.property
    @pulumi.getter(name="profileIdentifier")
    def profile_identifier(self) -> _builtins.str:
        """
        The identifier of the profile.
        """
        return pulumi.get(self, "profile_identifier")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The verison of the profile.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSmDevicesItemResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 ip: _builtins.str,
                 name: _builtins.str,
                 notes: _builtins.str,
                 os_name: _builtins.str,
                 serial: _builtins.str,
                 serial_number: _builtins.str,
                 ssid: _builtins.str,
                 system_model: _builtins.str,
                 tags: Sequence[_builtins.str],
                 uuid: _builtins.str,
                 wifi_mac: _builtins.str):
        """
        :param _builtins.str id: The Meraki Id of the device record.
        :param _builtins.str ip: The IP address of the device.
        :param _builtins.str name: The name of the device.
        :param _builtins.str notes: Notes associated with the device.
        :param _builtins.str os_name: The name of the device OS.
        :param _builtins.str serial: The device serial.
        :param _builtins.str serial_number: The device serial number.
        :param _builtins.str ssid: The name of the SSID the device was last connected to.
        :param _builtins.str system_model: The device model.
        :param Sequence[_builtins.str] tags: An array of tags associated with the device.
        :param _builtins.str uuid: The UUID of the device.
        :param _builtins.str wifi_mac: The MAC of the device.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notes", notes)
        pulumi.set(__self__, "os_name", os_name)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "serial_number", serial_number)
        pulumi.set(__self__, "ssid", ssid)
        pulumi.set(__self__, "system_model", system_model)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "uuid", uuid)
        pulumi.set(__self__, "wifi_mac", wifi_mac)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The Meraki Id of the device record.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        The IP address of the device.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the device.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> _builtins.str:
        """
        Notes associated with the device.
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter(name="osName")
    def os_name(self) -> _builtins.str:
        """
        The name of the device OS.
        """
        return pulumi.get(self, "os_name")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        The device serial.
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> _builtins.str:
        """
        The device serial number.
        """
        return pulumi.get(self, "serial_number")

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> _builtins.str:
        """
        The name of the SSID the device was last connected to.
        """
        return pulumi.get(self, "ssid")

    @_builtins.property
    @pulumi.getter(name="systemModel")
    def system_model(self) -> _builtins.str:
        """
        The device model.
        """
        return pulumi.get(self, "system_model")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        An array of tags associated with the device.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        The UUID of the device.
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter(name="wifiMac")
    def wifi_mac(self) -> _builtins.str:
        """
        The MAC of the device.
        """
        return pulumi.get(self, "wifi_mac")


@pulumi.output_type
class GetSmDevicesNetworkAdaptersItemResult(dict):
    def __init__(__self__, *,
                 dhcp_server: _builtins.str,
                 dns_server: _builtins.str,
                 gateway: _builtins.str,
                 id: _builtins.str,
                 ip: _builtins.str,
                 mac: _builtins.str,
                 name: _builtins.str,
                 subnet: _builtins.str):
        """
        :param _builtins.str dhcp_server: The IP address of the DCHP Server.
        :param _builtins.str dns_server: The IP address of the DNS Server.
        :param _builtins.str gateway: The IP address of the Gateway.
        :param _builtins.str id: The Meraki Id of the network adapter record.
        :param _builtins.str ip: The IP address of the network adapter.
        :param _builtins.str mac: The MAC associated with the network adapter.
        :param _builtins.str name: The name of the newtwork adapter.
        :param _builtins.str subnet: The subnet for the network adapter.
        """
        pulumi.set(__self__, "dhcp_server", dhcp_server)
        pulumi.set(__self__, "dns_server", dns_server)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter(name="dhcpServer")
    def dhcp_server(self) -> _builtins.str:
        """
        The IP address of the DCHP Server.
        """
        return pulumi.get(self, "dhcp_server")

    @_builtins.property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> _builtins.str:
        """
        The IP address of the DNS Server.
        """
        return pulumi.get(self, "dns_server")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        The IP address of the Gateway.
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The Meraki Id of the network adapter record.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        The IP address of the network adapter.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        The MAC associated with the network adapter.
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the newtwork adapter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        The subnet for the network adapter.
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class GetSmDevicesPerformanceHistoryItemResult(dict):
    def __init__(__self__, *,
                 cpu_percent_used: _builtins.float,
                 disk_usage: 'outputs.GetSmDevicesPerformanceHistoryItemDiskUsageResult',
                 mem_active: _builtins.int,
                 mem_free: _builtins.int,
                 mem_inactive: _builtins.int,
                 mem_wired: _builtins.int,
                 network_received: _builtins.int,
                 network_sent: _builtins.int,
                 swap_used: _builtins.int,
                 ts: _builtins.str):
        """
        :param _builtins.float cpu_percent_used: The percentage of CPU used as a decimal format.
        :param 'GetSmDevicesPerformanceHistoryItemDiskUsageArgs' disk_usage: An object containing disk usage details.
        :param _builtins.int mem_active: The active RAM on the device.
        :param _builtins.int mem_free: Memory that is not yet in use by the system.
        :param _builtins.int mem_inactive: The inactive RAM on the device.
        :param _builtins.int mem_wired: Memory used for core OS functions on the device.
        :param _builtins.int network_received: Network bandwith received.
        :param _builtins.int network_sent: Network bandwith transmitted.
        :param _builtins.int swap_used: The amount of space being used on the startup disk to swap unused files to and from RAM.
        :param _builtins.str ts: The time at which the performance was measured.
        """
        pulumi.set(__self__, "cpu_percent_used", cpu_percent_used)
        pulumi.set(__self__, "disk_usage", disk_usage)
        pulumi.set(__self__, "mem_active", mem_active)
        pulumi.set(__self__, "mem_free", mem_free)
        pulumi.set(__self__, "mem_inactive", mem_inactive)
        pulumi.set(__self__, "mem_wired", mem_wired)
        pulumi.set(__self__, "network_received", network_received)
        pulumi.set(__self__, "network_sent", network_sent)
        pulumi.set(__self__, "swap_used", swap_used)
        pulumi.set(__self__, "ts", ts)

    @_builtins.property
    @pulumi.getter(name="cpuPercentUsed")
    def cpu_percent_used(self) -> _builtins.float:
        """
        The percentage of CPU used as a decimal format.
        """
        return pulumi.get(self, "cpu_percent_used")

    @_builtins.property
    @pulumi.getter(name="diskUsage")
    def disk_usage(self) -> 'outputs.GetSmDevicesPerformanceHistoryItemDiskUsageResult':
        """
        An object containing disk usage details.
        """
        return pulumi.get(self, "disk_usage")

    @_builtins.property
    @pulumi.getter(name="memActive")
    def mem_active(self) -> _builtins.int:
        """
        The active RAM on the device.
        """
        return pulumi.get(self, "mem_active")

    @_builtins.property
    @pulumi.getter(name="memFree")
    def mem_free(self) -> _builtins.int:
        """
        Memory that is not yet in use by the system.
        """
        return pulumi.get(self, "mem_free")

    @_builtins.property
    @pulumi.getter(name="memInactive")
    def mem_inactive(self) -> _builtins.int:
        """
        The inactive RAM on the device.
        """
        return pulumi.get(self, "mem_inactive")

    @_builtins.property
    @pulumi.getter(name="memWired")
    def mem_wired(self) -> _builtins.int:
        """
        Memory used for core OS functions on the device.
        """
        return pulumi.get(self, "mem_wired")

    @_builtins.property
    @pulumi.getter(name="networkReceived")
    def network_received(self) -> _builtins.int:
        """
        Network bandwith received.
        """
        return pulumi.get(self, "network_received")

    @_builtins.property
    @pulumi.getter(name="networkSent")
    def network_sent(self) -> _builtins.int:
        """
        Network bandwith transmitted.
        """
        return pulumi.get(self, "network_sent")

    @_builtins.property
    @pulumi.getter(name="swapUsed")
    def swap_used(self) -> _builtins.int:
        """
        The amount of space being used on the startup disk to swap unused files to and from RAM.
        """
        return pulumi.get(self, "swap_used")

    @_builtins.property
    @pulumi.getter
    def ts(self) -> _builtins.str:
        """
        The time at which the performance was measured.
        """
        return pulumi.get(self, "ts")


@pulumi.output_type
class GetSmDevicesPerformanceHistoryItemDiskUsageResult(dict):
    def __init__(__self__, *,
                 c: 'outputs.GetSmDevicesPerformanceHistoryItemDiskUsageCResult'):
        """
        :param 'GetSmDevicesPerformanceHistoryItemDiskUsageCArgs' c: An object containing current disk usage details.
        """
        pulumi.set(__self__, "c", c)

    @_builtins.property
    @pulumi.getter
    def c(self) -> 'outputs.GetSmDevicesPerformanceHistoryItemDiskUsageCResult':
        """
        An object containing current disk usage details.
        """
        return pulumi.get(self, "c")


@pulumi.output_type
class GetSmDevicesPerformanceHistoryItemDiskUsageCResult(dict):
    def __init__(__self__, *,
                 space: _builtins.int,
                 used: _builtins.int):
        """
        :param _builtins.int space: The available disk space.
        :param _builtins.int used: The used disk space.
        """
        pulumi.set(__self__, "space", space)
        pulumi.set(__self__, "used", used)

    @_builtins.property
    @pulumi.getter
    def space(self) -> _builtins.int:
        """
        The available disk space.
        """
        return pulumi.get(self, "space")

    @_builtins.property
    @pulumi.getter
    def used(self) -> _builtins.int:
        """
        The used disk space.
        """
        return pulumi.get(self, "used")


@pulumi.output_type
class GetSmDevicesSecurityCentersItemResult(dict):
    def __init__(__self__, *,
                 app_id: _builtins.str,
                 bundle_size: _builtins.int,
                 created_at: _builtins.str,
                 device_id: _builtins.str,
                 dynamic_size: _builtins.int,
                 id: _builtins.str,
                 identifier: _builtins.str,
                 installed_at: _builtins.str,
                 ios_redemption_code: _builtins.bool,
                 is_managed: _builtins.bool,
                 itunes_id: _builtins.str,
                 license_key: _builtins.str,
                 name: _builtins.str,
                 path: _builtins.str,
                 redemption_code: _builtins.int,
                 short_version: _builtins.str,
                 status: _builtins.str,
                 to_install: _builtins.bool,
                 to_uninstall: _builtins.bool,
                 uninstalled_at: _builtins.str,
                 updated_at: _builtins.str,
                 vendor: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str app_id: The Meraki managed application Id for this record on a particular device.
        :param _builtins.int bundle_size: The size of the software bundle.
        :param _builtins.str created_at: When the Meraki record for the software was created.
        :param _builtins.str device_id: The Meraki managed device Id.
        :param _builtins.int dynamic_size: The size of the data stored in the application.
        :param _builtins.str id: The Meraki software Id.
        :param _builtins.str identifier: Software bundle identifier.
        :param _builtins.str installed_at: When the Software was installed on the device.
        :param _builtins.bool ios_redemption_code: A boolean indicating whether or not an iOS redemption code was used.
        :param _builtins.bool is_managed: A boolean indicating whether or not the software is managed by Meraki.
        :param _builtins.str itunes_id: The itunes numerical identifier.
        :param _builtins.str license_key: The license key associated with this software installation.
        :param _builtins.str name: The name of the software.
        :param _builtins.str path: The path on the device where the software record is located.
        :param _builtins.int redemption_code: The redemption code used for this software.
        :param _builtins.str short_version: Short version notation for the software.
        :param _builtins.str status: The management status of the software.
        :param _builtins.bool to_install: A boolean indicating this software record should be installed on the associated device.
        :param _builtins.bool to_uninstall: A boolean indicating this software record should be uninstalled on the associated device.
        :param _builtins.str uninstalled_at: When the record was uninstalled from the device.
        :param _builtins.str updated_at: When the record was last updated by Meraki.
        :param _builtins.str vendor: The vendor of the software.
        :param _builtins.str version: Full version notation for the software.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "bundle_size", bundle_size)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "dynamic_size", dynamic_size)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "installed_at", installed_at)
        pulumi.set(__self__, "ios_redemption_code", ios_redemption_code)
        pulumi.set(__self__, "is_managed", is_managed)
        pulumi.set(__self__, "itunes_id", itunes_id)
        pulumi.set(__self__, "license_key", license_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "redemption_code", redemption_code)
        pulumi.set(__self__, "short_version", short_version)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "to_install", to_install)
        pulumi.set(__self__, "to_uninstall", to_uninstall)
        pulumi.set(__self__, "uninstalled_at", uninstalled_at)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "vendor", vendor)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> _builtins.str:
        """
        The Meraki managed application Id for this record on a particular device.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="bundleSize")
    def bundle_size(self) -> _builtins.int:
        """
        The size of the software bundle.
        """
        return pulumi.get(self, "bundle_size")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        When the Meraki record for the software was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> _builtins.str:
        """
        The Meraki managed device Id.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter(name="dynamicSize")
    def dynamic_size(self) -> _builtins.int:
        """
        The size of the data stored in the application.
        """
        return pulumi.get(self, "dynamic_size")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The Meraki software Id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        """
        Software bundle identifier.
        """
        return pulumi.get(self, "identifier")

    @_builtins.property
    @pulumi.getter(name="installedAt")
    def installed_at(self) -> _builtins.str:
        """
        When the Software was installed on the device.
        """
        return pulumi.get(self, "installed_at")

    @_builtins.property
    @pulumi.getter(name="iosRedemptionCode")
    def ios_redemption_code(self) -> _builtins.bool:
        """
        A boolean indicating whether or not an iOS redemption code was used.
        """
        return pulumi.get(self, "ios_redemption_code")

    @_builtins.property
    @pulumi.getter(name="isManaged")
    def is_managed(self) -> _builtins.bool:
        """
        A boolean indicating whether or not the software is managed by Meraki.
        """
        return pulumi.get(self, "is_managed")

    @_builtins.property
    @pulumi.getter(name="itunesId")
    def itunes_id(self) -> _builtins.str:
        """
        The itunes numerical identifier.
        """
        return pulumi.get(self, "itunes_id")

    @_builtins.property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> _builtins.str:
        """
        The license key associated with this software installation.
        """
        return pulumi.get(self, "license_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the software.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path on the device where the software record is located.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="redemptionCode")
    def redemption_code(self) -> _builtins.int:
        """
        The redemption code used for this software.
        """
        return pulumi.get(self, "redemption_code")

    @_builtins.property
    @pulumi.getter(name="shortVersion")
    def short_version(self) -> _builtins.str:
        """
        Short version notation for the software.
        """
        return pulumi.get(self, "short_version")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The management status of the software.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="toInstall")
    def to_install(self) -> _builtins.bool:
        """
        A boolean indicating this software record should be installed on the associated device.
        """
        return pulumi.get(self, "to_install")

    @_builtins.property
    @pulumi.getter(name="toUninstall")
    def to_uninstall(self) -> _builtins.bool:
        """
        A boolean indicating this software record should be uninstalled on the associated device.
        """
        return pulumi.get(self, "to_uninstall")

    @_builtins.property
    @pulumi.getter(name="uninstalledAt")
    def uninstalled_at(self) -> _builtins.str:
        """
        When the record was uninstalled from the device.
        """
        return pulumi.get(self, "uninstalled_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        When the record was last updated by Meraki.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> _builtins.str:
        """
        The vendor of the software.
        """
        return pulumi.get(self, "vendor")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Full version notation for the software.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSmDevicesWlanListsItemResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 xml: _builtins.str):
        """
        :param _builtins.str created_at: When the Meraki record for the wlanList was created.
        :param _builtins.str id: The Meraki managed Id of the wlanList record.
        :param _builtins.str xml: An XML string containing the WLAN List for the device.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "xml", xml)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        When the Meraki record for the wlanList was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The Meraki managed Id of the wlanList record.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def xml(self) -> _builtins.str:
        """
        An XML string containing the WLAN List for the device.
        """
        return pulumi.get(self, "xml")


@pulumi.output_type
class GetSmProfilesItemResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 payload_types: Sequence[_builtins.str],
                 scope: _builtins.str,
                 tags: Sequence[_builtins.str]):
        """
        :param _builtins.str description: Description of a profile.
        :param _builtins.str id: ID of a profile.
        :param _builtins.str name: Name of a profile.
        :param Sequence[_builtins.str] payload_types: Payloads in the profile.
        :param _builtins.str scope: Scope of a profile.
        :param Sequence[_builtins.str] tags: Tags of a profile.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "payload_types", payload_types)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of a profile.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of a profile.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a profile.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="payloadTypes")
    def payload_types(self) -> Sequence[_builtins.str]:
        """
        Payloads in the profile.
        """
        return pulumi.get(self, "payload_types")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        Scope of a profile.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        Tags of a profile.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSmTargetGroupsItemResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 scope: _builtins.str,
                 tags: Sequence[_builtins.str]):
        """
        :param _builtins.str id: The ID of this target group.
        :param _builtins.str name: The name of this target group.
        :param _builtins.str scope: The scope of the target group.
        :param Sequence[_builtins.str] tags: The tags of the target group.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of this target group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of this target group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        The scope of the target group.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        The tags of the target group.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSmTrustedAccessConfigsItemResult(dict):
    def __init__(__self__, *,
                 access_end_at: _builtins.str,
                 access_start_at: _builtins.str,
                 additional_email_text: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 notify_time_before_access_ends: _builtins.int,
                 scope: _builtins.str,
                 send_expiration_emails: _builtins.bool,
                 ssid_name: _builtins.str,
                 tags: Sequence[_builtins.str],
                 timebound_type: _builtins.str):
        """
        :param _builtins.str access_end_at: time that access ends
        :param _builtins.str access_start_at: time that access starts
        :param _builtins.str additional_email_text: Optional email text
        :param _builtins.str id: device ID
        :param _builtins.str name: device name
        :param _builtins.int notify_time_before_access_ends: Time before access expiration reminder email sends
        :param _builtins.str scope: scope
        :param _builtins.bool send_expiration_emails: Send Email Notifications
        :param _builtins.str ssid_name: SSID name
        :param Sequence[_builtins.str] tags: device tags
        :param _builtins.str timebound_type: type of access period, either a static range or a dynamic period
        """
        pulumi.set(__self__, "access_end_at", access_end_at)
        pulumi.set(__self__, "access_start_at", access_start_at)
        pulumi.set(__self__, "additional_email_text", additional_email_text)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notify_time_before_access_ends", notify_time_before_access_ends)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "send_expiration_emails", send_expiration_emails)
        pulumi.set(__self__, "ssid_name", ssid_name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "timebound_type", timebound_type)

    @_builtins.property
    @pulumi.getter(name="accessEndAt")
    def access_end_at(self) -> _builtins.str:
        """
        time that access ends
        """
        return pulumi.get(self, "access_end_at")

    @_builtins.property
    @pulumi.getter(name="accessStartAt")
    def access_start_at(self) -> _builtins.str:
        """
        time that access starts
        """
        return pulumi.get(self, "access_start_at")

    @_builtins.property
    @pulumi.getter(name="additionalEmailText")
    def additional_email_text(self) -> _builtins.str:
        """
        Optional email text
        """
        return pulumi.get(self, "additional_email_text")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        device ID
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        device name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notifyTimeBeforeAccessEnds")
    def notify_time_before_access_ends(self) -> _builtins.int:
        """
        Time before access expiration reminder email sends
        """
        return pulumi.get(self, "notify_time_before_access_ends")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        scope
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="sendExpirationEmails")
    def send_expiration_emails(self) -> _builtins.bool:
        """
        Send Email Notifications
        """
        return pulumi.get(self, "send_expiration_emails")

    @_builtins.property
    @pulumi.getter(name="ssidName")
    def ssid_name(self) -> _builtins.str:
        """
        SSID name
        """
        return pulumi.get(self, "ssid_name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        device tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="timeboundType")
    def timebound_type(self) -> _builtins.str:
        """
        type of access period, either a static range or a dynamic period
        """
        return pulumi.get(self, "timebound_type")


@pulumi.output_type
class GetSmUserAccessDevicesItemResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 id: _builtins.str,
                 mac: _builtins.str,
                 name: _builtins.str,
                 system_type: _builtins.str,
                 tags: Sequence[_builtins.str],
                 trusted_access_connections: Sequence['outputs.GetSmUserAccessDevicesItemTrustedAccessConnectionResult'],
                 username: _builtins.str):
        """
        :param _builtins.str email: user email
        :param _builtins.str id: device ID
        :param _builtins.str mac: mac address
        :param _builtins.str name: device name
        :param _builtins.str system_type: system type
        :param Sequence[_builtins.str] tags: device tags
        :param Sequence['GetSmUserAccessDevicesItemTrustedAccessConnectionArgs'] trusted_access_connections: Array of trusted access configs
        :param _builtins.str username: username
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "system_type", system_type)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "trusted_access_connections", trusted_access_connections)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        user email
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        device ID
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        mac address
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        device name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="systemType")
    def system_type(self) -> _builtins.str:
        """
        system type
        """
        return pulumi.get(self, "system_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        device tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="trustedAccessConnections")
    def trusted_access_connections(self) -> Sequence['outputs.GetSmUserAccessDevicesItemTrustedAccessConnectionResult']:
        """
        Array of trusted access configs
        """
        return pulumi.get(self, "trusted_access_connections")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        username
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetSmUserAccessDevicesItemTrustedAccessConnectionResult(dict):
    def __init__(__self__, *,
                 downloaded_at: _builtins.str,
                 last_connected_at: _builtins.str,
                 scep_completed_at: _builtins.str,
                 trusted_access_config_id: _builtins.str):
        """
        :param _builtins.str downloaded_at: time that config was downloaded
        :param _builtins.str last_connected_at: time of last connection
        :param _builtins.str scep_completed_at: time that SCEP completed
        :param _builtins.str trusted_access_config_id: config id
        """
        pulumi.set(__self__, "downloaded_at", downloaded_at)
        pulumi.set(__self__, "last_connected_at", last_connected_at)
        pulumi.set(__self__, "scep_completed_at", scep_completed_at)
        pulumi.set(__self__, "trusted_access_config_id", trusted_access_config_id)

    @_builtins.property
    @pulumi.getter(name="downloadedAt")
    def downloaded_at(self) -> _builtins.str:
        """
        time that config was downloaded
        """
        return pulumi.get(self, "downloaded_at")

    @_builtins.property
    @pulumi.getter(name="lastConnectedAt")
    def last_connected_at(self) -> _builtins.str:
        """
        time of last connection
        """
        return pulumi.get(self, "last_connected_at")

    @_builtins.property
    @pulumi.getter(name="scepCompletedAt")
    def scep_completed_at(self) -> _builtins.str:
        """
        time that SCEP completed
        """
        return pulumi.get(self, "scep_completed_at")

    @_builtins.property
    @pulumi.getter(name="trustedAccessConfigId")
    def trusted_access_config_id(self) -> _builtins.str:
        """
        config id
        """
        return pulumi.get(self, "trusted_access_config_id")


@pulumi.output_type
class GetSmUsersDeviceProfilesItemResult(dict):
    def __init__(__self__, *,
                 device_id: _builtins.str,
                 id: _builtins.str,
                 is_encrypted: _builtins.bool,
                 is_managed: _builtins.bool,
                 name: _builtins.str,
                 profile_data: _builtins.str,
                 profile_identifier: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str device_id: The Meraki managed device Id.
        :param _builtins.str id: The numerical Meraki Id of the profile.
        :param _builtins.bool is_encrypted: A boolean indicating if the profile is encrypted.
        :param _builtins.bool is_managed: Whether or not the profile is managed by Meraki.
        :param _builtins.str name: The name of the profile.
        :param _builtins.str profile_data: A string containing a JSON object with the profile data.
        :param _builtins.str profile_identifier: The identifier of the profile.
        :param _builtins.str version: The verison of the profile.
        """
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_encrypted", is_encrypted)
        pulumi.set(__self__, "is_managed", is_managed)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "profile_data", profile_data)
        pulumi.set(__self__, "profile_identifier", profile_identifier)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> _builtins.str:
        """
        The Meraki managed device Id.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The numerical Meraki Id of the profile.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isEncrypted")
    def is_encrypted(self) -> _builtins.bool:
        """
        A boolean indicating if the profile is encrypted.
        """
        return pulumi.get(self, "is_encrypted")

    @_builtins.property
    @pulumi.getter(name="isManaged")
    def is_managed(self) -> _builtins.bool:
        """
        Whether or not the profile is managed by Meraki.
        """
        return pulumi.get(self, "is_managed")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the profile.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="profileData")
    def profile_data(self) -> _builtins.str:
        """
        A string containing a JSON object with the profile data.
        """
        return pulumi.get(self, "profile_data")

    @_builtins.property
    @pulumi.getter(name="profileIdentifier")
    def profile_identifier(self) -> _builtins.str:
        """
        The identifier of the profile.
        """
        return pulumi.get(self, "profile_identifier")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The verison of the profile.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSmUsersItemResult(dict):
    def __init__(__self__, *,
                 ad_groups: Sequence[_builtins.str],
                 asm_groups: Sequence[_builtins.str],
                 azure_ad_groups: Sequence[_builtins.str],
                 display_name: _builtins.str,
                 email: _builtins.str,
                 full_name: _builtins.str,
                 has_identity_certificate: _builtins.bool,
                 has_password: _builtins.bool,
                 id: _builtins.str,
                 is_external: _builtins.bool,
                 saml_groups: Sequence[_builtins.str],
                 tags: _builtins.str,
                 user_thumbnail: _builtins.str,
                 username: _builtins.str):
        """
        :param Sequence[_builtins.str] ad_groups: Active Directory Groups the user belongs to.
        :param Sequence[_builtins.str] asm_groups: Apple School Manager Groups the user belongs to.
        :param Sequence[_builtins.str] azure_ad_groups: Azure Active Directory Groups the user belongs to.
        :param _builtins.str display_name: The user display name.
        :param _builtins.str email: User email.
        :param _builtins.str full_name: User full name.
        :param _builtins.bool has_identity_certificate: A boolean indicating if the user has an associated identity certificate..
        :param _builtins.bool has_password: A boolean denoting if the user has a password associated with the record.
        :param _builtins.str id: The Meraki managed Id of the user record.
        :param _builtins.bool is_external: Whether the user was created using an external integration, or via the Meraki Dashboard.
        :param Sequence[_builtins.str] saml_groups: SAML Groups the user belongs to.
        :param _builtins.str tags: The set of tags the user is scoped to.
        :param _builtins.str user_thumbnail: The url where the users thumbnail is hosted.
        :param _builtins.str username: The users username.
        """
        pulumi.set(__self__, "ad_groups", ad_groups)
        pulumi.set(__self__, "asm_groups", asm_groups)
        pulumi.set(__self__, "azure_ad_groups", azure_ad_groups)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "full_name", full_name)
        pulumi.set(__self__, "has_identity_certificate", has_identity_certificate)
        pulumi.set(__self__, "has_password", has_password)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_external", is_external)
        pulumi.set(__self__, "saml_groups", saml_groups)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "user_thumbnail", user_thumbnail)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="adGroups")
    def ad_groups(self) -> Sequence[_builtins.str]:
        """
        Active Directory Groups the user belongs to.
        """
        return pulumi.get(self, "ad_groups")

    @_builtins.property
    @pulumi.getter(name="asmGroups")
    def asm_groups(self) -> Sequence[_builtins.str]:
        """
        Apple School Manager Groups the user belongs to.
        """
        return pulumi.get(self, "asm_groups")

    @_builtins.property
    @pulumi.getter(name="azureAdGroups")
    def azure_ad_groups(self) -> Sequence[_builtins.str]:
        """
        Azure Active Directory Groups the user belongs to.
        """
        return pulumi.get(self, "azure_ad_groups")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        User email.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> _builtins.str:
        """
        User full name.
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="hasIdentityCertificate")
    def has_identity_certificate(self) -> _builtins.bool:
        """
        A boolean indicating if the user has an associated identity certificate..
        """
        return pulumi.get(self, "has_identity_certificate")

    @_builtins.property
    @pulumi.getter(name="hasPassword")
    def has_password(self) -> _builtins.bool:
        """
        A boolean denoting if the user has a password associated with the record.
        """
        return pulumi.get(self, "has_password")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The Meraki managed Id of the user record.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isExternal")
    def is_external(self) -> _builtins.bool:
        """
        Whether the user was created using an external integration, or via the Meraki Dashboard.
        """
        return pulumi.get(self, "is_external")

    @_builtins.property
    @pulumi.getter(name="samlGroups")
    def saml_groups(self) -> Sequence[_builtins.str]:
        """
        SAML Groups the user belongs to.
        """
        return pulumi.get(self, "saml_groups")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> _builtins.str:
        """
        The set of tags the user is scoped to.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userThumbnail")
    def user_thumbnail(self) -> _builtins.str:
        """
        The url where the users thumbnail is hosted.
        """
        return pulumi.get(self, "user_thumbnail")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The users username.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetSmUsersSoftwaresItemResult(dict):
    def __init__(__self__, *,
                 app_id: _builtins.str,
                 bundle_size: _builtins.int,
                 created_at: _builtins.str,
                 device_id: _builtins.str,
                 dynamic_size: _builtins.int,
                 id: _builtins.str,
                 identifier: _builtins.str,
                 installed_at: _builtins.str,
                 ios_redemption_code: _builtins.bool,
                 is_managed: _builtins.bool,
                 itunes_id: _builtins.str,
                 license_key: _builtins.str,
                 name: _builtins.str,
                 path: _builtins.str,
                 redemption_code: _builtins.int,
                 short_version: _builtins.str,
                 status: _builtins.str,
                 to_install: _builtins.bool,
                 to_uninstall: _builtins.bool,
                 uninstalled_at: _builtins.str,
                 updated_at: _builtins.str,
                 vendor: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str app_id: The Meraki managed application Id for this record on a particular device.
        :param _builtins.int bundle_size: The size of the software bundle.
        :param _builtins.str created_at: When the Meraki record for the software was created.
        :param _builtins.str device_id: The Meraki managed device Id.
        :param _builtins.int dynamic_size: The size of the data stored in the application.
        :param _builtins.str id: The Meraki software Id.
        :param _builtins.str identifier: Software bundle identifier.
        :param _builtins.str installed_at: When the Software was installed on the device.
        :param _builtins.bool ios_redemption_code: A boolean indicating whether or not an iOS redemption code was used.
        :param _builtins.bool is_managed: A boolean indicating whether or not the software is managed by Meraki.
        :param _builtins.str itunes_id: The itunes numerical identifier.
        :param _builtins.str license_key: The license key associated with this software installation.
        :param _builtins.str name: The name of the software.
        :param _builtins.str path: The path on the device where the software record is located.
        :param _builtins.int redemption_code: The redemption code used for this software.
        :param _builtins.str short_version: Short version notation for the software.
        :param _builtins.str status: The management status of the software.
        :param _builtins.bool to_install: A boolean indicating this software record should be installed on the associated device.
        :param _builtins.bool to_uninstall: A boolean indicating this software record should be uninstalled on the associated device.
        :param _builtins.str uninstalled_at: When the record was uninstalled from the device.
        :param _builtins.str updated_at: When the record was last updated by Meraki.
        :param _builtins.str vendor: The vendor of the software.
        :param _builtins.str version: Full version notation for the software.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "bundle_size", bundle_size)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "dynamic_size", dynamic_size)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "installed_at", installed_at)
        pulumi.set(__self__, "ios_redemption_code", ios_redemption_code)
        pulumi.set(__self__, "is_managed", is_managed)
        pulumi.set(__self__, "itunes_id", itunes_id)
        pulumi.set(__self__, "license_key", license_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "redemption_code", redemption_code)
        pulumi.set(__self__, "short_version", short_version)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "to_install", to_install)
        pulumi.set(__self__, "to_uninstall", to_uninstall)
        pulumi.set(__self__, "uninstalled_at", uninstalled_at)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "vendor", vendor)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> _builtins.str:
        """
        The Meraki managed application Id for this record on a particular device.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="bundleSize")
    def bundle_size(self) -> _builtins.int:
        """
        The size of the software bundle.
        """
        return pulumi.get(self, "bundle_size")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        When the Meraki record for the software was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> _builtins.str:
        """
        The Meraki managed device Id.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter(name="dynamicSize")
    def dynamic_size(self) -> _builtins.int:
        """
        The size of the data stored in the application.
        """
        return pulumi.get(self, "dynamic_size")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The Meraki software Id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        """
        Software bundle identifier.
        """
        return pulumi.get(self, "identifier")

    @_builtins.property
    @pulumi.getter(name="installedAt")
    def installed_at(self) -> _builtins.str:
        """
        When the Software was installed on the device.
        """
        return pulumi.get(self, "installed_at")

    @_builtins.property
    @pulumi.getter(name="iosRedemptionCode")
    def ios_redemption_code(self) -> _builtins.bool:
        """
        A boolean indicating whether or not an iOS redemption code was used.
        """
        return pulumi.get(self, "ios_redemption_code")

    @_builtins.property
    @pulumi.getter(name="isManaged")
    def is_managed(self) -> _builtins.bool:
        """
        A boolean indicating whether or not the software is managed by Meraki.
        """
        return pulumi.get(self, "is_managed")

    @_builtins.property
    @pulumi.getter(name="itunesId")
    def itunes_id(self) -> _builtins.str:
        """
        The itunes numerical identifier.
        """
        return pulumi.get(self, "itunes_id")

    @_builtins.property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> _builtins.str:
        """
        The license key associated with this software installation.
        """
        return pulumi.get(self, "license_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the software.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path on the device where the software record is located.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="redemptionCode")
    def redemption_code(self) -> _builtins.int:
        """
        The redemption code used for this software.
        """
        return pulumi.get(self, "redemption_code")

    @_builtins.property
    @pulumi.getter(name="shortVersion")
    def short_version(self) -> _builtins.str:
        """
        Short version notation for the software.
        """
        return pulumi.get(self, "short_version")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The management status of the software.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="toInstall")
    def to_install(self) -> _builtins.bool:
        """
        A boolean indicating this software record should be installed on the associated device.
        """
        return pulumi.get(self, "to_install")

    @_builtins.property
    @pulumi.getter(name="toUninstall")
    def to_uninstall(self) -> _builtins.bool:
        """
        A boolean indicating this software record should be uninstalled on the associated device.
        """
        return pulumi.get(self, "to_uninstall")

    @_builtins.property
    @pulumi.getter(name="uninstalledAt")
    def uninstalled_at(self) -> _builtins.str:
        """
        When the record was uninstalled from the device.
        """
        return pulumi.get(self, "uninstalled_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        When the record was last updated by Meraki.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> _builtins.str:
        """
        The vendor of the software.
        """
        return pulumi.get(self, "vendor")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Full version notation for the software.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSnmpItemResult(dict):
    def __init__(__self__, *,
                 access: _builtins.str,
                 community_string: _builtins.str,
                 users: Sequence['outputs.GetSnmpItemUserResult']):
        """
        :param _builtins.str access: The type of SNMP access. Can be one of 'none' (disabled), 'community' (V1/V2c), or 'users' (V3).
        :param _builtins.str community_string: SNMP community string if access is 'community'.
        :param Sequence['GetSnmpItemUserArgs'] users: SNMP settings if access is 'users'.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "community_string", community_string)
        pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def access(self) -> _builtins.str:
        """
        The type of SNMP access. Can be one of 'none' (disabled), 'community' (V1/V2c), or 'users' (V3).
        """
        return pulumi.get(self, "access")

    @_builtins.property
    @pulumi.getter(name="communityString")
    def community_string(self) -> _builtins.str:
        """
        SNMP community string if access is 'community'.
        """
        return pulumi.get(self, "community_string")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetSnmpItemUserResult']:
        """
        SNMP settings if access is 'users'.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetSnmpItemUserResult(dict):
    def __init__(__self__, *,
                 passphrase: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str passphrase: The passphrase for the SNMP user.
        :param _builtins.str username: The username for the SNMP user.
        """
        pulumi.set(__self__, "passphrase", passphrase)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> _builtins.str:
        """
        The passphrase for the SNMP user.
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username for the SNMP user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetSwitchAccessControlListsItemResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetSwitchAccessControlListsItemRuleResult']):
        """
        :param Sequence['GetSwitchAccessControlListsItemRuleArgs'] rules: An ordered array of the access control list rules
        """
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetSwitchAccessControlListsItemRuleResult']:
        """
        An ordered array of the access control list rules
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetSwitchAccessControlListsItemRuleResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 dst_cidr: _builtins.str,
                 dst_port: _builtins.str,
                 ip_version: _builtins.str,
                 policy: _builtins.str,
                 protocol: _builtins.str,
                 src_cidr: _builtins.str,
                 src_port: _builtins.str,
                 vlan: _builtins.str):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dst_cidr: Destination IP address (in IP or CIDR notation)
        :param _builtins.str dst_port: Destination port
        :param _builtins.str ip_version: IP address version
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol
        :param _builtins.str src_cidr: Source IP address (in IP or CIDR notation)
        :param _builtins.str src_port: Source port
        :param _builtins.str vlan: ncoming traffic VLAN
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "dst_cidr", dst_cidr)
        pulumi.set(__self__, "dst_port", dst_port)
        pulumi.set(__self__, "ip_version", ip_version)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "src_cidr", src_cidr)
        pulumi.set(__self__, "src_port", src_port)
        pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="dstCidr")
    def dst_cidr(self) -> _builtins.str:
        """
        Destination IP address (in IP or CIDR notation)
        """
        return pulumi.get(self, "dst_cidr")

    @_builtins.property
    @pulumi.getter(name="dstPort")
    def dst_port(self) -> _builtins.str:
        """
        Destination port
        """
        return pulumi.get(self, "dst_port")

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> _builtins.str:
        """
        IP address version
        """
        return pulumi.get(self, "ip_version")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The type of protocol
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> _builtins.str:
        """
        Source IP address (in IP or CIDR notation)
        """
        return pulumi.get(self, "src_cidr")

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> _builtins.str:
        """
        Source port
        """
        return pulumi.get(self, "src_port")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.str:
        """
        ncoming traffic VLAN
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetSwitchAccessPoliciesItemResult(dict):
    def __init__(__self__, *,
                 access_policy_type: _builtins.str,
                 counts: 'outputs.GetSwitchAccessPoliciesItemCountsResult',
                 dot1x: 'outputs.GetSwitchAccessPoliciesItemDot1xResult',
                 guest_port_bouncing: _builtins.bool,
                 guest_vlan_id: _builtins.int,
                 host_mode: _builtins.str,
                 increase_access_speed: _builtins.bool,
                 name: _builtins.str,
                 radius: 'outputs.GetSwitchAccessPoliciesItemRadiusResult',
                 radius_accounting_enabled: _builtins.bool,
                 radius_accounting_servers: Sequence['outputs.GetSwitchAccessPoliciesItemRadiusAccountingServerResult'],
                 radius_coa_support_enabled: _builtins.bool,
                 radius_group_attribute: _builtins.str,
                 radius_servers: Sequence['outputs.GetSwitchAccessPoliciesItemRadiusServerResult'],
                 radius_testing_enabled: _builtins.bool,
                 url_redirect_walled_garden_enabled: _builtins.bool,
                 url_redirect_walled_garden_ranges: Sequence[_builtins.str],
                 voice_vlan_clients: _builtins.bool):
        """
        :param _builtins.str access_policy_type: Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
        :param 'GetSwitchAccessPoliciesItemCountsArgs' counts: Counts associated with the access policy
        :param 'GetSwitchAccessPoliciesItemDot1xArgs' dot1x: 802.1x Settings
        :param _builtins.bool guest_port_bouncing: If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
        :param _builtins.int guest_vlan_id: ID for the guest VLAN allow unauthorized devices access to limited network resources
        :param _builtins.str host_mode: Choose the Host Mode for the access policy.
        :param _builtins.bool increase_access_speed: Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
        :param _builtins.str name: Name of the access policy
        :param 'GetSwitchAccessPoliciesItemRadiusArgs' radius: Object for RADIUS Settings
        :param _builtins.bool radius_accounting_enabled: Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
        :param Sequence['GetSwitchAccessPoliciesItemRadiusAccountingServerArgs'] radius_accounting_servers: List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
        :param _builtins.bool radius_coa_support_enabled: Change of authentication for RADIUS re-authentication and disconnection
        :param _builtins.str radius_group_attribute: Acceptable values are *''* for None, or *'11'* for Group Policies ACL
        :param Sequence['GetSwitchAccessPoliciesItemRadiusServerArgs'] radius_servers: List of RADIUS servers to require connecting devices to authenticate against before granting network access
        :param _builtins.bool radius_testing_enabled: If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
        :param _builtins.bool url_redirect_walled_garden_enabled: Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication
        :param Sequence[_builtins.str] url_redirect_walled_garden_ranges: IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
        :param _builtins.bool voice_vlan_clients: CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
        """
        pulumi.set(__self__, "access_policy_type", access_policy_type)
        pulumi.set(__self__, "counts", counts)
        pulumi.set(__self__, "dot1x", dot1x)
        pulumi.set(__self__, "guest_port_bouncing", guest_port_bouncing)
        pulumi.set(__self__, "guest_vlan_id", guest_vlan_id)
        pulumi.set(__self__, "host_mode", host_mode)
        pulumi.set(__self__, "increase_access_speed", increase_access_speed)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "radius", radius)
        pulumi.set(__self__, "radius_accounting_enabled", radius_accounting_enabled)
        pulumi.set(__self__, "radius_accounting_servers", radius_accounting_servers)
        pulumi.set(__self__, "radius_coa_support_enabled", radius_coa_support_enabled)
        pulumi.set(__self__, "radius_group_attribute", radius_group_attribute)
        pulumi.set(__self__, "radius_servers", radius_servers)
        pulumi.set(__self__, "radius_testing_enabled", radius_testing_enabled)
        pulumi.set(__self__, "url_redirect_walled_garden_enabled", url_redirect_walled_garden_enabled)
        pulumi.set(__self__, "url_redirect_walled_garden_ranges", url_redirect_walled_garden_ranges)
        pulumi.set(__self__, "voice_vlan_clients", voice_vlan_clients)

    @_builtins.property
    @pulumi.getter(name="accessPolicyType")
    def access_policy_type(self) -> _builtins.str:
        """
        Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
        """
        return pulumi.get(self, "access_policy_type")

    @_builtins.property
    @pulumi.getter
    def counts(self) -> 'outputs.GetSwitchAccessPoliciesItemCountsResult':
        """
        Counts associated with the access policy
        """
        return pulumi.get(self, "counts")

    @_builtins.property
    @pulumi.getter
    def dot1x(self) -> 'outputs.GetSwitchAccessPoliciesItemDot1xResult':
        """
        802.1x Settings
        """
        return pulumi.get(self, "dot1x")

    @_builtins.property
    @pulumi.getter(name="guestPortBouncing")
    def guest_port_bouncing(self) -> _builtins.bool:
        """
        If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
        """
        return pulumi.get(self, "guest_port_bouncing")

    @_builtins.property
    @pulumi.getter(name="guestVlanId")
    def guest_vlan_id(self) -> _builtins.int:
        """
        ID for the guest VLAN allow unauthorized devices access to limited network resources
        """
        return pulumi.get(self, "guest_vlan_id")

    @_builtins.property
    @pulumi.getter(name="hostMode")
    def host_mode(self) -> _builtins.str:
        """
        Choose the Host Mode for the access policy.
        """
        return pulumi.get(self, "host_mode")

    @_builtins.property
    @pulumi.getter(name="increaseAccessSpeed")
    def increase_access_speed(self) -> _builtins.bool:
        """
        Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
        """
        return pulumi.get(self, "increase_access_speed")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the access policy
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def radius(self) -> 'outputs.GetSwitchAccessPoliciesItemRadiusResult':
        """
        Object for RADIUS Settings
        """
        return pulumi.get(self, "radius")

    @_builtins.property
    @pulumi.getter(name="radiusAccountingEnabled")
    def radius_accounting_enabled(self) -> _builtins.bool:
        """
        Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
        """
        return pulumi.get(self, "radius_accounting_enabled")

    @_builtins.property
    @pulumi.getter(name="radiusAccountingServers")
    def radius_accounting_servers(self) -> Sequence['outputs.GetSwitchAccessPoliciesItemRadiusAccountingServerResult']:
        """
        List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
        """
        return pulumi.get(self, "radius_accounting_servers")

    @_builtins.property
    @pulumi.getter(name="radiusCoaSupportEnabled")
    def radius_coa_support_enabled(self) -> _builtins.bool:
        """
        Change of authentication for RADIUS re-authentication and disconnection
        """
        return pulumi.get(self, "radius_coa_support_enabled")

    @_builtins.property
    @pulumi.getter(name="radiusGroupAttribute")
    def radius_group_attribute(self) -> _builtins.str:
        """
        Acceptable values are *''* for None, or *'11'* for Group Policies ACL
        """
        return pulumi.get(self, "radius_group_attribute")

    @_builtins.property
    @pulumi.getter(name="radiusServers")
    def radius_servers(self) -> Sequence['outputs.GetSwitchAccessPoliciesItemRadiusServerResult']:
        """
        List of RADIUS servers to require connecting devices to authenticate against before granting network access
        """
        return pulumi.get(self, "radius_servers")

    @_builtins.property
    @pulumi.getter(name="radiusTestingEnabled")
    def radius_testing_enabled(self) -> _builtins.bool:
        """
        If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
        """
        return pulumi.get(self, "radius_testing_enabled")

    @_builtins.property
    @pulumi.getter(name="urlRedirectWalledGardenEnabled")
    def url_redirect_walled_garden_enabled(self) -> _builtins.bool:
        """
        Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication
        """
        return pulumi.get(self, "url_redirect_walled_garden_enabled")

    @_builtins.property
    @pulumi.getter(name="urlRedirectWalledGardenRanges")
    def url_redirect_walled_garden_ranges(self) -> Sequence[_builtins.str]:
        """
        IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
        """
        return pulumi.get(self, "url_redirect_walled_garden_ranges")

    @_builtins.property
    @pulumi.getter(name="voiceVlanClients")
    def voice_vlan_clients(self) -> _builtins.bool:
        """
        CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
        """
        return pulumi.get(self, "voice_vlan_clients")


@pulumi.output_type
class GetSwitchAccessPoliciesItemCountsResult(dict):
    def __init__(__self__, *,
                 ports: 'outputs.GetSwitchAccessPoliciesItemCountsPortsResult'):
        """
        :param 'GetSwitchAccessPoliciesItemCountsPortsArgs' ports: Counts associated with ports
        """
        pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> 'outputs.GetSwitchAccessPoliciesItemCountsPortsResult':
        """
        Counts associated with ports
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class GetSwitchAccessPoliciesItemCountsPortsResult(dict):
    def __init__(__self__, *,
                 with_this_policy: _builtins.int):
        """
        :param _builtins.int with_this_policy: Number of ports in the network with this policy. For template networks, this is the number of template ports (not child ports) with this policy.
        """
        pulumi.set(__self__, "with_this_policy", with_this_policy)

    @_builtins.property
    @pulumi.getter(name="withThisPolicy")
    def with_this_policy(self) -> _builtins.int:
        """
        Number of ports in the network with this policy. For template networks, this is the number of template ports (not child ports) with this policy.
        """
        return pulumi.get(self, "with_this_policy")


@pulumi.output_type
class GetSwitchAccessPoliciesItemDot1xResult(dict):
    def __init__(__self__, *,
                 control_direction: _builtins.str):
        """
        :param _builtins.str control_direction: Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
        """
        pulumi.set(__self__, "control_direction", control_direction)

    @_builtins.property
    @pulumi.getter(name="controlDirection")
    def control_direction(self) -> _builtins.str:
        """
        Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
        """
        return pulumi.get(self, "control_direction")


@pulumi.output_type
class GetSwitchAccessPoliciesItemRadiusResult(dict):
    def __init__(__self__, *,
                 critical_auth: 'outputs.GetSwitchAccessPoliciesItemRadiusCriticalAuthResult',
                 failed_auth_vlan_id: _builtins.int,
                 re_authentication_interval: _builtins.int):
        """
        :param 'GetSwitchAccessPoliciesItemRadiusCriticalAuthArgs' critical_auth: Critical auth settings for when authentication is rejected by the RADIUS server
        :param _builtins.int failed_auth_vlan_id: VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        :param _builtins.int re_authentication_interval: Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
        """
        pulumi.set(__self__, "critical_auth", critical_auth)
        pulumi.set(__self__, "failed_auth_vlan_id", failed_auth_vlan_id)
        pulumi.set(__self__, "re_authentication_interval", re_authentication_interval)

    @_builtins.property
    @pulumi.getter(name="criticalAuth")
    def critical_auth(self) -> 'outputs.GetSwitchAccessPoliciesItemRadiusCriticalAuthResult':
        """
        Critical auth settings for when authentication is rejected by the RADIUS server
        """
        return pulumi.get(self, "critical_auth")

    @_builtins.property
    @pulumi.getter(name="failedAuthVlanId")
    def failed_auth_vlan_id(self) -> _builtins.int:
        """
        VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        return pulumi.get(self, "failed_auth_vlan_id")

    @_builtins.property
    @pulumi.getter(name="reAuthenticationInterval")
    def re_authentication_interval(self) -> _builtins.int:
        """
        Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
        """
        return pulumi.get(self, "re_authentication_interval")


@pulumi.output_type
class GetSwitchAccessPoliciesItemRadiusAccountingServerResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str host: Public IP address of the RADIUS accounting server
        :param _builtins.int port: UDP port that the RADIUS Accounting server listens on for access requests
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Public IP address of the RADIUS accounting server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        UDP port that the RADIUS Accounting server listens on for access requests
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetSwitchAccessPoliciesItemRadiusCriticalAuthResult(dict):
    def __init__(__self__, *,
                 data_vlan_id: _builtins.int,
                 suspend_port_bounce: _builtins.bool,
                 voice_vlan_id: _builtins.int):
        """
        :param _builtins.int data_vlan_id: VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        :param _builtins.bool suspend_port_bounce: Enable to suspend port bounce when RADIUS servers are unreachable
        :param _builtins.int voice_vlan_id: VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        pulumi.set(__self__, "data_vlan_id", data_vlan_id)
        pulumi.set(__self__, "suspend_port_bounce", suspend_port_bounce)
        pulumi.set(__self__, "voice_vlan_id", voice_vlan_id)

    @_builtins.property
    @pulumi.getter(name="dataVlanId")
    def data_vlan_id(self) -> _builtins.int:
        """
        VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        return pulumi.get(self, "data_vlan_id")

    @_builtins.property
    @pulumi.getter(name="suspendPortBounce")
    def suspend_port_bounce(self) -> _builtins.bool:
        """
        Enable to suspend port bounce when RADIUS servers are unreachable
        """
        return pulumi.get(self, "suspend_port_bounce")

    @_builtins.property
    @pulumi.getter(name="voiceVlanId")
    def voice_vlan_id(self) -> _builtins.int:
        """
        VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        return pulumi.get(self, "voice_vlan_id")


@pulumi.output_type
class GetSwitchAccessPoliciesItemRadiusServerResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str host: Public IP address of the RADIUS server
        :param _builtins.int port: UDP port that the RADIUS server listens on for access requests
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Public IP address of the RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        UDP port that the RADIUS server listens on for access requests
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetSwitchAlternateManagementInterfaceItemResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 protocols: Sequence[_builtins.str],
                 switches: Sequence['outputs.GetSwitchAlternateManagementInterfaceItemSwitchResult'],
                 vlan_id: _builtins.int):
        """
        :param _builtins.bool enabled: Boolean value to enable or disable AMI configuration. If enabled, VLAN and protocols must be set
        :param Sequence[_builtins.str] protocols: Can be one or more of the following values: 'radius', 'snmp' or 'syslog'
        :param Sequence['GetSwitchAlternateManagementInterfaceItemSwitchArgs'] switches: Array of switch serial number and IP assignment. If parameter is present, it cannot have empty body. Note: switches parameter is not applicable for template networks, in other words, do not put 'switches' in the body when updating template networks. Also, an empty 'switches' array will remove all previous assignments
        :param _builtins.int vlan_id: Alternate management VLAN, must be between 1 and 4094
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "protocols", protocols)
        pulumi.set(__self__, "switches", switches)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Boolean value to enable or disable AMI configuration. If enabled, VLAN and protocols must be set
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Sequence[_builtins.str]:
        """
        Can be one or more of the following values: 'radius', 'snmp' or 'syslog'
        """
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter
    def switches(self) -> Sequence['outputs.GetSwitchAlternateManagementInterfaceItemSwitchResult']:
        """
        Array of switch serial number and IP assignment. If parameter is present, it cannot have empty body. Note: switches parameter is not applicable for template networks, in other words, do not put 'switches' in the body when updating template networks. Also, an empty 'switches' array will remove all previous assignments
        """
        return pulumi.get(self, "switches")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.int:
        """
        Alternate management VLAN, must be between 1 and 4094
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetSwitchAlternateManagementInterfaceItemSwitchResult(dict):
    def __init__(__self__, *,
                 alternate_management_ip: _builtins.str,
                 gateway: _builtins.str,
                 serial: _builtins.str,
                 subnet_mask: _builtins.str):
        """
        :param _builtins.str alternate_management_ip: Switch alternative management IP. To remove a prior IP setting, provide an empty string
        :param _builtins.str gateway: Switch gateway must be in IP format. Only and must be specified for Polaris switches
        :param _builtins.str serial: Switch serial number
        :param _builtins.str subnet_mask: Switch subnet mask must be in IP format. Only and must be specified for Polaris switches
        """
        pulumi.set(__self__, "alternate_management_ip", alternate_management_ip)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "subnet_mask", subnet_mask)

    @_builtins.property
    @pulumi.getter(name="alternateManagementIp")
    def alternate_management_ip(self) -> _builtins.str:
        """
        Switch alternative management IP. To remove a prior IP setting, provide an empty string
        """
        return pulumi.get(self, "alternate_management_ip")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        Switch gateway must be in IP format. Only and must be specified for Polaris switches
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Switch serial number
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> _builtins.str:
        """
        Switch subnet mask must be in IP format. Only and must be specified for Polaris switches
        """
        return pulumi.get(self, "subnet_mask")


@pulumi.output_type
class GetSwitchDhcpServerPolicyArpInspectionTrustedServersItemResult(dict):
    def __init__(__self__, *,
                 ipv4: 'outputs.GetSwitchDhcpServerPolicyArpInspectionTrustedServersItemIpv4Result',
                 mac: _builtins.str,
                 trusted_server_id: _builtins.str,
                 vlan: _builtins.int):
        """
        :param 'GetSwitchDhcpServerPolicyArpInspectionTrustedServersItemIpv4Args' ipv4: IPv4 attributes of the trusted server.
        :param _builtins.str mac: Mac address of the trusted server.
        :param _builtins.str trusted_server_id: ID of the trusted server.
        :param _builtins.int vlan: Vlan ID of the trusted server.
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "trusted_server_id", trusted_server_id)
        pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> 'outputs.GetSwitchDhcpServerPolicyArpInspectionTrustedServersItemIpv4Result':
        """
        IPv4 attributes of the trusted server.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Mac address of the trusted server.
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter(name="trustedServerId")
    def trusted_server_id(self) -> _builtins.str:
        """
        ID of the trusted server.
        """
        return pulumi.get(self, "trusted_server_id")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.int:
        """
        Vlan ID of the trusted server.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetSwitchDhcpServerPolicyArpInspectionTrustedServersItemIpv4Result(dict):
    def __init__(__self__, *,
                 address: _builtins.str):
        """
        :param _builtins.str address: IPv4 address of the trusted server.
        """
        pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        IPv4 address of the trusted server.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class GetSwitchDhcpServerPolicyArpInspectionWarningsByDeviceItemResult(dict):
    def __init__(__self__, *,
                 has_trusted_port: _builtins.bool,
                 name: _builtins.str,
                 serial: _builtins.str,
                 supports_inspection: _builtins.bool,
                 url: _builtins.str):
        """
        :param _builtins.bool has_trusted_port: Whether this switch has a trusted DAI port. Always false if supportsInspection is false.
        :param _builtins.str name: Switch name.
        :param _builtins.str serial: Switch serial.
        :param _builtins.bool supports_inspection: Whether this switch supports Dynamic ARP Inspection.
        :param _builtins.str url: Url link to switch.
        """
        pulumi.set(__self__, "has_trusted_port", has_trusted_port)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "supports_inspection", supports_inspection)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="hasTrustedPort")
    def has_trusted_port(self) -> _builtins.bool:
        """
        Whether this switch has a trusted DAI port. Always false if supportsInspection is false.
        """
        return pulumi.get(self, "has_trusted_port")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Switch name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Switch serial.
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="supportsInspection")
    def supports_inspection(self) -> _builtins.bool:
        """
        Whether this switch supports Dynamic ARP Inspection.
        """
        return pulumi.get(self, "supports_inspection")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Url link to switch.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetSwitchDhcpServerPolicyItemResult(dict):
    def __init__(__self__, *,
                 alerts: 'outputs.GetSwitchDhcpServerPolicyItemAlertsResult',
                 allowed_servers: Sequence[_builtins.str],
                 arp_inspection: 'outputs.GetSwitchDhcpServerPolicyItemArpInspectionResult',
                 blocked_servers: Sequence[_builtins.str],
                 default_policy: _builtins.str):
        """
        :param 'GetSwitchDhcpServerPolicyItemAlertsArgs' alerts: Email alert settings for DHCP servers
        :param Sequence[_builtins.str] allowed_servers: List the MAC addresses of DHCP servers to permit on the network when defaultPolicy is set
                 to block.An empty array will clear the entries.
        :param 'GetSwitchDhcpServerPolicyItemArpInspectionArgs' arp_inspection: Dynamic ARP Inspection settings
        :param Sequence[_builtins.str] blocked_servers: List the MAC addresses of DHCP servers to block on the network when defaultPolicy is set
                 to allow.An empty array will clear the entries.
        :param _builtins.str default_policy: 'allow' or 'block' new DHCP servers. Default value is 'allow'.
        """
        pulumi.set(__self__, "alerts", alerts)
        pulumi.set(__self__, "allowed_servers", allowed_servers)
        pulumi.set(__self__, "arp_inspection", arp_inspection)
        pulumi.set(__self__, "blocked_servers", blocked_servers)
        pulumi.set(__self__, "default_policy", default_policy)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> 'outputs.GetSwitchDhcpServerPolicyItemAlertsResult':
        """
        Email alert settings for DHCP servers
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter(name="allowedServers")
    def allowed_servers(self) -> Sequence[_builtins.str]:
        """
        List the MAC addresses of DHCP servers to permit on the network when defaultPolicy is set
          to block.An empty array will clear the entries.
        """
        return pulumi.get(self, "allowed_servers")

    @_builtins.property
    @pulumi.getter(name="arpInspection")
    def arp_inspection(self) -> 'outputs.GetSwitchDhcpServerPolicyItemArpInspectionResult':
        """
        Dynamic ARP Inspection settings
        """
        return pulumi.get(self, "arp_inspection")

    @_builtins.property
    @pulumi.getter(name="blockedServers")
    def blocked_servers(self) -> Sequence[_builtins.str]:
        """
        List the MAC addresses of DHCP servers to block on the network when defaultPolicy is set
          to allow.An empty array will clear the entries.
        """
        return pulumi.get(self, "blocked_servers")

    @_builtins.property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> _builtins.str:
        """
        'allow' or 'block' new DHCP servers. Default value is 'allow'.
        """
        return pulumi.get(self, "default_policy")


@pulumi.output_type
class GetSwitchDhcpServerPolicyItemAlertsResult(dict):
    def __init__(__self__, *,
                 email: 'outputs.GetSwitchDhcpServerPolicyItemAlertsEmailResult'):
        """
        :param 'GetSwitchDhcpServerPolicyItemAlertsEmailArgs' email: Alert settings for DHCP servers
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> 'outputs.GetSwitchDhcpServerPolicyItemAlertsEmailResult':
        """
        Alert settings for DHCP servers
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetSwitchDhcpServerPolicyItemAlertsEmailResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: When enabled, send an email if a new DHCP server is seen. Default value is false.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        When enabled, send an email if a new DHCP server is seen. Default value is false.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetSwitchDhcpServerPolicyItemArpInspectionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 unsupported_models: Sequence[_builtins.str]):
        """
        :param _builtins.bool enabled: Enable or disable Dynamic ARP Inspection on the network. Default value is false.
        :param Sequence[_builtins.str] unsupported_models: List of switch models that does not support dynamic ARP inspection
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "unsupported_models", unsupported_models)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable or disable Dynamic ARP Inspection on the network. Default value is false.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="unsupportedModels")
    def unsupported_models(self) -> Sequence[_builtins.str]:
        """
        List of switch models that does not support dynamic ARP inspection
        """
        return pulumi.get(self, "unsupported_models")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 device: 'outputs.GetSwitchDhcpV4ServersSeenItemDeviceResult',
                 ipv4: 'outputs.GetSwitchDhcpV4ServersSeenItemIpv4Result',
                 is_allowed: _builtins.bool,
                 is_configured: _builtins.bool,
                 last_ack: 'outputs.GetSwitchDhcpV4ServersSeenItemLastAckResult',
                 last_packet: 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketResult',
                 last_seen_at: _builtins.str,
                 mac: _builtins.str,
                 seen_bies: Sequence['outputs.GetSwitchDhcpV4ServersSeenItemSeenByResult'],
                 type: _builtins.str,
                 vlan: _builtins.int):
        """
        :param _builtins.str client_id: Client id of the server if available.
        :param 'GetSwitchDhcpV4ServersSeenItemDeviceArgs' device: Attributes of the server when it's a device.
        :param 'GetSwitchDhcpV4ServersSeenItemIpv4Args' ipv4: IPv4 attributes of the server.
        :param _builtins.bool is_allowed: Whether the server is allowed or blocked. Always true for configured servers.
        :param _builtins.bool is_configured: Whether the server is configured.
        :param 'GetSwitchDhcpV4ServersSeenItemLastAckArgs' last_ack: Attributes of the server's last ack.
        :param 'GetSwitchDhcpV4ServersSeenItemLastPacketArgs' last_packet: Last packet the server received.
        :param _builtins.str last_seen_at: Last time the server was seen.
        :param _builtins.str mac: Mac address of the server.
        :param Sequence['GetSwitchDhcpV4ServersSeenItemSeenByArgs'] seen_bies: Devices that saw the server.
        :param _builtins.str type: server type. Can be a 'device', 'stack', or 'discovered' (i.e client).
        :param _builtins.int vlan: Vlan id of the server.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "is_allowed", is_allowed)
        pulumi.set(__self__, "is_configured", is_configured)
        pulumi.set(__self__, "last_ack", last_ack)
        pulumi.set(__self__, "last_packet", last_packet)
        pulumi.set(__self__, "last_seen_at", last_seen_at)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "seen_bies", seen_bies)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Client id of the server if available.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def device(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemDeviceResult':
        """
        Attributes of the server when it's a device.
        """
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemIpv4Result':
        """
        IPv4 attributes of the server.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter(name="isAllowed")
    def is_allowed(self) -> _builtins.bool:
        """
        Whether the server is allowed or blocked. Always true for configured servers.
        """
        return pulumi.get(self, "is_allowed")

    @_builtins.property
    @pulumi.getter(name="isConfigured")
    def is_configured(self) -> _builtins.bool:
        """
        Whether the server is configured.
        """
        return pulumi.get(self, "is_configured")

    @_builtins.property
    @pulumi.getter(name="lastAck")
    def last_ack(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemLastAckResult':
        """
        Attributes of the server's last ack.
        """
        return pulumi.get(self, "last_ack")

    @_builtins.property
    @pulumi.getter(name="lastPacket")
    def last_packet(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketResult':
        """
        Last packet the server received.
        """
        return pulumi.get(self, "last_packet")

    @_builtins.property
    @pulumi.getter(name="lastSeenAt")
    def last_seen_at(self) -> _builtins.str:
        """
        Last time the server was seen.
        """
        return pulumi.get(self, "last_seen_at")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Mac address of the server.
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter(name="seenBies")
    def seen_bies(self) -> Sequence['outputs.GetSwitchDhcpV4ServersSeenItemSeenByResult']:
        """
        Devices that saw the server.
        """
        return pulumi.get(self, "seen_bies")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        server type. Can be a 'device', 'stack', or 'discovered' (i.e client).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.int:
        """
        Vlan id of the server.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemDeviceResult(dict):
    def __init__(__self__, *,
                 interface: 'outputs.GetSwitchDhcpV4ServersSeenItemDeviceInterfaceResult',
                 name: _builtins.str,
                 serial: _builtins.str,
                 url: _builtins.str):
        """
        :param 'GetSwitchDhcpV4ServersSeenItemDeviceInterfaceArgs' interface: Interface attributes of the server. Only for configured servers.
        :param _builtins.str name: Device name.
        :param _builtins.str serial: Device serial.
        :param _builtins.str url: Url link to device.
        """
        pulumi.set(__self__, "interface", interface)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemDeviceInterfaceResult':
        """
        Interface attributes of the server. Only for configured servers.
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Device name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Device serial.
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Url link to device.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemDeviceInterfaceResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str name: Interface name.
        :param _builtins.str url: Url link to interface.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Interface name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Url link to interface.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemIpv4Result(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 gateway: _builtins.str,
                 subnet: _builtins.str):
        """
        :param _builtins.str address: IPv4 address of the server.
        :param _builtins.str gateway: IPv4 gateway address of the server.
        :param _builtins.str subnet: Subnet of the server.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        IPv4 address of the server.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        IPv4 gateway address of the server.
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        Subnet of the server.
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastAckResult(dict):
    def __init__(__self__, *,
                 ipv4: 'outputs.GetSwitchDhcpV4ServersSeenItemLastAckIpv4Result',
                 ts: _builtins.str):
        """
        :param 'GetSwitchDhcpV4ServersSeenItemLastAckIpv4Args' ipv4: IPv4 attributes of the last ack.
        :param _builtins.str ts: Last time the server was acked.
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ts", ts)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemLastAckIpv4Result':
        """
        IPv4 attributes of the last ack.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def ts(self) -> _builtins.str:
        """
        Last time the server was acked.
        """
        return pulumi.get(self, "ts")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastAckIpv4Result(dict):
    def __init__(__self__, *,
                 address: _builtins.str):
        """
        :param _builtins.str address: IPv4 address of the last ack.
        """
        pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        IPv4 address of the last ack.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastPacketResult(dict):
    def __init__(__self__, *,
                 destination: 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketDestinationResult',
                 ethernet: 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketEthernetResult',
                 fields: 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketFieldsResult',
                 ip: 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketIpResult',
                 source: 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketSourceResult',
                 type: _builtins.str,
                 udp: 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketUdpResult'):
        """
        :param 'GetSwitchDhcpV4ServersSeenItemLastPacketDestinationArgs' destination: Destination of the packet.
        :param 'GetSwitchDhcpV4ServersSeenItemLastPacketEthernetArgs' ethernet: Additional ethernet attributes of the packet.
        :param 'GetSwitchDhcpV4ServersSeenItemLastPacketFieldsArgs' fields: DHCP-specific fields of the packet.
        :param 'GetSwitchDhcpV4ServersSeenItemLastPacketIpArgs' ip: Additional IP attributes of the packet.
        :param 'GetSwitchDhcpV4ServersSeenItemLastPacketSourceArgs' source: Source of the packet.
        :param _builtins.str type: Packet type.
        :param 'GetSwitchDhcpV4ServersSeenItemLastPacketUdpArgs' udp: UDP attributes of the packet.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "ethernet", ethernet)
        pulumi.set(__self__, "fields", fields)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "udp", udp)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketDestinationResult':
        """
        Destination of the packet.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def ethernet(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketEthernetResult':
        """
        Additional ethernet attributes of the packet.
        """
        return pulumi.get(self, "ethernet")

    @_builtins.property
    @pulumi.getter
    def fields(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketFieldsResult':
        """
        DHCP-specific fields of the packet.
        """
        return pulumi.get(self, "fields")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketIpResult':
        """
        Additional IP attributes of the packet.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def source(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketSourceResult':
        """
        Source of the packet.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Packet type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketUdpResult':
        """
        UDP attributes of the packet.
        """
        return pulumi.get(self, "udp")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastPacketDestinationResult(dict):
    def __init__(__self__, *,
                 ipv4: 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketDestinationIpv4Result',
                 mac: _builtins.str,
                 port: _builtins.int):
        """
        :param 'GetSwitchDhcpV4ServersSeenItemLastPacketDestinationIpv4Args' ipv4: Destination ipv4 attributes of the packet.
        :param _builtins.str mac: Destination mac address of the packet.
        :param _builtins.int port: Destination port of the packet.
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketDestinationIpv4Result':
        """
        Destination ipv4 attributes of the packet.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Destination mac address of the packet.
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Destination port of the packet.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastPacketDestinationIpv4Result(dict):
    def __init__(__self__, *,
                 address: _builtins.str):
        """
        :param _builtins.str address: Destination ipv4 address of the packet.
        """
        pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Destination ipv4 address of the packet.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastPacketEthernetResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Ethernet type of the packet.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Ethernet type of the packet.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastPacketFieldsResult(dict):
    def __init__(__self__, *,
                 chaddr: _builtins.str,
                 ciaddr: _builtins.str,
                 flags: _builtins.str,
                 giaddr: _builtins.str,
                 hlen: _builtins.int,
                 hops: _builtins.int,
                 htype: _builtins.int,
                 magic_cookie: _builtins.str,
                 op: _builtins.int,
                 options: Sequence['outputs.GetSwitchDhcpV4ServersSeenItemLastPacketFieldsOptionResult'],
                 secs: _builtins.int,
                 siaddr: _builtins.str,
                 sname: _builtins.str,
                 xid: _builtins.str,
                 yiaddr: _builtins.str):
        """
        :param _builtins.str chaddr: Client hardware address of the packet.
        :param _builtins.str ciaddr: Client IP address of the packet.
        :param _builtins.str flags: Packet flags.
        :param _builtins.str giaddr: Gateway IP address of the packet.
        :param _builtins.int hlen: Hardware length of the packet.
        :param _builtins.int hops: Number of hops the packet took.
        :param _builtins.int htype: Hardware type code of the packet.
        :param _builtins.str magic_cookie: Magic cookie of the packet.
        :param _builtins.int op: Operation code of the packet.
        :param Sequence['GetSwitchDhcpV4ServersSeenItemLastPacketFieldsOptionArgs'] options: Additional DHCP options of the packet.
        :param _builtins.int secs: Number of seconds since receiving the packet.
        :param _builtins.str siaddr: Server IP address of the packet.
        :param _builtins.str sname: Server identifier address of the packet.
        :param _builtins.str xid: Transaction id of the packet.
        :param _builtins.str yiaddr: Assigned IP address of the packet.
        """
        pulumi.set(__self__, "chaddr", chaddr)
        pulumi.set(__self__, "ciaddr", ciaddr)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "giaddr", giaddr)
        pulumi.set(__self__, "hlen", hlen)
        pulumi.set(__self__, "hops", hops)
        pulumi.set(__self__, "htype", htype)
        pulumi.set(__self__, "magic_cookie", magic_cookie)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "secs", secs)
        pulumi.set(__self__, "siaddr", siaddr)
        pulumi.set(__self__, "sname", sname)
        pulumi.set(__self__, "xid", xid)
        pulumi.set(__self__, "yiaddr", yiaddr)

    @_builtins.property
    @pulumi.getter
    def chaddr(self) -> _builtins.str:
        """
        Client hardware address of the packet.
        """
        return pulumi.get(self, "chaddr")

    @_builtins.property
    @pulumi.getter
    def ciaddr(self) -> _builtins.str:
        """
        Client IP address of the packet.
        """
        return pulumi.get(self, "ciaddr")

    @_builtins.property
    @pulumi.getter
    def flags(self) -> _builtins.str:
        """
        Packet flags.
        """
        return pulumi.get(self, "flags")

    @_builtins.property
    @pulumi.getter
    def giaddr(self) -> _builtins.str:
        """
        Gateway IP address of the packet.
        """
        return pulumi.get(self, "giaddr")

    @_builtins.property
    @pulumi.getter
    def hlen(self) -> _builtins.int:
        """
        Hardware length of the packet.
        """
        return pulumi.get(self, "hlen")

    @_builtins.property
    @pulumi.getter
    def hops(self) -> _builtins.int:
        """
        Number of hops the packet took.
        """
        return pulumi.get(self, "hops")

    @_builtins.property
    @pulumi.getter
    def htype(self) -> _builtins.int:
        """
        Hardware type code of the packet.
        """
        return pulumi.get(self, "htype")

    @_builtins.property
    @pulumi.getter(name="magicCookie")
    def magic_cookie(self) -> _builtins.str:
        """
        Magic cookie of the packet.
        """
        return pulumi.get(self, "magic_cookie")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.int:
        """
        Operation code of the packet.
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Sequence['outputs.GetSwitchDhcpV4ServersSeenItemLastPacketFieldsOptionResult']:
        """
        Additional DHCP options of the packet.
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def secs(self) -> _builtins.int:
        """
        Number of seconds since receiving the packet.
        """
        return pulumi.get(self, "secs")

    @_builtins.property
    @pulumi.getter
    def siaddr(self) -> _builtins.str:
        """
        Server IP address of the packet.
        """
        return pulumi.get(self, "siaddr")

    @_builtins.property
    @pulumi.getter
    def sname(self) -> _builtins.str:
        """
        Server identifier address of the packet.
        """
        return pulumi.get(self, "sname")

    @_builtins.property
    @pulumi.getter
    def xid(self) -> _builtins.str:
        """
        Transaction id of the packet.
        """
        return pulumi.get(self, "xid")

    @_builtins.property
    @pulumi.getter
    def yiaddr(self) -> _builtins.str:
        """
        Assigned IP address of the packet.
        """
        return pulumi.get(self, "yiaddr")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastPacketFieldsOptionResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Option name.
        :param _builtins.str value: Option value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Option name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Option value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastPacketIpResult(dict):
    def __init__(__self__, *,
                 dscp: 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketIpDscpResult',
                 header_length: _builtins.int,
                 id: _builtins.str,
                 length: _builtins.int,
                 protocol: _builtins.int,
                 ttl: _builtins.int,
                 version: _builtins.int):
        """
        :param 'GetSwitchDhcpV4ServersSeenItemLastPacketIpDscpArgs' dscp: DSCP attributes of the packet.
        :param _builtins.int header_length: IP header length of the packet.
        :param _builtins.str id: IP ID of the packet.
        :param _builtins.int length: IP length of the packet.
        :param _builtins.int protocol: IP protocol number of the packet.
        :param _builtins.int ttl: Time to live of the packet.
        :param _builtins.int version: IP version of the packet.
        """
        pulumi.set(__self__, "dscp", dscp)
        pulumi.set(__self__, "header_length", header_length)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def dscp(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketIpDscpResult':
        """
        DSCP attributes of the packet.
        """
        return pulumi.get(self, "dscp")

    @_builtins.property
    @pulumi.getter(name="headerLength")
    def header_length(self) -> _builtins.int:
        """
        IP header length of the packet.
        """
        return pulumi.get(self, "header_length")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        IP ID of the packet.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def length(self) -> _builtins.int:
        """
        IP length of the packet.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.int:
        """
        IP protocol number of the packet.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        Time to live of the packet.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        IP version of the packet.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastPacketIpDscpResult(dict):
    def __init__(__self__, *,
                 ecn: _builtins.int,
                 tag: _builtins.int):
        """
        :param _builtins.int ecn: ECN number of the packet.
        :param _builtins.int tag: DSCP tag number of the packet.
        """
        pulumi.set(__self__, "ecn", ecn)
        pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def ecn(self) -> _builtins.int:
        """
        ECN number of the packet.
        """
        return pulumi.get(self, "ecn")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.int:
        """
        DSCP tag number of the packet.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastPacketSourceResult(dict):
    def __init__(__self__, *,
                 ipv4: 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketSourceIpv4Result',
                 mac: _builtins.str,
                 port: _builtins.int):
        """
        :param 'GetSwitchDhcpV4ServersSeenItemLastPacketSourceIpv4Args' ipv4: Source ipv4 attributes of the packet.
        :param _builtins.str mac: Source mac address of the packet.
        :param _builtins.int port: Source port of the packet.
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> 'outputs.GetSwitchDhcpV4ServersSeenItemLastPacketSourceIpv4Result':
        """
        Source ipv4 attributes of the packet.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Source mac address of the packet.
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Source port of the packet.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastPacketSourceIpv4Result(dict):
    def __init__(__self__, *,
                 address: _builtins.str):
        """
        :param _builtins.str address: Source ipv4 address of the packet.
        """
        pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Source ipv4 address of the packet.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemLastPacketUdpResult(dict):
    def __init__(__self__, *,
                 checksum: _builtins.str,
                 length: _builtins.int):
        """
        :param _builtins.str checksum: UDP checksum of the packet.
        :param _builtins.int length: UDP length of the packet.
        """
        pulumi.set(__self__, "checksum", checksum)
        pulumi.set(__self__, "length", length)

    @_builtins.property
    @pulumi.getter
    def checksum(self) -> _builtins.str:
        """
        UDP checksum of the packet.
        """
        return pulumi.get(self, "checksum")

    @_builtins.property
    @pulumi.getter
    def length(self) -> _builtins.int:
        """
        UDP length of the packet.
        """
        return pulumi.get(self, "length")


@pulumi.output_type
class GetSwitchDhcpV4ServersSeenItemSeenByResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 serial: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str name: Device name.
        :param _builtins.str serial: Device serial.
        :param _builtins.str url: Url link to device.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Device name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Device serial.
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Url link to device.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetSwitchDscpToCosMappingsItemResult(dict):
    def __init__(__self__, *,
                 mappings: Sequence['outputs.GetSwitchDscpToCosMappingsItemMappingResult']):
        """
        :param Sequence['GetSwitchDscpToCosMappingsItemMappingArgs'] mappings: An array of DSCP to CoS mappings. An empty array will reset the mappings to default.
        """
        pulumi.set(__self__, "mappings", mappings)

    @_builtins.property
    @pulumi.getter
    def mappings(self) -> Sequence['outputs.GetSwitchDscpToCosMappingsItemMappingResult']:
        """
        An array of DSCP to CoS mappings. An empty array will reset the mappings to default.
        """
        return pulumi.get(self, "mappings")


@pulumi.output_type
class GetSwitchDscpToCosMappingsItemMappingResult(dict):
    def __init__(__self__, *,
                 cos: _builtins.int,
                 dscp: _builtins.int,
                 title: _builtins.str):
        """
        :param _builtins.int cos: The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
        :param _builtins.int dscp: The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
        :param _builtins.str title: Label for the mapping (optional).
        """
        pulumi.set(__self__, "cos", cos)
        pulumi.set(__self__, "dscp", dscp)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def cos(self) -> _builtins.int:
        """
        The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
        """
        return pulumi.get(self, "cos")

    @_builtins.property
    @pulumi.getter
    def dscp(self) -> _builtins.int:
        """
        The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
        """
        return pulumi.get(self, "dscp")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        Label for the mapping (optional).
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSwitchLinkAggregationsItemResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 switch_ports: Sequence['outputs.GetSwitchLinkAggregationsItemSwitchPortResult']):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "switch_ports", switch_ports)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="switchPorts")
    def switch_ports(self) -> Sequence['outputs.GetSwitchLinkAggregationsItemSwitchPortResult']:
        return pulumi.get(self, "switch_ports")


@pulumi.output_type
class GetSwitchLinkAggregationsItemSwitchPortResult(dict):
    def __init__(__self__, *,
                 port_id: _builtins.str,
                 serial: _builtins.str):
        pulumi.set(__self__, "port_id", port_id)
        pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        return pulumi.get(self, "serial")


@pulumi.output_type
class GetSwitchMtuItemResult(dict):
    def __init__(__self__, *,
                 default_mtu_size: _builtins.int,
                 overrides: Sequence['outputs.GetSwitchMtuItemOverrideResult']):
        """
        :param _builtins.int default_mtu_size: MTU size for the entire network. Default value is 9578.
        :param Sequence['GetSwitchMtuItemOverrideArgs'] overrides: Override MTU size for individual switches or switch templates.
                 An empty array will clear overrides.
        """
        pulumi.set(__self__, "default_mtu_size", default_mtu_size)
        pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="defaultMtuSize")
    def default_mtu_size(self) -> _builtins.int:
        """
        MTU size for the entire network. Default value is 9578.
        """
        return pulumi.get(self, "default_mtu_size")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Sequence['outputs.GetSwitchMtuItemOverrideResult']:
        """
        Override MTU size for individual switches or switch templates.
          An empty array will clear overrides.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class GetSwitchMtuItemOverrideResult(dict):
    def __init__(__self__, *,
                 mtu_size: _builtins.int,
                 switch_profiles: Sequence[_builtins.str],
                 switches: Sequence[_builtins.str]):
        """
        :param _builtins.int mtu_size: MTU size for the switches or switch templates.
        :param Sequence[_builtins.str] switch_profiles: List of switch template IDs. Applicable only for template network.
        :param Sequence[_builtins.str] switches: List of switch serials. Applicable only for switch network.
        """
        pulumi.set(__self__, "mtu_size", mtu_size)
        pulumi.set(__self__, "switch_profiles", switch_profiles)
        pulumi.set(__self__, "switches", switches)

    @_builtins.property
    @pulumi.getter(name="mtuSize")
    def mtu_size(self) -> _builtins.int:
        """
        MTU size for the switches or switch templates.
        """
        return pulumi.get(self, "mtu_size")

    @_builtins.property
    @pulumi.getter(name="switchProfiles")
    def switch_profiles(self) -> Sequence[_builtins.str]:
        """
        List of switch template IDs. Applicable only for template network.
        """
        return pulumi.get(self, "switch_profiles")

    @_builtins.property
    @pulumi.getter
    def switches(self) -> Sequence[_builtins.str]:
        """
        List of switch serials. Applicable only for switch network.
        """
        return pulumi.get(self, "switches")


@pulumi.output_type
class GetSwitchPortSchedulesItemResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 network_id: _builtins.str,
                 port_schedule: 'outputs.GetSwitchPortSchedulesItemPortScheduleResult'):
        """
        :param _builtins.str id: Switch port schedule ID
        :param _builtins.str name: Switch port schedule name
        :param _builtins.str network_id: Network ID
        :param 'GetSwitchPortSchedulesItemPortScheduleArgs' port_schedule: Port schedule
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "port_schedule", port_schedule)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Switch port schedule ID
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Switch port schedule name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        Network ID
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="portSchedule")
    def port_schedule(self) -> 'outputs.GetSwitchPortSchedulesItemPortScheduleResult':
        """
        Port schedule
        """
        return pulumi.get(self, "port_schedule")


@pulumi.output_type
class GetSwitchPortSchedulesItemPortScheduleResult(dict):
    def __init__(__self__, *,
                 friday: 'outputs.GetSwitchPortSchedulesItemPortScheduleFridayResult',
                 monday: 'outputs.GetSwitchPortSchedulesItemPortScheduleMondayResult',
                 saturday: 'outputs.GetSwitchPortSchedulesItemPortScheduleSaturdayResult',
                 sunday: 'outputs.GetSwitchPortSchedulesItemPortScheduleSundayResult',
                 thursday: 'outputs.GetSwitchPortSchedulesItemPortScheduleThursdayResult',
                 tuesday: 'outputs.GetSwitchPortSchedulesItemPortScheduleTuesdayResult',
                 wednesday: 'outputs.GetSwitchPortSchedulesItemPortScheduleWednesdayResult'):
        """
        :param 'GetSwitchPortSchedulesItemPortScheduleFridayArgs' friday: Friday schedule
        :param 'GetSwitchPortSchedulesItemPortScheduleMondayArgs' monday: Monday schedule
        :param 'GetSwitchPortSchedulesItemPortScheduleSaturdayArgs' saturday: Saturday schedule
        :param 'GetSwitchPortSchedulesItemPortScheduleSundayArgs' sunday: Sunday schedule
        :param 'GetSwitchPortSchedulesItemPortScheduleThursdayArgs' thursday: Thursday schedule
        :param 'GetSwitchPortSchedulesItemPortScheduleTuesdayArgs' tuesday: Tuesday schedule
        :param 'GetSwitchPortSchedulesItemPortScheduleWednesdayArgs' wednesday: Wednesday schedule
        """
        pulumi.set(__self__, "friday", friday)
        pulumi.set(__self__, "monday", monday)
        pulumi.set(__self__, "saturday", saturday)
        pulumi.set(__self__, "sunday", sunday)
        pulumi.set(__self__, "thursday", thursday)
        pulumi.set(__self__, "tuesday", tuesday)
        pulumi.set(__self__, "wednesday", wednesday)

    @_builtins.property
    @pulumi.getter
    def friday(self) -> 'outputs.GetSwitchPortSchedulesItemPortScheduleFridayResult':
        """
        Friday schedule
        """
        return pulumi.get(self, "friday")

    @_builtins.property
    @pulumi.getter
    def monday(self) -> 'outputs.GetSwitchPortSchedulesItemPortScheduleMondayResult':
        """
        Monday schedule
        """
        return pulumi.get(self, "monday")

    @_builtins.property
    @pulumi.getter
    def saturday(self) -> 'outputs.GetSwitchPortSchedulesItemPortScheduleSaturdayResult':
        """
        Saturday schedule
        """
        return pulumi.get(self, "saturday")

    @_builtins.property
    @pulumi.getter
    def sunday(self) -> 'outputs.GetSwitchPortSchedulesItemPortScheduleSundayResult':
        """
        Sunday schedule
        """
        return pulumi.get(self, "sunday")

    @_builtins.property
    @pulumi.getter
    def thursday(self) -> 'outputs.GetSwitchPortSchedulesItemPortScheduleThursdayResult':
        """
        Thursday schedule
        """
        return pulumi.get(self, "thursday")

    @_builtins.property
    @pulumi.getter
    def tuesday(self) -> 'outputs.GetSwitchPortSchedulesItemPortScheduleTuesdayResult':
        """
        Tuesday schedule
        """
        return pulumi.get(self, "tuesday")

    @_builtins.property
    @pulumi.getter
    def wednesday(self) -> 'outputs.GetSwitchPortSchedulesItemPortScheduleWednesdayResult':
        """
        Wednesday schedule
        """
        return pulumi.get(self, "wednesday")


@pulumi.output_type
class GetSwitchPortSchedulesItemPortScheduleFridayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active or inactive
        :param _builtins.str from_: The time, from '00:00' to '24:00'
        :param _builtins.str to: The time, from '00:00' to '24:00'
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active or inactive
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetSwitchPortSchedulesItemPortScheduleMondayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active or inactive
        :param _builtins.str from_: The time, from '00:00' to '24:00'
        :param _builtins.str to: The time, from '00:00' to '24:00'
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active or inactive
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetSwitchPortSchedulesItemPortScheduleSaturdayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active or inactive
        :param _builtins.str from_: The time, from '00:00' to '24:00'
        :param _builtins.str to: The time, from '00:00' to '24:00'
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active or inactive
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetSwitchPortSchedulesItemPortScheduleSundayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active or inactive
        :param _builtins.str from_: The time, from '00:00' to '24:00'
        :param _builtins.str to: The time, from '00:00' to '24:00'
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active or inactive
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetSwitchPortSchedulesItemPortScheduleThursdayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active or inactive
        :param _builtins.str from_: The time, from '00:00' to '24:00'
        :param _builtins.str to: The time, from '00:00' to '24:00'
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active or inactive
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetSwitchPortSchedulesItemPortScheduleTuesdayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active or inactive
        :param _builtins.str from_: The time, from '00:00' to '24:00'
        :param _builtins.str to: The time, from '00:00' to '24:00'
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active or inactive
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetSwitchPortSchedulesItemPortScheduleWednesdayResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.bool active: Whether the schedule is active or inactive
        :param _builtins.str from_: The time, from '00:00' to '24:00'
        :param _builtins.str to: The time, from '00:00' to '24:00'
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Whether the schedule is active or inactive
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The time, from '00:00' to '24:00'
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetSwitchQosRulesOrderItemResult(dict):
    def __init__(__self__, *,
                 dscp: _builtins.int,
                 dst_port: _builtins.int,
                 dst_port_range: _builtins.str,
                 id: _builtins.str,
                 protocol: _builtins.str,
                 src_port: _builtins.int,
                 src_port_range: _builtins.str,
                 vlan: _builtins.int):
        pulumi.set(__self__, "dscp", dscp)
        pulumi.set(__self__, "dst_port", dst_port)
        pulumi.set(__self__, "dst_port_range", dst_port_range)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "src_port", src_port)
        pulumi.set(__self__, "src_port_range", src_port_range)
        pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def dscp(self) -> _builtins.int:
        return pulumi.get(self, "dscp")

    @_builtins.property
    @pulumi.getter(name="dstPort")
    def dst_port(self) -> _builtins.int:
        return pulumi.get(self, "dst_port")

    @_builtins.property
    @pulumi.getter(name="dstPortRange")
    def dst_port_range(self) -> _builtins.str:
        return pulumi.get(self, "dst_port_range")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> _builtins.int:
        return pulumi.get(self, "src_port")

    @_builtins.property
    @pulumi.getter(name="srcPortRange")
    def src_port_range(self) -> _builtins.str:
        return pulumi.get(self, "src_port_range")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.int:
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetSwitchRoutingMulticastItemResult(dict):
    def __init__(__self__, *,
                 default_settings: 'outputs.GetSwitchRoutingMulticastItemDefaultSettingsResult',
                 overrides: Sequence['outputs.GetSwitchRoutingMulticastItemOverrideResult']):
        """
        :param 'GetSwitchRoutingMulticastItemDefaultSettingsArgs' default_settings: Default multicast setting for entire network. IGMP snooping and Flood unknown
                 multicast traffic settings are enabled by default.
        :param Sequence['GetSwitchRoutingMulticastItemOverrideArgs'] overrides: Array of paired switches/stacks/profiles and corresponding multicast settings.
                 An empty array will clear the multicast settings.
        """
        pulumi.set(__self__, "default_settings", default_settings)
        pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="defaultSettings")
    def default_settings(self) -> 'outputs.GetSwitchRoutingMulticastItemDefaultSettingsResult':
        """
        Default multicast setting for entire network. IGMP snooping and Flood unknown
          multicast traffic settings are enabled by default.
        """
        return pulumi.get(self, "default_settings")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Sequence['outputs.GetSwitchRoutingMulticastItemOverrideResult']:
        """
        Array of paired switches/stacks/profiles and corresponding multicast settings.
          An empty array will clear the multicast settings.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class GetSwitchRoutingMulticastItemDefaultSettingsResult(dict):
    def __init__(__self__, *,
                 flood_unknown_multicast_traffic_enabled: _builtins.bool,
                 igmp_snooping_enabled: _builtins.bool):
        """
        :param _builtins.bool flood_unknown_multicast_traffic_enabled: Flood unknown multicast traffic enabled for the entire network
        :param _builtins.bool igmp_snooping_enabled: IGMP snooping enabled for the entire network
        """
        pulumi.set(__self__, "flood_unknown_multicast_traffic_enabled", flood_unknown_multicast_traffic_enabled)
        pulumi.set(__self__, "igmp_snooping_enabled", igmp_snooping_enabled)

    @_builtins.property
    @pulumi.getter(name="floodUnknownMulticastTrafficEnabled")
    def flood_unknown_multicast_traffic_enabled(self) -> _builtins.bool:
        """
        Flood unknown multicast traffic enabled for the entire network
        """
        return pulumi.get(self, "flood_unknown_multicast_traffic_enabled")

    @_builtins.property
    @pulumi.getter(name="igmpSnoopingEnabled")
    def igmp_snooping_enabled(self) -> _builtins.bool:
        """
        IGMP snooping enabled for the entire network
        """
        return pulumi.get(self, "igmp_snooping_enabled")


@pulumi.output_type
class GetSwitchRoutingMulticastItemOverrideResult(dict):
    def __init__(__self__, *,
                 flood_unknown_multicast_traffic_enabled: _builtins.bool,
                 igmp_snooping_enabled: _builtins.bool,
                 stacks: Sequence[_builtins.str],
                 switch_profiles: Sequence[_builtins.str],
                 switches: Sequence[_builtins.str]):
        """
        :param _builtins.bool flood_unknown_multicast_traffic_enabled: Flood unknown multicast traffic enabled for switches, switch stacks or switch templates
        :param _builtins.bool igmp_snooping_enabled: IGMP snooping enabled for switches, switch stacks or switch templates
        :param Sequence[_builtins.str] stacks: (optional) List of switch stack ids for non-template network
        :param Sequence[_builtins.str] switch_profiles: (optional) List of switch templates ids for template network
        :param Sequence[_builtins.str] switches: (optional) List of switch serials for non-template network
        """
        pulumi.set(__self__, "flood_unknown_multicast_traffic_enabled", flood_unknown_multicast_traffic_enabled)
        pulumi.set(__self__, "igmp_snooping_enabled", igmp_snooping_enabled)
        pulumi.set(__self__, "stacks", stacks)
        pulumi.set(__self__, "switch_profiles", switch_profiles)
        pulumi.set(__self__, "switches", switches)

    @_builtins.property
    @pulumi.getter(name="floodUnknownMulticastTrafficEnabled")
    def flood_unknown_multicast_traffic_enabled(self) -> _builtins.bool:
        """
        Flood unknown multicast traffic enabled for switches, switch stacks or switch templates
        """
        return pulumi.get(self, "flood_unknown_multicast_traffic_enabled")

    @_builtins.property
    @pulumi.getter(name="igmpSnoopingEnabled")
    def igmp_snooping_enabled(self) -> _builtins.bool:
        """
        IGMP snooping enabled for switches, switch stacks or switch templates
        """
        return pulumi.get(self, "igmp_snooping_enabled")

    @_builtins.property
    @pulumi.getter
    def stacks(self) -> Sequence[_builtins.str]:
        """
        (optional) List of switch stack ids for non-template network
        """
        return pulumi.get(self, "stacks")

    @_builtins.property
    @pulumi.getter(name="switchProfiles")
    def switch_profiles(self) -> Sequence[_builtins.str]:
        """
        (optional) List of switch templates ids for template network
        """
        return pulumi.get(self, "switch_profiles")

    @_builtins.property
    @pulumi.getter
    def switches(self) -> Sequence[_builtins.str]:
        """
        (optional) List of switch serials for non-template network
        """
        return pulumi.get(self, "switches")


@pulumi.output_type
class GetSwitchRoutingMulticastRendezvousPointsItemResult(dict):
    def __init__(__self__, *,
                 interface_ip: _builtins.str,
                 interface_name: _builtins.str,
                 multicast_group: _builtins.str,
                 rendezvous_point_id: _builtins.str,
                 serial: _builtins.str):
        """
        :param _builtins.str interface_ip: The IP address of the interface to use.
        :param _builtins.str interface_name: The name of the interface to use.
        :param _builtins.str multicast_group: 'Any', or the IP address of a multicast group.
        :param _builtins.str rendezvous_point_id: The id.
        :param _builtins.str serial: The serial.
        """
        pulumi.set(__self__, "interface_ip", interface_ip)
        pulumi.set(__self__, "interface_name", interface_name)
        pulumi.set(__self__, "multicast_group", multicast_group)
        pulumi.set(__self__, "rendezvous_point_id", rendezvous_point_id)
        pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter(name="interfaceIp")
    def interface_ip(self) -> _builtins.str:
        """
        The IP address of the interface to use.
        """
        return pulumi.get(self, "interface_ip")

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> _builtins.str:
        """
        The name of the interface to use.
        """
        return pulumi.get(self, "interface_name")

    @_builtins.property
    @pulumi.getter(name="multicastGroup")
    def multicast_group(self) -> _builtins.str:
        """
        'Any', or the IP address of a multicast group.
        """
        return pulumi.get(self, "multicast_group")

    @_builtins.property
    @pulumi.getter(name="rendezvousPointId")
    def rendezvous_point_id(self) -> _builtins.str:
        """
        The id.
        """
        return pulumi.get(self, "rendezvous_point_id")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        The serial.
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class GetSwitchRoutingOspfItemResult(dict):
    def __init__(__self__, *,
                 areas: Sequence['outputs.GetSwitchRoutingOspfItemAreaResult'],
                 dead_timer_in_seconds: _builtins.int,
                 enabled: _builtins.bool,
                 hello_timer_in_seconds: _builtins.int,
                 md5_authentication_enabled: _builtins.bool,
                 md5_authentication_key: 'outputs.GetSwitchRoutingOspfItemMd5AuthenticationKeyResult',
                 v3: 'outputs.GetSwitchRoutingOspfItemV3Result'):
        pulumi.set(__self__, "areas", areas)
        pulumi.set(__self__, "dead_timer_in_seconds", dead_timer_in_seconds)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "hello_timer_in_seconds", hello_timer_in_seconds)
        pulumi.set(__self__, "md5_authentication_enabled", md5_authentication_enabled)
        pulumi.set(__self__, "md5_authentication_key", md5_authentication_key)
        pulumi.set(__self__, "v3", v3)

    @_builtins.property
    @pulumi.getter
    def areas(self) -> Sequence['outputs.GetSwitchRoutingOspfItemAreaResult']:
        return pulumi.get(self, "areas")

    @_builtins.property
    @pulumi.getter(name="deadTimerInSeconds")
    def dead_timer_in_seconds(self) -> _builtins.int:
        return pulumi.get(self, "dead_timer_in_seconds")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="helloTimerInSeconds")
    def hello_timer_in_seconds(self) -> _builtins.int:
        return pulumi.get(self, "hello_timer_in_seconds")

    @_builtins.property
    @pulumi.getter(name="md5AuthenticationEnabled")
    def md5_authentication_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "md5_authentication_enabled")

    @_builtins.property
    @pulumi.getter(name="md5AuthenticationKey")
    def md5_authentication_key(self) -> 'outputs.GetSwitchRoutingOspfItemMd5AuthenticationKeyResult':
        return pulumi.get(self, "md5_authentication_key")

    @_builtins.property
    @pulumi.getter
    def v3(self) -> 'outputs.GetSwitchRoutingOspfItemV3Result':
        return pulumi.get(self, "v3")


@pulumi.output_type
class GetSwitchRoutingOspfItemAreaResult(dict):
    def __init__(__self__, *,
                 area_id: _builtins.str,
                 area_name: _builtins.str,
                 area_type: _builtins.str):
        pulumi.set(__self__, "area_id", area_id)
        pulumi.set(__self__, "area_name", area_name)
        pulumi.set(__self__, "area_type", area_type)

    @_builtins.property
    @pulumi.getter(name="areaId")
    def area_id(self) -> _builtins.str:
        return pulumi.get(self, "area_id")

    @_builtins.property
    @pulumi.getter(name="areaName")
    def area_name(self) -> _builtins.str:
        return pulumi.get(self, "area_name")

    @_builtins.property
    @pulumi.getter(name="areaType")
    def area_type(self) -> _builtins.str:
        return pulumi.get(self, "area_type")


@pulumi.output_type
class GetSwitchRoutingOspfItemMd5AuthenticationKeyResult(dict):
    def __init__(__self__, *,
                 id: _builtins.int,
                 passphrase: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "passphrase", passphrase)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> _builtins.str:
        return pulumi.get(self, "passphrase")


@pulumi.output_type
class GetSwitchRoutingOspfItemV3Result(dict):
    def __init__(__self__, *,
                 areas: Sequence['outputs.GetSwitchRoutingOspfItemV3AreaResult'],
                 dead_timer_in_seconds: _builtins.int,
                 enabled: _builtins.bool,
                 hello_timer_in_seconds: _builtins.int):
        pulumi.set(__self__, "areas", areas)
        pulumi.set(__self__, "dead_timer_in_seconds", dead_timer_in_seconds)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "hello_timer_in_seconds", hello_timer_in_seconds)

    @_builtins.property
    @pulumi.getter
    def areas(self) -> Sequence['outputs.GetSwitchRoutingOspfItemV3AreaResult']:
        return pulumi.get(self, "areas")

    @_builtins.property
    @pulumi.getter(name="deadTimerInSeconds")
    def dead_timer_in_seconds(self) -> _builtins.int:
        return pulumi.get(self, "dead_timer_in_seconds")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="helloTimerInSeconds")
    def hello_timer_in_seconds(self) -> _builtins.int:
        return pulumi.get(self, "hello_timer_in_seconds")


@pulumi.output_type
class GetSwitchRoutingOspfItemV3AreaResult(dict):
    def __init__(__self__, *,
                 area_id: _builtins.str,
                 area_name: _builtins.str,
                 area_type: _builtins.str):
        pulumi.set(__self__, "area_id", area_id)
        pulumi.set(__self__, "area_name", area_name)
        pulumi.set(__self__, "area_type", area_type)

    @_builtins.property
    @pulumi.getter(name="areaId")
    def area_id(self) -> _builtins.str:
        return pulumi.get(self, "area_id")

    @_builtins.property
    @pulumi.getter(name="areaName")
    def area_name(self) -> _builtins.str:
        return pulumi.get(self, "area_name")

    @_builtins.property
    @pulumi.getter(name="areaType")
    def area_type(self) -> _builtins.str:
        return pulumi.get(self, "area_type")


@pulumi.output_type
class GetSwitchSettingsItemResult(dict):
    def __init__(__self__, *,
                 mac_blocklist: 'outputs.GetSwitchSettingsItemMacBlocklistResult',
                 power_exceptions: Sequence['outputs.GetSwitchSettingsItemPowerExceptionResult'],
                 uplink_client_sampling: 'outputs.GetSwitchSettingsItemUplinkClientSamplingResult',
                 use_combined_power: _builtins.bool,
                 vlan: _builtins.int):
        """
        :param 'GetSwitchSettingsItemMacBlocklistArgs' mac_blocklist: MAC blocklist
        :param Sequence['GetSwitchSettingsItemPowerExceptionArgs'] power_exceptions: Exceptions on a per switch basis to "useCombinedPower"
        :param 'GetSwitchSettingsItemUplinkClientSamplingArgs' uplink_client_sampling: Uplink client sampling
        :param _builtins.bool use_combined_power: The use Combined Power as the default behavior of secondary power supplies on supported devices.
        :param _builtins.int vlan: Management VLAN
        """
        pulumi.set(__self__, "mac_blocklist", mac_blocklist)
        pulumi.set(__self__, "power_exceptions", power_exceptions)
        pulumi.set(__self__, "uplink_client_sampling", uplink_client_sampling)
        pulumi.set(__self__, "use_combined_power", use_combined_power)
        pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter(name="macBlocklist")
    def mac_blocklist(self) -> 'outputs.GetSwitchSettingsItemMacBlocklistResult':
        """
        MAC blocklist
        """
        return pulumi.get(self, "mac_blocklist")

    @_builtins.property
    @pulumi.getter(name="powerExceptions")
    def power_exceptions(self) -> Sequence['outputs.GetSwitchSettingsItemPowerExceptionResult']:
        """
        Exceptions on a per switch basis to "useCombinedPower"
        """
        return pulumi.get(self, "power_exceptions")

    @_builtins.property
    @pulumi.getter(name="uplinkClientSampling")
    def uplink_client_sampling(self) -> 'outputs.GetSwitchSettingsItemUplinkClientSamplingResult':
        """
        Uplink client sampling
        """
        return pulumi.get(self, "uplink_client_sampling")

    @_builtins.property
    @pulumi.getter(name="useCombinedPower")
    def use_combined_power(self) -> _builtins.bool:
        """
        The use Combined Power as the default behavior of secondary power supplies on supported devices.
        """
        return pulumi.get(self, "use_combined_power")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.int:
        """
        Management VLAN
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetSwitchSettingsItemMacBlocklistResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Enable MAC blocklist for switches in the network
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable MAC blocklist for switches in the network
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetSwitchSettingsItemPowerExceptionResult(dict):
    def __init__(__self__, *,
                 power_type: _builtins.str,
                 serial: _builtins.str):
        """
        :param _builtins.str power_type: Per switch exception (combined, redundant, useNetworkSetting)
        :param _builtins.str serial: Serial number of the switch
        """
        pulumi.set(__self__, "power_type", power_type)
        pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter(name="powerType")
    def power_type(self) -> _builtins.str:
        """
        Per switch exception (combined, redundant, useNetworkSetting)
        """
        return pulumi.get(self, "power_type")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Serial number of the switch
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class GetSwitchSettingsItemUplinkClientSamplingResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Enable client sampling on uplink
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable client sampling on uplink
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetSwitchStacksItemResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 serials: Sequence[_builtins.str]):
        """
        :param _builtins.str id: ID of the Switch stack
        :param _builtins.str name: Name of the Switch stack
        :param Sequence[_builtins.str] serials: Serials of the switches in the switch stack
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the Switch stack
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Switch stack
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Sequence[_builtins.str]:
        """
        Serials of the switches in the switch stack
        """
        return pulumi.get(self, "serials")


@pulumi.output_type
class GetSwitchStacksRoutingInterfacesDhcpItemResult(dict):
    def __init__(__self__, *,
                 boot_file_name: _builtins.str,
                 boot_next_server: _builtins.str,
                 boot_options_enabled: _builtins.bool,
                 dhcp_lease_time: _builtins.str,
                 dhcp_mode: _builtins.str,
                 dhcp_options: Sequence['outputs.GetSwitchStacksRoutingInterfacesDhcpItemDhcpOptionResult'],
                 dhcp_relay_server_ips: Sequence[_builtins.str],
                 dns_custom_nameservers: Sequence[_builtins.str],
                 dns_nameservers_option: _builtins.str,
                 fixed_ip_assignments: Sequence['outputs.GetSwitchStacksRoutingInterfacesDhcpItemFixedIpAssignmentResult'],
                 reserved_ip_ranges: Sequence['outputs.GetSwitchStacksRoutingInterfacesDhcpItemReservedIpRangeResult']):
        """
        :param _builtins.str boot_file_name: The PXE boot server file name for the DHCP server running on the switch stack interface
        :param _builtins.str boot_next_server: The PXE boot server IP for the DHCP server running on the switch stack interface
        :param _builtins.bool boot_options_enabled: Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface
        :param _builtins.str dhcp_lease_time: The DHCP lease time config for the dhcp server running on the switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')
        :param _builtins.str dhcp_mode: The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')
        :param Sequence['GetSwitchStacksRoutingInterfacesDhcpItemDhcpOptionArgs'] dhcp_options: Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface
        :param Sequence[_builtins.str] dhcp_relay_server_ips: The DHCP relay server IPs to which DHCP packets would get relayed for the switch stack interface
        :param Sequence[_builtins.str] dns_custom_nameservers: The DHCP name server IPs when DHCP name server option is 'custom'
        :param _builtins.str dns_nameservers_option: The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom')
        :param Sequence['GetSwitchStacksRoutingInterfacesDhcpItemFixedIpAssignmentArgs'] fixed_ip_assignments: Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface
        :param Sequence['GetSwitchStacksRoutingInterfacesDhcpItemReservedIpRangeArgs'] reserved_ip_ranges: Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface
        """
        pulumi.set(__self__, "boot_file_name", boot_file_name)
        pulumi.set(__self__, "boot_next_server", boot_next_server)
        pulumi.set(__self__, "boot_options_enabled", boot_options_enabled)
        pulumi.set(__self__, "dhcp_lease_time", dhcp_lease_time)
        pulumi.set(__self__, "dhcp_mode", dhcp_mode)
        pulumi.set(__self__, "dhcp_options", dhcp_options)
        pulumi.set(__self__, "dhcp_relay_server_ips", dhcp_relay_server_ips)
        pulumi.set(__self__, "dns_custom_nameservers", dns_custom_nameservers)
        pulumi.set(__self__, "dns_nameservers_option", dns_nameservers_option)
        pulumi.set(__self__, "fixed_ip_assignments", fixed_ip_assignments)
        pulumi.set(__self__, "reserved_ip_ranges", reserved_ip_ranges)

    @_builtins.property
    @pulumi.getter(name="bootFileName")
    def boot_file_name(self) -> _builtins.str:
        """
        The PXE boot server file name for the DHCP server running on the switch stack interface
        """
        return pulumi.get(self, "boot_file_name")

    @_builtins.property
    @pulumi.getter(name="bootNextServer")
    def boot_next_server(self) -> _builtins.str:
        """
        The PXE boot server IP for the DHCP server running on the switch stack interface
        """
        return pulumi.get(self, "boot_next_server")

    @_builtins.property
    @pulumi.getter(name="bootOptionsEnabled")
    def boot_options_enabled(self) -> _builtins.bool:
        """
        Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface
        """
        return pulumi.get(self, "boot_options_enabled")

    @_builtins.property
    @pulumi.getter(name="dhcpLeaseTime")
    def dhcp_lease_time(self) -> _builtins.str:
        """
        The DHCP lease time config for the dhcp server running on the switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')
        """
        return pulumi.get(self, "dhcp_lease_time")

    @_builtins.property
    @pulumi.getter(name="dhcpMode")
    def dhcp_mode(self) -> _builtins.str:
        """
        The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')
        """
        return pulumi.get(self, "dhcp_mode")

    @_builtins.property
    @pulumi.getter(name="dhcpOptions")
    def dhcp_options(self) -> Sequence['outputs.GetSwitchStacksRoutingInterfacesDhcpItemDhcpOptionResult']:
        """
        Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface
        """
        return pulumi.get(self, "dhcp_options")

    @_builtins.property
    @pulumi.getter(name="dhcpRelayServerIps")
    def dhcp_relay_server_ips(self) -> Sequence[_builtins.str]:
        """
        The DHCP relay server IPs to which DHCP packets would get relayed for the switch stack interface
        """
        return pulumi.get(self, "dhcp_relay_server_ips")

    @_builtins.property
    @pulumi.getter(name="dnsCustomNameservers")
    def dns_custom_nameservers(self) -> Sequence[_builtins.str]:
        """
        The DHCP name server IPs when DHCP name server option is 'custom'
        """
        return pulumi.get(self, "dns_custom_nameservers")

    @_builtins.property
    @pulumi.getter(name="dnsNameserversOption")
    def dns_nameservers_option(self) -> _builtins.str:
        """
        The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom')
        """
        return pulumi.get(self, "dns_nameservers_option")

    @_builtins.property
    @pulumi.getter(name="fixedIpAssignments")
    def fixed_ip_assignments(self) -> Sequence['outputs.GetSwitchStacksRoutingInterfacesDhcpItemFixedIpAssignmentResult']:
        """
        Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface
        """
        return pulumi.get(self, "fixed_ip_assignments")

    @_builtins.property
    @pulumi.getter(name="reservedIpRanges")
    def reserved_ip_ranges(self) -> Sequence['outputs.GetSwitchStacksRoutingInterfacesDhcpItemReservedIpRangeResult']:
        """
        Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface
        """
        return pulumi.get(self, "reserved_ip_ranges")


@pulumi.output_type
class GetSwitchStacksRoutingInterfacesDhcpItemDhcpOptionResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str code: The code for DHCP option which should be from 2 to 254
        :param _builtins.str type: The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
        :param _builtins.str value: The value of the DHCP option
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        The code for DHCP option which should be from 2 to 254
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the DHCP option
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSwitchStacksRoutingInterfacesDhcpItemFixedIpAssignmentResult(dict):
    def __init__(__self__, *,
                 ip: _builtins.str,
                 mac: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str ip: The IP address of the client which has fixed IP address assigned to it
        :param _builtins.str mac: The MAC address of the client which has fixed IP address
        :param _builtins.str name: The name of the client which has fixed IP address
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        The IP address of the client which has fixed IP address assigned to it
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        The MAC address of the client which has fixed IP address
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the client which has fixed IP address
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSwitchStacksRoutingInterfacesDhcpItemReservedIpRangeResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 end: _builtins.str,
                 start: _builtins.str):
        """
        :param _builtins.str comment: The comment for the reserved IP range
        :param _builtins.str end: The ending IP address of the reserved IP range
        :param _builtins.str start: The starting IP address of the reserved IP range
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        The comment for the reserved IP range
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        """
        The ending IP address of the reserved IP range
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        """
        The starting IP address of the reserved IP range
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class GetSwitchStacksRoutingInterfacesItemResult(dict):
    def __init__(__self__, *,
                 default_gateway: _builtins.str,
                 interface_id: _builtins.str,
                 interface_ip: _builtins.str,
                 ipv6: 'outputs.GetSwitchStacksRoutingInterfacesItemIpv6Result',
                 multicast_routing: _builtins.str,
                 name: _builtins.str,
                 ospf_settings: 'outputs.GetSwitchStacksRoutingInterfacesItemOspfSettingsResult',
                 ospf_v3: 'outputs.GetSwitchStacksRoutingInterfacesItemOspfV3Result',
                 subnet: _builtins.str,
                 vlan_id: _builtins.int):
        """
        :param _builtins.str default_gateway: IPv4 default gateway
        :param _builtins.str interface_id: The id
        :param _builtins.str interface_ip: IPv4 address
        :param 'GetSwitchStacksRoutingInterfacesItemIpv6Args' ipv6: IPv6 addressing
        :param _builtins.str multicast_routing: Multicast routing status
        :param _builtins.str name: The name
        :param 'GetSwitchStacksRoutingInterfacesItemOspfSettingsArgs' ospf_settings: IPv4 OSPF Settings
        :param 'GetSwitchStacksRoutingInterfacesItemOspfV3Args' ospf_v3: IPv6 OSPF Settings
        :param _builtins.str subnet: IPv4 subnet
        :param _builtins.int vlan_id: VLAN id
        """
        pulumi.set(__self__, "default_gateway", default_gateway)
        pulumi.set(__self__, "interface_id", interface_id)
        pulumi.set(__self__, "interface_ip", interface_ip)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "multicast_routing", multicast_routing)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ospf_settings", ospf_settings)
        pulumi.set(__self__, "ospf_v3", ospf_v3)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter(name="defaultGateway")
    def default_gateway(self) -> _builtins.str:
        """
        IPv4 default gateway
        """
        return pulumi.get(self, "default_gateway")

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> _builtins.str:
        """
        The id
        """
        return pulumi.get(self, "interface_id")

    @_builtins.property
    @pulumi.getter(name="interfaceIp")
    def interface_ip(self) -> _builtins.str:
        """
        IPv4 address
        """
        return pulumi.get(self, "interface_ip")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> 'outputs.GetSwitchStacksRoutingInterfacesItemIpv6Result':
        """
        IPv6 addressing
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="multicastRouting")
    def multicast_routing(self) -> _builtins.str:
        """
        Multicast routing status
        """
        return pulumi.get(self, "multicast_routing")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="ospfSettings")
    def ospf_settings(self) -> 'outputs.GetSwitchStacksRoutingInterfacesItemOspfSettingsResult':
        """
        IPv4 OSPF Settings
        """
        return pulumi.get(self, "ospf_settings")

    @_builtins.property
    @pulumi.getter(name="ospfV3")
    def ospf_v3(self) -> 'outputs.GetSwitchStacksRoutingInterfacesItemOspfV3Result':
        """
        IPv6 OSPF Settings
        """
        return pulumi.get(self, "ospf_v3")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        IPv4 subnet
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.int:
        """
        VLAN id
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetSwitchStacksRoutingInterfacesItemIpv6Result(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 assignment_mode: _builtins.str,
                 gateway: _builtins.str,
                 prefix: _builtins.str):
        """
        :param _builtins.str address: IPv6 address
        :param _builtins.str assignment_mode: Assignment mode
        :param _builtins.str gateway: IPv6 gateway
        :param _builtins.str prefix: IPv6 subnet
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "assignment_mode", assignment_mode)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        IPv6 address
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="assignmentMode")
    def assignment_mode(self) -> _builtins.str:
        """
        Assignment mode
        """
        return pulumi.get(self, "assignment_mode")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        IPv6 gateway
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        IPv6 subnet
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetSwitchStacksRoutingInterfacesItemOspfSettingsResult(dict):
    def __init__(__self__, *,
                 area: _builtins.str,
                 cost: _builtins.int,
                 is_passive_enabled: _builtins.bool):
        """
        :param _builtins.str area: Area id
        :param _builtins.int cost: OSPF Cost
        :param _builtins.bool is_passive_enabled: Disable sending Hello packets on this interface's IPv4 area
        """
        pulumi.set(__self__, "area", area)
        pulumi.set(__self__, "cost", cost)
        pulumi.set(__self__, "is_passive_enabled", is_passive_enabled)

    @_builtins.property
    @pulumi.getter
    def area(self) -> _builtins.str:
        """
        Area id
        """
        return pulumi.get(self, "area")

    @_builtins.property
    @pulumi.getter
    def cost(self) -> _builtins.int:
        """
        OSPF Cost
        """
        return pulumi.get(self, "cost")

    @_builtins.property
    @pulumi.getter(name="isPassiveEnabled")
    def is_passive_enabled(self) -> _builtins.bool:
        """
        Disable sending Hello packets on this interface's IPv4 area
        """
        return pulumi.get(self, "is_passive_enabled")


@pulumi.output_type
class GetSwitchStacksRoutingInterfacesItemOspfV3Result(dict):
    def __init__(__self__, *,
                 area: _builtins.str,
                 cost: _builtins.int,
                 is_passive_enabled: _builtins.bool):
        """
        :param _builtins.str area: Area id
        :param _builtins.int cost: OSPF Cost
        :param _builtins.bool is_passive_enabled: Disable sending Hello packets on this interface's IPv6 area
        """
        pulumi.set(__self__, "area", area)
        pulumi.set(__self__, "cost", cost)
        pulumi.set(__self__, "is_passive_enabled", is_passive_enabled)

    @_builtins.property
    @pulumi.getter
    def area(self) -> _builtins.str:
        """
        Area id
        """
        return pulumi.get(self, "area")

    @_builtins.property
    @pulumi.getter
    def cost(self) -> _builtins.int:
        """
        OSPF Cost
        """
        return pulumi.get(self, "cost")

    @_builtins.property
    @pulumi.getter(name="isPassiveEnabled")
    def is_passive_enabled(self) -> _builtins.bool:
        """
        Disable sending Hello packets on this interface's IPv6 area
        """
        return pulumi.get(self, "is_passive_enabled")


@pulumi.output_type
class GetSwitchStacksRoutingStaticRoutesItemResult(dict):
    def __init__(__self__, *,
                 advertise_via_ospf_enabled: _builtins.bool,
                 name: _builtins.str,
                 next_hop_ip: _builtins.str,
                 prefer_over_ospf_routes_enabled: _builtins.bool,
                 static_route_id: _builtins.str,
                 subnet: _builtins.str):
        """
        :param _builtins.bool advertise_via_ospf_enabled: Option to advertise static routes via OSPF
        :param _builtins.str name: The name or description of the layer 3 static route
        :param _builtins.str next_hop_ip: The IP address of the router to which traffic for this destination network should be sent
        :param _builtins.bool prefer_over_ospf_routes_enabled: Option to prefer static routes over OSPF routes
        :param _builtins.str static_route_id: The identifier of a layer 3 static route
        :param _builtins.str subnet: The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)
        """
        pulumi.set(__self__, "advertise_via_ospf_enabled", advertise_via_ospf_enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_hop_ip", next_hop_ip)
        pulumi.set(__self__, "prefer_over_ospf_routes_enabled", prefer_over_ospf_routes_enabled)
        pulumi.set(__self__, "static_route_id", static_route_id)
        pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter(name="advertiseViaOspfEnabled")
    def advertise_via_ospf_enabled(self) -> _builtins.bool:
        """
        Option to advertise static routes via OSPF
        """
        return pulumi.get(self, "advertise_via_ospf_enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name or description of the layer 3 static route
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nextHopIp")
    def next_hop_ip(self) -> _builtins.str:
        """
        The IP address of the router to which traffic for this destination network should be sent
        """
        return pulumi.get(self, "next_hop_ip")

    @_builtins.property
    @pulumi.getter(name="preferOverOspfRoutesEnabled")
    def prefer_over_ospf_routes_enabled(self) -> _builtins.bool:
        """
        Option to prefer static routes over OSPF routes
        """
        return pulumi.get(self, "prefer_over_ospf_routes_enabled")

    @_builtins.property
    @pulumi.getter(name="staticRouteId")
    def static_route_id(self) -> _builtins.str:
        """
        The identifier of a layer 3 static route
        """
        return pulumi.get(self, "static_route_id")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class GetSwitchStormControlItemResult(dict):
    def __init__(__self__, *,
                 broadcast_threshold: _builtins.int,
                 multicast_threshold: _builtins.int,
                 unknown_unicast_threshold: _builtins.int):
        """
        :param _builtins.int broadcast_threshold: Broadcast threshold.
        :param _builtins.int multicast_threshold: Multicast threshold.
        :param _builtins.int unknown_unicast_threshold: Unknown Unicast threshold.
        """
        pulumi.set(__self__, "broadcast_threshold", broadcast_threshold)
        pulumi.set(__self__, "multicast_threshold", multicast_threshold)
        pulumi.set(__self__, "unknown_unicast_threshold", unknown_unicast_threshold)

    @_builtins.property
    @pulumi.getter(name="broadcastThreshold")
    def broadcast_threshold(self) -> _builtins.int:
        """
        Broadcast threshold.
        """
        return pulumi.get(self, "broadcast_threshold")

    @_builtins.property
    @pulumi.getter(name="multicastThreshold")
    def multicast_threshold(self) -> _builtins.int:
        """
        Multicast threshold.
        """
        return pulumi.get(self, "multicast_threshold")

    @_builtins.property
    @pulumi.getter(name="unknownUnicastThreshold")
    def unknown_unicast_threshold(self) -> _builtins.int:
        """
        Unknown Unicast threshold.
        """
        return pulumi.get(self, "unknown_unicast_threshold")


@pulumi.output_type
class GetSwitchStpItemResult(dict):
    def __init__(__self__, *,
                 rstp_enabled: _builtins.bool,
                 stp_bridge_priorities: Sequence['outputs.GetSwitchStpItemStpBridgePriorityResult']):
        pulumi.set(__self__, "rstp_enabled", rstp_enabled)
        pulumi.set(__self__, "stp_bridge_priorities", stp_bridge_priorities)

    @_builtins.property
    @pulumi.getter(name="rstpEnabled")
    def rstp_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "rstp_enabled")

    @_builtins.property
    @pulumi.getter(name="stpBridgePriorities")
    def stp_bridge_priorities(self) -> Sequence['outputs.GetSwitchStpItemStpBridgePriorityResult']:
        return pulumi.get(self, "stp_bridge_priorities")


@pulumi.output_type
class GetSwitchStpItemStpBridgePriorityResult(dict):
    def __init__(__self__, *,
                 stp_priority: _builtins.int,
                 switches: Sequence[_builtins.str]):
        pulumi.set(__self__, "stp_priority", stp_priority)
        pulumi.set(__self__, "switches", switches)

    @_builtins.property
    @pulumi.getter(name="stpPriority")
    def stp_priority(self) -> _builtins.int:
        return pulumi.get(self, "stp_priority")

    @_builtins.property
    @pulumi.getter
    def switches(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "switches")


@pulumi.output_type
class GetSyslogServersItemResult(dict):
    def __init__(__self__, *,
                 servers: Sequence['outputs.GetSyslogServersItemServerResult']):
        """
        :param Sequence['GetSyslogServersItemServerArgs'] servers: List of the syslog servers for this network
        """
        pulumi.set(__self__, "servers", servers)

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Sequence['outputs.GetSyslogServersItemServerResult']:
        """
        List of the syslog servers for this network
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class GetSyslogServersItemServerResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 port: _builtins.int,
                 roles: Sequence[_builtins.str]):
        """
        :param _builtins.str host: The IP address of the syslog server
        :param _builtins.int port: The port of the syslog server
        :param Sequence[_builtins.str] roles: A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The IP address of the syslog server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port of the syslog server
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        """
        A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetTopologyLinkLayerItemResult(dict):
    def __init__(__self__, *,
                 errors: Sequence[_builtins.str],
                 links: Sequence['outputs.GetTopologyLinkLayerItemLinkResult'],
                 nodes: Sequence['outputs.GetTopologyLinkLayerItemNodeResult']):
        pulumi.set(__self__, "errors", errors)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "nodes", nodes)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "errors")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetTopologyLinkLayerItemLinkResult']:
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetTopologyLinkLayerItemNodeResult']:
        return pulumi.get(self, "nodes")


@pulumi.output_type
class GetTopologyLinkLayerItemLinkResult(dict):
    def __init__(__self__, *,
                 ends: Sequence['outputs.GetTopologyLinkLayerItemLinkEndResult'],
                 last_reported_at: _builtins.str):
        pulumi.set(__self__, "ends", ends)
        pulumi.set(__self__, "last_reported_at", last_reported_at)

    @_builtins.property
    @pulumi.getter
    def ends(self) -> Sequence['outputs.GetTopologyLinkLayerItemLinkEndResult']:
        return pulumi.get(self, "ends")

    @_builtins.property
    @pulumi.getter(name="lastReportedAt")
    def last_reported_at(self) -> _builtins.str:
        return pulumi.get(self, "last_reported_at")


@pulumi.output_type
class GetTopologyLinkLayerItemLinkEndResult(dict):
    def __init__(__self__, *,
                 device: 'outputs.GetTopologyLinkLayerItemLinkEndDeviceResult',
                 discovered: 'outputs.GetTopologyLinkLayerItemLinkEndDiscoveredResult',
                 node: 'outputs.GetTopologyLinkLayerItemLinkEndNodeResult'):
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "discovered", discovered)
        pulumi.set(__self__, "node", node)

    @_builtins.property
    @pulumi.getter
    def device(self) -> 'outputs.GetTopologyLinkLayerItemLinkEndDeviceResult':
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter
    def discovered(self) -> 'outputs.GetTopologyLinkLayerItemLinkEndDiscoveredResult':
        return pulumi.get(self, "discovered")

    @_builtins.property
    @pulumi.getter
    def node(self) -> 'outputs.GetTopologyLinkLayerItemLinkEndNodeResult':
        return pulumi.get(self, "node")


@pulumi.output_type
class GetTopologyLinkLayerItemLinkEndDeviceResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 serial: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        return pulumi.get(self, "serial")


@pulumi.output_type
class GetTopologyLinkLayerItemLinkEndDiscoveredResult(dict):
    def __init__(__self__, *,
                 cdp: 'outputs.GetTopologyLinkLayerItemLinkEndDiscoveredCdpResult',
                 lldp: 'outputs.GetTopologyLinkLayerItemLinkEndDiscoveredLldpResult'):
        pulumi.set(__self__, "cdp", cdp)
        pulumi.set(__self__, "lldp", lldp)

    @_builtins.property
    @pulumi.getter
    def cdp(self) -> 'outputs.GetTopologyLinkLayerItemLinkEndDiscoveredCdpResult':
        return pulumi.get(self, "cdp")

    @_builtins.property
    @pulumi.getter
    def lldp(self) -> 'outputs.GetTopologyLinkLayerItemLinkEndDiscoveredLldpResult':
        return pulumi.get(self, "lldp")


@pulumi.output_type
class GetTopologyLinkLayerItemLinkEndDiscoveredCdpResult(dict):
    def __init__(__self__, *,
                 native_vlan: _builtins.int,
                 port_id: _builtins.str):
        pulumi.set(__self__, "native_vlan", native_vlan)
        pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="nativeVlan")
    def native_vlan(self) -> _builtins.int:
        return pulumi.get(self, "native_vlan")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")


@pulumi.output_type
class GetTopologyLinkLayerItemLinkEndDiscoveredLldpResult(dict):
    def __init__(__self__, *,
                 port_description: _builtins.str,
                 port_id: _builtins.str):
        pulumi.set(__self__, "port_description", port_description)
        pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="portDescription")
    def port_description(self) -> _builtins.str:
        return pulumi.get(self, "port_description")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")


@pulumi.output_type
class GetTopologyLinkLayerItemLinkEndNodeResult(dict):
    def __init__(__self__, *,
                 derived_id: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "derived_id", derived_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="derivedId")
    def derived_id(self) -> _builtins.str:
        return pulumi.get(self, "derived_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTopologyLinkLayerItemNodeResult(dict):
    def __init__(__self__, *,
                 derived_id: _builtins.str,
                 discovered: 'outputs.GetTopologyLinkLayerItemNodeDiscoveredResult',
                 mac: _builtins.str,
                 root: _builtins.bool,
                 type: _builtins.str):
        pulumi.set(__self__, "derived_id", derived_id)
        pulumi.set(__self__, "discovered", discovered)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "root", root)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="derivedId")
    def derived_id(self) -> _builtins.str:
        return pulumi.get(self, "derived_id")

    @_builtins.property
    @pulumi.getter
    def discovered(self) -> 'outputs.GetTopologyLinkLayerItemNodeDiscoveredResult':
        return pulumi.get(self, "discovered")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def root(self) -> _builtins.bool:
        return pulumi.get(self, "root")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTopologyLinkLayerItemNodeDiscoveredResult(dict):
    def __init__(__self__, *,
                 cdp: _builtins.str,
                 lldp: 'outputs.GetTopologyLinkLayerItemNodeDiscoveredLldpResult'):
        pulumi.set(__self__, "cdp", cdp)
        pulumi.set(__self__, "lldp", lldp)

    @_builtins.property
    @pulumi.getter
    def cdp(self) -> _builtins.str:
        return pulumi.get(self, "cdp")

    @_builtins.property
    @pulumi.getter
    def lldp(self) -> 'outputs.GetTopologyLinkLayerItemNodeDiscoveredLldpResult':
        return pulumi.get(self, "lldp")


@pulumi.output_type
class GetTopologyLinkLayerItemNodeDiscoveredLldpResult(dict):
    def __init__(__self__, *,
                 chassis_id: _builtins.str,
                 management_address: _builtins.str,
                 system_capabilities: Sequence[_builtins.str],
                 system_description: _builtins.str,
                 system_name: _builtins.str):
        pulumi.set(__self__, "chassis_id", chassis_id)
        pulumi.set(__self__, "management_address", management_address)
        pulumi.set(__self__, "system_capabilities", system_capabilities)
        pulumi.set(__self__, "system_description", system_description)
        pulumi.set(__self__, "system_name", system_name)

    @_builtins.property
    @pulumi.getter(name="chassisId")
    def chassis_id(self) -> _builtins.str:
        return pulumi.get(self, "chassis_id")

    @_builtins.property
    @pulumi.getter(name="managementAddress")
    def management_address(self) -> _builtins.str:
        return pulumi.get(self, "management_address")

    @_builtins.property
    @pulumi.getter(name="systemCapabilities")
    def system_capabilities(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "system_capabilities")

    @_builtins.property
    @pulumi.getter(name="systemDescription")
    def system_description(self) -> _builtins.str:
        return pulumi.get(self, "system_description")

    @_builtins.property
    @pulumi.getter(name="systemName")
    def system_name(self) -> _builtins.str:
        return pulumi.get(self, "system_name")


@pulumi.output_type
class GetTrafficAnalysisItemResult(dict):
    def __init__(__self__, *,
                 custom_pie_chart_items: Sequence['outputs.GetTrafficAnalysisItemCustomPieChartItemResult'],
                 mode: _builtins.str):
        """
        :param Sequence['GetTrafficAnalysisItemCustomPieChartItemArgs'] custom_pie_chart_items: The list of items that make up the custom pie chart for traffic reporting.
        :param _builtins.str mode: The traffic analysis mode for the network. Can be one of 'disabled' (do not collect traffic types),
               'basic' (collect generic traffic categories), or 'detailed' (collect destination hostnames).
        """
        pulumi.set(__self__, "custom_pie_chart_items", custom_pie_chart_items)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="customPieChartItems")
    def custom_pie_chart_items(self) -> Sequence['outputs.GetTrafficAnalysisItemCustomPieChartItemResult']:
        """
        The list of items that make up the custom pie chart for traffic reporting.
        """
        return pulumi.get(self, "custom_pie_chart_items")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The traffic analysis mode for the network. Can be one of 'disabled' (do not collect traffic types),
        'basic' (collect generic traffic categories), or 'detailed' (collect destination hostnames).
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetTrafficAnalysisItemCustomPieChartItemResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the custom pie chart item.
        :param _builtins.str type: The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
        :param _builtins.str value: The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
               (see sample request/response for more details).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the custom pie chart item.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
        (see sample request/response for more details).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetTrafficShapingApplicationCategoriesItemResult(dict):
    def __init__(__self__, *,
                 application_categories: Sequence['outputs.GetTrafficShapingApplicationCategoriesItemApplicationCategoryResult']):
        pulumi.set(__self__, "application_categories", application_categories)

    @_builtins.property
    @pulumi.getter(name="applicationCategories")
    def application_categories(self) -> Sequence['outputs.GetTrafficShapingApplicationCategoriesItemApplicationCategoryResult']:
        return pulumi.get(self, "application_categories")


@pulumi.output_type
class GetTrafficShapingApplicationCategoriesItemApplicationCategoryResult(dict):
    def __init__(__self__, *,
                 applications: Sequence['outputs.GetTrafficShapingApplicationCategoriesItemApplicationCategoryApplicationResult'],
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "applications", applications)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> Sequence['outputs.GetTrafficShapingApplicationCategoriesItemApplicationCategoryApplicationResult']:
        return pulumi.get(self, "applications")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetTrafficShapingApplicationCategoriesItemApplicationCategoryApplicationResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetTrafficShapingDscpTaggingOptionsItemResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 dscp_tag_value: _builtins.int):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dscp_tag_value", dscp_tag_value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="dscpTagValue")
    def dscp_tag_value(self) -> _builtins.int:
        return pulumi.get(self, "dscp_tag_value")


@pulumi.output_type
class GetVlanProfilesAssignmentsByDeviceItemResult(dict):
    def __init__(__self__, *,
                 mac: _builtins.str,
                 name: _builtins.str,
                 product_type: _builtins.str,
                 serial: _builtins.str,
                 stack: 'outputs.GetVlanProfilesAssignmentsByDeviceItemStackResult',
                 vlan_profile: 'outputs.GetVlanProfilesAssignmentsByDeviceItemVlanProfileResult'):
        """
        :param _builtins.str mac: MAC address of the device
        :param _builtins.str name: Name of the Device
        :param _builtins.str product_type: The product type
        :param _builtins.str serial: Serial of the Device
        :param 'GetVlanProfilesAssignmentsByDeviceItemStackArgs' stack: The Switch Stack the device belongs to
        :param 'GetVlanProfilesAssignmentsByDeviceItemVlanProfileArgs' vlan_profile: The VLAN Profile
        """
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product_type", product_type)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "stack", stack)
        pulumi.set(__self__, "vlan_profile", vlan_profile)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        MAC address of the device
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Device
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> _builtins.str:
        """
        The product type
        """
        return pulumi.get(self, "product_type")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Serial of the Device
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def stack(self) -> 'outputs.GetVlanProfilesAssignmentsByDeviceItemStackResult':
        """
        The Switch Stack the device belongs to
        """
        return pulumi.get(self, "stack")

    @_builtins.property
    @pulumi.getter(name="vlanProfile")
    def vlan_profile(self) -> 'outputs.GetVlanProfilesAssignmentsByDeviceItemVlanProfileResult':
        """
        The VLAN Profile
        """
        return pulumi.get(self, "vlan_profile")


@pulumi.output_type
class GetVlanProfilesAssignmentsByDeviceItemStackResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the Switch Stack
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the Switch Stack
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetVlanProfilesAssignmentsByDeviceItemVlanProfileResult(dict):
    def __init__(__self__, *,
                 iname: _builtins.str,
                 is_default: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.str iname: IName of the VLAN Profile
        :param _builtins.bool is_default: Is this VLAN profile the default for the network?
        :param _builtins.str name: Name of the VLAN Profile
        """
        pulumi.set(__self__, "iname", iname)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def iname(self) -> _builtins.str:
        """
        IName of the VLAN Profile
        """
        return pulumi.get(self, "iname")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> _builtins.bool:
        """
        Is this VLAN profile the default for the network?
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the VLAN Profile
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetVlanProfilesItemResult(dict):
    def __init__(__self__, *,
                 iname: _builtins.str,
                 is_default: _builtins.bool,
                 name: _builtins.str,
                 vlan_groups: Sequence['outputs.GetVlanProfilesItemVlanGroupResult'],
                 vlan_names: Sequence['outputs.GetVlanProfilesItemVlanNameResult']):
        """
        :param _builtins.str iname: IName of the VLAN profile
        :param _builtins.bool is_default: Boolean indicating the default VLAN Profile for any device that does not have a profile explicitly assigned
        :param _builtins.str name: Name of the profile, string length must be from 1 to 255 characters
        :param Sequence['GetVlanProfilesItemVlanGroupArgs'] vlan_groups: An array of named VLANs
        :param Sequence['GetVlanProfilesItemVlanNameArgs'] vlan_names: An array of named VLANs
        """
        pulumi.set(__self__, "iname", iname)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vlan_groups", vlan_groups)
        pulumi.set(__self__, "vlan_names", vlan_names)

    @_builtins.property
    @pulumi.getter
    def iname(self) -> _builtins.str:
        """
        IName of the VLAN profile
        """
        return pulumi.get(self, "iname")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> _builtins.bool:
        """
        Boolean indicating the default VLAN Profile for any device that does not have a profile explicitly assigned
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the profile, string length must be from 1 to 255 characters
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="vlanGroups")
    def vlan_groups(self) -> Sequence['outputs.GetVlanProfilesItemVlanGroupResult']:
        """
        An array of named VLANs
        """
        return pulumi.get(self, "vlan_groups")

    @_builtins.property
    @pulumi.getter(name="vlanNames")
    def vlan_names(self) -> Sequence['outputs.GetVlanProfilesItemVlanNameResult']:
        """
        An array of named VLANs
        """
        return pulumi.get(self, "vlan_names")


@pulumi.output_type
class GetVlanProfilesItemVlanGroupResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 vlan_ids: _builtins.str):
        """
        :param _builtins.str name: Name of the VLAN, string length must be from 1 to 32 characters
        :param _builtins.str vlan_ids: Comma-separated VLAN IDs or ID ranges
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vlan_ids", vlan_ids)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the VLAN, string length must be from 1 to 32 characters
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> _builtins.str:
        """
        Comma-separated VLAN IDs or ID ranges
        """
        return pulumi.get(self, "vlan_ids")


@pulumi.output_type
class GetVlanProfilesItemVlanNameResult(dict):
    def __init__(__self__, *,
                 adaptive_policy_group: 'outputs.GetVlanProfilesItemVlanNameAdaptivePolicyGroupResult',
                 name: _builtins.str,
                 vlan_id: _builtins.str):
        """
        :param 'GetVlanProfilesItemVlanNameAdaptivePolicyGroupArgs' adaptive_policy_group: Adaptive Policy Group assigned to Vlan ID
        :param _builtins.str name: Name of the VLAN, string length must be from 1 to 32 characters
        :param _builtins.str vlan_id: VLAN ID
        """
        pulumi.set(__self__, "adaptive_policy_group", adaptive_policy_group)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter(name="adaptivePolicyGroup")
    def adaptive_policy_group(self) -> 'outputs.GetVlanProfilesItemVlanNameAdaptivePolicyGroupResult':
        """
        Adaptive Policy Group assigned to Vlan ID
        """
        return pulumi.get(self, "adaptive_policy_group")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the VLAN, string length must be from 1 to 32 characters
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        """
        VLAN ID
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetVlanProfilesItemVlanNameAdaptivePolicyGroupResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: Adaptive Policy Group ID
        :param _builtins.str name: Adaptive Policy Group name
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Adaptive Policy Group ID
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Adaptive Policy Group name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWebhooksHttpServersItemResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 network_id: _builtins.str,
                 payload_template: 'outputs.GetWebhooksHttpServersItemPayloadTemplateResult',
                 url: _builtins.str):
        """
        :param _builtins.str id: A Base64 encoded ID.
        :param _builtins.str name: A name for easy reference to the HTTP server
        :param _builtins.str network_id: A Meraki network ID.
        :param 'GetWebhooksHttpServersItemPayloadTemplateArgs' payload_template: The payload template to use when posting data to the HTTP server.
        :param _builtins.str url: The URL of the HTTP server.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "payload_template", payload_template)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        A Base64 encoded ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A name for easy reference to the HTTP server
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        A Meraki network ID.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="payloadTemplate")
    def payload_template(self) -> 'outputs.GetWebhooksHttpServersItemPayloadTemplateResult':
        """
        The payload template to use when posting data to the HTTP server.
        """
        return pulumi.get(self, "payload_template")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the HTTP server.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetWebhooksHttpServersItemPayloadTemplateResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 payload_template_id: _builtins.str):
        """
        :param _builtins.str name: The name of the payload template.
        :param _builtins.str payload_template_id: The ID of the payload template.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "payload_template_id", payload_template_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the payload template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="payloadTemplateId")
    def payload_template_id(self) -> _builtins.str:
        """
        The ID of the payload template.
        """
        return pulumi.get(self, "payload_template_id")


@pulumi.output_type
class GetWebhooksPayloadTemplatesItemResult(dict):
    def __init__(__self__, *,
                 body: _builtins.str,
                 headers: Sequence['outputs.GetWebhooksPayloadTemplatesItemHeaderResult'],
                 name: _builtins.str,
                 payload_template_id: _builtins.str,
                 sharing: 'outputs.GetWebhooksPayloadTemplatesItemSharingResult',
                 type: _builtins.str):
        """
        :param _builtins.str body: The body of the payload template, in liquid template
        :param Sequence['GetWebhooksPayloadTemplatesItemHeaderArgs'] headers: The payload template headers, will be rendered as a key-value pair in the webhook.
        :param _builtins.str name: The name of the payload template
        :param _builtins.str payload_template_id: Webhook payload template Id
        :param 'GetWebhooksPayloadTemplatesItemSharingArgs' sharing: Information on which entities have access to the template
        :param _builtins.str type: The type of the payload template
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "payload_template_id", payload_template_id)
        pulumi.set(__self__, "sharing", sharing)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        The body of the payload template, in liquid template
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetWebhooksPayloadTemplatesItemHeaderResult']:
        """
        The payload template headers, will be rendered as a key-value pair in the webhook.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the payload template
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="payloadTemplateId")
    def payload_template_id(self) -> _builtins.str:
        """
        Webhook payload template Id
        """
        return pulumi.get(self, "payload_template_id")

    @_builtins.property
    @pulumi.getter
    def sharing(self) -> 'outputs.GetWebhooksPayloadTemplatesItemSharingResult':
        """
        Information on which entities have access to the template
        """
        return pulumi.get(self, "sharing")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the payload template
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetWebhooksPayloadTemplatesItemHeaderResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 template: _builtins.str):
        """
        :param _builtins.str name: The name of the header attribute
        :param _builtins.str template: The value returned in the header attribute, in liquid template
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the header attribute
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def template(self) -> _builtins.str:
        """
        The value returned in the header attribute, in liquid template
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class GetWebhooksPayloadTemplatesItemSharingResult(dict):
    def __init__(__self__, *,
                 by_network: 'outputs.GetWebhooksPayloadTemplatesItemSharingByNetworkResult'):
        """
        :param 'GetWebhooksPayloadTemplatesItemSharingByNetworkArgs' by_network: Information on network access to the template
        """
        pulumi.set(__self__, "by_network", by_network)

    @_builtins.property
    @pulumi.getter(name="byNetwork")
    def by_network(self) -> 'outputs.GetWebhooksPayloadTemplatesItemSharingByNetworkResult':
        """
        Information on network access to the template
        """
        return pulumi.get(self, "by_network")


@pulumi.output_type
class GetWebhooksPayloadTemplatesItemSharingByNetworkResult(dict):
    def __init__(__self__, *,
                 admins_can_modify: _builtins.bool):
        """
        :param _builtins.bool admins_can_modify: Indicates whether network admins may modify this template
        """
        pulumi.set(__self__, "admins_can_modify", admins_can_modify)

    @_builtins.property
    @pulumi.getter(name="adminsCanModify")
    def admins_can_modify(self) -> _builtins.bool:
        """
        Indicates whether network admins may modify this template
        """
        return pulumi.get(self, "admins_can_modify")


@pulumi.output_type
class GetWebhooksWebhookTestsItemResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 status: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str id: Webhook delivery identifier
        :param _builtins.str status: Current status of the webhook delivery
        :param _builtins.str url: URL where the webhook was delivered
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Webhook delivery identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Current status of the webhook delivery
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL where the webhook was delivered
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetWirelessAlternateManagementInterfaceItemResult(dict):
    def __init__(__self__, *,
                 access_points: Sequence['outputs.GetWirelessAlternateManagementInterfaceItemAccessPointResult'],
                 enabled: _builtins.bool,
                 protocols: Sequence[_builtins.str],
                 vlan_id: _builtins.int):
        pulumi.set(__self__, "access_points", access_points)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "protocols", protocols)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter(name="accessPoints")
    def access_points(self) -> Sequence['outputs.GetWirelessAlternateManagementInterfaceItemAccessPointResult']:
        return pulumi.get(self, "access_points")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.int:
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetWirelessAlternateManagementInterfaceItemAccessPointResult(dict):
    def __init__(__self__, *,
                 alternate_management_ip: _builtins.str,
                 dns1: _builtins.str,
                 dns2: _builtins.str,
                 gateway: _builtins.str,
                 serial: _builtins.str,
                 subnet_mask: _builtins.str):
        pulumi.set(__self__, "alternate_management_ip", alternate_management_ip)
        pulumi.set(__self__, "dns1", dns1)
        pulumi.set(__self__, "dns2", dns2)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "subnet_mask", subnet_mask)

    @_builtins.property
    @pulumi.getter(name="alternateManagementIp")
    def alternate_management_ip(self) -> _builtins.str:
        return pulumi.get(self, "alternate_management_ip")

    @_builtins.property
    @pulumi.getter
    def dns1(self) -> _builtins.str:
        return pulumi.get(self, "dns1")

    @_builtins.property
    @pulumi.getter
    def dns2(self) -> _builtins.str:
        return pulumi.get(self, "dns2")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> _builtins.str:
        return pulumi.get(self, "subnet_mask")


@pulumi.output_type
class GetWirelessBillingItemResult(dict):
    def __init__(__self__, *,
                 currency: _builtins.str,
                 plans: Sequence['outputs.GetWirelessBillingItemPlanResult']):
        """
        :param _builtins.str currency: The currency code of this node group's billing plans
        :param Sequence['GetWirelessBillingItemPlanArgs'] plans: Array of billing plans in the node group. (Can configure a maximum of 5)
        """
        pulumi.set(__self__, "currency", currency)
        pulumi.set(__self__, "plans", plans)

    @_builtins.property
    @pulumi.getter
    def currency(self) -> _builtins.str:
        """
        The currency code of this node group's billing plans
        """
        return pulumi.get(self, "currency")

    @_builtins.property
    @pulumi.getter
    def plans(self) -> Sequence['outputs.GetWirelessBillingItemPlanResult']:
        """
        Array of billing plans in the node group. (Can configure a maximum of 5)
        """
        return pulumi.get(self, "plans")


@pulumi.output_type
class GetWirelessBillingItemPlanResult(dict):
    def __init__(__self__, *,
                 bandwidth_limits: 'outputs.GetWirelessBillingItemPlanBandwidthLimitsResult',
                 id: _builtins.str,
                 price: _builtins.float,
                 time_limit: _builtins.str):
        """
        :param 'GetWirelessBillingItemPlanBandwidthLimitsArgs' bandwidth_limits: The uplink bandwidth settings for the pricing plan.
        :param _builtins.str id: The id of the pricing plan to update.
        :param _builtins.float price: The price of the billing plan.
        :param _builtins.str time_limit: The time limit of the pricing plan in minutes.
        """
        pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "price", price)
        pulumi.set(__self__, "time_limit", time_limit)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> 'outputs.GetWirelessBillingItemPlanBandwidthLimitsResult':
        """
        The uplink bandwidth settings for the pricing plan.
        """
        return pulumi.get(self, "bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the pricing plan to update.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def price(self) -> _builtins.float:
        """
        The price of the billing plan.
        """
        return pulumi.get(self, "price")

    @_builtins.property
    @pulumi.getter(name="timeLimit")
    def time_limit(self) -> _builtins.str:
        """
        The time limit of the pricing plan in minutes.
        """
        return pulumi.get(self, "time_limit")


@pulumi.output_type
class GetWirelessBillingItemPlanBandwidthLimitsResult(dict):
    def __init__(__self__, *,
                 limit_down: _builtins.int,
                 limit_up: _builtins.int):
        """
        :param _builtins.int limit_down: The maximum download limit (integer, in Kbps).
        :param _builtins.int limit_up: The maximum upload limit (integer, in Kbps).
        """
        pulumi.set(__self__, "limit_down", limit_down)
        pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> _builtins.int:
        """
        The maximum download limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> _builtins.int:
        """
        The maximum upload limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class GetWirelessBluetoothSettingsItemResult(dict):
    def __init__(__self__, *,
                 advertising_enabled: _builtins.bool,
                 esl_enabled: _builtins.bool,
                 major: _builtins.int,
                 major_minor_assignment_mode: _builtins.str,
                 minor: _builtins.int,
                 scanning_enabled: _builtins.bool,
                 uuid: _builtins.str):
        """
        :param _builtins.bool advertising_enabled: Whether APs will advertise beacons.
        :param _builtins.bool esl_enabled: Whether ESL is enabled on this network.
        :param _builtins.int major: The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
        :param _builtins.str major_minor_assignment_mode: The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')
        :param _builtins.int minor: The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
        :param _builtins.bool scanning_enabled: Whether APs will scan for Bluetooth enabled clients.
        :param _builtins.str uuid: The UUID to be used in the beacon identifier.
        """
        pulumi.set(__self__, "advertising_enabled", advertising_enabled)
        pulumi.set(__self__, "esl_enabled", esl_enabled)
        pulumi.set(__self__, "major", major)
        pulumi.set(__self__, "major_minor_assignment_mode", major_minor_assignment_mode)
        pulumi.set(__self__, "minor", minor)
        pulumi.set(__self__, "scanning_enabled", scanning_enabled)
        pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="advertisingEnabled")
    def advertising_enabled(self) -> _builtins.bool:
        """
        Whether APs will advertise beacons.
        """
        return pulumi.get(self, "advertising_enabled")

    @_builtins.property
    @pulumi.getter(name="eslEnabled")
    def esl_enabled(self) -> _builtins.bool:
        """
        Whether ESL is enabled on this network.
        """
        return pulumi.get(self, "esl_enabled")

    @_builtins.property
    @pulumi.getter
    def major(self) -> _builtins.int:
        """
        The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
        """
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter(name="majorMinorAssignmentMode")
    def major_minor_assignment_mode(self) -> _builtins.str:
        """
        The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')
        """
        return pulumi.get(self, "major_minor_assignment_mode")

    @_builtins.property
    @pulumi.getter
    def minor(self) -> _builtins.int:
        """
        The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
        """
        return pulumi.get(self, "minor")

    @_builtins.property
    @pulumi.getter(name="scanningEnabled")
    def scanning_enabled(self) -> _builtins.bool:
        """
        Whether APs will scan for Bluetooth enabled clients.
        """
        return pulumi.get(self, "scanning_enabled")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        The UUID to be used in the beacon identifier.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetWirelessChannelUtilizationHistoryItemResult(dict):
    def __init__(__self__, *,
                 end_ts: _builtins.str,
                 start_ts: _builtins.str,
                 utilization80211: _builtins.float,
                 utilization_non80211: _builtins.float,
                 utilization_total: _builtins.float):
        """
        :param _builtins.str end_ts: The end time of the query range
        :param _builtins.str start_ts: The start time of the query range
        :param _builtins.float utilization80211: Average wifi utilization
        :param _builtins.float utilization_non80211: Average signal interference
        :param _builtins.float utilization_total: Total channel utilization
        """
        pulumi.set(__self__, "end_ts", end_ts)
        pulumi.set(__self__, "start_ts", start_ts)
        pulumi.set(__self__, "utilization80211", utilization80211)
        pulumi.set(__self__, "utilization_non80211", utilization_non80211)
        pulumi.set(__self__, "utilization_total", utilization_total)

    @_builtins.property
    @pulumi.getter(name="endTs")
    def end_ts(self) -> _builtins.str:
        """
        The end time of the query range
        """
        return pulumi.get(self, "end_ts")

    @_builtins.property
    @pulumi.getter(name="startTs")
    def start_ts(self) -> _builtins.str:
        """
        The start time of the query range
        """
        return pulumi.get(self, "start_ts")

    @_builtins.property
    @pulumi.getter
    def utilization80211(self) -> _builtins.float:
        """
        Average wifi utilization
        """
        return pulumi.get(self, "utilization80211")

    @_builtins.property
    @pulumi.getter(name="utilizationNon80211")
    def utilization_non80211(self) -> _builtins.float:
        """
        Average signal interference
        """
        return pulumi.get(self, "utilization_non80211")

    @_builtins.property
    @pulumi.getter(name="utilizationTotal")
    def utilization_total(self) -> _builtins.float:
        """
        Total channel utilization
        """
        return pulumi.get(self, "utilization_total")


@pulumi.output_type
class GetWirelessClientCountHistoryItemResult(dict):
    def __init__(__self__, *,
                 client_count: _builtins.int,
                 end_ts: _builtins.str,
                 start_ts: _builtins.str):
        """
        :param _builtins.int client_count: Number of connected clients
        :param _builtins.str end_ts: The end time of the query range
        :param _builtins.str start_ts: The start time of the query range
        """
        pulumi.set(__self__, "client_count", client_count)
        pulumi.set(__self__, "end_ts", end_ts)
        pulumi.set(__self__, "start_ts", start_ts)

    @_builtins.property
    @pulumi.getter(name="clientCount")
    def client_count(self) -> _builtins.int:
        """
        Number of connected clients
        """
        return pulumi.get(self, "client_count")

    @_builtins.property
    @pulumi.getter(name="endTs")
    def end_ts(self) -> _builtins.str:
        """
        The end time of the query range
        """
        return pulumi.get(self, "end_ts")

    @_builtins.property
    @pulumi.getter(name="startTs")
    def start_ts(self) -> _builtins.str:
        """
        The start time of the query range
        """
        return pulumi.get(self, "start_ts")


@pulumi.output_type
class GetWirelessClientsConnectionStatsItemResult(dict):
    def __init__(__self__, *,
                 connection_stats: 'outputs.GetWirelessClientsConnectionStatsItemConnectionStatsResult',
                 mac: _builtins.str):
        pulumi.set(__self__, "connection_stats", connection_stats)
        pulumi.set(__self__, "mac", mac)

    @_builtins.property
    @pulumi.getter(name="connectionStats")
    def connection_stats(self) -> 'outputs.GetWirelessClientsConnectionStatsItemConnectionStatsResult':
        return pulumi.get(self, "connection_stats")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        return pulumi.get(self, "mac")


@pulumi.output_type
class GetWirelessClientsConnectionStatsItemConnectionStatsResult(dict):
    def __init__(__self__, *,
                 assoc: _builtins.int,
                 auth: _builtins.int,
                 dhcp: _builtins.int,
                 dns: _builtins.int,
                 success: _builtins.int):
        pulumi.set(__self__, "assoc", assoc)
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "success", success)

    @_builtins.property
    @pulumi.getter
    def assoc(self) -> _builtins.int:
        return pulumi.get(self, "assoc")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> _builtins.int:
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def dhcp(self) -> _builtins.int:
        return pulumi.get(self, "dhcp")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> _builtins.int:
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter
    def success(self) -> _builtins.int:
        return pulumi.get(self, "success")


@pulumi.output_type
class GetWirelessClientsLatencyStatsItemResult(dict):
    def __init__(__self__, *,
                 latency_stats: 'outputs.GetWirelessClientsLatencyStatsItemLatencyStatsResult',
                 mac: _builtins.str):
        pulumi.set(__self__, "latency_stats", latency_stats)
        pulumi.set(__self__, "mac", mac)

    @_builtins.property
    @pulumi.getter(name="latencyStats")
    def latency_stats(self) -> 'outputs.GetWirelessClientsLatencyStatsItemLatencyStatsResult':
        return pulumi.get(self, "latency_stats")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        return pulumi.get(self, "mac")


@pulumi.output_type
class GetWirelessClientsLatencyStatsItemLatencyStatsResult(dict):
    def __init__(__self__, *,
                 background_traffic: 'outputs.GetWirelessClientsLatencyStatsItemLatencyStatsBackgroundTrafficResult',
                 best_effort_traffic: _builtins.str,
                 video_traffic: _builtins.str,
                 voice_traffic: _builtins.str):
        pulumi.set(__self__, "background_traffic", background_traffic)
        pulumi.set(__self__, "best_effort_traffic", best_effort_traffic)
        pulumi.set(__self__, "video_traffic", video_traffic)
        pulumi.set(__self__, "voice_traffic", voice_traffic)

    @_builtins.property
    @pulumi.getter(name="backgroundTraffic")
    def background_traffic(self) -> 'outputs.GetWirelessClientsLatencyStatsItemLatencyStatsBackgroundTrafficResult':
        return pulumi.get(self, "background_traffic")

    @_builtins.property
    @pulumi.getter(name="bestEffortTraffic")
    def best_effort_traffic(self) -> _builtins.str:
        return pulumi.get(self, "best_effort_traffic")

    @_builtins.property
    @pulumi.getter(name="videoTraffic")
    def video_traffic(self) -> _builtins.str:
        return pulumi.get(self, "video_traffic")

    @_builtins.property
    @pulumi.getter(name="voiceTraffic")
    def voice_traffic(self) -> _builtins.str:
        return pulumi.get(self, "voice_traffic")


@pulumi.output_type
class GetWirelessClientsLatencyStatsItemLatencyStatsBackgroundTrafficResult(dict):
    def __init__(__self__, *,
                 avg: _builtins.float,
                 raw_distribution: 'outputs.GetWirelessClientsLatencyStatsItemLatencyStatsBackgroundTrafficRawDistributionResult'):
        pulumi.set(__self__, "avg", avg)
        pulumi.set(__self__, "raw_distribution", raw_distribution)

    @_builtins.property
    @pulumi.getter
    def avg(self) -> _builtins.float:
        return pulumi.get(self, "avg")

    @_builtins.property
    @pulumi.getter(name="rawDistribution")
    def raw_distribution(self) -> 'outputs.GetWirelessClientsLatencyStatsItemLatencyStatsBackgroundTrafficRawDistributionResult':
        return pulumi.get(self, "raw_distribution")


@pulumi.output_type
class GetWirelessClientsLatencyStatsItemLatencyStatsBackgroundTrafficRawDistributionResult(dict):
    def __init__(__self__, *,
                 status0: _builtins.int,
                 status1: _builtins.int,
                 status1024: _builtins.int,
                 status128: _builtins.int,
                 status16: _builtins.int,
                 status2: _builtins.int,
                 status2048: _builtins.int,
                 status256: _builtins.int,
                 status32: _builtins.int,
                 status4: _builtins.int,
                 status512: _builtins.int,
                 status64: _builtins.int,
                 status8: _builtins.int):
        pulumi.set(__self__, "status0", status0)
        pulumi.set(__self__, "status1", status1)
        pulumi.set(__self__, "status1024", status1024)
        pulumi.set(__self__, "status128", status128)
        pulumi.set(__self__, "status16", status16)
        pulumi.set(__self__, "status2", status2)
        pulumi.set(__self__, "status2048", status2048)
        pulumi.set(__self__, "status256", status256)
        pulumi.set(__self__, "status32", status32)
        pulumi.set(__self__, "status4", status4)
        pulumi.set(__self__, "status512", status512)
        pulumi.set(__self__, "status64", status64)
        pulumi.set(__self__, "status8", status8)

    @_builtins.property
    @pulumi.getter
    def status0(self) -> _builtins.int:
        return pulumi.get(self, "status0")

    @_builtins.property
    @pulumi.getter
    def status1(self) -> _builtins.int:
        return pulumi.get(self, "status1")

    @_builtins.property
    @pulumi.getter
    def status1024(self) -> _builtins.int:
        return pulumi.get(self, "status1024")

    @_builtins.property
    @pulumi.getter
    def status128(self) -> _builtins.int:
        return pulumi.get(self, "status128")

    @_builtins.property
    @pulumi.getter
    def status16(self) -> _builtins.int:
        return pulumi.get(self, "status16")

    @_builtins.property
    @pulumi.getter
    def status2(self) -> _builtins.int:
        return pulumi.get(self, "status2")

    @_builtins.property
    @pulumi.getter
    def status2048(self) -> _builtins.int:
        return pulumi.get(self, "status2048")

    @_builtins.property
    @pulumi.getter
    def status256(self) -> _builtins.int:
        return pulumi.get(self, "status256")

    @_builtins.property
    @pulumi.getter
    def status32(self) -> _builtins.int:
        return pulumi.get(self, "status32")

    @_builtins.property
    @pulumi.getter
    def status4(self) -> _builtins.int:
        return pulumi.get(self, "status4")

    @_builtins.property
    @pulumi.getter
    def status512(self) -> _builtins.int:
        return pulumi.get(self, "status512")

    @_builtins.property
    @pulumi.getter
    def status64(self) -> _builtins.int:
        return pulumi.get(self, "status64")

    @_builtins.property
    @pulumi.getter
    def status8(self) -> _builtins.int:
        return pulumi.get(self, "status8")


@pulumi.output_type
class GetWirelessConnectionStatsItemResult(dict):
    def __init__(__self__, *,
                 assoc: _builtins.int,
                 auth: _builtins.int,
                 dhcp: _builtins.int,
                 dns: _builtins.int,
                 success: _builtins.int):
        """
        :param _builtins.int assoc: The number of failed association attempts
        :param _builtins.int auth: The number of failed authentication attempts
        :param _builtins.int dhcp: The number of failed DHCP attempts
        :param _builtins.int dns: The number of failed DNS attempts
        :param _builtins.int success: The number of successful connection attempts
        """
        pulumi.set(__self__, "assoc", assoc)
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "success", success)

    @_builtins.property
    @pulumi.getter
    def assoc(self) -> _builtins.int:
        """
        The number of failed association attempts
        """
        return pulumi.get(self, "assoc")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> _builtins.int:
        """
        The number of failed authentication attempts
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def dhcp(self) -> _builtins.int:
        """
        The number of failed DHCP attempts
        """
        return pulumi.get(self, "dhcp")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> _builtins.int:
        """
        The number of failed DNS attempts
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter
    def success(self) -> _builtins.int:
        """
        The number of successful connection attempts
        """
        return pulumi.get(self, "success")


@pulumi.output_type
class GetWirelessDataRateHistoryItemResult(dict):
    def __init__(__self__, *,
                 average_kbps: _builtins.int,
                 download_kbps: _builtins.int,
                 end_ts: _builtins.str,
                 start_ts: _builtins.str,
                 upload_kbps: _builtins.int):
        """
        :param _builtins.int average_kbps: Average data rate in kilobytes-per-second
        :param _builtins.int download_kbps: Download rate in kilobytes-per-second
        :param _builtins.str end_ts: The end time of the query range
        :param _builtins.str start_ts: The start time of the query range
        :param _builtins.int upload_kbps: Upload rate in kilobytes-per-second
        """
        pulumi.set(__self__, "average_kbps", average_kbps)
        pulumi.set(__self__, "download_kbps", download_kbps)
        pulumi.set(__self__, "end_ts", end_ts)
        pulumi.set(__self__, "start_ts", start_ts)
        pulumi.set(__self__, "upload_kbps", upload_kbps)

    @_builtins.property
    @pulumi.getter(name="averageKbps")
    def average_kbps(self) -> _builtins.int:
        """
        Average data rate in kilobytes-per-second
        """
        return pulumi.get(self, "average_kbps")

    @_builtins.property
    @pulumi.getter(name="downloadKbps")
    def download_kbps(self) -> _builtins.int:
        """
        Download rate in kilobytes-per-second
        """
        return pulumi.get(self, "download_kbps")

    @_builtins.property
    @pulumi.getter(name="endTs")
    def end_ts(self) -> _builtins.str:
        """
        The end time of the query range
        """
        return pulumi.get(self, "end_ts")

    @_builtins.property
    @pulumi.getter(name="startTs")
    def start_ts(self) -> _builtins.str:
        """
        The start time of the query range
        """
        return pulumi.get(self, "start_ts")

    @_builtins.property
    @pulumi.getter(name="uploadKbps")
    def upload_kbps(self) -> _builtins.int:
        """
        Upload rate in kilobytes-per-second
        """
        return pulumi.get(self, "upload_kbps")


@pulumi.output_type
class GetWirelessDevicesConnectionStatsItemResult(dict):
    def __init__(__self__, *,
                 connection_stats: 'outputs.GetWirelessDevicesConnectionStatsItemConnectionStatsResult',
                 serial: _builtins.str):
        """
        :param 'GetWirelessDevicesConnectionStatsItemConnectionStatsArgs' connection_stats: The connection stats of the device
        :param _builtins.str serial: The serial number for the device
        """
        pulumi.set(__self__, "connection_stats", connection_stats)
        pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter(name="connectionStats")
    def connection_stats(self) -> 'outputs.GetWirelessDevicesConnectionStatsItemConnectionStatsResult':
        """
        The connection stats of the device
        """
        return pulumi.get(self, "connection_stats")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        The serial number for the device
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class GetWirelessDevicesConnectionStatsItemConnectionStatsResult(dict):
    def __init__(__self__, *,
                 assoc: _builtins.int,
                 auth: _builtins.int,
                 dhcp: _builtins.int,
                 dns: _builtins.int,
                 success: _builtins.int):
        """
        :param _builtins.int assoc: The number of failed association attempts
        :param _builtins.int auth: The number of failed authentication attempts
        :param _builtins.int dhcp: The number of failed DHCP attempts
        :param _builtins.int dns: The number of failed DNS attempts
        :param _builtins.int success: The number of successful connection attempts
        """
        pulumi.set(__self__, "assoc", assoc)
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "success", success)

    @_builtins.property
    @pulumi.getter
    def assoc(self) -> _builtins.int:
        """
        The number of failed association attempts
        """
        return pulumi.get(self, "assoc")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> _builtins.int:
        """
        The number of failed authentication attempts
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def dhcp(self) -> _builtins.int:
        """
        The number of failed DHCP attempts
        """
        return pulumi.get(self, "dhcp")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> _builtins.int:
        """
        The number of failed DNS attempts
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter
    def success(self) -> _builtins.int:
        """
        The number of successful connection attempts
        """
        return pulumi.get(self, "success")


@pulumi.output_type
class GetWirelessEthernetPortsProfilesItemResult(dict):
    def __init__(__self__, *,
                 is_default: _builtins.bool,
                 name: _builtins.str,
                 ports: Sequence['outputs.GetWirelessEthernetPortsProfilesItemPortResult'],
                 profile_id: _builtins.str,
                 usb_ports: Sequence['outputs.GetWirelessEthernetPortsProfilesItemUsbPortResult']):
        """
        :param _builtins.bool is_default: Is default profile
        :param _builtins.str name: AP port profile name
        :param Sequence['GetWirelessEthernetPortsProfilesItemPortArgs'] ports: Ports config
        :param _builtins.str profile_id: AP port profile ID
        :param Sequence['GetWirelessEthernetPortsProfilesItemUsbPortArgs'] usb_ports: Usb ports config
        """
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "profile_id", profile_id)
        pulumi.set(__self__, "usb_ports", usb_ports)

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> _builtins.bool:
        """
        Is default profile
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        AP port profile name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.GetWirelessEthernetPortsProfilesItemPortResult']:
        """
        Ports config
        """
        return pulumi.get(self, "ports")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> _builtins.str:
        """
        AP port profile ID
        """
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter(name="usbPorts")
    def usb_ports(self) -> Sequence['outputs.GetWirelessEthernetPortsProfilesItemUsbPortResult']:
        """
        Usb ports config
        """
        return pulumi.get(self, "usb_ports")


@pulumi.output_type
class GetWirelessEthernetPortsProfilesItemPortResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 name: _builtins.str,
                 number: _builtins.int,
                 psk_group_id: _builtins.str,
                 ssid: _builtins.int):
        """
        :param _builtins.bool enabled: Enabled
        :param _builtins.str name: Name
        :param _builtins.int number: Number
        :param _builtins.str psk_group_id: PSK Group number
        :param _builtins.int ssid: Ssid number
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "psk_group_id", psk_group_id)
        pulumi.set(__self__, "ssid", ssid)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def number(self) -> _builtins.int:
        """
        Number
        """
        return pulumi.get(self, "number")

    @_builtins.property
    @pulumi.getter(name="pskGroupId")
    def psk_group_id(self) -> _builtins.str:
        """
        PSK Group number
        """
        return pulumi.get(self, "psk_group_id")

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> _builtins.int:
        """
        Ssid number
        """
        return pulumi.get(self, "ssid")


@pulumi.output_type
class GetWirelessEthernetPortsProfilesItemUsbPortResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 name: _builtins.str,
                 ssid: _builtins.int):
        """
        :param _builtins.bool enabled: Enabled
        :param _builtins.str name: Name
        :param _builtins.int ssid: Ssid number
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ssid", ssid)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> _builtins.int:
        """
        Ssid number
        """
        return pulumi.get(self, "ssid")


@pulumi.output_type
class GetWirelessFailedConnectionsItemResult(dict):
    def __init__(__self__, *,
                 client_mac: _builtins.str,
                 failure_step: _builtins.str,
                 serial: _builtins.str,
                 ssid_number: _builtins.int,
                 ts: _builtins.str,
                 type: _builtins.str,
                 vlan: _builtins.int):
        """
        :param _builtins.str client_mac: Client Mac
        :param _builtins.str failure_step: The failed onboarding step. One of: assoc, auth, dhcp, dns.
        :param _builtins.str serial: Serial Number
        :param _builtins.int ssid_number: SSID Number
        :param _builtins.str ts: The timestamp when the client mac failed
        :param _builtins.str type: The failure type in the onboarding step
        :param _builtins.int vlan: LAN
        """
        pulumi.set(__self__, "client_mac", client_mac)
        pulumi.set(__self__, "failure_step", failure_step)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "ssid_number", ssid_number)
        pulumi.set(__self__, "ts", ts)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter(name="clientMac")
    def client_mac(self) -> _builtins.str:
        """
        Client Mac
        """
        return pulumi.get(self, "client_mac")

    @_builtins.property
    @pulumi.getter(name="failureStep")
    def failure_step(self) -> _builtins.str:
        """
        The failed onboarding step. One of: assoc, auth, dhcp, dns.
        """
        return pulumi.get(self, "failure_step")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Serial Number
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="ssidNumber")
    def ssid_number(self) -> _builtins.int:
        """
        SSID Number
        """
        return pulumi.get(self, "ssid_number")

    @_builtins.property
    @pulumi.getter
    def ts(self) -> _builtins.str:
        """
        The timestamp when the client mac failed
        """
        return pulumi.get(self, "ts")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The failure type in the onboarding step
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.int:
        """
        LAN
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetWirelessLatencyHistoryItemResult(dict):
    def __init__(__self__, *,
                 avg_latency_ms: _builtins.int,
                 end_ts: _builtins.str,
                 start_ts: _builtins.str):
        """
        :param _builtins.int avg_latency_ms: Average latency in milliseconds
        :param _builtins.str end_ts: The end time of the query range
        :param _builtins.str start_ts: The start time of the query range
        """
        pulumi.set(__self__, "avg_latency_ms", avg_latency_ms)
        pulumi.set(__self__, "end_ts", end_ts)
        pulumi.set(__self__, "start_ts", start_ts)

    @_builtins.property
    @pulumi.getter(name="avgLatencyMs")
    def avg_latency_ms(self) -> _builtins.int:
        """
        Average latency in milliseconds
        """
        return pulumi.get(self, "avg_latency_ms")

    @_builtins.property
    @pulumi.getter(name="endTs")
    def end_ts(self) -> _builtins.str:
        """
        The end time of the query range
        """
        return pulumi.get(self, "end_ts")

    @_builtins.property
    @pulumi.getter(name="startTs")
    def start_ts(self) -> _builtins.str:
        """
        The start time of the query range
        """
        return pulumi.get(self, "start_ts")


@pulumi.output_type
class GetWirelessLatencyStatsItemResult(dict):
    def __init__(__self__, *,
                 background_traffic: 'outputs.GetWirelessLatencyStatsItemBackgroundTrafficResult',
                 best_effort_traffic: _builtins.str,
                 video_traffic: _builtins.str,
                 voice_traffic: _builtins.str):
        pulumi.set(__self__, "background_traffic", background_traffic)
        pulumi.set(__self__, "best_effort_traffic", best_effort_traffic)
        pulumi.set(__self__, "video_traffic", video_traffic)
        pulumi.set(__self__, "voice_traffic", voice_traffic)

    @_builtins.property
    @pulumi.getter(name="backgroundTraffic")
    def background_traffic(self) -> 'outputs.GetWirelessLatencyStatsItemBackgroundTrafficResult':
        return pulumi.get(self, "background_traffic")

    @_builtins.property
    @pulumi.getter(name="bestEffortTraffic")
    def best_effort_traffic(self) -> _builtins.str:
        return pulumi.get(self, "best_effort_traffic")

    @_builtins.property
    @pulumi.getter(name="videoTraffic")
    def video_traffic(self) -> _builtins.str:
        return pulumi.get(self, "video_traffic")

    @_builtins.property
    @pulumi.getter(name="voiceTraffic")
    def voice_traffic(self) -> _builtins.str:
        return pulumi.get(self, "voice_traffic")


@pulumi.output_type
class GetWirelessLatencyStatsItemBackgroundTrafficResult(dict):
    def __init__(__self__, *,
                 avg: _builtins.float,
                 raw_distribution: 'outputs.GetWirelessLatencyStatsItemBackgroundTrafficRawDistributionResult'):
        pulumi.set(__self__, "avg", avg)
        pulumi.set(__self__, "raw_distribution", raw_distribution)

    @_builtins.property
    @pulumi.getter
    def avg(self) -> _builtins.float:
        return pulumi.get(self, "avg")

    @_builtins.property
    @pulumi.getter(name="rawDistribution")
    def raw_distribution(self) -> 'outputs.GetWirelessLatencyStatsItemBackgroundTrafficRawDistributionResult':
        return pulumi.get(self, "raw_distribution")


@pulumi.output_type
class GetWirelessLatencyStatsItemBackgroundTrafficRawDistributionResult(dict):
    def __init__(__self__, *,
                 status0: _builtins.int,
                 status1: _builtins.int,
                 status1024: _builtins.int,
                 status128: _builtins.int,
                 status16: _builtins.int,
                 status2: _builtins.int,
                 status2048: _builtins.int,
                 status256: _builtins.int,
                 status32: _builtins.int,
                 status4: _builtins.int,
                 status512: _builtins.int,
                 status64: _builtins.int,
                 status8: _builtins.int):
        pulumi.set(__self__, "status0", status0)
        pulumi.set(__self__, "status1", status1)
        pulumi.set(__self__, "status1024", status1024)
        pulumi.set(__self__, "status128", status128)
        pulumi.set(__self__, "status16", status16)
        pulumi.set(__self__, "status2", status2)
        pulumi.set(__self__, "status2048", status2048)
        pulumi.set(__self__, "status256", status256)
        pulumi.set(__self__, "status32", status32)
        pulumi.set(__self__, "status4", status4)
        pulumi.set(__self__, "status512", status512)
        pulumi.set(__self__, "status64", status64)
        pulumi.set(__self__, "status8", status8)

    @_builtins.property
    @pulumi.getter
    def status0(self) -> _builtins.int:
        return pulumi.get(self, "status0")

    @_builtins.property
    @pulumi.getter
    def status1(self) -> _builtins.int:
        return pulumi.get(self, "status1")

    @_builtins.property
    @pulumi.getter
    def status1024(self) -> _builtins.int:
        return pulumi.get(self, "status1024")

    @_builtins.property
    @pulumi.getter
    def status128(self) -> _builtins.int:
        return pulumi.get(self, "status128")

    @_builtins.property
    @pulumi.getter
    def status16(self) -> _builtins.int:
        return pulumi.get(self, "status16")

    @_builtins.property
    @pulumi.getter
    def status2(self) -> _builtins.int:
        return pulumi.get(self, "status2")

    @_builtins.property
    @pulumi.getter
    def status2048(self) -> _builtins.int:
        return pulumi.get(self, "status2048")

    @_builtins.property
    @pulumi.getter
    def status256(self) -> _builtins.int:
        return pulumi.get(self, "status256")

    @_builtins.property
    @pulumi.getter
    def status32(self) -> _builtins.int:
        return pulumi.get(self, "status32")

    @_builtins.property
    @pulumi.getter
    def status4(self) -> _builtins.int:
        return pulumi.get(self, "status4")

    @_builtins.property
    @pulumi.getter
    def status512(self) -> _builtins.int:
        return pulumi.get(self, "status512")

    @_builtins.property
    @pulumi.getter
    def status64(self) -> _builtins.int:
        return pulumi.get(self, "status64")

    @_builtins.property
    @pulumi.getter
    def status8(self) -> _builtins.int:
        return pulumi.get(self, "status8")


@pulumi.output_type
class GetWirelessMeshStatusesItemResult(dict):
    def __init__(__self__, *,
                 latest_mesh_performance: 'outputs.GetWirelessMeshStatusesItemLatestMeshPerformanceResult',
                 mesh_routes: Sequence[_builtins.str],
                 serial: _builtins.str):
        """
        :param 'GetWirelessMeshStatusesItemLatestMeshPerformanceArgs' latest_mesh_performance: Current metrics on how the mesh is performing.
        :param Sequence[_builtins.str] mesh_routes: List of device serials that make up the mesh.
        :param _builtins.str serial: The serial number for the device.
        """
        pulumi.set(__self__, "latest_mesh_performance", latest_mesh_performance)
        pulumi.set(__self__, "mesh_routes", mesh_routes)
        pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter(name="latestMeshPerformance")
    def latest_mesh_performance(self) -> 'outputs.GetWirelessMeshStatusesItemLatestMeshPerformanceResult':
        """
        Current metrics on how the mesh is performing.
        """
        return pulumi.get(self, "latest_mesh_performance")

    @_builtins.property
    @pulumi.getter(name="meshRoutes")
    def mesh_routes(self) -> Sequence[_builtins.str]:
        """
        List of device serials that make up the mesh.
        """
        return pulumi.get(self, "mesh_routes")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        The serial number for the device.
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class GetWirelessMeshStatusesItemLatestMeshPerformanceResult(dict):
    def __init__(__self__, *,
                 mbps: _builtins.int,
                 metric: _builtins.int,
                 usage_percentage: _builtins.str):
        """
        :param _builtins.int mbps: Average Mbps.
        :param _builtins.int metric: Represents the quality of the entire route from the repeater access point to its gateway access point.
        :param _builtins.str usage_percentage: Mesh utilization as a percentage.
        """
        pulumi.set(__self__, "mbps", mbps)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "usage_percentage", usage_percentage)

    @_builtins.property
    @pulumi.getter
    def mbps(self) -> _builtins.int:
        """
        Average Mbps.
        """
        return pulumi.get(self, "mbps")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.int:
        """
        Represents the quality of the entire route from the repeater access point to its gateway access point.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="usagePercentage")
    def usage_percentage(self) -> _builtins.str:
        """
        Mesh utilization as a percentage.
        """
        return pulumi.get(self, "usage_percentage")


@pulumi.output_type
class GetWirelessRfProfilesItemResult(dict):
    def __init__(__self__, *,
                 ap_band_settings: 'outputs.GetWirelessRfProfilesItemApBandSettingsResult',
                 band_selection_type: _builtins.str,
                 client_balancing_enabled: _builtins.bool,
                 five_ghz_settings: 'outputs.GetWirelessRfProfilesItemFiveGhzSettingsResult',
                 id: _builtins.str,
                 min_bitrate_type: _builtins.str,
                 name: _builtins.str,
                 network_id: _builtins.str,
                 per_ssid_settings: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsResult',
                 six_ghz_settings: 'outputs.GetWirelessRfProfilesItemSixGhzSettingsResult',
                 transmission: 'outputs.GetWirelessRfProfilesItemTransmissionResult',
                 two_four_ghz_settings: 'outputs.GetWirelessRfProfilesItemTwoFourGhzSettingsResult'):
        """
        :param 'GetWirelessRfProfilesItemApBandSettingsArgs' ap_band_settings: Settings that will be enabled if selectionType is set to 'ap'.
        :param _builtins.str band_selection_type: Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.
        :param _builtins.bool client_balancing_enabled: Steers client to best available access point. Can be either true or false. Defaults to true.
        :param 'GetWirelessRfProfilesItemFiveGhzSettingsArgs' five_ghz_settings: Settings related to 5Ghz band
        :param _builtins.str id: The name of the new profile. Must be unique.
        :param _builtins.str min_bitrate_type: Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band.
        :param _builtins.str name: The name of the new profile. Must be unique. This param is required on creation.
        :param _builtins.str network_id: The network ID of the RF Profile
        :param 'GetWirelessRfProfilesItemPerSsidSettingsArgs' per_ssid_settings: Per-SSID radio settings by number.
        :param 'GetWirelessRfProfilesItemSixGhzSettingsArgs' six_ghz_settings: Settings related to 6Ghz band. Only applicable to networks with 6Ghz capable APs
        :param 'GetWirelessRfProfilesItemTransmissionArgs' transmission: Settings related to radio transmission.
        :param 'GetWirelessRfProfilesItemTwoFourGhzSettingsArgs' two_four_ghz_settings: Settings related to 2.4Ghz band
        """
        pulumi.set(__self__, "ap_band_settings", ap_band_settings)
        pulumi.set(__self__, "band_selection_type", band_selection_type)
        pulumi.set(__self__, "client_balancing_enabled", client_balancing_enabled)
        pulumi.set(__self__, "five_ghz_settings", five_ghz_settings)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "min_bitrate_type", min_bitrate_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "per_ssid_settings", per_ssid_settings)
        pulumi.set(__self__, "six_ghz_settings", six_ghz_settings)
        pulumi.set(__self__, "transmission", transmission)
        pulumi.set(__self__, "two_four_ghz_settings", two_four_ghz_settings)

    @_builtins.property
    @pulumi.getter(name="apBandSettings")
    def ap_band_settings(self) -> 'outputs.GetWirelessRfProfilesItemApBandSettingsResult':
        """
        Settings that will be enabled if selectionType is set to 'ap'.
        """
        return pulumi.get(self, "ap_band_settings")

    @_builtins.property
    @pulumi.getter(name="bandSelectionType")
    def band_selection_type(self) -> _builtins.str:
        """
        Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.
        """
        return pulumi.get(self, "band_selection_type")

    @_builtins.property
    @pulumi.getter(name="clientBalancingEnabled")
    def client_balancing_enabled(self) -> _builtins.bool:
        """
        Steers client to best available access point. Can be either true or false. Defaults to true.
        """
        return pulumi.get(self, "client_balancing_enabled")

    @_builtins.property
    @pulumi.getter(name="fiveGhzSettings")
    def five_ghz_settings(self) -> 'outputs.GetWirelessRfProfilesItemFiveGhzSettingsResult':
        """
        Settings related to 5Ghz band
        """
        return pulumi.get(self, "five_ghz_settings")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The name of the new profile. Must be unique.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="minBitrateType")
    def min_bitrate_type(self) -> _builtins.str:
        """
        Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band.
        """
        return pulumi.get(self, "min_bitrate_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the new profile. Must be unique. This param is required on creation.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        The network ID of the RF Profile
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="perSsidSettings")
    def per_ssid_settings(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsResult':
        """
        Per-SSID radio settings by number.
        """
        return pulumi.get(self, "per_ssid_settings")

    @_builtins.property
    @pulumi.getter(name="sixGhzSettings")
    def six_ghz_settings(self) -> 'outputs.GetWirelessRfProfilesItemSixGhzSettingsResult':
        """
        Settings related to 6Ghz band. Only applicable to networks with 6Ghz capable APs
        """
        return pulumi.get(self, "six_ghz_settings")

    @_builtins.property
    @pulumi.getter
    def transmission(self) -> 'outputs.GetWirelessRfProfilesItemTransmissionResult':
        """
        Settings related to radio transmission.
        """
        return pulumi.get(self, "transmission")

    @_builtins.property
    @pulumi.getter(name="twoFourGhzSettings")
    def two_four_ghz_settings(self) -> 'outputs.GetWirelessRfProfilesItemTwoFourGhzSettingsResult':
        """
        Settings related to 2.4Ghz band
        """
        return pulumi.get(self, "two_four_ghz_settings")


@pulumi.output_type
class GetWirelessRfProfilesItemApBandSettingsResult(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemApBandSettingsBandsResult'):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'. Defaults to dual.
        :param _builtins.bool band_steering_enabled: Steers client to most open band. Can be either true or false. Defaults to true.
        :param 'GetWirelessRfProfilesItemApBandSettingsBandsArgs' bands: Settings related to all bands
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'. Defaults to dual.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band. Can be either true or false. Defaults to true.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemApBandSettingsBandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")


@pulumi.output_type
class GetWirelessRfProfilesItemApBandSettingsBandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemFiveGhzSettingsResult(dict):
    def __init__(__self__, *,
                 channel_width: _builtins.str,
                 max_power: _builtins.int,
                 min_bitrate: _builtins.int,
                 min_power: _builtins.int,
                 rxsop: _builtins.int,
                 valid_auto_channels: Sequence[_builtins.int]):
        """
        :param _builtins.str channel_width: Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
        :param _builtins.int max_power: Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        :param _builtins.int min_power: Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
        :param _builtins.int rxsop: The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        :param Sequence[_builtins.int] valid_auto_channels: Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
        """
        pulumi.set(__self__, "channel_width", channel_width)
        pulumi.set(__self__, "max_power", max_power)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "min_power", min_power)
        pulumi.set(__self__, "rxsop", rxsop)
        pulumi.set(__self__, "valid_auto_channels", valid_auto_channels)

    @_builtins.property
    @pulumi.getter(name="channelWidth")
    def channel_width(self) -> _builtins.str:
        """
        Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
        """
        return pulumi.get(self, "channel_width")

    @_builtins.property
    @pulumi.getter(name="maxPower")
    def max_power(self) -> _builtins.int:
        """
        Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
        """
        return pulumi.get(self, "max_power")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter(name="minPower")
    def min_power(self) -> _builtins.int:
        """
        Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
        """
        return pulumi.get(self, "min_power")

    @_builtins.property
    @pulumi.getter
    def rxsop(self) -> _builtins.int:
        """
        The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        """
        return pulumi.get(self, "rxsop")

    @_builtins.property
    @pulumi.getter(name="validAutoChannels")
    def valid_auto_channels(self) -> Sequence[_builtins.int]:
        """
        Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
        """
        return pulumi.get(self, "valid_auto_channels")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsResult(dict):
    def __init__(__self__, *,
                 status0: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus0Result',
                 status1: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus1Result',
                 status10: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus10Result',
                 status11: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus11Result',
                 status12: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus12Result',
                 status13: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus13Result',
                 status14: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus14Result',
                 status2: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus2Result',
                 status3: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus3Result',
                 status4: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus4Result',
                 status5: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus5Result',
                 status6: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus6Result',
                 status7: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus7Result',
                 status8: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus8Result',
                 status9: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus9Result'):
        """
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus0Args' status0: Settings for SSID 0
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus1Args' status1: Settings for SSID 1
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus10Args' status10: Settings for SSID 10
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus11Args' status11: Settings for SSID 11
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus12Args' status12: Settings for SSID 12
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus13Args' status13: Settings for SSID 13
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus14Args' status14: Settings for SSID 14
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus2Args' status2: Settings for SSID 2
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus3Args' status3: Settings for SSID 3
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus4Args' status4: Settings for SSID 4
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus5Args' status5: Settings for SSID 5
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus6Args' status6: Settings for SSID 6
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus7Args' status7: Settings for SSID 7
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus8Args' status8: Settings for SSID 8
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus9Args' status9: Settings for SSID 9
        """
        pulumi.set(__self__, "status0", status0)
        pulumi.set(__self__, "status1", status1)
        pulumi.set(__self__, "status10", status10)
        pulumi.set(__self__, "status11", status11)
        pulumi.set(__self__, "status12", status12)
        pulumi.set(__self__, "status13", status13)
        pulumi.set(__self__, "status14", status14)
        pulumi.set(__self__, "status2", status2)
        pulumi.set(__self__, "status3", status3)
        pulumi.set(__self__, "status4", status4)
        pulumi.set(__self__, "status5", status5)
        pulumi.set(__self__, "status6", status6)
        pulumi.set(__self__, "status7", status7)
        pulumi.set(__self__, "status8", status8)
        pulumi.set(__self__, "status9", status9)

    @_builtins.property
    @pulumi.getter
    def status0(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus0Result':
        """
        Settings for SSID 0
        """
        return pulumi.get(self, "status0")

    @_builtins.property
    @pulumi.getter
    def status1(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus1Result':
        """
        Settings for SSID 1
        """
        return pulumi.get(self, "status1")

    @_builtins.property
    @pulumi.getter
    def status10(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus10Result':
        """
        Settings for SSID 10
        """
        return pulumi.get(self, "status10")

    @_builtins.property
    @pulumi.getter
    def status11(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus11Result':
        """
        Settings for SSID 11
        """
        return pulumi.get(self, "status11")

    @_builtins.property
    @pulumi.getter
    def status12(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus12Result':
        """
        Settings for SSID 12
        """
        return pulumi.get(self, "status12")

    @_builtins.property
    @pulumi.getter
    def status13(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus13Result':
        """
        Settings for SSID 13
        """
        return pulumi.get(self, "status13")

    @_builtins.property
    @pulumi.getter
    def status14(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus14Result':
        """
        Settings for SSID 14
        """
        return pulumi.get(self, "status14")

    @_builtins.property
    @pulumi.getter
    def status2(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus2Result':
        """
        Settings for SSID 2
        """
        return pulumi.get(self, "status2")

    @_builtins.property
    @pulumi.getter
    def status3(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus3Result':
        """
        Settings for SSID 3
        """
        return pulumi.get(self, "status3")

    @_builtins.property
    @pulumi.getter
    def status4(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus4Result':
        """
        Settings for SSID 4
        """
        return pulumi.get(self, "status4")

    @_builtins.property
    @pulumi.getter
    def status5(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus5Result':
        """
        Settings for SSID 5
        """
        return pulumi.get(self, "status5")

    @_builtins.property
    @pulumi.getter
    def status6(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus6Result':
        """
        Settings for SSID 6
        """
        return pulumi.get(self, "status6")

    @_builtins.property
    @pulumi.getter
    def status7(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus7Result':
        """
        Settings for SSID 7
        """
        return pulumi.get(self, "status7")

    @_builtins.property
    @pulumi.getter
    def status8(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus8Result':
        """
        Settings for SSID 8
        """
        return pulumi.get(self, "status8")

    @_builtins.property
    @pulumi.getter
    def status9(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus9Result':
        """
        Settings for SSID 9
        """
        return pulumi.get(self, "status9")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus0Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus0BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus0BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus0BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus0BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus10Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus10BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus10BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus10BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus10BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus11Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus11BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus11BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus11BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus11BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus12Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus12BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus12BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus12BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus12BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus13Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus13BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus13BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus13BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus13BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus14Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus14BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus14BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus14BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus14BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus1Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus1BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus1BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus1BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus1BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus2Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus2BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus2BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus2BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus2BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus3Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus3BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus3BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus3BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus3BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus4Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus4BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus4BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus4BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus4BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus5Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus5BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus5BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus5BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus5BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus6Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus6BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus6BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus6BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus6BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus7Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus7BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus7BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus7BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus7BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus8Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus8BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus8BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus8BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus8BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus9Result(dict):
    def __init__(__self__, *,
                 band_operation_mode: _builtins.str,
                 band_steering_enabled: _builtins.bool,
                 bands: 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus9BandsResult',
                 min_bitrate: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param _builtins.bool band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param 'GetWirelessRfProfilesItemPerSsidSettingsStatus9BandsArgs' bands: Settings related to all bands
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param _builtins.str name: Name of SSID
        """
        pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> _builtins.str:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> _builtins.bool:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> 'outputs.GetWirelessRfProfilesItemPerSsidSettingsStatus9BandsResult':
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessRfProfilesItemPerSsidSettingsStatus9BandsResult(dict):
    def __init__(__self__, *,
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")


@pulumi.output_type
class GetWirelessRfProfilesItemSixGhzSettingsResult(dict):
    def __init__(__self__, *,
                 channel_width: _builtins.str,
                 max_power: _builtins.int,
                 min_bitrate: _builtins.int,
                 min_power: _builtins.int,
                 rxsop: _builtins.int,
                 valid_auto_channels: Sequence[_builtins.int]):
        """
        :param _builtins.str channel_width: Sets channel width (MHz) for 6Ghz band. Can be one of '0', '20', '40', '80' or '160'. Defaults to auto.
        :param _builtins.int max_power: Sets max power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 30.
        :param _builtins.int min_bitrate: Sets min bitrate (Mbps) of 6Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        :param _builtins.int min_power: Sets min power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 8.
        :param _builtins.int rxsop: The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        :param Sequence[_builtins.int] valid_auto_channels: Sets valid auto channels for 6Ghz band. Can be one of '1', '5', '9', '13', '17', '21', '25', '29', '33', '37', '41', '45', '49', '53', '57', '61', '65', '69', '73', '77', '81', '85', '89', '93', '97', '101', '105', '109', '113', '117', '121', '125', '129', '133', '137', '141', '145', '149', '153', '157', '161', '165', '169', '173', '177', '181', '185', '189', '193', '197', '201', '205', '209', '213', '217', '221', '225', '229' or '233'. Defaults to auto.
        """
        pulumi.set(__self__, "channel_width", channel_width)
        pulumi.set(__self__, "max_power", max_power)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "min_power", min_power)
        pulumi.set(__self__, "rxsop", rxsop)
        pulumi.set(__self__, "valid_auto_channels", valid_auto_channels)

    @_builtins.property
    @pulumi.getter(name="channelWidth")
    def channel_width(self) -> _builtins.str:
        """
        Sets channel width (MHz) for 6Ghz band. Can be one of '0', '20', '40', '80' or '160'. Defaults to auto.
        """
        return pulumi.get(self, "channel_width")

    @_builtins.property
    @pulumi.getter(name="maxPower")
    def max_power(self) -> _builtins.int:
        """
        Sets max power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 30.
        """
        return pulumi.get(self, "max_power")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        Sets min bitrate (Mbps) of 6Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter(name="minPower")
    def min_power(self) -> _builtins.int:
        """
        Sets min power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 8.
        """
        return pulumi.get(self, "min_power")

    @_builtins.property
    @pulumi.getter
    def rxsop(self) -> _builtins.int:
        """
        The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        """
        return pulumi.get(self, "rxsop")

    @_builtins.property
    @pulumi.getter(name="validAutoChannels")
    def valid_auto_channels(self) -> Sequence[_builtins.int]:
        """
        Sets valid auto channels for 6Ghz band. Can be one of '1', '5', '9', '13', '17', '21', '25', '29', '33', '37', '41', '45', '49', '53', '57', '61', '65', '69', '73', '77', '81', '85', '89', '93', '97', '101', '105', '109', '113', '117', '121', '125', '129', '133', '137', '141', '145', '149', '153', '157', '161', '165', '169', '173', '177', '181', '185', '189', '193', '197', '201', '205', '209', '213', '217', '221', '225', '229' or '233'. Defaults to auto.
        """
        return pulumi.get(self, "valid_auto_channels")


@pulumi.output_type
class GetWirelessRfProfilesItemTransmissionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Toggle for radio transmission. When false, radios will not transmit at all.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Toggle for radio transmission. When false, radios will not transmit at all.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetWirelessRfProfilesItemTwoFourGhzSettingsResult(dict):
    def __init__(__self__, *,
                 ax_enabled: _builtins.bool,
                 max_power: _builtins.int,
                 min_bitrate: _builtins.float,
                 min_power: _builtins.int,
                 rxsop: _builtins.int,
                 valid_auto_channels: Sequence[_builtins.int]):
        """
        :param _builtins.bool ax_enabled: Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
        :param _builtins.int max_power: Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
        :param _builtins.float min_bitrate: Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
        :param _builtins.int min_power: Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
        :param _builtins.int rxsop: The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        :param Sequence[_builtins.int] valid_auto_channels: Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
        """
        pulumi.set(__self__, "ax_enabled", ax_enabled)
        pulumi.set(__self__, "max_power", max_power)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "min_power", min_power)
        pulumi.set(__self__, "rxsop", rxsop)
        pulumi.set(__self__, "valid_auto_channels", valid_auto_channels)

    @_builtins.property
    @pulumi.getter(name="axEnabled")
    def ax_enabled(self) -> _builtins.bool:
        """
        Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
        """
        return pulumi.get(self, "ax_enabled")

    @_builtins.property
    @pulumi.getter(name="maxPower")
    def max_power(self) -> _builtins.int:
        """
        Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
        """
        return pulumi.get(self, "max_power")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.float:
        """
        Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter(name="minPower")
    def min_power(self) -> _builtins.int:
        """
        Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
        """
        return pulumi.get(self, "min_power")

    @_builtins.property
    @pulumi.getter
    def rxsop(self) -> _builtins.int:
        """
        The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        """
        return pulumi.get(self, "rxsop")

    @_builtins.property
    @pulumi.getter(name="validAutoChannels")
    def valid_auto_channels(self) -> Sequence[_builtins.int]:
        """
        Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
        """
        return pulumi.get(self, "valid_auto_channels")


@pulumi.output_type
class GetWirelessSettingsItemResult(dict):
    def __init__(__self__, *,
                 ipv6_bridge_enabled: _builtins.bool,
                 led_lights_on: _builtins.bool,
                 location_analytics_enabled: _builtins.bool,
                 meshing_enabled: _builtins.bool,
                 named_vlans: 'outputs.GetWirelessSettingsItemNamedVlansResult',
                 regulatory_domain: 'outputs.GetWirelessSettingsItemRegulatoryDomainResult',
                 upgradestrategy: _builtins.str):
        """
        :param _builtins.bool ipv6_bridge_enabled: Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode)
        :param _builtins.bool led_lights_on: Toggle for enabling or disabling LED lights on all APs in the network (making them run dark)
        :param _builtins.bool location_analytics_enabled: Toggle for enabling or disabling location analytics for your network
        :param _builtins.bool meshing_enabled: Toggle for enabling or disabling meshing in a network
        :param 'GetWirelessSettingsItemNamedVlansArgs' named_vlans: Named VLAN settings for wireless networks.
        :param 'GetWirelessSettingsItemRegulatoryDomainArgs' regulatory_domain: Regulatory domain information for this network.
        :param _builtins.str upgradestrategy: The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher'
        """
        pulumi.set(__self__, "ipv6_bridge_enabled", ipv6_bridge_enabled)
        pulumi.set(__self__, "led_lights_on", led_lights_on)
        pulumi.set(__self__, "location_analytics_enabled", location_analytics_enabled)
        pulumi.set(__self__, "meshing_enabled", meshing_enabled)
        pulumi.set(__self__, "named_vlans", named_vlans)
        pulumi.set(__self__, "regulatory_domain", regulatory_domain)
        pulumi.set(__self__, "upgradestrategy", upgradestrategy)

    @_builtins.property
    @pulumi.getter(name="ipv6BridgeEnabled")
    def ipv6_bridge_enabled(self) -> _builtins.bool:
        """
        Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode)
        """
        return pulumi.get(self, "ipv6_bridge_enabled")

    @_builtins.property
    @pulumi.getter(name="ledLightsOn")
    def led_lights_on(self) -> _builtins.bool:
        """
        Toggle for enabling or disabling LED lights on all APs in the network (making them run dark)
        """
        return pulumi.get(self, "led_lights_on")

    @_builtins.property
    @pulumi.getter(name="locationAnalyticsEnabled")
    def location_analytics_enabled(self) -> _builtins.bool:
        """
        Toggle for enabling or disabling location analytics for your network
        """
        return pulumi.get(self, "location_analytics_enabled")

    @_builtins.property
    @pulumi.getter(name="meshingEnabled")
    def meshing_enabled(self) -> _builtins.bool:
        """
        Toggle for enabling or disabling meshing in a network
        """
        return pulumi.get(self, "meshing_enabled")

    @_builtins.property
    @pulumi.getter(name="namedVlans")
    def named_vlans(self) -> 'outputs.GetWirelessSettingsItemNamedVlansResult':
        """
        Named VLAN settings for wireless networks.
        """
        return pulumi.get(self, "named_vlans")

    @_builtins.property
    @pulumi.getter(name="regulatoryDomain")
    def regulatory_domain(self) -> 'outputs.GetWirelessSettingsItemRegulatoryDomainResult':
        """
        Regulatory domain information for this network.
        """
        return pulumi.get(self, "regulatory_domain")

    @_builtins.property
    @pulumi.getter
    def upgradestrategy(self) -> _builtins.str:
        """
        The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher'
        """
        return pulumi.get(self, "upgradestrategy")


@pulumi.output_type
class GetWirelessSettingsItemNamedVlansResult(dict):
    def __init__(__self__, *,
                 pool_dhcp_monitoring: 'outputs.GetWirelessSettingsItemNamedVlansPoolDhcpMonitoringResult'):
        """
        :param 'GetWirelessSettingsItemNamedVlansPoolDhcpMonitoringArgs' pool_dhcp_monitoring: Named VLAN Pool DHCP Monitoring settings.
        """
        pulumi.set(__self__, "pool_dhcp_monitoring", pool_dhcp_monitoring)

    @_builtins.property
    @pulumi.getter(name="poolDhcpMonitoring")
    def pool_dhcp_monitoring(self) -> 'outputs.GetWirelessSettingsItemNamedVlansPoolDhcpMonitoringResult':
        """
        Named VLAN Pool DHCP Monitoring settings.
        """
        return pulumi.get(self, "pool_dhcp_monitoring")


@pulumi.output_type
class GetWirelessSettingsItemNamedVlansPoolDhcpMonitoringResult(dict):
    def __init__(__self__, *,
                 duration: _builtins.int,
                 enabled: _builtins.bool):
        """
        :param _builtins.int duration: The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool.
        :param _builtins.bool enabled: Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.int:
        """
        The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetWirelessSettingsItemRegulatoryDomainResult(dict):
    def __init__(__self__, *,
                 country_code: _builtins.str,
                 name: _builtins.str,
                 permits6e: _builtins.bool):
        """
        :param _builtins.str country_code: The country code of the regulatory domain.
        :param _builtins.str name: The name of the regulatory domain for this network.
        :param _builtins.bool permits6e: Whether or not the regulatory domain for this network permits Wifi 6E.
        """
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permits6e", permits6e)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        """
        The country code of the regulatory domain.
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the regulatory domain for this network.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permits6e(self) -> _builtins.bool:
        """
        Whether or not the regulatory domain for this network permits Wifi 6E.
        """
        return pulumi.get(self, "permits6e")


@pulumi.output_type
class GetWirelessSignalQualityHistoryItemResult(dict):
    def __init__(__self__, *,
                 end_ts: _builtins.str,
                 rssi: _builtins.int,
                 snr: _builtins.int,
                 start_ts: _builtins.str):
        """
        :param _builtins.str end_ts: The end time of the query range
        :param _builtins.int rssi: Received signal strength indicator
        :param _builtins.int snr: Signal to noise ratio
        :param _builtins.str start_ts: The start time of the query range
        """
        pulumi.set(__self__, "end_ts", end_ts)
        pulumi.set(__self__, "rssi", rssi)
        pulumi.set(__self__, "snr", snr)
        pulumi.set(__self__, "start_ts", start_ts)

    @_builtins.property
    @pulumi.getter(name="endTs")
    def end_ts(self) -> _builtins.str:
        """
        The end time of the query range
        """
        return pulumi.get(self, "end_ts")

    @_builtins.property
    @pulumi.getter
    def rssi(self) -> _builtins.int:
        """
        Received signal strength indicator
        """
        return pulumi.get(self, "rssi")

    @_builtins.property
    @pulumi.getter
    def snr(self) -> _builtins.int:
        """
        Signal to noise ratio
        """
        return pulumi.get(self, "snr")

    @_builtins.property
    @pulumi.getter(name="startTs")
    def start_ts(self) -> _builtins.str:
        """
        The start time of the query range
        """
        return pulumi.get(self, "start_ts")


@pulumi.output_type
class GetWirelessSsidsBonjourForwardingItemResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 exception: 'outputs.GetWirelessSsidsBonjourForwardingItemExceptionResult',
                 rules: Sequence['outputs.GetWirelessSsidsBonjourForwardingItemRuleResult']):
        """
        :param _builtins.bool enabled: If true, Bonjour forwarding is enabled on the SSID.
        :param 'GetWirelessSsidsBonjourForwardingItemExceptionArgs' exception: Bonjour forwarding exception
        :param Sequence['GetWirelessSsidsBonjourForwardingItemRuleArgs'] rules: Bonjour forwarding rules
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "exception", exception)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        If true, Bonjour forwarding is enabled on the SSID.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def exception(self) -> 'outputs.GetWirelessSsidsBonjourForwardingItemExceptionResult':
        """
        Bonjour forwarding exception
        """
        return pulumi.get(self, "exception")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetWirelessSsidsBonjourForwardingItemRuleResult']:
        """
        Bonjour forwarding rules
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetWirelessSsidsBonjourForwardingItemExceptionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: If true, Bonjour forwarding exception is enabled on this SSID. Exception is required to enable L2 isolation and Bonjour forwarding to work together.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        If true, Bonjour forwarding exception is enabled on this SSID. Exception is required to enable L2 isolation and Bonjour forwarding to work together.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetWirelessSsidsBonjourForwardingItemRuleResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 services: Sequence[_builtins.str],
                 vlan_id: _builtins.str):
        """
        :param _builtins.str description: Desctiption of the bonjour forwarding rule
        :param Sequence[_builtins.str] services: A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        :param _builtins.str vlan_id: The ID of the service VLAN. Required
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Desctiption of the bonjour forwarding rule
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Sequence[_builtins.str]:
        """
        A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        """
        The ID of the service VLAN. Required
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetWirelessSsidsDeviceTypeGroupPoliciesItemResult(dict):
    def __init__(__self__, *,
                 device_type_policies: Sequence['outputs.GetWirelessSsidsDeviceTypeGroupPoliciesItemDeviceTypePolicyResult'],
                 enabled: _builtins.bool):
        pulumi.set(__self__, "device_type_policies", device_type_policies)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="deviceTypePolicies")
    def device_type_policies(self) -> Sequence['outputs.GetWirelessSsidsDeviceTypeGroupPoliciesItemDeviceTypePolicyResult']:
        return pulumi.get(self, "device_type_policies")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetWirelessSsidsDeviceTypeGroupPoliciesItemDeviceTypePolicyResult(dict):
    def __init__(__self__, *,
                 device_policy: _builtins.str,
                 device_type: _builtins.str):
        pulumi.set(__self__, "device_policy", device_policy)
        pulumi.set(__self__, "device_type", device_type)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> _builtins.str:
        return pulumi.get(self, "device_policy")

    @_builtins.property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> _builtins.str:
        return pulumi.get(self, "device_type")


@pulumi.output_type
class GetWirelessSsidsEapOverrideItemResult(dict):
    def __init__(__self__, *,
                 eapol_key: 'outputs.GetWirelessSsidsEapOverrideItemEapolKeyResult',
                 identity: 'outputs.GetWirelessSsidsEapOverrideItemIdentityResult',
                 max_retries: _builtins.int,
                 timeout: _builtins.int):
        """
        :param 'GetWirelessSsidsEapOverrideItemEapolKeyArgs' eapol_key: EAPOL Key settings.
        :param 'GetWirelessSsidsEapOverrideItemIdentityArgs' identity: EAP settings for identity requests.
        :param _builtins.int max_retries: Maximum number of general EAP retries.
        :param _builtins.int timeout: General EAP timeout in seconds.
        """
        pulumi.set(__self__, "eapol_key", eapol_key)
        pulumi.set(__self__, "identity", identity)
        pulumi.set(__self__, "max_retries", max_retries)
        pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="eapolKey")
    def eapol_key(self) -> 'outputs.GetWirelessSsidsEapOverrideItemEapolKeyResult':
        """
        EAPOL Key settings.
        """
        return pulumi.get(self, "eapol_key")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> 'outputs.GetWirelessSsidsEapOverrideItemIdentityResult':
        """
        EAP settings for identity requests.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> _builtins.int:
        """
        Maximum number of general EAP retries.
        """
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        General EAP timeout in seconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class GetWirelessSsidsEapOverrideItemEapolKeyResult(dict):
    def __init__(__self__, *,
                 retries: _builtins.int,
                 timeout_in_ms: _builtins.int):
        """
        :param _builtins.int retries: Maximum number of EAPOL key retries.
        :param _builtins.int timeout_in_ms: EAPOL Key timeout in milliseconds.
        """
        pulumi.set(__self__, "retries", retries)
        pulumi.set(__self__, "timeout_in_ms", timeout_in_ms)

    @_builtins.property
    @pulumi.getter
    def retries(self) -> _builtins.int:
        """
        Maximum number of EAPOL key retries.
        """
        return pulumi.get(self, "retries")

    @_builtins.property
    @pulumi.getter(name="timeoutInMs")
    def timeout_in_ms(self) -> _builtins.int:
        """
        EAPOL Key timeout in milliseconds.
        """
        return pulumi.get(self, "timeout_in_ms")


@pulumi.output_type
class GetWirelessSsidsEapOverrideItemIdentityResult(dict):
    def __init__(__self__, *,
                 retries: _builtins.int,
                 timeout: _builtins.int):
        """
        :param _builtins.int retries: Maximum number of EAP retries.
        :param _builtins.int timeout: EAP timeout in seconds.
        """
        pulumi.set(__self__, "retries", retries)
        pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def retries(self) -> _builtins.int:
        """
        Maximum number of EAP retries.
        """
        return pulumi.get(self, "retries")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        EAP timeout in seconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class GetWirelessSsidsFirewallL3FirewallRulesItemResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetWirelessSsidsFirewallL3FirewallRulesItemRuleResult']):
        """
        :param Sequence['GetWirelessSsidsFirewallL3FirewallRulesItemRuleArgs'] rules: An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule).
        """
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetWirelessSsidsFirewallL3FirewallRulesItemRuleResult']:
        """
        An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule).
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetWirelessSsidsFirewallL3FirewallRulesItemRuleResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 dest_cidr: _builtins.str,
                 dest_port: _builtins.str,
                 policy: _builtins.str,
                 protocol: _builtins.str):
        """
        :param _builtins.str comment: Description of the rule (optional)
        :param _builtins.str dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param _builtins.str dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param _builtins.str policy: 'allow' or 'deny' traffic specified by this rule
        :param _builtins.str protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "dest_cidr", dest_cidr)
        pulumi.set(__self__, "dest_port", dest_port)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> _builtins.str:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> _builtins.str:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetWirelessSsidsFirewallL7FirewallRulesItemResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetWirelessSsidsFirewallL7FirewallRulesItemRuleResult']):
        """
        :param Sequence['GetWirelessSsidsFirewallL7FirewallRulesItemRuleArgs'] rules: An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule).
        """
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetWirelessSsidsFirewallL7FirewallRulesItemRuleResult']:
        """
        An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule).
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetWirelessSsidsFirewallL7FirewallRulesItemRuleResult(dict):
    def __init__(__self__, *,
                 policy: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str policy: 'Deny' traffic specified by this rule
        :param _builtins.str type: Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        :param _builtins.str value: The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected.
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        'Deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWirelessSsidsHotspot20ItemResult(dict):
    def __init__(__self__, *,
                 domains: Sequence[_builtins.str],
                 enabled: _builtins.bool,
                 mcc_mncs: Sequence['outputs.GetWirelessSsidsHotspot20ItemMccMncResult'],
                 nai_realms: Sequence['outputs.GetWirelessSsidsHotspot20ItemNaiRealmResult'],
                 network_access_type: _builtins.str,
                 operator: 'outputs.GetWirelessSsidsHotspot20ItemOperatorResult',
                 roam_consort_ois: Sequence[_builtins.str],
                 venue: 'outputs.GetWirelessSsidsHotspot20ItemVenueResult'):
        pulumi.set(__self__, "domains", domains)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "mcc_mncs", mcc_mncs)
        pulumi.set(__self__, "nai_realms", nai_realms)
        pulumi.set(__self__, "network_access_type", network_access_type)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "roam_consort_ois", roam_consort_ois)
        pulumi.set(__self__, "venue", venue)

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "domains")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="mccMncs")
    def mcc_mncs(self) -> Sequence['outputs.GetWirelessSsidsHotspot20ItemMccMncResult']:
        return pulumi.get(self, "mcc_mncs")

    @_builtins.property
    @pulumi.getter(name="naiRealms")
    def nai_realms(self) -> Sequence['outputs.GetWirelessSsidsHotspot20ItemNaiRealmResult']:
        return pulumi.get(self, "nai_realms")

    @_builtins.property
    @pulumi.getter(name="networkAccessType")
    def network_access_type(self) -> _builtins.str:
        return pulumi.get(self, "network_access_type")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> 'outputs.GetWirelessSsidsHotspot20ItemOperatorResult':
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter(name="roamConsortOis")
    def roam_consort_ois(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "roam_consort_ois")

    @_builtins.property
    @pulumi.getter
    def venue(self) -> 'outputs.GetWirelessSsidsHotspot20ItemVenueResult':
        return pulumi.get(self, "venue")


@pulumi.output_type
class GetWirelessSsidsHotspot20ItemMccMncResult(dict):
    def __init__(__self__, *,
                 mcc: _builtins.str,
                 mnc: _builtins.str):
        pulumi.set(__self__, "mcc", mcc)
        pulumi.set(__self__, "mnc", mnc)

    @_builtins.property
    @pulumi.getter
    def mcc(self) -> _builtins.str:
        return pulumi.get(self, "mcc")

    @_builtins.property
    @pulumi.getter
    def mnc(self) -> _builtins.str:
        return pulumi.get(self, "mnc")


@pulumi.output_type
class GetWirelessSsidsHotspot20ItemNaiRealmResult(dict):
    def __init__(__self__, *,
                 format: _builtins.str,
                 methods: Sequence['outputs.GetWirelessSsidsHotspot20ItemNaiRealmMethodResult'],
                 name: _builtins.str):
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "methods", methods)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Sequence['outputs.GetWirelessSsidsHotspot20ItemNaiRealmMethodResult']:
        return pulumi.get(self, "methods")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessSsidsHotspot20ItemNaiRealmMethodResult(dict):
    def __init__(__self__, *,
                 authentication_types: 'outputs.GetWirelessSsidsHotspot20ItemNaiRealmMethodAuthenticationTypesResult',
                 id: _builtins.str):
        pulumi.set(__self__, "authentication_types", authentication_types)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="authenticationTypes")
    def authentication_types(self) -> 'outputs.GetWirelessSsidsHotspot20ItemNaiRealmMethodAuthenticationTypesResult':
        return pulumi.get(self, "authentication_types")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetWirelessSsidsHotspot20ItemNaiRealmMethodAuthenticationTypesResult(dict):
    def __init__(__self__, *,
                 credentials: Sequence[_builtins.str],
                 eapinner_authentications: Sequence[_builtins.str],
                 non_eapinner_authentications: Sequence[_builtins.str],
                 tunneled_eap_method_credentials: Sequence[_builtins.str]):
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "eapinner_authentications", eapinner_authentications)
        pulumi.set(__self__, "non_eapinner_authentications", non_eapinner_authentications)
        pulumi.set(__self__, "tunneled_eap_method_credentials", tunneled_eap_method_credentials)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "credentials")

    @_builtins.property
    @pulumi.getter(name="eapinnerAuthentications")
    def eapinner_authentications(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "eapinner_authentications")

    @_builtins.property
    @pulumi.getter(name="nonEapinnerAuthentications")
    def non_eapinner_authentications(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "non_eapinner_authentications")

    @_builtins.property
    @pulumi.getter(name="tunneledEapMethodCredentials")
    def tunneled_eap_method_credentials(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "tunneled_eap_method_credentials")


@pulumi.output_type
class GetWirelessSsidsHotspot20ItemOperatorResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWirelessSsidsHotspot20ItemVenueResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetWirelessSsidsIdentityPsksItemResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 expires_at: _builtins.str,
                 group_policy_id: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 passphrase: _builtins.str,
                 wifi_personal_network_id: _builtins.str):
        """
        :param _builtins.str email: The email associated with the System's Manager User
        :param _builtins.str expires_at: Timestamp for when the Identity PSK expires, or 'null' to never expire
        :param _builtins.str group_policy_id: The group policy to be applied to clients
        :param _builtins.str id: The unique identifier of the Identity PSK
        :param _builtins.str name: The name of the Identity PSK
        :param _builtins.str passphrase: The passphrase for client authentication
        :param _builtins.str wifi_personal_network_id: The WiFi Personal Network unique identifier
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "group_policy_id", group_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "passphrase", passphrase)
        pulumi.set(__self__, "wifi_personal_network_id", wifi_personal_network_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email associated with the System's Manager User
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        Timestamp for when the Identity PSK expires, or 'null' to never expire
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> _builtins.str:
        """
        The group policy to be applied to clients
        """
        return pulumi.get(self, "group_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier of the Identity PSK
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Identity PSK
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> _builtins.str:
        """
        The passphrase for client authentication
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter(name="wifiPersonalNetworkId")
    def wifi_personal_network_id(self) -> _builtins.str:
        """
        The WiFi Personal Network unique identifier
        """
        return pulumi.get(self, "wifi_personal_network_id")


@pulumi.output_type
class GetWirelessSsidsItemResult(dict):
    def __init__(__self__, *,
                 admin_splash_url: _builtins.str,
                 auth_mode: _builtins.str,
                 availability_tags: Sequence[_builtins.str],
                 available_on_all_aps: _builtins.bool,
                 band_selection: _builtins.str,
                 enabled: _builtins.bool,
                 encryption_mode: _builtins.str,
                 ip_assignment_mode: _builtins.str,
                 local_auth: _builtins.bool,
                 mandatory_dhcp_enabled: _builtins.bool,
                 min_bitrate: _builtins.int,
                 name: _builtins.str,
                 number: _builtins.int,
                 per_client_bandwidth_limit_down: _builtins.int,
                 per_client_bandwidth_limit_up: _builtins.int,
                 per_ssid_bandwidth_limit_down: _builtins.int,
                 per_ssid_bandwidth_limit_up: _builtins.int,
                 radius_accounting_enabled: _builtins.bool,
                 radius_accounting_servers: Sequence['outputs.GetWirelessSsidsItemRadiusAccountingServerResult'],
                 radius_attribute_for_group_policies: _builtins.str,
                 radius_enabled: _builtins.bool,
                 radius_failover_policy: _builtins.str,
                 radius_load_balancing_policy: _builtins.str,
                 radius_servers: Sequence['outputs.GetWirelessSsidsItemRadiusServerResult'],
                 splash_page: _builtins.str,
                 splash_timeout: _builtins.str,
                 ssid_admin_accessible: _builtins.bool,
                 visible: _builtins.bool,
                 walled_garden_enabled: _builtins.bool,
                 walled_garden_ranges: Sequence[_builtins.str],
                 wpa_encryption_mode: _builtins.str):
        """
        :param _builtins.str admin_splash_url: URL for the admin splash page
        :param _builtins.str auth_mode: The association control method for the SSID
        :param Sequence[_builtins.str] availability_tags: List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
        :param _builtins.bool available_on_all_aps: Whether all APs broadcast the SSID or if it's restricted to APs matching any availability tags
        :param _builtins.str band_selection: The client-serving radio frequencies of this SSID in the default indoor RF profile
        :param _builtins.bool enabled: Whether or not the SSID is enabled
        :param _builtins.str encryption_mode: The psk encryption mode for the SSID
        :param _builtins.str ip_assignment_mode: The client IP assignment mode
        :param _builtins.bool local_auth: Extended local auth flag for Enterprise NAC
        :param _builtins.bool mandatory_dhcp_enabled: Whether clients connecting to this SSID must use the IP address assigned by the DHCP server
        :param _builtins.int min_bitrate: The minimum bitrate in Mbps of this SSID in the default indoor RF profile
        :param _builtins.str name: The name of the SSID
        :param _builtins.int number: Unique identifier of the SSID
        :param _builtins.int per_client_bandwidth_limit_down: The download bandwidth limit in Kbps. (0 represents no limit.)
        :param _builtins.int per_client_bandwidth_limit_up: The upload bandwidth limit in Kbps. (0 represents no limit.)
        :param _builtins.int per_ssid_bandwidth_limit_down: The total download bandwidth limit in Kbps (0 represents no limit)
        :param _builtins.int per_ssid_bandwidth_limit_up: The total upload bandwidth limit in Kbps (0 represents no limit)
        :param _builtins.bool radius_accounting_enabled: Whether or not RADIUS accounting is enabled
        :param Sequence['GetWirelessSsidsItemRadiusAccountingServerArgs'] radius_accounting_servers: List of RADIUS accounting 802.1X servers to be used for authentication
        :param _builtins.str radius_attribute_for_group_policies: RADIUS attribute used to look up group policies
        :param _builtins.bool radius_enabled: Whether RADIUS authentication is enabled
        :param _builtins.str radius_failover_policy: Policy which determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable
        :param _builtins.str radius_load_balancing_policy: Policy which determines which RADIUS server will be contacted first in an authentication attempt, and the ordering of any necessary retry attempts
        :param Sequence['GetWirelessSsidsItemRadiusServerArgs'] radius_servers: List of RADIUS 802.1X servers to be used for authentication
        :param _builtins.str splash_page: The type of splash page for the SSID
        :param _builtins.str splash_timeout: Splash page timeout
        :param _builtins.bool ssid_admin_accessible: SSID Administrator access status
        :param _builtins.bool visible: Whether the SSID is advertised or hidden by the AP
        :param _builtins.bool walled_garden_enabled: Allow users to access a configurable list of IP ranges prior to sign-on
        :param Sequence[_builtins.str] walled_garden_ranges: Domain names and IP address ranges available in Walled Garden mode
        :param _builtins.str wpa_encryption_mode: The types of WPA encryption
        """
        pulumi.set(__self__, "admin_splash_url", admin_splash_url)
        pulumi.set(__self__, "auth_mode", auth_mode)
        pulumi.set(__self__, "availability_tags", availability_tags)
        pulumi.set(__self__, "available_on_all_aps", available_on_all_aps)
        pulumi.set(__self__, "band_selection", band_selection)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "encryption_mode", encryption_mode)
        pulumi.set(__self__, "ip_assignment_mode", ip_assignment_mode)
        pulumi.set(__self__, "local_auth", local_auth)
        pulumi.set(__self__, "mandatory_dhcp_enabled", mandatory_dhcp_enabled)
        pulumi.set(__self__, "min_bitrate", min_bitrate)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "per_client_bandwidth_limit_down", per_client_bandwidth_limit_down)
        pulumi.set(__self__, "per_client_bandwidth_limit_up", per_client_bandwidth_limit_up)
        pulumi.set(__self__, "per_ssid_bandwidth_limit_down", per_ssid_bandwidth_limit_down)
        pulumi.set(__self__, "per_ssid_bandwidth_limit_up", per_ssid_bandwidth_limit_up)
        pulumi.set(__self__, "radius_accounting_enabled", radius_accounting_enabled)
        pulumi.set(__self__, "radius_accounting_servers", radius_accounting_servers)
        pulumi.set(__self__, "radius_attribute_for_group_policies", radius_attribute_for_group_policies)
        pulumi.set(__self__, "radius_enabled", radius_enabled)
        pulumi.set(__self__, "radius_failover_policy", radius_failover_policy)
        pulumi.set(__self__, "radius_load_balancing_policy", radius_load_balancing_policy)
        pulumi.set(__self__, "radius_servers", radius_servers)
        pulumi.set(__self__, "splash_page", splash_page)
        pulumi.set(__self__, "splash_timeout", splash_timeout)
        pulumi.set(__self__, "ssid_admin_accessible", ssid_admin_accessible)
        pulumi.set(__self__, "visible", visible)
        pulumi.set(__self__, "walled_garden_enabled", walled_garden_enabled)
        pulumi.set(__self__, "walled_garden_ranges", walled_garden_ranges)
        pulumi.set(__self__, "wpa_encryption_mode", wpa_encryption_mode)

    @_builtins.property
    @pulumi.getter(name="adminSplashUrl")
    def admin_splash_url(self) -> _builtins.str:
        """
        URL for the admin splash page
        """
        return pulumi.get(self, "admin_splash_url")

    @_builtins.property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> _builtins.str:
        """
        The association control method for the SSID
        """
        return pulumi.get(self, "auth_mode")

    @_builtins.property
    @pulumi.getter(name="availabilityTags")
    def availability_tags(self) -> Sequence[_builtins.str]:
        """
        List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
        """
        return pulumi.get(self, "availability_tags")

    @_builtins.property
    @pulumi.getter(name="availableOnAllAps")
    def available_on_all_aps(self) -> _builtins.bool:
        """
        Whether all APs broadcast the SSID or if it's restricted to APs matching any availability tags
        """
        return pulumi.get(self, "available_on_all_aps")

    @_builtins.property
    @pulumi.getter(name="bandSelection")
    def band_selection(self) -> _builtins.str:
        """
        The client-serving radio frequencies of this SSID in the default indoor RF profile
        """
        return pulumi.get(self, "band_selection")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether or not the SSID is enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="encryptionMode")
    def encryption_mode(self) -> _builtins.str:
        """
        The psk encryption mode for the SSID
        """
        return pulumi.get(self, "encryption_mode")

    @_builtins.property
    @pulumi.getter(name="ipAssignmentMode")
    def ip_assignment_mode(self) -> _builtins.str:
        """
        The client IP assignment mode
        """
        return pulumi.get(self, "ip_assignment_mode")

    @_builtins.property
    @pulumi.getter(name="localAuth")
    def local_auth(self) -> _builtins.bool:
        """
        Extended local auth flag for Enterprise NAC
        """
        return pulumi.get(self, "local_auth")

    @_builtins.property
    @pulumi.getter(name="mandatoryDhcpEnabled")
    def mandatory_dhcp_enabled(self) -> _builtins.bool:
        """
        Whether clients connecting to this SSID must use the IP address assigned by the DHCP server
        """
        return pulumi.get(self, "mandatory_dhcp_enabled")

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> _builtins.int:
        """
        The minimum bitrate in Mbps of this SSID in the default indoor RF profile
        """
        return pulumi.get(self, "min_bitrate")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the SSID
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def number(self) -> _builtins.int:
        """
        Unique identifier of the SSID
        """
        return pulumi.get(self, "number")

    @_builtins.property
    @pulumi.getter(name="perClientBandwidthLimitDown")
    def per_client_bandwidth_limit_down(self) -> _builtins.int:
        """
        The download bandwidth limit in Kbps. (0 represents no limit.)
        """
        return pulumi.get(self, "per_client_bandwidth_limit_down")

    @_builtins.property
    @pulumi.getter(name="perClientBandwidthLimitUp")
    def per_client_bandwidth_limit_up(self) -> _builtins.int:
        """
        The upload bandwidth limit in Kbps. (0 represents no limit.)
        """
        return pulumi.get(self, "per_client_bandwidth_limit_up")

    @_builtins.property
    @pulumi.getter(name="perSsidBandwidthLimitDown")
    def per_ssid_bandwidth_limit_down(self) -> _builtins.int:
        """
        The total download bandwidth limit in Kbps (0 represents no limit)
        """
        return pulumi.get(self, "per_ssid_bandwidth_limit_down")

    @_builtins.property
    @pulumi.getter(name="perSsidBandwidthLimitUp")
    def per_ssid_bandwidth_limit_up(self) -> _builtins.int:
        """
        The total upload bandwidth limit in Kbps (0 represents no limit)
        """
        return pulumi.get(self, "per_ssid_bandwidth_limit_up")

    @_builtins.property
    @pulumi.getter(name="radiusAccountingEnabled")
    def radius_accounting_enabled(self) -> _builtins.bool:
        """
        Whether or not RADIUS accounting is enabled
        """
        return pulumi.get(self, "radius_accounting_enabled")

    @_builtins.property
    @pulumi.getter(name="radiusAccountingServers")
    def radius_accounting_servers(self) -> Sequence['outputs.GetWirelessSsidsItemRadiusAccountingServerResult']:
        """
        List of RADIUS accounting 802.1X servers to be used for authentication
        """
        return pulumi.get(self, "radius_accounting_servers")

    @_builtins.property
    @pulumi.getter(name="radiusAttributeForGroupPolicies")
    def radius_attribute_for_group_policies(self) -> _builtins.str:
        """
        RADIUS attribute used to look up group policies
        """
        return pulumi.get(self, "radius_attribute_for_group_policies")

    @_builtins.property
    @pulumi.getter(name="radiusEnabled")
    def radius_enabled(self) -> _builtins.bool:
        """
        Whether RADIUS authentication is enabled
        """
        return pulumi.get(self, "radius_enabled")

    @_builtins.property
    @pulumi.getter(name="radiusFailoverPolicy")
    def radius_failover_policy(self) -> _builtins.str:
        """
        Policy which determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable
        """
        return pulumi.get(self, "radius_failover_policy")

    @_builtins.property
    @pulumi.getter(name="radiusLoadBalancingPolicy")
    def radius_load_balancing_policy(self) -> _builtins.str:
        """
        Policy which determines which RADIUS server will be contacted first in an authentication attempt, and the ordering of any necessary retry attempts
        """
        return pulumi.get(self, "radius_load_balancing_policy")

    @_builtins.property
    @pulumi.getter(name="radiusServers")
    def radius_servers(self) -> Sequence['outputs.GetWirelessSsidsItemRadiusServerResult']:
        """
        List of RADIUS 802.1X servers to be used for authentication
        """
        return pulumi.get(self, "radius_servers")

    @_builtins.property
    @pulumi.getter(name="splashPage")
    def splash_page(self) -> _builtins.str:
        """
        The type of splash page for the SSID
        """
        return pulumi.get(self, "splash_page")

    @_builtins.property
    @pulumi.getter(name="splashTimeout")
    def splash_timeout(self) -> _builtins.str:
        """
        Splash page timeout
        """
        return pulumi.get(self, "splash_timeout")

    @_builtins.property
    @pulumi.getter(name="ssidAdminAccessible")
    def ssid_admin_accessible(self) -> _builtins.bool:
        """
        SSID Administrator access status
        """
        return pulumi.get(self, "ssid_admin_accessible")

    @_builtins.property
    @pulumi.getter
    def visible(self) -> _builtins.bool:
        """
        Whether the SSID is advertised or hidden by the AP
        """
        return pulumi.get(self, "visible")

    @_builtins.property
    @pulumi.getter(name="walledGardenEnabled")
    def walled_garden_enabled(self) -> _builtins.bool:
        """
        Allow users to access a configurable list of IP ranges prior to sign-on
        """
        return pulumi.get(self, "walled_garden_enabled")

    @_builtins.property
    @pulumi.getter(name="walledGardenRanges")
    def walled_garden_ranges(self) -> Sequence[_builtins.str]:
        """
        Domain names and IP address ranges available in Walled Garden mode
        """
        return pulumi.get(self, "walled_garden_ranges")

    @_builtins.property
    @pulumi.getter(name="wpaEncryptionMode")
    def wpa_encryption_mode(self) -> _builtins.str:
        """
        The types of WPA encryption
        """
        return pulumi.get(self, "wpa_encryption_mode")


@pulumi.output_type
class GetWirelessSsidsItemRadiusAccountingServerResult(dict):
    def __init__(__self__, *,
                 ca_certificate: _builtins.str,
                 host: _builtins.str,
                 open_roaming_certificate_id: _builtins.int,
                 port: _builtins.int):
        """
        :param _builtins.str ca_certificate: Certificate used for authorization for the RADSEC Server
        :param _builtins.str host: IP address (or FQDN) to which the APs will send RADIUS accounting messages
        :param _builtins.int open_roaming_certificate_id: The ID of the Openroaming Certificate attached to radius server
        :param _builtins.int port: Port on the RADIUS server that is listening for accounting messages
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "open_roaming_certificate_id", open_roaming_certificate_id)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> _builtins.str:
        """
        Certificate used for authorization for the RADSEC Server
        """
        return pulumi.get(self, "ca_certificate")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP address (or FQDN) to which the APs will send RADIUS accounting messages
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="openRoamingCertificateId")
    def open_roaming_certificate_id(self) -> _builtins.int:
        """
        The ID of the Openroaming Certificate attached to radius server
        """
        return pulumi.get(self, "open_roaming_certificate_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port on the RADIUS server that is listening for accounting messages
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetWirelessSsidsItemRadiusServerResult(dict):
    def __init__(__self__, *,
                 ca_certificate: _builtins.str,
                 host: _builtins.str,
                 open_roaming_certificate_id: _builtins.int,
                 port: _builtins.int):
        """
        :param _builtins.str ca_certificate: Certificate used for authorization for the RADSEC Server
        :param _builtins.str host: IP address (or FQDN) of your RADIUS server
        :param _builtins.int open_roaming_certificate_id: The ID of the Openroaming Certificate attached to radius server
        :param _builtins.int port: UDP port the RADIUS server listens on for Access-requests
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "open_roaming_certificate_id", open_roaming_certificate_id)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> _builtins.str:
        """
        Certificate used for authorization for the RADSEC Server
        """
        return pulumi.get(self, "ca_certificate")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP address (or FQDN) of your RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="openRoamingCertificateId")
    def open_roaming_certificate_id(self) -> _builtins.int:
        """
        The ID of the Openroaming Certificate attached to radius server
        """
        return pulumi.get(self, "open_roaming_certificate_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        UDP port the RADIUS server listens on for Access-requests
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetWirelessSsidsSchedulesItemResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 ranges: Sequence['outputs.GetWirelessSsidsSchedulesItemRangeResult']):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "ranges", ranges)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def ranges(self) -> Sequence['outputs.GetWirelessSsidsSchedulesItemRangeResult']:
        return pulumi.get(self, "ranges")


@pulumi.output_type
class GetWirelessSsidsSchedulesItemRangeResult(dict):
    def __init__(__self__, *,
                 end_day: _builtins.str,
                 end_time: _builtins.str,
                 start_day: _builtins.str,
                 start_time: _builtins.str):
        pulumi.set(__self__, "end_day", end_day)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_day", start_day)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endDay")
    def end_day(self) -> _builtins.str:
        return pulumi.get(self, "end_day")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startDay")
    def start_day(self) -> _builtins.str:
        return pulumi.get(self, "start_day")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetWirelessSsidsSplashSettingsItemResult(dict):
    def __init__(__self__, *,
                 allow_simultaneous_logins: _builtins.bool,
                 billing: 'outputs.GetWirelessSsidsSplashSettingsItemBillingResult',
                 block_all_traffic_before_sign_on: _builtins.bool,
                 controller_disconnection_behavior: _builtins.str,
                 guest_sponsorship: 'outputs.GetWirelessSsidsSplashSettingsItemGuestSponsorshipResult',
                 redirect_url: _builtins.str,
                 self_registration: 'outputs.GetWirelessSsidsSplashSettingsItemSelfRegistrationResult',
                 sentry_enrollment: 'outputs.GetWirelessSsidsSplashSettingsItemSentryEnrollmentResult',
                 splash_image: 'outputs.GetWirelessSsidsSplashSettingsItemSplashImageResult',
                 splash_logo: 'outputs.GetWirelessSsidsSplashSettingsItemSplashLogoResult',
                 splash_page: _builtins.str,
                 splash_prepaid_front: 'outputs.GetWirelessSsidsSplashSettingsItemSplashPrepaidFrontResult',
                 splash_timeout: _builtins.int,
                 splash_url: _builtins.str,
                 ssid_number: _builtins.int,
                 theme_id: _builtins.str,
                 use_redirect_url: _builtins.bool,
                 use_splash_url: _builtins.bool,
                 welcome_message: _builtins.str):
        """
        :param _builtins.bool allow_simultaneous_logins: Whether or not to allow simultaneous logins from different devices.
        :param 'GetWirelessSsidsSplashSettingsItemBillingArgs' billing: Details associated with billing splash
        :param _builtins.bool block_all_traffic_before_sign_on: How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged.
        :param _builtins.str controller_disconnection_behavior: How login attempts should be handled when the controller is unreachable.
        :param 'GetWirelessSsidsSplashSettingsItemGuestSponsorshipArgs' guest_sponsorship: Details associated with guest sponsored splash
        :param _builtins.str redirect_url: The custom redirect URL where the users will go after the splash page.
        :param 'GetWirelessSsidsSplashSettingsItemSelfRegistrationArgs' self_registration: Self-registration for splash with Meraki authentication.
        :param 'GetWirelessSsidsSplashSettingsItemSentryEnrollmentArgs' sentry_enrollment: Systems Manager sentry enrollment splash settings.
        :param 'GetWirelessSsidsSplashSettingsItemSplashImageArgs' splash_image: The image used in the splash page.
        :param 'GetWirelessSsidsSplashSettingsItemSplashLogoArgs' splash_logo: The logo used in the splash page.
        :param _builtins.str splash_page: The type of splash page for this SSID
        :param 'GetWirelessSsidsSplashSettingsItemSplashPrepaidFrontArgs' splash_prepaid_front: The prepaid front image used in the splash page.
        :param _builtins.int splash_timeout: Splash timeout in minutes.
        :param _builtins.str splash_url: The custom splash URL of the click-through splash page.
        :param _builtins.int ssid_number: SSID number
        :param _builtins.str theme_id: The id of the selected splash theme.
        :param _builtins.bool use_redirect_url: The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page.
        :param _builtins.bool use_splash_url: Boolean indicating whether the users will be redirected to the custom splash url
        :param _builtins.str welcome_message: The welcome message for the users on the splash page.
        """
        pulumi.set(__self__, "allow_simultaneous_logins", allow_simultaneous_logins)
        pulumi.set(__self__, "billing", billing)
        pulumi.set(__self__, "block_all_traffic_before_sign_on", block_all_traffic_before_sign_on)
        pulumi.set(__self__, "controller_disconnection_behavior", controller_disconnection_behavior)
        pulumi.set(__self__, "guest_sponsorship", guest_sponsorship)
        pulumi.set(__self__, "redirect_url", redirect_url)
        pulumi.set(__self__, "self_registration", self_registration)
        pulumi.set(__self__, "sentry_enrollment", sentry_enrollment)
        pulumi.set(__self__, "splash_image", splash_image)
        pulumi.set(__self__, "splash_logo", splash_logo)
        pulumi.set(__self__, "splash_page", splash_page)
        pulumi.set(__self__, "splash_prepaid_front", splash_prepaid_front)
        pulumi.set(__self__, "splash_timeout", splash_timeout)
        pulumi.set(__self__, "splash_url", splash_url)
        pulumi.set(__self__, "ssid_number", ssid_number)
        pulumi.set(__self__, "theme_id", theme_id)
        pulumi.set(__self__, "use_redirect_url", use_redirect_url)
        pulumi.set(__self__, "use_splash_url", use_splash_url)
        pulumi.set(__self__, "welcome_message", welcome_message)

    @_builtins.property
    @pulumi.getter(name="allowSimultaneousLogins")
    def allow_simultaneous_logins(self) -> _builtins.bool:
        """
        Whether or not to allow simultaneous logins from different devices.
        """
        return pulumi.get(self, "allow_simultaneous_logins")

    @_builtins.property
    @pulumi.getter
    def billing(self) -> 'outputs.GetWirelessSsidsSplashSettingsItemBillingResult':
        """
        Details associated with billing splash
        """
        return pulumi.get(self, "billing")

    @_builtins.property
    @pulumi.getter(name="blockAllTrafficBeforeSignOn")
    def block_all_traffic_before_sign_on(self) -> _builtins.bool:
        """
        How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged.
        """
        return pulumi.get(self, "block_all_traffic_before_sign_on")

    @_builtins.property
    @pulumi.getter(name="controllerDisconnectionBehavior")
    def controller_disconnection_behavior(self) -> _builtins.str:
        """
        How login attempts should be handled when the controller is unreachable.
        """
        return pulumi.get(self, "controller_disconnection_behavior")

    @_builtins.property
    @pulumi.getter(name="guestSponsorship")
    def guest_sponsorship(self) -> 'outputs.GetWirelessSsidsSplashSettingsItemGuestSponsorshipResult':
        """
        Details associated with guest sponsored splash
        """
        return pulumi.get(self, "guest_sponsorship")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> _builtins.str:
        """
        The custom redirect URL where the users will go after the splash page.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter(name="selfRegistration")
    def self_registration(self) -> 'outputs.GetWirelessSsidsSplashSettingsItemSelfRegistrationResult':
        """
        Self-registration for splash with Meraki authentication.
        """
        return pulumi.get(self, "self_registration")

    @_builtins.property
    @pulumi.getter(name="sentryEnrollment")
    def sentry_enrollment(self) -> 'outputs.GetWirelessSsidsSplashSettingsItemSentryEnrollmentResult':
        """
        Systems Manager sentry enrollment splash settings.
        """
        return pulumi.get(self, "sentry_enrollment")

    @_builtins.property
    @pulumi.getter(name="splashImage")
    def splash_image(self) -> 'outputs.GetWirelessSsidsSplashSettingsItemSplashImageResult':
        """
        The image used in the splash page.
        """
        return pulumi.get(self, "splash_image")

    @_builtins.property
    @pulumi.getter(name="splashLogo")
    def splash_logo(self) -> 'outputs.GetWirelessSsidsSplashSettingsItemSplashLogoResult':
        """
        The logo used in the splash page.
        """
        return pulumi.get(self, "splash_logo")

    @_builtins.property
    @pulumi.getter(name="splashPage")
    def splash_page(self) -> _builtins.str:
        """
        The type of splash page for this SSID
        """
        return pulumi.get(self, "splash_page")

    @_builtins.property
    @pulumi.getter(name="splashPrepaidFront")
    def splash_prepaid_front(self) -> 'outputs.GetWirelessSsidsSplashSettingsItemSplashPrepaidFrontResult':
        """
        The prepaid front image used in the splash page.
        """
        return pulumi.get(self, "splash_prepaid_front")

    @_builtins.property
    @pulumi.getter(name="splashTimeout")
    def splash_timeout(self) -> _builtins.int:
        """
        Splash timeout in minutes.
        """
        return pulumi.get(self, "splash_timeout")

    @_builtins.property
    @pulumi.getter(name="splashUrl")
    def splash_url(self) -> _builtins.str:
        """
        The custom splash URL of the click-through splash page.
        """
        return pulumi.get(self, "splash_url")

    @_builtins.property
    @pulumi.getter(name="ssidNumber")
    def ssid_number(self) -> _builtins.int:
        """
        SSID number
        """
        return pulumi.get(self, "ssid_number")

    @_builtins.property
    @pulumi.getter(name="themeId")
    def theme_id(self) -> _builtins.str:
        """
        The id of the selected splash theme.
        """
        return pulumi.get(self, "theme_id")

    @_builtins.property
    @pulumi.getter(name="useRedirectUrl")
    def use_redirect_url(self) -> _builtins.bool:
        """
        The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page.
        """
        return pulumi.get(self, "use_redirect_url")

    @_builtins.property
    @pulumi.getter(name="useSplashUrl")
    def use_splash_url(self) -> _builtins.bool:
        """
        Boolean indicating whether the users will be redirected to the custom splash url
        """
        return pulumi.get(self, "use_splash_url")

    @_builtins.property
    @pulumi.getter(name="welcomeMessage")
    def welcome_message(self) -> _builtins.str:
        """
        The welcome message for the users on the splash page.
        """
        return pulumi.get(self, "welcome_message")


@pulumi.output_type
class GetWirelessSsidsSplashSettingsItemBillingResult(dict):
    def __init__(__self__, *,
                 free_access: 'outputs.GetWirelessSsidsSplashSettingsItemBillingFreeAccessResult',
                 prepaid_access_fast_login_enabled: _builtins.bool,
                 reply_to_email_address: _builtins.str):
        """
        :param 'GetWirelessSsidsSplashSettingsItemBillingFreeAccessArgs' free_access: Details associated with a free access plan with limits
        :param _builtins.bool prepaid_access_fast_login_enabled: Whether or not billing uses the fast login prepaid access option.
        :param _builtins.str reply_to_email_address: The email address that reeceives replies from clients
        """
        pulumi.set(__self__, "free_access", free_access)
        pulumi.set(__self__, "prepaid_access_fast_login_enabled", prepaid_access_fast_login_enabled)
        pulumi.set(__self__, "reply_to_email_address", reply_to_email_address)

    @_builtins.property
    @pulumi.getter(name="freeAccess")
    def free_access(self) -> 'outputs.GetWirelessSsidsSplashSettingsItemBillingFreeAccessResult':
        """
        Details associated with a free access plan with limits
        """
        return pulumi.get(self, "free_access")

    @_builtins.property
    @pulumi.getter(name="prepaidAccessFastLoginEnabled")
    def prepaid_access_fast_login_enabled(self) -> _builtins.bool:
        """
        Whether or not billing uses the fast login prepaid access option.
        """
        return pulumi.get(self, "prepaid_access_fast_login_enabled")

    @_builtins.property
    @pulumi.getter(name="replyToEmailAddress")
    def reply_to_email_address(self) -> _builtins.str:
        """
        The email address that reeceives replies from clients
        """
        return pulumi.get(self, "reply_to_email_address")


@pulumi.output_type
class GetWirelessSsidsSplashSettingsItemBillingFreeAccessResult(dict):
    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 enabled: _builtins.bool):
        """
        :param _builtins.int duration_in_minutes: How long a device can use a network for free.
        :param _builtins.bool enabled: Whether or not free access is enabled.
        """
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        """
        How long a device can use a network for free.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether or not free access is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetWirelessSsidsSplashSettingsItemGuestSponsorshipResult(dict):
    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 guest_can_request_timeframe: _builtins.bool):
        """
        :param _builtins.int duration_in_minutes: Duration in minutes of sponsored guest authorization.
        :param _builtins.bool guest_can_request_timeframe: Whether or not guests can specify how much time they are requesting.
        """
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "guest_can_request_timeframe", guest_can_request_timeframe)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        """
        Duration in minutes of sponsored guest authorization.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter(name="guestCanRequestTimeframe")
    def guest_can_request_timeframe(self) -> _builtins.bool:
        """
        Whether or not guests can specify how much time they are requesting.
        """
        return pulumi.get(self, "guest_can_request_timeframe")


@pulumi.output_type
class GetWirelessSsidsSplashSettingsItemSelfRegistrationResult(dict):
    def __init__(__self__, *,
                 authorization_type: _builtins.str,
                 enabled: _builtins.bool):
        """
        :param _builtins.str authorization_type: How created user accounts should be authorized.
        :param _builtins.bool enabled: Whether or not to allow users to create their own account on the network.
        """
        pulumi.set(__self__, "authorization_type", authorization_type)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="authorizationType")
    def authorization_type(self) -> _builtins.str:
        """
        How created user accounts should be authorized.
        """
        return pulumi.get(self, "authorization_type")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether or not to allow users to create their own account on the network.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetWirelessSsidsSplashSettingsItemSentryEnrollmentResult(dict):
    def __init__(__self__, *,
                 enforced_systems: Sequence[_builtins.str],
                 strength: _builtins.str,
                 systems_manager_network: 'outputs.GetWirelessSsidsSplashSettingsItemSentryEnrollmentSystemsManagerNetworkResult'):
        """
        :param Sequence[_builtins.str] enforced_systems: The system types that the Sentry enforces.
        :param _builtins.str strength: The strength of the enforcement of selected system types.
        :param 'GetWirelessSsidsSplashSettingsItemSentryEnrollmentSystemsManagerNetworkArgs' systems_manager_network: Systems Manager network targeted for sentry enrollment.
        """
        pulumi.set(__self__, "enforced_systems", enforced_systems)
        pulumi.set(__self__, "strength", strength)
        pulumi.set(__self__, "systems_manager_network", systems_manager_network)

    @_builtins.property
    @pulumi.getter(name="enforcedSystems")
    def enforced_systems(self) -> Sequence[_builtins.str]:
        """
        The system types that the Sentry enforces.
        """
        return pulumi.get(self, "enforced_systems")

    @_builtins.property
    @pulumi.getter
    def strength(self) -> _builtins.str:
        """
        The strength of the enforcement of selected system types.
        """
        return pulumi.get(self, "strength")

    @_builtins.property
    @pulumi.getter(name="systemsManagerNetwork")
    def systems_manager_network(self) -> 'outputs.GetWirelessSsidsSplashSettingsItemSentryEnrollmentSystemsManagerNetworkResult':
        """
        Systems Manager network targeted for sentry enrollment.
        """
        return pulumi.get(self, "systems_manager_network")


@pulumi.output_type
class GetWirelessSsidsSplashSettingsItemSentryEnrollmentSystemsManagerNetworkResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The network ID of the Systems Manager network.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The network ID of the Systems Manager network.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetWirelessSsidsSplashSettingsItemSplashImageResult(dict):
    def __init__(__self__, *,
                 extension: _builtins.str,
                 md5: _builtins.str):
        """
        :param _builtins.str extension: The extension of the image file.
        :param _builtins.str md5: The MD5 value of the image file.
        """
        pulumi.set(__self__, "extension", extension)
        pulumi.set(__self__, "md5", md5)

    @_builtins.property
    @pulumi.getter
    def extension(self) -> _builtins.str:
        """
        The extension of the image file.
        """
        return pulumi.get(self, "extension")

    @_builtins.property
    @pulumi.getter
    def md5(self) -> _builtins.str:
        """
        The MD5 value of the image file.
        """
        return pulumi.get(self, "md5")


@pulumi.output_type
class GetWirelessSsidsSplashSettingsItemSplashLogoResult(dict):
    def __init__(__self__, *,
                 extension: _builtins.str,
                 md5: _builtins.str):
        """
        :param _builtins.str extension: The extension of the logo file.
        :param _builtins.str md5: The MD5 value of the logo file.
        """
        pulumi.set(__self__, "extension", extension)
        pulumi.set(__self__, "md5", md5)

    @_builtins.property
    @pulumi.getter
    def extension(self) -> _builtins.str:
        """
        The extension of the logo file.
        """
        return pulumi.get(self, "extension")

    @_builtins.property
    @pulumi.getter
    def md5(self) -> _builtins.str:
        """
        The MD5 value of the logo file.
        """
        return pulumi.get(self, "md5")


@pulumi.output_type
class GetWirelessSsidsSplashSettingsItemSplashPrepaidFrontResult(dict):
    def __init__(__self__, *,
                 extension: _builtins.str,
                 md5: _builtins.str):
        """
        :param _builtins.str extension: The extension of the prepaid front image file.
        :param _builtins.str md5: The MD5 value of the prepaid front image file.
        """
        pulumi.set(__self__, "extension", extension)
        pulumi.set(__self__, "md5", md5)

    @_builtins.property
    @pulumi.getter
    def extension(self) -> _builtins.str:
        """
        The extension of the prepaid front image file.
        """
        return pulumi.get(self, "extension")

    @_builtins.property
    @pulumi.getter
    def md5(self) -> _builtins.str:
        """
        The MD5 value of the prepaid front image file.
        """
        return pulumi.get(self, "md5")


@pulumi.output_type
class GetWirelessSsidsTrafficShapingRulesItemResult(dict):
    def __init__(__self__, *,
                 default_rules_enabled: _builtins.bool,
                 rules: Sequence['outputs.GetWirelessSsidsTrafficShapingRulesItemRuleResult'],
                 traffic_shaping_enabled: _builtins.bool):
        """
        :param _builtins.bool default_rules_enabled: Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
        :param Sequence['GetWirelessSsidsTrafficShapingRulesItemRuleArgs'] rules: An array of traffic shaping rules. Rules are applied in the order that
               they are specified in. An empty list (or null) means no rules. Note that
               you are allowed a maximum of 8 rules.
        :param _builtins.bool traffic_shaping_enabled: Whether traffic shaping rules are applied to clients on your SSID.
        """
        pulumi.set(__self__, "default_rules_enabled", default_rules_enabled)
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "traffic_shaping_enabled", traffic_shaping_enabled)

    @_builtins.property
    @pulumi.getter(name="defaultRulesEnabled")
    def default_rules_enabled(self) -> _builtins.bool:
        """
        Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
        """
        return pulumi.get(self, "default_rules_enabled")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetWirelessSsidsTrafficShapingRulesItemRuleResult']:
        """
        An array of traffic shaping rules. Rules are applied in the order that
        they are specified in. An empty list (or null) means no rules. Note that
        you are allowed a maximum of 8 rules.
        """
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter(name="trafficShapingEnabled")
    def traffic_shaping_enabled(self) -> _builtins.bool:
        """
        Whether traffic shaping rules are applied to clients on your SSID.
        """
        return pulumi.get(self, "traffic_shaping_enabled")


@pulumi.output_type
class GetWirelessSsidsTrafficShapingRulesItemRuleResult(dict):
    def __init__(__self__, *,
                 definitions: Sequence['outputs.GetWirelessSsidsTrafficShapingRulesItemRuleDefinitionResult'],
                 dscp_tag_value: _builtins.int,
                 pcp_tag_value: _builtins.int,
                 per_client_bandwidth_limits: 'outputs.GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimitsResult'):
        """
        :param Sequence['GetWirelessSsidsTrafficShapingRulesItemRuleDefinitionArgs'] definitions: A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        :param _builtins.int dscp_tag_value: The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
               For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        :param _builtins.int pcp_tag_value: The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
               null means 'Do not set PCP tag'.
        :param 'GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimitsArgs' per_client_bandwidth_limits: An object describing the bandwidth settings for your rule.
        """
        pulumi.set(__self__, "definitions", definitions)
        pulumi.set(__self__, "dscp_tag_value", dscp_tag_value)
        pulumi.set(__self__, "pcp_tag_value", pcp_tag_value)
        pulumi.set(__self__, "per_client_bandwidth_limits", per_client_bandwidth_limits)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> Sequence['outputs.GetWirelessSsidsTrafficShapingRulesItemRuleDefinitionResult']:
        """
        A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        """
        return pulumi.get(self, "definitions")

    @_builtins.property
    @pulumi.getter(name="dscpTagValue")
    def dscp_tag_value(self) -> _builtins.int:
        """
        The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        """
        return pulumi.get(self, "dscp_tag_value")

    @_builtins.property
    @pulumi.getter(name="pcpTagValue")
    def pcp_tag_value(self) -> _builtins.int:
        """
        The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
        null means 'Do not set PCP tag'.
        """
        return pulumi.get(self, "pcp_tag_value")

    @_builtins.property
    @pulumi.getter(name="perClientBandwidthLimits")
    def per_client_bandwidth_limits(self) -> 'outputs.GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimitsResult':
        """
        An object describing the bandwidth settings for your rule.
        """
        return pulumi.get(self, "per_client_bandwidth_limits")


@pulumi.output_type
class GetWirelessSsidsTrafficShapingRulesItemRuleDefinitionResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str type: The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        :param _builtins.str value: If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
               a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
               "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
               custom ports.
                If "type" is 'application' or 'applicationCategory', then "value" must be an object
               with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
               application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
               endpoint).
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
        a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
        "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
        custom ports.
         If "type" is 'application' or 'applicationCategory', then "value" must be an object
        with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
        application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
        endpoint).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimitsResult(dict):
    def __init__(__self__, *,
                 bandwidth_limits: 'outputs.GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimitsResult',
                 settings: _builtins.str):
        """
        :param 'GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimitsArgs' bandwidth_limits: The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        :param _builtins.str settings: How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> 'outputs.GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimitsResult':
        """
        The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "bandwidth_limits")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> _builtins.str:
        """
        How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimitsResult(dict):
    def __init__(__self__, *,
                 limit_down: _builtins.int,
                 limit_up: _builtins.int):
        """
        :param _builtins.int limit_down: The maximum download limit (integer, in Kbps).
        :param _builtins.int limit_up: The maximum upload limit (integer, in Kbps).
        """
        pulumi.set(__self__, "limit_down", limit_down)
        pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> _builtins.int:
        """
        The maximum download limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_down")

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> _builtins.int:
        """
        The maximum upload limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_up")


@pulumi.output_type
class GetWirelessSsidsVpnItemResult(dict):
    def __init__(__self__, *,
                 concentrator: 'outputs.GetWirelessSsidsVpnItemConcentratorResult',
                 failover: 'outputs.GetWirelessSsidsVpnItemFailoverResult',
                 split_tunnel: 'outputs.GetWirelessSsidsVpnItemSplitTunnelResult'):
        pulumi.set(__self__, "concentrator", concentrator)
        pulumi.set(__self__, "failover", failover)
        pulumi.set(__self__, "split_tunnel", split_tunnel)

    @_builtins.property
    @pulumi.getter
    def concentrator(self) -> 'outputs.GetWirelessSsidsVpnItemConcentratorResult':
        return pulumi.get(self, "concentrator")

    @_builtins.property
    @pulumi.getter
    def failover(self) -> 'outputs.GetWirelessSsidsVpnItemFailoverResult':
        return pulumi.get(self, "failover")

    @_builtins.property
    @pulumi.getter(name="splitTunnel")
    def split_tunnel(self) -> 'outputs.GetWirelessSsidsVpnItemSplitTunnelResult':
        return pulumi.get(self, "split_tunnel")


@pulumi.output_type
class GetWirelessSsidsVpnItemConcentratorResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 network_id: _builtins.str,
                 vlan_id: _builtins.int):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.int:
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetWirelessSsidsVpnItemFailoverResult(dict):
    def __init__(__self__, *,
                 heartbeat_interval: _builtins.int,
                 idle_timeout: _builtins.int,
                 request_ip: _builtins.str):
        pulumi.set(__self__, "heartbeat_interval", heartbeat_interval)
        pulumi.set(__self__, "idle_timeout", idle_timeout)
        pulumi.set(__self__, "request_ip", request_ip)

    @_builtins.property
    @pulumi.getter(name="heartbeatInterval")
    def heartbeat_interval(self) -> _builtins.int:
        return pulumi.get(self, "heartbeat_interval")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> _builtins.int:
        return pulumi.get(self, "idle_timeout")

    @_builtins.property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> _builtins.str:
        return pulumi.get(self, "request_ip")


@pulumi.output_type
class GetWirelessSsidsVpnItemSplitTunnelResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 rules: Sequence['outputs.GetWirelessSsidsVpnItemSplitTunnelRuleResult']):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetWirelessSsidsVpnItemSplitTunnelRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetWirelessSsidsVpnItemSplitTunnelRuleResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 dest_cidr: _builtins.str,
                 dest_port: _builtins.str,
                 policy: _builtins.str,
                 protocol: _builtins.str):
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "dest_cidr", dest_cidr)
        pulumi.set(__self__, "dest_port", dest_port)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> _builtins.str:
        return pulumi.get(self, "dest_cidr")

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> _builtins.str:
        return pulumi.get(self, "dest_port")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetWirelessUsageHistoryItemResult(dict):
    def __init__(__self__, *,
                 end_ts: _builtins.str,
                 received_kbps: _builtins.int,
                 sent_kbps: _builtins.int,
                 start_ts: _builtins.str,
                 total_kbps: _builtins.int):
        """
        :param _builtins.str end_ts: The end time of the query range
        :param _builtins.int received_kbps: Received kilobytes-per-second
        :param _builtins.int sent_kbps: Sent kilobytes-per-second
        :param _builtins.str start_ts: The start time of the query range
        :param _builtins.int total_kbps: Total usage in kilobytes-per-second
        """
        pulumi.set(__self__, "end_ts", end_ts)
        pulumi.set(__self__, "received_kbps", received_kbps)
        pulumi.set(__self__, "sent_kbps", sent_kbps)
        pulumi.set(__self__, "start_ts", start_ts)
        pulumi.set(__self__, "total_kbps", total_kbps)

    @_builtins.property
    @pulumi.getter(name="endTs")
    def end_ts(self) -> _builtins.str:
        """
        The end time of the query range
        """
        return pulumi.get(self, "end_ts")

    @_builtins.property
    @pulumi.getter(name="receivedKbps")
    def received_kbps(self) -> _builtins.int:
        """
        Received kilobytes-per-second
        """
        return pulumi.get(self, "received_kbps")

    @_builtins.property
    @pulumi.getter(name="sentKbps")
    def sent_kbps(self) -> _builtins.int:
        """
        Sent kilobytes-per-second
        """
        return pulumi.get(self, "sent_kbps")

    @_builtins.property
    @pulumi.getter(name="startTs")
    def start_ts(self) -> _builtins.str:
        """
        The start time of the query range
        """
        return pulumi.get(self, "start_ts")

    @_builtins.property
    @pulumi.getter(name="totalKbps")
    def total_kbps(self) -> _builtins.int:
        """
        Total usage in kilobytes-per-second
        """
        return pulumi.get(self, "total_kbps")


