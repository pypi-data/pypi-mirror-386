# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApplianceRadioSettingsFiveGhzSettingsArgs',
    'ApplianceRadioSettingsFiveGhzSettingsArgsDict',
    'ApplianceRadioSettingsTwoFourGhzSettingsArgs',
    'ApplianceRadioSettingsTwoFourGhzSettingsArgsDict',
    'ApplianceUplinksSettingsInterfacesArgs',
    'ApplianceUplinksSettingsInterfacesArgsDict',
    'ApplianceUplinksSettingsInterfacesWan1Args',
    'ApplianceUplinksSettingsInterfacesWan1ArgsDict',
    'ApplianceUplinksSettingsInterfacesWan1PppoeArgs',
    'ApplianceUplinksSettingsInterfacesWan1PppoeArgsDict',
    'ApplianceUplinksSettingsInterfacesWan1PppoeAuthenticationArgs',
    'ApplianceUplinksSettingsInterfacesWan1PppoeAuthenticationArgsDict',
    'ApplianceUplinksSettingsInterfacesWan1SvisArgs',
    'ApplianceUplinksSettingsInterfacesWan1SvisArgsDict',
    'ApplianceUplinksSettingsInterfacesWan1SvisIpv4Args',
    'ApplianceUplinksSettingsInterfacesWan1SvisIpv4ArgsDict',
    'ApplianceUplinksSettingsInterfacesWan1SvisIpv4NameserversArgs',
    'ApplianceUplinksSettingsInterfacesWan1SvisIpv4NameserversArgsDict',
    'ApplianceUplinksSettingsInterfacesWan1SvisIpv6Args',
    'ApplianceUplinksSettingsInterfacesWan1SvisIpv6ArgsDict',
    'ApplianceUplinksSettingsInterfacesWan1SvisIpv6NameserversArgs',
    'ApplianceUplinksSettingsInterfacesWan1SvisIpv6NameserversArgsDict',
    'ApplianceUplinksSettingsInterfacesWan1VlanTaggingArgs',
    'ApplianceUplinksSettingsInterfacesWan1VlanTaggingArgsDict',
    'ApplianceUplinksSettingsInterfacesWan2Args',
    'ApplianceUplinksSettingsInterfacesWan2ArgsDict',
    'ApplianceUplinksSettingsInterfacesWan2PppoeArgs',
    'ApplianceUplinksSettingsInterfacesWan2PppoeArgsDict',
    'ApplianceUplinksSettingsInterfacesWan2PppoeAuthenticationArgs',
    'ApplianceUplinksSettingsInterfacesWan2PppoeAuthenticationArgsDict',
    'ApplianceUplinksSettingsInterfacesWan2SvisArgs',
    'ApplianceUplinksSettingsInterfacesWan2SvisArgsDict',
    'ApplianceUplinksSettingsInterfacesWan2SvisIpv4Args',
    'ApplianceUplinksSettingsInterfacesWan2SvisIpv4ArgsDict',
    'ApplianceUplinksSettingsInterfacesWan2SvisIpv4NameserversArgs',
    'ApplianceUplinksSettingsInterfacesWan2SvisIpv4NameserversArgsDict',
    'ApplianceUplinksSettingsInterfacesWan2SvisIpv6Args',
    'ApplianceUplinksSettingsInterfacesWan2SvisIpv6ArgsDict',
    'ApplianceUplinksSettingsInterfacesWan2SvisIpv6NameserversArgs',
    'ApplianceUplinksSettingsInterfacesWan2SvisIpv6NameserversArgsDict',
    'ApplianceUplinksSettingsInterfacesWan2VlanTaggingArgs',
    'ApplianceUplinksSettingsInterfacesWan2VlanTaggingArgsDict',
    'ApplianceVmxAuthenticationTokenItemArgs',
    'ApplianceVmxAuthenticationTokenItemArgsDict',
    'BlinkLedsItemArgs',
    'BlinkLedsItemArgsDict',
    'BlinkLedsParametersArgs',
    'BlinkLedsParametersArgsDict',
    'CameraCustomAnalyticsParameterArgs',
    'CameraCustomAnalyticsParameterArgsDict',
    'CameraGenerateSnapshotParametersArgs',
    'CameraGenerateSnapshotParametersArgsDict',
    'CameraSenseAudioDetectionArgs',
    'CameraSenseAudioDetectionArgsDict',
    'CameraWirelessProfilesIdsArgs',
    'CameraWirelessProfilesIdsArgsDict',
    'CellularGatewayLanFixedIpAssignmentArgs',
    'CellularGatewayLanFixedIpAssignmentArgsDict',
    'CellularGatewayLanReservedIpRangeArgs',
    'CellularGatewayLanReservedIpRangeArgsDict',
    'CellularGatewayPortForwardingRulesRuleArgs',
    'CellularGatewayPortForwardingRulesRuleArgsDict',
    'CellularSimsSimArgs',
    'CellularSimsSimArgsDict',
    'CellularSimsSimApnArgs',
    'CellularSimsSimApnArgsDict',
    'CellularSimsSimApnAuthenticationArgs',
    'CellularSimsSimApnAuthenticationArgsDict',
    'CellularSimsSimFailoverArgs',
    'CellularSimsSimFailoverArgsDict',
    'LiveToolsArpTableCallbackArgs',
    'LiveToolsArpTableCallbackArgsDict',
    'LiveToolsArpTableCallbackHttpServerArgs',
    'LiveToolsArpTableCallbackHttpServerArgsDict',
    'LiveToolsArpTableCallbackPayloadTemplateArgs',
    'LiveToolsArpTableCallbackPayloadTemplateArgsDict',
    'LiveToolsArpTableEntryArgs',
    'LiveToolsArpTableEntryArgsDict',
    'LiveToolsArpTableRequestArgs',
    'LiveToolsArpTableRequestArgsDict',
    'LiveToolsCableCallbackArgs',
    'LiveToolsCableCallbackArgsDict',
    'LiveToolsCableCallbackHttpServerArgs',
    'LiveToolsCableCallbackHttpServerArgsDict',
    'LiveToolsCableCallbackPayloadTemplateArgs',
    'LiveToolsCableCallbackPayloadTemplateArgsDict',
    'LiveToolsCableRequestArgs',
    'LiveToolsCableRequestArgsDict',
    'LiveToolsCableResultArgs',
    'LiveToolsCableResultArgsDict',
    'LiveToolsCableResultPairArgs',
    'LiveToolsCableResultPairArgsDict',
    'LiveToolsPingDeviceItemArgs',
    'LiveToolsPingDeviceItemArgsDict',
    'LiveToolsPingDeviceItemCallbackArgs',
    'LiveToolsPingDeviceItemCallbackArgsDict',
    'LiveToolsPingDeviceItemRequestArgs',
    'LiveToolsPingDeviceItemRequestArgsDict',
    'LiveToolsPingDeviceParametersArgs',
    'LiveToolsPingDeviceParametersArgsDict',
    'LiveToolsPingDeviceParametersCallbackArgs',
    'LiveToolsPingDeviceParametersCallbackArgsDict',
    'LiveToolsPingDeviceParametersCallbackHttpServerArgs',
    'LiveToolsPingDeviceParametersCallbackHttpServerArgsDict',
    'LiveToolsPingDeviceParametersCallbackPayloadTemplateArgs',
    'LiveToolsPingDeviceParametersCallbackPayloadTemplateArgsDict',
    'LiveToolsPingItemArgs',
    'LiveToolsPingItemArgsDict',
    'LiveToolsPingItemCallbackArgs',
    'LiveToolsPingItemCallbackArgsDict',
    'LiveToolsPingItemRequestArgs',
    'LiveToolsPingItemRequestArgsDict',
    'LiveToolsPingParametersArgs',
    'LiveToolsPingParametersArgsDict',
    'LiveToolsPingParametersCallbackArgs',
    'LiveToolsPingParametersCallbackArgsDict',
    'LiveToolsPingParametersCallbackHttpServerArgs',
    'LiveToolsPingParametersCallbackHttpServerArgsDict',
    'LiveToolsPingParametersCallbackPayloadTemplateArgs',
    'LiveToolsPingParametersCallbackPayloadTemplateArgsDict',
    'LiveToolsThroughputTestCallbackArgs',
    'LiveToolsThroughputTestCallbackArgsDict',
    'LiveToolsThroughputTestCallbackHttpServerArgs',
    'LiveToolsThroughputTestCallbackHttpServerArgsDict',
    'LiveToolsThroughputTestCallbackPayloadTemplateArgs',
    'LiveToolsThroughputTestCallbackPayloadTemplateArgsDict',
    'LiveToolsThroughputTestRequestArgs',
    'LiveToolsThroughputTestRequestArgsDict',
    'LiveToolsThroughputTestResultArgs',
    'LiveToolsThroughputTestResultArgsDict',
    'LiveToolsThroughputTestResultSpeedsArgs',
    'LiveToolsThroughputTestResultSpeedsArgsDict',
    'LiveToolsWakeOnLanCallbackArgs',
    'LiveToolsWakeOnLanCallbackArgsDict',
    'LiveToolsWakeOnLanCallbackHttpServerArgs',
    'LiveToolsWakeOnLanCallbackHttpServerArgsDict',
    'LiveToolsWakeOnLanCallbackPayloadTemplateArgs',
    'LiveToolsWakeOnLanCallbackPayloadTemplateArgsDict',
    'LiveToolsWakeOnLanRequestArgs',
    'LiveToolsWakeOnLanRequestArgsDict',
    'ManagementInterfaceDdnsHostnamesArgs',
    'ManagementInterfaceDdnsHostnamesArgsDict',
    'ManagementInterfaceWan1Args',
    'ManagementInterfaceWan1ArgsDict',
    'ManagementInterfaceWan2Args',
    'ManagementInterfaceWan2ArgsDict',
    'SensorRelationshipsLivestreamArgs',
    'SensorRelationshipsLivestreamArgsDict',
    'SensorRelationshipsLivestreamRelatedDeviceArgs',
    'SensorRelationshipsLivestreamRelatedDeviceArgsDict',
    'SensorRelationshipsLivestreamRequestArgs',
    'SensorRelationshipsLivestreamRequestArgsDict',
    'SensorRelationshipsLivestreamRequestRelatedDeviceArgs',
    'SensorRelationshipsLivestreamRequestRelatedDeviceArgsDict',
    'SwitchPortsCycleItemArgs',
    'SwitchPortsCycleItemArgsDict',
    'SwitchPortsCycleParametersArgs',
    'SwitchPortsCycleParametersArgsDict',
    'SwitchPortsMirrorArgs',
    'SwitchPortsMirrorArgsDict',
    'SwitchPortsModuleArgs',
    'SwitchPortsModuleArgsDict',
    'SwitchPortsProfileArgs',
    'SwitchPortsProfileArgsDict',
    'SwitchRoutingInterfacesDhcpDhcpOptionArgs',
    'SwitchRoutingInterfacesDhcpDhcpOptionArgsDict',
    'SwitchRoutingInterfacesDhcpFixedIpAssignmentArgs',
    'SwitchRoutingInterfacesDhcpFixedIpAssignmentArgsDict',
    'SwitchRoutingInterfacesDhcpReservedIpRangeArgs',
    'SwitchRoutingInterfacesDhcpReservedIpRangeArgsDict',
    'SwitchRoutingInterfacesIpv6Args',
    'SwitchRoutingInterfacesIpv6ArgsDict',
    'SwitchRoutingInterfacesOspfSettingsArgs',
    'SwitchRoutingInterfacesOspfSettingsArgsDict',
    'SwitchRoutingInterfacesOspfV3Args',
    'SwitchRoutingInterfacesOspfV3ArgsDict',
    'WirelessAlternateManagementInterfaceIpv6ItemArgs',
    'WirelessAlternateManagementInterfaceIpv6ItemArgsDict',
    'WirelessAlternateManagementInterfaceIpv6ItemAddressArgs',
    'WirelessAlternateManagementInterfaceIpv6ItemAddressArgsDict',
    'WirelessAlternateManagementInterfaceIpv6ItemAddressNameserversArgs',
    'WirelessAlternateManagementInterfaceIpv6ItemAddressNameserversArgsDict',
    'WirelessAlternateManagementInterfaceIpv6ParametersArgs',
    'WirelessAlternateManagementInterfaceIpv6ParametersArgsDict',
    'WirelessAlternateManagementInterfaceIpv6ParametersAddressArgs',
    'WirelessAlternateManagementInterfaceIpv6ParametersAddressArgsDict',
    'WirelessAlternateManagementInterfaceIpv6ParametersAddressNameserversArgs',
    'WirelessAlternateManagementInterfaceIpv6ParametersAddressNameserversArgsDict',
    'WirelessRadioSettingsFiveGhzSettingsArgs',
    'WirelessRadioSettingsFiveGhzSettingsArgsDict',
    'WirelessRadioSettingsTwoFourGhzSettingsArgs',
    'WirelessRadioSettingsTwoFourGhzSettingsArgsDict',
    'BaseDetailArgs',
    'BaseDetailArgsDict',
]

MYPY = False

if not MYPY:
    class ApplianceRadioSettingsFiveGhzSettingsArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.int]]
        """
        Manual channel for 5 GHz
        """
        channel_width: NotRequired[pulumi.Input[_builtins.int]]
        """
        Manual channel width for 5 GHz
        """
        target_power: NotRequired[pulumi.Input[_builtins.int]]
        """
        Manual target power for 5 GHz
        """
elif False:
    ApplianceRadioSettingsFiveGhzSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceRadioSettingsFiveGhzSettingsArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.int]] = None,
                 channel_width: Optional[pulumi.Input[_builtins.int]] = None,
                 target_power: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] channel: Manual channel for 5 GHz
        :param pulumi.Input[_builtins.int] channel_width: Manual channel width for 5 GHz
        :param pulumi.Input[_builtins.int] target_power: Manual target power for 5 GHz
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channel_width is not None:
            pulumi.set(__self__, "channel_width", channel_width)
        if target_power is not None:
            pulumi.set(__self__, "target_power", target_power)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Manual channel for 5 GHz
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="channelWidth")
    def channel_width(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Manual channel width for 5 GHz
        """
        return pulumi.get(self, "channel_width")

    @channel_width.setter
    def channel_width(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "channel_width", value)

    @_builtins.property
    @pulumi.getter(name="targetPower")
    def target_power(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Manual target power for 5 GHz
        """
        return pulumi.get(self, "target_power")

    @target_power.setter
    def target_power(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_power", value)


if not MYPY:
    class ApplianceRadioSettingsTwoFourGhzSettingsArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.int]]
        """
        Manual channel for 2.4 GHz
        """
        target_power: NotRequired[pulumi.Input[_builtins.int]]
        """
        Manual target power for 2.4 GHz
        """
elif False:
    ApplianceRadioSettingsTwoFourGhzSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceRadioSettingsTwoFourGhzSettingsArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.int]] = None,
                 target_power: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] channel: Manual channel for 2.4 GHz
        :param pulumi.Input[_builtins.int] target_power: Manual target power for 2.4 GHz
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if target_power is not None:
            pulumi.set(__self__, "target_power", target_power)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Manual channel for 2.4 GHz
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="targetPower")
    def target_power(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Manual target power for 2.4 GHz
        """
        return pulumi.get(self, "target_power")

    @target_power.setter
    def target_power(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_power", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesArgsDict(TypedDict):
        wan1: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1ArgsDict']]
        """
        WAN 1 settings.
        """
        wan2: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2ArgsDict']]
        """
        WAN 2 settings.
        """
elif False:
    ApplianceUplinksSettingsInterfacesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesArgs:
    def __init__(__self__, *,
                 wan1: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1Args']] = None,
                 wan2: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2Args']] = None):
        """
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan1Args'] wan1: WAN 1 settings.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan2Args'] wan2: WAN 2 settings.
        """
        if wan1 is not None:
            pulumi.set(__self__, "wan1", wan1)
        if wan2 is not None:
            pulumi.set(__self__, "wan2", wan2)

    @_builtins.property
    @pulumi.getter
    def wan1(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1Args']]:
        """
        WAN 1 settings.
        """
        return pulumi.get(self, "wan1")

    @wan1.setter
    def wan1(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1Args']]):
        pulumi.set(self, "wan1", value)

    @_builtins.property
    @pulumi.getter
    def wan2(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2Args']]:
        """
        WAN 2 settings.
        """
        return pulumi.get(self, "wan2")

    @wan2.setter
    def wan2(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2Args']]):
        pulumi.set(self, "wan2", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan1ArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable or disable the interface.
        """
        pppoe: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1PppoeArgsDict']]
        """
        Configuration options for PPPoE.
        """
        svis: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisArgsDict']]
        """
        SVI settings by protocol.
        """
        vlan_tagging: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1VlanTaggingArgsDict']]
        """
        VLAN tagging settings.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan1Args:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 pppoe: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1PppoeArgs']] = None,
                 svis: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisArgs']] = None,
                 vlan_tagging: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1VlanTaggingArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable or disable the interface.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan1PppoeArgs'] pppoe: Configuration options for PPPoE.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisArgs'] svis: SVI settings by protocol.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan1VlanTaggingArgs'] vlan_tagging: VLAN tagging settings.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if pppoe is not None:
            pulumi.set(__self__, "pppoe", pppoe)
        if svis is not None:
            pulumi.set(__self__, "svis", svis)
        if vlan_tagging is not None:
            pulumi.set(__self__, "vlan_tagging", vlan_tagging)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable or disable the interface.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def pppoe(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1PppoeArgs']]:
        """
        Configuration options for PPPoE.
        """
        return pulumi.get(self, "pppoe")

    @pppoe.setter
    def pppoe(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1PppoeArgs']]):
        pulumi.set(self, "pppoe", value)

    @_builtins.property
    @pulumi.getter
    def svis(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisArgs']]:
        """
        SVI settings by protocol.
        """
        return pulumi.get(self, "svis")

    @svis.setter
    def svis(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisArgs']]):
        pulumi.set(self, "svis", value)

    @_builtins.property
    @pulumi.getter(name="vlanTagging")
    def vlan_tagging(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1VlanTaggingArgs']]:
        """
        VLAN tagging settings.
        """
        return pulumi.get(self, "vlan_tagging")

    @vlan_tagging.setter
    def vlan_tagging(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1VlanTaggingArgs']]):
        pulumi.set(self, "vlan_tagging", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan1PppoeArgsDict(TypedDict):
        authentication: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1PppoeAuthenticationArgsDict']]
        """
        Settings for PPPoE Authentication.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether PPPoE is enabled.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan1PppoeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan1PppoeArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1PppoeAuthenticationArgs']] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan1PppoeAuthenticationArgs'] authentication: Settings for PPPoE Authentication.
        :param pulumi.Input[_builtins.bool] enabled: Whether PPPoE is enabled.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1PppoeAuthenticationArgs']]:
        """
        Settings for PPPoE Authentication.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1PppoeAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether PPPoE is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan1PppoeAuthenticationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether PPPoE authentication is enabled.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password for PPPoE authentication. This parameter is not returned.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        Username for PPPoE authentication.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan1PppoeAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan1PppoeAuthenticationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether PPPoE authentication is enabled.
        :param pulumi.Input[_builtins.str] password: Password for PPPoE authentication. This parameter is not returned.
        :param pulumi.Input[_builtins.str] username: Username for PPPoE authentication.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether PPPoE authentication is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password for PPPoE authentication. This parameter is not returned.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Username for PPPoE authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan1SvisArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv4ArgsDict']]
        """
        IPv4 settings for static/dynamic mode.
        """
        ipv6: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv6ArgsDict']]
        """
        IPv6 settings for static/dynamic mode.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan1SvisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan1SvisArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv6Args']] = None):
        """
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv4Args'] ipv4: IPv4 settings for static/dynamic mode.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv6Args'] ipv6: IPv6 settings for static/dynamic mode.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv4Args']]:
        """
        IPv4 settings for static/dynamic mode.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv6Args']]:
        """
        IPv6 settings for static/dynamic mode.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan1SvisIpv4ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address and subnet mask when in static mode.
        """
        assignment_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The assignment mode for this SVI. Applies only when PPPoE is disabled.
        """
        gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        Gateway IP address when in static mode.
        """
        nameservers: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv4NameserversArgsDict']]
        """
        The nameserver settings for this SVI.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan1SvisIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan1SvisIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 assignment_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 nameservers: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv4NameserversArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] address: IP address and subnet mask when in static mode.
        :param pulumi.Input[_builtins.str] assignment_mode: The assignment mode for this SVI. Applies only when PPPoE is disabled.
        :param pulumi.Input[_builtins.str] gateway: Gateway IP address when in static mode.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv4NameserversArgs'] nameservers: The nameserver settings for this SVI.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if assignment_mode is not None:
            pulumi.set(__self__, "assignment_mode", assignment_mode)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address and subnet mask when in static mode.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="assignmentMode")
    def assignment_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The assignment mode for this SVI. Applies only when PPPoE is disabled.
        """
        return pulumi.get(self, "assignment_mode")

    @assignment_mode.setter
    def assignment_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "assignment_mode", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Gateway IP address when in static mode.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def nameservers(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv4NameserversArgs']]:
        """
        The nameserver settings for this SVI.
        """
        return pulumi.get(self, "nameservers")

    @nameservers.setter
    def nameservers(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv4NameserversArgs']]):
        pulumi.set(self, "nameservers", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan1SvisIpv4NameserversArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan1SvisIpv4NameserversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan1SvisIpv4NameserversArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] addresses: Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan1SvisIpv6ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Static address that will override the one(s) received by SLAAC.
        """
        assignment_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The assignment mode for this SVI. Applies only when PPPoE is disabled.
        """
        gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        Static gateway that will override the one received by autoconf.
        """
        nameservers: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv6NameserversArgsDict']]
        """
        The nameserver settings for this SVI.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan1SvisIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan1SvisIpv6Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 assignment_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 nameservers: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv6NameserversArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] address: Static address that will override the one(s) received by SLAAC.
        :param pulumi.Input[_builtins.str] assignment_mode: The assignment mode for this SVI. Applies only when PPPoE is disabled.
        :param pulumi.Input[_builtins.str] gateway: Static gateway that will override the one received by autoconf.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv6NameserversArgs'] nameservers: The nameserver settings for this SVI.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if assignment_mode is not None:
            pulumi.set(__self__, "assignment_mode", assignment_mode)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Static address that will override the one(s) received by SLAAC.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="assignmentMode")
    def assignment_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The assignment mode for this SVI. Applies only when PPPoE is disabled.
        """
        return pulumi.get(self, "assignment_mode")

    @assignment_mode.setter
    def assignment_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "assignment_mode", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Static gateway that will override the one received by autoconf.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def nameservers(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv6NameserversArgs']]:
        """
        The nameserver settings for this SVI.
        """
        return pulumi.get(self, "nameservers")

    @nameservers.setter
    def nameservers(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan1SvisIpv6NameserversArgs']]):
        pulumi.set(self, "nameservers", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan1SvisIpv6NameserversArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan1SvisIpv6NameserversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan1SvisIpv6NameserversArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] addresses: Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan1VlanTaggingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether VLAN tagging is enabled.
        """
        vlan_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the VLAN to use for VLAN tagging.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan1VlanTaggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan1VlanTaggingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 vlan_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether VLAN tagging is enabled.
        :param pulumi.Input[_builtins.int] vlan_id: The ID of the VLAN to use for VLAN tagging.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether VLAN tagging is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the VLAN to use for VLAN tagging.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan2ArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable or disable the interface.
        """
        pppoe: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2PppoeArgsDict']]
        """
        Configuration options for PPPoE.
        """
        svis: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisArgsDict']]
        """
        SVI settings by protocol.
        """
        vlan_tagging: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2VlanTaggingArgsDict']]
        """
        VLAN tagging settings.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan2Args:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 pppoe: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2PppoeArgs']] = None,
                 svis: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisArgs']] = None,
                 vlan_tagging: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2VlanTaggingArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable or disable the interface.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan2PppoeArgs'] pppoe: Configuration options for PPPoE.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisArgs'] svis: SVI settings by protocol.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan2VlanTaggingArgs'] vlan_tagging: VLAN tagging settings.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if pppoe is not None:
            pulumi.set(__self__, "pppoe", pppoe)
        if svis is not None:
            pulumi.set(__self__, "svis", svis)
        if vlan_tagging is not None:
            pulumi.set(__self__, "vlan_tagging", vlan_tagging)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable or disable the interface.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def pppoe(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2PppoeArgs']]:
        """
        Configuration options for PPPoE.
        """
        return pulumi.get(self, "pppoe")

    @pppoe.setter
    def pppoe(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2PppoeArgs']]):
        pulumi.set(self, "pppoe", value)

    @_builtins.property
    @pulumi.getter
    def svis(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisArgs']]:
        """
        SVI settings by protocol.
        """
        return pulumi.get(self, "svis")

    @svis.setter
    def svis(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisArgs']]):
        pulumi.set(self, "svis", value)

    @_builtins.property
    @pulumi.getter(name="vlanTagging")
    def vlan_tagging(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2VlanTaggingArgs']]:
        """
        VLAN tagging settings.
        """
        return pulumi.get(self, "vlan_tagging")

    @vlan_tagging.setter
    def vlan_tagging(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2VlanTaggingArgs']]):
        pulumi.set(self, "vlan_tagging", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan2PppoeArgsDict(TypedDict):
        authentication: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2PppoeAuthenticationArgsDict']]
        """
        Settings for PPPoE Authentication.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether PPPoE is enabled.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan2PppoeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan2PppoeArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2PppoeAuthenticationArgs']] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan2PppoeAuthenticationArgs'] authentication: Settings for PPPoE Authentication.
        :param pulumi.Input[_builtins.bool] enabled: Whether PPPoE is enabled.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2PppoeAuthenticationArgs']]:
        """
        Settings for PPPoE Authentication.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2PppoeAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether PPPoE is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan2PppoeAuthenticationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether PPPoE authentication is enabled.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password for PPPoE authentication. This parameter is not returned.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        Username for PPPoE authentication.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan2PppoeAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan2PppoeAuthenticationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether PPPoE authentication is enabled.
        :param pulumi.Input[_builtins.str] password: Password for PPPoE authentication. This parameter is not returned.
        :param pulumi.Input[_builtins.str] username: Username for PPPoE authentication.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether PPPoE authentication is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password for PPPoE authentication. This parameter is not returned.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Username for PPPoE authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan2SvisArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv4ArgsDict']]
        """
        IPv4 settings for static/dynamic mode.
        """
        ipv6: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv6ArgsDict']]
        """
        IPv6 settings for static/dynamic mode.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan2SvisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan2SvisArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv6Args']] = None):
        """
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv4Args'] ipv4: IPv4 settings for static/dynamic mode.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv6Args'] ipv6: IPv6 settings for static/dynamic mode.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv4Args']]:
        """
        IPv4 settings for static/dynamic mode.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv6Args']]:
        """
        IPv6 settings for static/dynamic mode.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan2SvisIpv4ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address and subnet mask when in static mode.
        """
        assignment_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The assignment mode for this SVI. Applies only when PPPoE is disabled.
        """
        gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        Gateway IP address when in static mode.
        """
        nameservers: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv4NameserversArgsDict']]
        """
        The nameserver settings for this SVI.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan2SvisIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan2SvisIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 assignment_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 nameservers: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv4NameserversArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] address: IP address and subnet mask when in static mode.
        :param pulumi.Input[_builtins.str] assignment_mode: The assignment mode for this SVI. Applies only when PPPoE is disabled.
        :param pulumi.Input[_builtins.str] gateway: Gateway IP address when in static mode.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv4NameserversArgs'] nameservers: The nameserver settings for this SVI.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if assignment_mode is not None:
            pulumi.set(__self__, "assignment_mode", assignment_mode)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address and subnet mask when in static mode.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="assignmentMode")
    def assignment_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The assignment mode for this SVI. Applies only when PPPoE is disabled.
        """
        return pulumi.get(self, "assignment_mode")

    @assignment_mode.setter
    def assignment_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "assignment_mode", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Gateway IP address when in static mode.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def nameservers(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv4NameserversArgs']]:
        """
        The nameserver settings for this SVI.
        """
        return pulumi.get(self, "nameservers")

    @nameservers.setter
    def nameservers(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv4NameserversArgs']]):
        pulumi.set(self, "nameservers", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan2SvisIpv4NameserversArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan2SvisIpv4NameserversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan2SvisIpv4NameserversArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] addresses: Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan2SvisIpv6ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Static address that will override the one(s) received by SLAAC.
        """
        assignment_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The assignment mode for this SVI. Applies only when PPPoE is disabled.
        """
        gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        Static gateway that will override the one received by autoconf.
        """
        nameservers: NotRequired[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv6NameserversArgsDict']]
        """
        The nameserver settings for this SVI.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan2SvisIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan2SvisIpv6Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 assignment_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 nameservers: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv6NameserversArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] address: Static address that will override the one(s) received by SLAAC.
        :param pulumi.Input[_builtins.str] assignment_mode: The assignment mode for this SVI. Applies only when PPPoE is disabled.
        :param pulumi.Input[_builtins.str] gateway: Static gateway that will override the one received by autoconf.
        :param pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv6NameserversArgs'] nameservers: The nameserver settings for this SVI.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if assignment_mode is not None:
            pulumi.set(__self__, "assignment_mode", assignment_mode)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Static address that will override the one(s) received by SLAAC.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="assignmentMode")
    def assignment_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The assignment mode for this SVI. Applies only when PPPoE is disabled.
        """
        return pulumi.get(self, "assignment_mode")

    @assignment_mode.setter
    def assignment_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "assignment_mode", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Static gateway that will override the one received by autoconf.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def nameservers(self) -> Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv6NameserversArgs']]:
        """
        The nameserver settings for this SVI.
        """
        return pulumi.get(self, "nameservers")

    @nameservers.setter
    def nameservers(self, value: Optional[pulumi.Input['ApplianceUplinksSettingsInterfacesWan2SvisIpv6NameserversArgs']]):
        pulumi.set(self, "nameservers", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan2SvisIpv6NameserversArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan2SvisIpv6NameserversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan2SvisIpv6NameserversArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] addresses: Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class ApplianceUplinksSettingsInterfacesWan2VlanTaggingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether VLAN tagging is enabled.
        """
        vlan_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the VLAN to use for VLAN tagging.
        """
elif False:
    ApplianceUplinksSettingsInterfacesWan2VlanTaggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceUplinksSettingsInterfacesWan2VlanTaggingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 vlan_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether VLAN tagging is enabled.
        :param pulumi.Input[_builtins.int] vlan_id: The ID of the VLAN to use for VLAN tagging.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether VLAN tagging is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the VLAN to use for VLAN tagging.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class ApplianceVmxAuthenticationTokenItemArgsDict(TypedDict):
        expires_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expiration time for the token, in ISO 8601 format
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        The newly generated authentication token for the vMX instance
        """
elif False:
    ApplianceVmxAuthenticationTokenItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVmxAuthenticationTokenItemArgs:
    def __init__(__self__, *,
                 expires_at: Optional[pulumi.Input[_builtins.str]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expires_at: The expiration time for the token, in ISO 8601 format
        :param pulumi.Input[_builtins.str] token: The newly generated authentication token for the vMX instance
        """
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expiration time for the token, in ISO 8601 format
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expires_at", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The newly generated authentication token for the vMX instance
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class BlinkLedsItemArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration in seconds. Will be between 5 and 120. Default is 20 seconds
        """
        duty: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duty cycle as the percent active. Will be between 10 and 90. Default is 50
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        The period in milliseconds. Will be between 100 and 1000. Default is 160 milliseconds
        """
elif False:
    BlinkLedsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlinkLedsItemArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 duty: Optional[pulumi.Input[_builtins.int]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: The duration in seconds. Will be between 5 and 120. Default is 20 seconds
        :param pulumi.Input[_builtins.int] duty: The duty cycle as the percent active. Will be between 10 and 90. Default is 50
        :param pulumi.Input[_builtins.int] period: The period in milliseconds. Will be between 100 and 1000. Default is 160 milliseconds
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if duty is not None:
            pulumi.set(__self__, "duty", duty)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration in seconds. Will be between 5 and 120. Default is 20 seconds
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def duty(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duty cycle as the percent active. Will be between 10 and 90. Default is 50
        """
        return pulumi.get(self, "duty")

    @duty.setter
    def duty(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duty", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The period in milliseconds. Will be between 100 and 1000. Default is 160 milliseconds
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)


if not MYPY:
    class BlinkLedsParametersArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration in seconds. Must be between 5 and 120. Default is 20 seconds
        """
        duty: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duty cycle as the percent active. Must be between 10 and 90. Default is 50.
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        The period in milliseconds. Must be between 100 and 1000. Default is 160 milliseconds
        """
elif False:
    BlinkLedsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlinkLedsParametersArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 duty: Optional[pulumi.Input[_builtins.int]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: The duration in seconds. Must be between 5 and 120. Default is 20 seconds
        :param pulumi.Input[_builtins.int] duty: The duty cycle as the percent active. Must be between 10 and 90. Default is 50.
        :param pulumi.Input[_builtins.int] period: The period in milliseconds. Must be between 100 and 1000. Default is 160 milliseconds
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if duty is not None:
            pulumi.set(__self__, "duty", duty)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration in seconds. Must be between 5 and 120. Default is 20 seconds
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def duty(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duty cycle as the percent active. Must be between 10 and 90. Default is 50.
        """
        return pulumi.get(self, "duty")

    @duty.setter
    def duty(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duty", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The period in milliseconds. Must be between 100 and 1000. Default is 160 milliseconds
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)


if not MYPY:
    class CameraCustomAnalyticsParameterArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the parameter
        """
        value: NotRequired[pulumi.Input[_builtins.float]]
        """
        Value of the parameter
        """
elif False:
    CameraCustomAnalyticsParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraCustomAnalyticsParameterArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the parameter
        :param pulumi.Input[_builtins.float] value: Value of the parameter
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the parameter
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Value of the parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CameraGenerateSnapshotParametersArgsDict(TypedDict):
        fullframe: NotRequired[pulumi.Input[_builtins.bool]]
        """
        [optional] If set to "true" the snapshot will be taken at full sensor resolution. This will error if used with timestamp.
        """
        timestamp: NotRequired[pulumi.Input[_builtins.str]]
        """
        [optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time.
        """
elif False:
    CameraGenerateSnapshotParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraGenerateSnapshotParametersArgs:
    def __init__(__self__, *,
                 fullframe: Optional[pulumi.Input[_builtins.bool]] = None,
                 timestamp: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] fullframe: [optional] If set to "true" the snapshot will be taken at full sensor resolution. This will error if used with timestamp.
        :param pulumi.Input[_builtins.str] timestamp: [optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time.
        """
        if fullframe is not None:
            pulumi.set(__self__, "fullframe", fullframe)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter
    def fullframe(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        [optional] If set to "true" the snapshot will be taken at full sensor resolution. This will error if used with timestamp.
        """
        return pulumi.get(self, "fullframe")

    @fullframe.setter
    def fullframe(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fullframe", value)

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time.
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp", value)


if not MYPY:
    class CameraSenseAudioDetectionArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean indicating if audio detection is enabled(true) or disabled(false) on the camera
        """
elif False:
    CameraSenseAudioDetectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraSenseAudioDetectionArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Boolean indicating if audio detection is enabled(true) or disabled(false) on the camera
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean indicating if audio detection is enabled(true) or disabled(false) on the camera
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class CameraWirelessProfilesIdsArgsDict(TypedDict):
        backup: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the backup wireless profile
        """
        primary: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the primary wireless profile
        """
        secondary: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the secondary wireless profile
        """
elif False:
    CameraWirelessProfilesIdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraWirelessProfilesIdsArgs:
    def __init__(__self__, *,
                 backup: Optional[pulumi.Input[_builtins.str]] = None,
                 primary: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] backup: The id of the backup wireless profile
        :param pulumi.Input[_builtins.str] primary: The id of the primary wireless profile
        :param pulumi.Input[_builtins.str] secondary: The id of the secondary wireless profile
        """
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @_builtins.property
    @pulumi.getter
    def backup(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the backup wireless profile
        """
        return pulumi.get(self, "backup")

    @backup.setter
    def backup(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup", value)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the primary wireless profile
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the secondary wireless profile
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class CellularGatewayLanFixedIpAssignmentArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address you want to assign to a specific server or device
        """
        mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MAC address of the server or device that hosts the internal resource that you wish to receive the specified IP address
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A descriptive name of the assignment
        """
elif False:
    CellularGatewayLanFixedIpAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CellularGatewayLanFixedIpAssignmentArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 mac: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: The IP address you want to assign to a specific server or device
        :param pulumi.Input[_builtins.str] mac: The MAC address of the server or device that hosts the internal resource that you wish to receive the specified IP address
        :param pulumi.Input[_builtins.str] name: A descriptive name of the assignment
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address you want to assign to a specific server or device
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MAC address of the server or device that hosts the internal resource that you wish to receive the specified IP address
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A descriptive name of the assignment
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CellularGatewayLanReservedIpRangeArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment explaining the reserved IP range
        """
        end: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ending IP included in the reserved range of IPs
        """
        start: NotRequired[pulumi.Input[_builtins.str]]
        """
        Starting IP included in the reserved range of IPs
        """
elif False:
    CellularGatewayLanReservedIpRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CellularGatewayLanReservedIpRangeArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 end: Optional[pulumi.Input[_builtins.str]] = None,
                 start: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Comment explaining the reserved IP range
        :param pulumi.Input[_builtins.str] end: Ending IP included in the reserved range of IPs
        :param pulumi.Input[_builtins.str] start: Starting IP included in the reserved range of IPs
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment explaining the reserved IP range
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ending IP included in the reserved range of IPs
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Starting IP included in the reserved range of IPs
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class CellularGatewayPortForwardingRulesRuleArgsDict(TypedDict):
        access: NotRequired[pulumi.Input[_builtins.str]]
        """
        *any* or *restricted*. Specify the right to make inbound connections on the specified ports or port ranges. If *restricted*, a list of allowed IPs is mandatory.
        """
        allowed_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges.
        """
        lan_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        """
        local_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        A port or port ranges that will receive the forwarded traffic from the WAN
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A descriptive name for the rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        TCP or UDP
        """
        public_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        A port or port ranges that will be forwarded to the host on the LAN
        """
        uplink: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CellularGatewayPortForwardingRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CellularGatewayPortForwardingRulesRuleArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input[_builtins.str]] = None,
                 allowed_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 lan_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 local_port: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 public_port: Optional[pulumi.Input[_builtins.str]] = None,
                 uplink: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access: *any* or *restricted*. Specify the right to make inbound connections on the specified ports or port ranges. If *restricted*, a list of allowed IPs is mandatory.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ips: An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges.
        :param pulumi.Input[_builtins.str] lan_ip: The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        :param pulumi.Input[_builtins.str] local_port: A port or port ranges that will receive the forwarded traffic from the WAN
        :param pulumi.Input[_builtins.str] name: A descriptive name for the rule
        :param pulumi.Input[_builtins.str] protocol: TCP or UDP
        :param pulumi.Input[_builtins.str] public_port: A port or port ranges that will be forwarded to the host on the LAN
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if allowed_ips is not None:
            pulumi.set(__self__, "allowed_ips", allowed_ips)
        if lan_ip is not None:
            pulumi.set(__self__, "lan_ip", lan_ip)
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_port is not None:
            pulumi.set(__self__, "public_port", public_port)
        if uplink is not None:
            pulumi.set(__self__, "uplink", uplink)

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        *any* or *restricted*. Specify the right to make inbound connections on the specified ports or port ranges. If *restricted*, a list of allowed IPs is mandatory.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access", value)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges.
        """
        return pulumi.get(self, "allowed_ips")

    @allowed_ips.setter
    def allowed_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_ips", value)

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        """
        return pulumi.get(self, "lan_ip")

    @lan_ip.setter
    def lan_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lan_ip", value)

    @_builtins.property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A port or port ranges that will receive the forwarded traffic from the WAN
        """
        return pulumi.get(self, "local_port")

    @local_port.setter
    def local_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_port", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A descriptive name for the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        TCP or UDP
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="publicPort")
    def public_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A port or port ranges that will be forwarded to the host on the LAN
        """
        return pulumi.get(self, "public_port")

    @public_port.setter
    def public_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_port", value)

    @_builtins.property
    @pulumi.getter
    def uplink(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "uplink")

    @uplink.setter
    def uplink(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uplink", value)


if not MYPY:
    class CellularSimsSimArgsDict(TypedDict):
        apns: NotRequired[pulumi.Input[Sequence[pulumi.Input['CellularSimsSimApnArgsDict']]]]
        """
        APN configurations. If empty, the default APN will be used.
        """
        is_primary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, this SIM is used for boot. Must be true on single-sim devices.
        """
        slot: NotRequired[pulumi.Input[_builtins.str]]
        """
        SIM slot being configured. Must be 'sim1' on single-sim devices.
        """
elif False:
    CellularSimsSimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CellularSimsSimArgs:
    def __init__(__self__, *,
                 apns: Optional[pulumi.Input[Sequence[pulumi.Input['CellularSimsSimApnArgs']]]] = None,
                 is_primary: Optional[pulumi.Input[_builtins.bool]] = None,
                 slot: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CellularSimsSimApnArgs']]] apns: APN configurations. If empty, the default APN will be used.
        :param pulumi.Input[_builtins.bool] is_primary: If true, this SIM is used for boot. Must be true on single-sim devices.
        :param pulumi.Input[_builtins.str] slot: SIM slot being configured. Must be 'sim1' on single-sim devices.
        """
        if apns is not None:
            pulumi.set(__self__, "apns", apns)
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if slot is not None:
            pulumi.set(__self__, "slot", slot)

    @_builtins.property
    @pulumi.getter
    def apns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CellularSimsSimApnArgs']]]]:
        """
        APN configurations. If empty, the default APN will be used.
        """
        return pulumi.get(self, "apns")

    @apns.setter
    def apns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CellularSimsSimApnArgs']]]]):
        pulumi.set(self, "apns", value)

    @_builtins.property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, this SIM is used for boot. Must be true on single-sim devices.
        """
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_primary", value)

    @_builtins.property
    @pulumi.getter
    def slot(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SIM slot being configured. Must be 'sim1' on single-sim devices.
        """
        return pulumi.get(self, "slot")

    @slot.setter
    def slot(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "slot", value)


if not MYPY:
    class CellularSimsSimApnArgsDict(TypedDict):
        allowed_ip_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IP versions to support (permitted values include 'ipv4', 'ipv6').
        """
        authentication: NotRequired[pulumi.Input['CellularSimsSimApnAuthenticationArgsDict']]
        """
        APN authentication configurations.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        APN name.
        """
elif False:
    CellularSimsSimApnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CellularSimsSimApnArgs:
    def __init__(__self__, *,
                 allowed_ip_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 authentication: Optional[pulumi.Input['CellularSimsSimApnAuthenticationArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ip_types: IP versions to support (permitted values include 'ipv4', 'ipv6').
        :param pulumi.Input['CellularSimsSimApnAuthenticationArgs'] authentication: APN authentication configurations.
        :param pulumi.Input[_builtins.str] name: APN name.
        """
        if allowed_ip_types is not None:
            pulumi.set(__self__, "allowed_ip_types", allowed_ip_types)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="allowedIpTypes")
    def allowed_ip_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IP versions to support (permitted values include 'ipv4', 'ipv6').
        """
        return pulumi.get(self, "allowed_ip_types")

    @allowed_ip_types.setter
    def allowed_ip_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_ip_types", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['CellularSimsSimApnAuthenticationArgs']]:
        """
        APN authentication configurations.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['CellularSimsSimApnAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        APN name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CellularSimsSimApnAuthenticationArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        APN password, if type is set (if APN password is not supplied, the password is left unchanged).
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        APN auth type.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        APN username, if type is set.
        """
elif False:
    CellularSimsSimApnAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CellularSimsSimApnAuthenticationArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password: APN password, if type is set (if APN password is not supplied, the password is left unchanged).
        :param pulumi.Input[_builtins.str] type: APN auth type.
        :param pulumi.Input[_builtins.str] username: APN username, if type is set.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        APN password, if type is set (if APN password is not supplied, the password is left unchanged).
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        APN auth type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        APN username, if type is set.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class CellularSimsSimFailoverArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Failover to secondary SIM (optional)
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Failover timeout in seconds (optional)
        """
elif False:
    CellularSimsSimFailoverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CellularSimsSimFailoverArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Failover to secondary SIM (optional)
        :param pulumi.Input[_builtins.int] timeout: Failover timeout in seconds (optional)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Failover to secondary SIM (optional)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Failover timeout in seconds (optional)
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class LiveToolsArpTableCallbackArgsDict(TypedDict):
        http_server: NotRequired[pulumi.Input['LiveToolsArpTableCallbackHttpServerArgsDict']]
        """
        The webhook receiver used for the callback webhook.
        """
        payload_template: NotRequired[pulumi.Input['LiveToolsArpTableCallbackPayloadTemplateArgsDict']]
        """
        The payload template of the webhook used for the callback
        """
        shared_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
elif False:
    LiveToolsArpTableCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsArpTableCallbackArgs:
    def __init__(__self__, *,
                 http_server: Optional[pulumi.Input['LiveToolsArpTableCallbackHttpServerArgs']] = None,
                 payload_template: Optional[pulumi.Input['LiveToolsArpTableCallbackPayloadTemplateArgs']] = None,
                 shared_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LiveToolsArpTableCallbackHttpServerArgs'] http_server: The webhook receiver used for the callback webhook.
        :param pulumi.Input['LiveToolsArpTableCallbackPayloadTemplateArgs'] payload_template: The payload template of the webhook used for the callback
        :param pulumi.Input[_builtins.str] shared_secret: A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        :param pulumi.Input[_builtins.str] url: The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
        if http_server is not None:
            pulumi.set(__self__, "http_server", http_server)
        if payload_template is not None:
            pulumi.set(__self__, "payload_template", payload_template)
        if shared_secret is not None:
            pulumi.set(__self__, "shared_secret", shared_secret)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="httpServer")
    def http_server(self) -> Optional[pulumi.Input['LiveToolsArpTableCallbackHttpServerArgs']]:
        """
        The webhook receiver used for the callback webhook.
        """
        return pulumi.get(self, "http_server")

    @http_server.setter
    def http_server(self, value: Optional[pulumi.Input['LiveToolsArpTableCallbackHttpServerArgs']]):
        pulumi.set(self, "http_server", value)

    @_builtins.property
    @pulumi.getter(name="payloadTemplate")
    def payload_template(self) -> Optional[pulumi.Input['LiveToolsArpTableCallbackPayloadTemplateArgs']]:
        """
        The payload template of the webhook used for the callback
        """
        return pulumi.get(self, "payload_template")

    @payload_template.setter
    def payload_template(self, value: Optional[pulumi.Input['LiveToolsArpTableCallbackPayloadTemplateArgs']]):
        pulumi.set(self, "payload_template", value)

    @_builtins.property
    @pulumi.getter(name="sharedSecret")
    def shared_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        return pulumi.get(self, "shared_secret")

    @shared_secret.setter
    def shared_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shared_secret", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class LiveToolsArpTableCallbackHttpServerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
elif False:
    LiveToolsArpTableCallbackHttpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsArpTableCallbackHttpServerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LiveToolsArpTableCallbackPayloadTemplateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
elif False:
    LiveToolsArpTableCallbackPayloadTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsArpTableCallbackPayloadTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LiveToolsArpTableEntryArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the ARP table entry
        """
        last_updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time of the last update of the ARP table entry
        """
        mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MAC address of the ARP table entry
        """
        vlan_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The VLAN ID of the ARP table entry
        """
elif False:
    LiveToolsArpTableEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsArpTableEntryArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 last_updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 mac: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: The IP address of the ARP table entry
        :param pulumi.Input[_builtins.str] last_updated_at: Time of the last update of the ARP table entry
        :param pulumi.Input[_builtins.str] mac: The MAC address of the ARP table entry
        :param pulumi.Input[_builtins.int] vlan_id: The VLAN ID of the ARP table entry
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if last_updated_at is not None:
            pulumi.set(__self__, "last_updated_at", last_updated_at)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the ARP table entry
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="lastUpdatedAt")
    def last_updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time of the last update of the ARP table entry
        """
        return pulumi.get(self, "last_updated_at")

    @last_updated_at.setter
    def last_updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_updated_at", value)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MAC address of the ARP table entry
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac", value)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The VLAN ID of the ARP table entry
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class LiveToolsArpTableRequestArgsDict(TypedDict):
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device serial number
        """
elif False:
    LiveToolsArpTableRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsArpTableRequestArgs:
    def __init__(__self__, *,
                 serial: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] serial: Device serial number
        """
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device serial number
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)


if not MYPY:
    class LiveToolsCableCallbackArgsDict(TypedDict):
        http_server: NotRequired[pulumi.Input['LiveToolsCableCallbackHttpServerArgsDict']]
        """
        The webhook receiver used for the callback webhook.
        """
        payload_template: NotRequired[pulumi.Input['LiveToolsCableCallbackPayloadTemplateArgsDict']]
        """
        The payload template of the webhook used for the callback
        """
        shared_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
elif False:
    LiveToolsCableCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsCableCallbackArgs:
    def __init__(__self__, *,
                 http_server: Optional[pulumi.Input['LiveToolsCableCallbackHttpServerArgs']] = None,
                 payload_template: Optional[pulumi.Input['LiveToolsCableCallbackPayloadTemplateArgs']] = None,
                 shared_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LiveToolsCableCallbackHttpServerArgs'] http_server: The webhook receiver used for the callback webhook.
        :param pulumi.Input['LiveToolsCableCallbackPayloadTemplateArgs'] payload_template: The payload template of the webhook used for the callback
        :param pulumi.Input[_builtins.str] shared_secret: A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        :param pulumi.Input[_builtins.str] url: The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
        if http_server is not None:
            pulumi.set(__self__, "http_server", http_server)
        if payload_template is not None:
            pulumi.set(__self__, "payload_template", payload_template)
        if shared_secret is not None:
            pulumi.set(__self__, "shared_secret", shared_secret)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="httpServer")
    def http_server(self) -> Optional[pulumi.Input['LiveToolsCableCallbackHttpServerArgs']]:
        """
        The webhook receiver used for the callback webhook.
        """
        return pulumi.get(self, "http_server")

    @http_server.setter
    def http_server(self, value: Optional[pulumi.Input['LiveToolsCableCallbackHttpServerArgs']]):
        pulumi.set(self, "http_server", value)

    @_builtins.property
    @pulumi.getter(name="payloadTemplate")
    def payload_template(self) -> Optional[pulumi.Input['LiveToolsCableCallbackPayloadTemplateArgs']]:
        """
        The payload template of the webhook used for the callback
        """
        return pulumi.get(self, "payload_template")

    @payload_template.setter
    def payload_template(self, value: Optional[pulumi.Input['LiveToolsCableCallbackPayloadTemplateArgs']]):
        pulumi.set(self, "payload_template", value)

    @_builtins.property
    @pulumi.getter(name="sharedSecret")
    def shared_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        return pulumi.get(self, "shared_secret")

    @shared_secret.setter
    def shared_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shared_secret", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class LiveToolsCableCallbackHttpServerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
elif False:
    LiveToolsCableCallbackHttpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsCableCallbackHttpServerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LiveToolsCableCallbackPayloadTemplateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
elif False:
    LiveToolsCableCallbackPayloadTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsCableCallbackPayloadTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LiveToolsCableRequestArgsDict(TypedDict):
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of ports for which to perform the cable test.
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device serial number
        """
elif False:
    LiveToolsCableRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsCableRequestArgs:
    def __init__(__self__, *,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ports: A list of ports for which to perform the cable test.
        :param pulumi.Input[_builtins.str] serial: Device serial number
        """
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of ports for which to perform the cable test.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device serial number
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)


if not MYPY:
    class LiveToolsCableResultArgsDict(TypedDict):
        error: NotRequired[pulumi.Input[_builtins.str]]
        """
        If an error occurred during the cable test, the error message will be populated here.
        """
        pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['LiveToolsCableResultPairArgsDict']]]]
        """
        Results for each twisted pair within the cable.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port for which the test was performed.
        """
        speed_mbps: NotRequired[pulumi.Input[_builtins.int]]
        """
        Speed in Mbps.  A speed of 0 indicates the port is down or the port speed is automatic.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current status of the port. If the cable test is still being performed on the port, "in-progress" is used. If an error occurred during the cable test, "error" is used and the error property will be populated.
        """
elif False:
    LiveToolsCableResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsCableResultArgs:
    def __init__(__self__, *,
                 error: Optional[pulumi.Input[_builtins.str]] = None,
                 pairs: Optional[pulumi.Input[Sequence[pulumi.Input['LiveToolsCableResultPairArgs']]]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 speed_mbps: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] error: If an error occurred during the cable test, the error message will be populated here.
        :param pulumi.Input[Sequence[pulumi.Input['LiveToolsCableResultPairArgs']]] pairs: Results for each twisted pair within the cable.
        :param pulumi.Input[_builtins.str] port: The port for which the test was performed.
        :param pulumi.Input[_builtins.int] speed_mbps: Speed in Mbps.  A speed of 0 indicates the port is down or the port speed is automatic.
        :param pulumi.Input[_builtins.str] status: The current status of the port. If the cable test is still being performed on the port, "in-progress" is used. If an error occurred during the cable test, "error" is used and the error property will be populated.
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if pairs is not None:
            pulumi.set(__self__, "pairs", pairs)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if speed_mbps is not None:
            pulumi.set(__self__, "speed_mbps", speed_mbps)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If an error occurred during the cable test, the error message will be populated here.
        """
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error", value)

    @_builtins.property
    @pulumi.getter
    def pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LiveToolsCableResultPairArgs']]]]:
        """
        Results for each twisted pair within the cable.
        """
        return pulumi.get(self, "pairs")

    @pairs.setter
    def pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LiveToolsCableResultPairArgs']]]]):
        pulumi.set(self, "pairs", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port for which the test was performed.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="speedMbps")
    def speed_mbps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Speed in Mbps.  A speed of 0 indicates the port is down or the port speed is automatic.
        """
        return pulumi.get(self, "speed_mbps")

    @speed_mbps.setter
    def speed_mbps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "speed_mbps", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current status of the port. If the cable test is still being performed on the port, "in-progress" is used. If an error occurred during the cable test, "error" is used and the error property will be populated.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class LiveToolsCableResultPairArgsDict(TypedDict):
        index: NotRequired[pulumi.Input[_builtins.int]]
        """
        The index of the twisted pair tested.
        """
        length_meters: NotRequired[pulumi.Input[_builtins.int]]
        """
        The detected length of the twisted pair.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The test result of the twisted pair tested.
        """
elif False:
    LiveToolsCableResultPairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsCableResultPairArgs:
    def __init__(__self__, *,
                 index: Optional[pulumi.Input[_builtins.int]] = None,
                 length_meters: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] index: The index of the twisted pair tested.
        :param pulumi.Input[_builtins.int] length_meters: The detected length of the twisted pair.
        :param pulumi.Input[_builtins.str] status: The test result of the twisted pair tested.
        """
        if index is not None:
            pulumi.set(__self__, "index", index)
        if length_meters is not None:
            pulumi.set(__self__, "length_meters", length_meters)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The index of the twisted pair tested.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter(name="lengthMeters")
    def length_meters(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The detected length of the twisted pair.
        """
        return pulumi.get(self, "length_meters")

    @length_meters.setter
    def length_meters(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "length_meters", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The test result of the twisted pair tested.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class LiveToolsPingDeviceItemArgsDict(TypedDict):
        callback: NotRequired[pulumi.Input['LiveToolsPingDeviceItemCallbackArgsDict']]
        """
        Information for callback used to send back results
        """
        ping_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id to check the status of your ping request.
        """
        request: NotRequired[pulumi.Input['LiveToolsPingDeviceItemRequestArgsDict']]
        """
        Ping request parameters
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the ping request.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        GET this url to check the status of your ping request.
        """
elif False:
    LiveToolsPingDeviceItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingDeviceItemArgs:
    def __init__(__self__, *,
                 callback: Optional[pulumi.Input['LiveToolsPingDeviceItemCallbackArgs']] = None,
                 ping_id: Optional[pulumi.Input[_builtins.str]] = None,
                 request: Optional[pulumi.Input['LiveToolsPingDeviceItemRequestArgs']] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LiveToolsPingDeviceItemCallbackArgs'] callback: Information for callback used to send back results
        :param pulumi.Input[_builtins.str] ping_id: Id to check the status of your ping request.
        :param pulumi.Input['LiveToolsPingDeviceItemRequestArgs'] request: Ping request parameters
        :param pulumi.Input[_builtins.str] status: Status of the ping request.
        :param pulumi.Input[_builtins.str] url: GET this url to check the status of your ping request.
        """
        if callback is not None:
            pulumi.set(__self__, "callback", callback)
        if ping_id is not None:
            pulumi.set(__self__, "ping_id", ping_id)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def callback(self) -> Optional[pulumi.Input['LiveToolsPingDeviceItemCallbackArgs']]:
        """
        Information for callback used to send back results
        """
        return pulumi.get(self, "callback")

    @callback.setter
    def callback(self, value: Optional[pulumi.Input['LiveToolsPingDeviceItemCallbackArgs']]):
        pulumi.set(self, "callback", value)

    @_builtins.property
    @pulumi.getter(name="pingId")
    def ping_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id to check the status of your ping request.
        """
        return pulumi.get(self, "ping_id")

    @ping_id.setter
    def ping_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ping_id", value)

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['LiveToolsPingDeviceItemRequestArgs']]:
        """
        Ping request parameters
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['LiveToolsPingDeviceItemRequestArgs']]):
        pulumi.set(self, "request", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the ping request.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        GET this url to check the status of your ping request.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class LiveToolsPingDeviceItemCallbackArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the callback
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
        """
elif False:
    LiveToolsPingDeviceItemCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingDeviceItemCallbackArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
        :param pulumi.Input[_builtins.str] status: The status of the callback
        :param pulumi.Input[_builtins.str] url: The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the callback
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class LiveToolsPingDeviceItemRequestArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of pings to send
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device serial number
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address or FQDN to ping
        """
elif False:
    LiveToolsPingDeviceItemRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingDeviceItemRequestArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Number of pings to send
        :param pulumi.Input[_builtins.str] serial: Device serial number
        :param pulumi.Input[_builtins.str] target: IP address or FQDN to ping
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of pings to send
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device serial number
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address or FQDN to ping
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class LiveToolsPingDeviceParametersArgsDict(TypedDict):
        callback: NotRequired[pulumi.Input['LiveToolsPingDeviceParametersCallbackArgsDict']]
        """
        Details for the callback. Please include either an httpServerId OR url and sharedSecret
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Count parameter to pass to ping. [1..5], default 5
        """
elif False:
    LiveToolsPingDeviceParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingDeviceParametersArgs:
    def __init__(__self__, *,
                 callback: Optional[pulumi.Input['LiveToolsPingDeviceParametersCallbackArgs']] = None,
                 count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['LiveToolsPingDeviceParametersCallbackArgs'] callback: Details for the callback. Please include either an httpServerId OR url and sharedSecret
        :param pulumi.Input[_builtins.int] count: Count parameter to pass to ping. [1..5], default 5
        """
        if callback is not None:
            pulumi.set(__self__, "callback", callback)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def callback(self) -> Optional[pulumi.Input['LiveToolsPingDeviceParametersCallbackArgs']]:
        """
        Details for the callback. Please include either an httpServerId OR url and sharedSecret
        """
        return pulumi.get(self, "callback")

    @callback.setter
    def callback(self, value: Optional[pulumi.Input['LiveToolsPingDeviceParametersCallbackArgs']]):
        pulumi.set(self, "callback", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Count parameter to pass to ping. [1..5], default 5
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class LiveToolsPingDeviceParametersCallbackArgsDict(TypedDict):
        http_server: NotRequired[pulumi.Input['LiveToolsPingDeviceParametersCallbackHttpServerArgsDict']]
        """
        The webhook receiver used for the callback webhook.
        """
        payload_template: NotRequired[pulumi.Input['LiveToolsPingDeviceParametersCallbackPayloadTemplateArgsDict']]
        """
        The payload template of the webhook used for the callback
        """
        shared_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
elif False:
    LiveToolsPingDeviceParametersCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingDeviceParametersCallbackArgs:
    def __init__(__self__, *,
                 http_server: Optional[pulumi.Input['LiveToolsPingDeviceParametersCallbackHttpServerArgs']] = None,
                 payload_template: Optional[pulumi.Input['LiveToolsPingDeviceParametersCallbackPayloadTemplateArgs']] = None,
                 shared_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LiveToolsPingDeviceParametersCallbackHttpServerArgs'] http_server: The webhook receiver used for the callback webhook.
        :param pulumi.Input['LiveToolsPingDeviceParametersCallbackPayloadTemplateArgs'] payload_template: The payload template of the webhook used for the callback
        :param pulumi.Input[_builtins.str] shared_secret: A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        :param pulumi.Input[_builtins.str] url: The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
        if http_server is not None:
            pulumi.set(__self__, "http_server", http_server)
        if payload_template is not None:
            pulumi.set(__self__, "payload_template", payload_template)
        if shared_secret is not None:
            pulumi.set(__self__, "shared_secret", shared_secret)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="httpServer")
    def http_server(self) -> Optional[pulumi.Input['LiveToolsPingDeviceParametersCallbackHttpServerArgs']]:
        """
        The webhook receiver used for the callback webhook.
        """
        return pulumi.get(self, "http_server")

    @http_server.setter
    def http_server(self, value: Optional[pulumi.Input['LiveToolsPingDeviceParametersCallbackHttpServerArgs']]):
        pulumi.set(self, "http_server", value)

    @_builtins.property
    @pulumi.getter(name="payloadTemplate")
    def payload_template(self) -> Optional[pulumi.Input['LiveToolsPingDeviceParametersCallbackPayloadTemplateArgs']]:
        """
        The payload template of the webhook used for the callback
        """
        return pulumi.get(self, "payload_template")

    @payload_template.setter
    def payload_template(self, value: Optional[pulumi.Input['LiveToolsPingDeviceParametersCallbackPayloadTemplateArgs']]):
        pulumi.set(self, "payload_template", value)

    @_builtins.property
    @pulumi.getter(name="sharedSecret")
    def shared_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        return pulumi.get(self, "shared_secret")

    @shared_secret.setter
    def shared_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shared_secret", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class LiveToolsPingDeviceParametersCallbackHttpServerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
elif False:
    LiveToolsPingDeviceParametersCallbackHttpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingDeviceParametersCallbackHttpServerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LiveToolsPingDeviceParametersCallbackPayloadTemplateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
elif False:
    LiveToolsPingDeviceParametersCallbackPayloadTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingDeviceParametersCallbackPayloadTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LiveToolsPingItemArgsDict(TypedDict):
        callback: NotRequired[pulumi.Input['LiveToolsPingItemCallbackArgsDict']]
        """
        Information for callback used to send back results
        """
        ping_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id to check the status of your ping request.
        """
        request: NotRequired[pulumi.Input['LiveToolsPingItemRequestArgsDict']]
        """
        Ping request parameters
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the ping request.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        GET this url to check the status of your ping request.
        """
elif False:
    LiveToolsPingItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingItemArgs:
    def __init__(__self__, *,
                 callback: Optional[pulumi.Input['LiveToolsPingItemCallbackArgs']] = None,
                 ping_id: Optional[pulumi.Input[_builtins.str]] = None,
                 request: Optional[pulumi.Input['LiveToolsPingItemRequestArgs']] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LiveToolsPingItemCallbackArgs'] callback: Information for callback used to send back results
        :param pulumi.Input[_builtins.str] ping_id: Id to check the status of your ping request.
        :param pulumi.Input['LiveToolsPingItemRequestArgs'] request: Ping request parameters
        :param pulumi.Input[_builtins.str] status: Status of the ping request.
        :param pulumi.Input[_builtins.str] url: GET this url to check the status of your ping request.
        """
        if callback is not None:
            pulumi.set(__self__, "callback", callback)
        if ping_id is not None:
            pulumi.set(__self__, "ping_id", ping_id)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def callback(self) -> Optional[pulumi.Input['LiveToolsPingItemCallbackArgs']]:
        """
        Information for callback used to send back results
        """
        return pulumi.get(self, "callback")

    @callback.setter
    def callback(self, value: Optional[pulumi.Input['LiveToolsPingItemCallbackArgs']]):
        pulumi.set(self, "callback", value)

    @_builtins.property
    @pulumi.getter(name="pingId")
    def ping_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id to check the status of your ping request.
        """
        return pulumi.get(self, "ping_id")

    @ping_id.setter
    def ping_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ping_id", value)

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['LiveToolsPingItemRequestArgs']]:
        """
        Ping request parameters
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['LiveToolsPingItemRequestArgs']]):
        pulumi.set(self, "request", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the ping request.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        GET this url to check the status of your ping request.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class LiveToolsPingItemCallbackArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the callback
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
        """
elif False:
    LiveToolsPingItemCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingItemCallbackArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
        :param pulumi.Input[_builtins.str] status: The status of the callback
        :param pulumi.Input[_builtins.str] url: The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the callback
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class LiveToolsPingItemRequestArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of pings to send
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device serial number
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address or FQDN to ping
        """
elif False:
    LiveToolsPingItemRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingItemRequestArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Number of pings to send
        :param pulumi.Input[_builtins.str] serial: Device serial number
        :param pulumi.Input[_builtins.str] target: IP address or FQDN to ping
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of pings to send
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device serial number
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address or FQDN to ping
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class LiveToolsPingParametersArgsDict(TypedDict):
        callback: NotRequired[pulumi.Input['LiveToolsPingParametersCallbackArgsDict']]
        """
        Details for the callback. Please include either an httpServerId OR url and sharedSecret
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Count parameter to pass to ping. [1..5], default 5
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        FQDN, IPv4 or IPv6 address
        """
elif False:
    LiveToolsPingParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingParametersArgs:
    def __init__(__self__, *,
                 callback: Optional[pulumi.Input['LiveToolsPingParametersCallbackArgs']] = None,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LiveToolsPingParametersCallbackArgs'] callback: Details for the callback. Please include either an httpServerId OR url and sharedSecret
        :param pulumi.Input[_builtins.int] count: Count parameter to pass to ping. [1..5], default 5
        :param pulumi.Input[_builtins.str] target: FQDN, IPv4 or IPv6 address
        """
        if callback is not None:
            pulumi.set(__self__, "callback", callback)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def callback(self) -> Optional[pulumi.Input['LiveToolsPingParametersCallbackArgs']]:
        """
        Details for the callback. Please include either an httpServerId OR url and sharedSecret
        """
        return pulumi.get(self, "callback")

    @callback.setter
    def callback(self, value: Optional[pulumi.Input['LiveToolsPingParametersCallbackArgs']]):
        pulumi.set(self, "callback", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Count parameter to pass to ping. [1..5], default 5
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        FQDN, IPv4 or IPv6 address
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class LiveToolsPingParametersCallbackArgsDict(TypedDict):
        http_server: NotRequired[pulumi.Input['LiveToolsPingParametersCallbackHttpServerArgsDict']]
        """
        The webhook receiver used for the callback webhook.
        """
        payload_template: NotRequired[pulumi.Input['LiveToolsPingParametersCallbackPayloadTemplateArgsDict']]
        """
        The payload template of the webhook used for the callback
        """
        shared_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
elif False:
    LiveToolsPingParametersCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingParametersCallbackArgs:
    def __init__(__self__, *,
                 http_server: Optional[pulumi.Input['LiveToolsPingParametersCallbackHttpServerArgs']] = None,
                 payload_template: Optional[pulumi.Input['LiveToolsPingParametersCallbackPayloadTemplateArgs']] = None,
                 shared_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LiveToolsPingParametersCallbackHttpServerArgs'] http_server: The webhook receiver used for the callback webhook.
        :param pulumi.Input['LiveToolsPingParametersCallbackPayloadTemplateArgs'] payload_template: The payload template of the webhook used for the callback
        :param pulumi.Input[_builtins.str] shared_secret: A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        :param pulumi.Input[_builtins.str] url: The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
        if http_server is not None:
            pulumi.set(__self__, "http_server", http_server)
        if payload_template is not None:
            pulumi.set(__self__, "payload_template", payload_template)
        if shared_secret is not None:
            pulumi.set(__self__, "shared_secret", shared_secret)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="httpServer")
    def http_server(self) -> Optional[pulumi.Input['LiveToolsPingParametersCallbackHttpServerArgs']]:
        """
        The webhook receiver used for the callback webhook.
        """
        return pulumi.get(self, "http_server")

    @http_server.setter
    def http_server(self, value: Optional[pulumi.Input['LiveToolsPingParametersCallbackHttpServerArgs']]):
        pulumi.set(self, "http_server", value)

    @_builtins.property
    @pulumi.getter(name="payloadTemplate")
    def payload_template(self) -> Optional[pulumi.Input['LiveToolsPingParametersCallbackPayloadTemplateArgs']]:
        """
        The payload template of the webhook used for the callback
        """
        return pulumi.get(self, "payload_template")

    @payload_template.setter
    def payload_template(self, value: Optional[pulumi.Input['LiveToolsPingParametersCallbackPayloadTemplateArgs']]):
        pulumi.set(self, "payload_template", value)

    @_builtins.property
    @pulumi.getter(name="sharedSecret")
    def shared_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        return pulumi.get(self, "shared_secret")

    @shared_secret.setter
    def shared_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shared_secret", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class LiveToolsPingParametersCallbackHttpServerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
elif False:
    LiveToolsPingParametersCallbackHttpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingParametersCallbackHttpServerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LiveToolsPingParametersCallbackPayloadTemplateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
elif False:
    LiveToolsPingParametersCallbackPayloadTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsPingParametersCallbackPayloadTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LiveToolsThroughputTestCallbackArgsDict(TypedDict):
        http_server: NotRequired[pulumi.Input['LiveToolsThroughputTestCallbackHttpServerArgsDict']]
        """
        The webhook receiver used for the callback webhook.
        """
        payload_template: NotRequired[pulumi.Input['LiveToolsThroughputTestCallbackPayloadTemplateArgsDict']]
        """
        The payload template of the webhook used for the callback
        """
        shared_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
elif False:
    LiveToolsThroughputTestCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsThroughputTestCallbackArgs:
    def __init__(__self__, *,
                 http_server: Optional[pulumi.Input['LiveToolsThroughputTestCallbackHttpServerArgs']] = None,
                 payload_template: Optional[pulumi.Input['LiveToolsThroughputTestCallbackPayloadTemplateArgs']] = None,
                 shared_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LiveToolsThroughputTestCallbackHttpServerArgs'] http_server: The webhook receiver used for the callback webhook.
        :param pulumi.Input['LiveToolsThroughputTestCallbackPayloadTemplateArgs'] payload_template: The payload template of the webhook used for the callback
        :param pulumi.Input[_builtins.str] shared_secret: A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        :param pulumi.Input[_builtins.str] url: The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
        if http_server is not None:
            pulumi.set(__self__, "http_server", http_server)
        if payload_template is not None:
            pulumi.set(__self__, "payload_template", payload_template)
        if shared_secret is not None:
            pulumi.set(__self__, "shared_secret", shared_secret)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="httpServer")
    def http_server(self) -> Optional[pulumi.Input['LiveToolsThroughputTestCallbackHttpServerArgs']]:
        """
        The webhook receiver used for the callback webhook.
        """
        return pulumi.get(self, "http_server")

    @http_server.setter
    def http_server(self, value: Optional[pulumi.Input['LiveToolsThroughputTestCallbackHttpServerArgs']]):
        pulumi.set(self, "http_server", value)

    @_builtins.property
    @pulumi.getter(name="payloadTemplate")
    def payload_template(self) -> Optional[pulumi.Input['LiveToolsThroughputTestCallbackPayloadTemplateArgs']]:
        """
        The payload template of the webhook used for the callback
        """
        return pulumi.get(self, "payload_template")

    @payload_template.setter
    def payload_template(self, value: Optional[pulumi.Input['LiveToolsThroughputTestCallbackPayloadTemplateArgs']]):
        pulumi.set(self, "payload_template", value)

    @_builtins.property
    @pulumi.getter(name="sharedSecret")
    def shared_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        return pulumi.get(self, "shared_secret")

    @shared_secret.setter
    def shared_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shared_secret", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class LiveToolsThroughputTestCallbackHttpServerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
elif False:
    LiveToolsThroughputTestCallbackHttpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsThroughputTestCallbackHttpServerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LiveToolsThroughputTestCallbackPayloadTemplateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
elif False:
    LiveToolsThroughputTestCallbackPayloadTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsThroughputTestCallbackPayloadTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LiveToolsThroughputTestRequestArgsDict(TypedDict):
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device serial number
        """
elif False:
    LiveToolsThroughputTestRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsThroughputTestRequestArgs:
    def __init__(__self__, *,
                 serial: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] serial: Device serial number
        """
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device serial number
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)


if not MYPY:
    class LiveToolsThroughputTestResultArgsDict(TypedDict):
        speeds: NotRequired[pulumi.Input['LiveToolsThroughputTestResultSpeedsArgsDict']]
        """
        Shows the speeds (Mbps)
        """
elif False:
    LiveToolsThroughputTestResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsThroughputTestResultArgs:
    def __init__(__self__, *,
                 speeds: Optional[pulumi.Input['LiveToolsThroughputTestResultSpeedsArgs']] = None):
        """
        :param pulumi.Input['LiveToolsThroughputTestResultSpeedsArgs'] speeds: Shows the speeds (Mbps)
        """
        if speeds is not None:
            pulumi.set(__self__, "speeds", speeds)

    @_builtins.property
    @pulumi.getter
    def speeds(self) -> Optional[pulumi.Input['LiveToolsThroughputTestResultSpeedsArgs']]:
        """
        Shows the speeds (Mbps)
        """
        return pulumi.get(self, "speeds")

    @speeds.setter
    def speeds(self, value: Optional[pulumi.Input['LiveToolsThroughputTestResultSpeedsArgs']]):
        pulumi.set(self, "speeds", value)


if not MYPY:
    class LiveToolsThroughputTestResultSpeedsArgsDict(TypedDict):
        downstream: NotRequired[pulumi.Input[_builtins.int]]
        """
        Shows the download speed from shard (Mbps)
        """
elif False:
    LiveToolsThroughputTestResultSpeedsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsThroughputTestResultSpeedsArgs:
    def __init__(__self__, *,
                 downstream: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] downstream: Shows the download speed from shard (Mbps)
        """
        if downstream is not None:
            pulumi.set(__self__, "downstream", downstream)

    @_builtins.property
    @pulumi.getter
    def downstream(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Shows the download speed from shard (Mbps)
        """
        return pulumi.get(self, "downstream")

    @downstream.setter
    def downstream(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "downstream", value)


if not MYPY:
    class LiveToolsWakeOnLanCallbackArgsDict(TypedDict):
        http_server: NotRequired[pulumi.Input['LiveToolsWakeOnLanCallbackHttpServerArgsDict']]
        """
        The webhook receiver used for the callback webhook.
        """
        payload_template: NotRequired[pulumi.Input['LiveToolsWakeOnLanCallbackPayloadTemplateArgsDict']]
        """
        The payload template of the webhook used for the callback
        """
        shared_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
elif False:
    LiveToolsWakeOnLanCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsWakeOnLanCallbackArgs:
    def __init__(__self__, *,
                 http_server: Optional[pulumi.Input['LiveToolsWakeOnLanCallbackHttpServerArgs']] = None,
                 payload_template: Optional[pulumi.Input['LiveToolsWakeOnLanCallbackPayloadTemplateArgs']] = None,
                 shared_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LiveToolsWakeOnLanCallbackHttpServerArgs'] http_server: The webhook receiver used for the callback webhook.
        :param pulumi.Input['LiveToolsWakeOnLanCallbackPayloadTemplateArgs'] payload_template: The payload template of the webhook used for the callback
        :param pulumi.Input[_builtins.str] shared_secret: A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        :param pulumi.Input[_builtins.str] url: The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
        if http_server is not None:
            pulumi.set(__self__, "http_server", http_server)
        if payload_template is not None:
            pulumi.set(__self__, "payload_template", payload_template)
        if shared_secret is not None:
            pulumi.set(__self__, "shared_secret", shared_secret)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="httpServer")
    def http_server(self) -> Optional[pulumi.Input['LiveToolsWakeOnLanCallbackHttpServerArgs']]:
        """
        The webhook receiver used for the callback webhook.
        """
        return pulumi.get(self, "http_server")

    @http_server.setter
    def http_server(self, value: Optional[pulumi.Input['LiveToolsWakeOnLanCallbackHttpServerArgs']]):
        pulumi.set(self, "http_server", value)

    @_builtins.property
    @pulumi.getter(name="payloadTemplate")
    def payload_template(self) -> Optional[pulumi.Input['LiveToolsWakeOnLanCallbackPayloadTemplateArgs']]:
        """
        The payload template of the webhook used for the callback
        """
        return pulumi.get(self, "payload_template")

    @payload_template.setter
    def payload_template(self, value: Optional[pulumi.Input['LiveToolsWakeOnLanCallbackPayloadTemplateArgs']]):
        pulumi.set(self, "payload_template", value)

    @_builtins.property
    @pulumi.getter(name="sharedSecret")
    def shared_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
        """
        return pulumi.get(self, "shared_secret")

    @shared_secret.setter
    def shared_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shared_secret", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class LiveToolsWakeOnLanCallbackHttpServerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
elif False:
    LiveToolsWakeOnLanCallbackHttpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsWakeOnLanCallbackHttpServerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LiveToolsWakeOnLanCallbackPayloadTemplateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
elif False:
    LiveToolsWakeOnLanCallbackPayloadTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsWakeOnLanCallbackPayloadTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LiveToolsWakeOnLanRequestArgsDict(TypedDict):
        mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target's MAC address
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device serial number
        """
        vlan_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The target's VLAN (1 to 4094)
        """
elif False:
    LiveToolsWakeOnLanRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiveToolsWakeOnLanRequestArgs:
    def __init__(__self__, *,
                 mac: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] mac: The target's MAC address
        :param pulumi.Input[_builtins.str] serial: Device serial number
        :param pulumi.Input[_builtins.int] vlan_id: The target's VLAN (1 to 4094)
        """
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target's MAC address
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device serial number
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The target's VLAN (1 to 4094)
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class ManagementInterfaceDdnsHostnamesArgsDict(TypedDict):
        active_ddns_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Active dynamic DNS hostname.
        """
        ddns_hostname_wan1: NotRequired[pulumi.Input[_builtins.str]]
        """
        WAN 1 dynamic DNS hostname.
        """
        ddns_hostname_wan2: NotRequired[pulumi.Input[_builtins.str]]
        """
        WAN 2 dynamic DNS hostname.
        """
elif False:
    ManagementInterfaceDdnsHostnamesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementInterfaceDdnsHostnamesArgs:
    def __init__(__self__, *,
                 active_ddns_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 ddns_hostname_wan1: Optional[pulumi.Input[_builtins.str]] = None,
                 ddns_hostname_wan2: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] active_ddns_hostname: Active dynamic DNS hostname.
        :param pulumi.Input[_builtins.str] ddns_hostname_wan1: WAN 1 dynamic DNS hostname.
        :param pulumi.Input[_builtins.str] ddns_hostname_wan2: WAN 2 dynamic DNS hostname.
        """
        if active_ddns_hostname is not None:
            pulumi.set(__self__, "active_ddns_hostname", active_ddns_hostname)
        if ddns_hostname_wan1 is not None:
            pulumi.set(__self__, "ddns_hostname_wan1", ddns_hostname_wan1)
        if ddns_hostname_wan2 is not None:
            pulumi.set(__self__, "ddns_hostname_wan2", ddns_hostname_wan2)

    @_builtins.property
    @pulumi.getter(name="activeDdnsHostname")
    def active_ddns_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Active dynamic DNS hostname.
        """
        return pulumi.get(self, "active_ddns_hostname")

    @active_ddns_hostname.setter
    def active_ddns_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "active_ddns_hostname", value)

    @_builtins.property
    @pulumi.getter(name="ddnsHostnameWan1")
    def ddns_hostname_wan1(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        WAN 1 dynamic DNS hostname.
        """
        return pulumi.get(self, "ddns_hostname_wan1")

    @ddns_hostname_wan1.setter
    def ddns_hostname_wan1(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ddns_hostname_wan1", value)

    @_builtins.property
    @pulumi.getter(name="ddnsHostnameWan2")
    def ddns_hostname_wan2(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        WAN 2 dynamic DNS hostname.
        """
        return pulumi.get(self, "ddns_hostname_wan2")

    @ddns_hostname_wan2.setter
    def ddns_hostname_wan2(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ddns_hostname_wan2", value)


if not MYPY:
    class ManagementInterfaceWan1ArgsDict(TypedDict):
        static_dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Up to two DNS IPs.
        """
        static_gateway_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP of the gateway on the WAN.
        """
        static_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP the device should use on the WAN.
        """
        static_subnet_mask: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet mask for the WAN.
        """
        using_static_ip: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Configure the interface to have static IP settings or use DHCP.
        """
        vlan: NotRequired[pulumi.Input[_builtins.int]]
        """
        The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
        """
        wan_enabled: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
        """
elif False:
    ManagementInterfaceWan1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementInterfaceWan1Args:
    def __init__(__self__, *,
                 static_dns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 static_gateway_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 static_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 static_subnet_mask: Optional[pulumi.Input[_builtins.str]] = None,
                 using_static_ip: Optional[pulumi.Input[_builtins.bool]] = None,
                 vlan: Optional[pulumi.Input[_builtins.int]] = None,
                 wan_enabled: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] static_dns: Up to two DNS IPs.
        :param pulumi.Input[_builtins.str] static_gateway_ip: The IP of the gateway on the WAN.
        :param pulumi.Input[_builtins.str] static_ip: The IP the device should use on the WAN.
        :param pulumi.Input[_builtins.str] static_subnet_mask: The subnet mask for the WAN.
        :param pulumi.Input[_builtins.bool] using_static_ip: Configure the interface to have static IP settings or use DHCP.
        :param pulumi.Input[_builtins.int] vlan: The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
        :param pulumi.Input[_builtins.str] wan_enabled: Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
        """
        if static_dns is not None:
            pulumi.set(__self__, "static_dns", static_dns)
        if static_gateway_ip is not None:
            pulumi.set(__self__, "static_gateway_ip", static_gateway_ip)
        if static_ip is not None:
            pulumi.set(__self__, "static_ip", static_ip)
        if static_subnet_mask is not None:
            pulumi.set(__self__, "static_subnet_mask", static_subnet_mask)
        if using_static_ip is not None:
            pulumi.set(__self__, "using_static_ip", using_static_ip)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)
        if wan_enabled is not None:
            pulumi.set(__self__, "wan_enabled", wan_enabled)

    @_builtins.property
    @pulumi.getter(name="staticDns")
    def static_dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Up to two DNS IPs.
        """
        return pulumi.get(self, "static_dns")

    @static_dns.setter
    def static_dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "static_dns", value)

    @_builtins.property
    @pulumi.getter(name="staticGatewayIp")
    def static_gateway_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP of the gateway on the WAN.
        """
        return pulumi.get(self, "static_gateway_ip")

    @static_gateway_ip.setter
    def static_gateway_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_gateway_ip", value)

    @_builtins.property
    @pulumi.getter(name="staticIp")
    def static_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP the device should use on the WAN.
        """
        return pulumi.get(self, "static_ip")

    @static_ip.setter
    def static_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_ip", value)

    @_builtins.property
    @pulumi.getter(name="staticSubnetMask")
    def static_subnet_mask(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet mask for the WAN.
        """
        return pulumi.get(self, "static_subnet_mask")

    @static_subnet_mask.setter
    def static_subnet_mask(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_subnet_mask", value)

    @_builtins.property
    @pulumi.getter(name="usingStaticIp")
    def using_static_ip(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Configure the interface to have static IP settings or use DHCP.
        """
        return pulumi.get(self, "using_static_ip")

    @using_static_ip.setter
    def using_static_ip(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "using_static_ip", value)

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan", value)

    @_builtins.property
    @pulumi.getter(name="wanEnabled")
    def wan_enabled(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
        """
        return pulumi.get(self, "wan_enabled")

    @wan_enabled.setter
    def wan_enabled(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wan_enabled", value)


if not MYPY:
    class ManagementInterfaceWan2ArgsDict(TypedDict):
        static_dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Up to two DNS IPs.
        """
        static_gateway_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP of the gateway on the WAN.
        """
        static_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP the device should use on the WAN.
        """
        static_subnet_mask: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet mask for the WAN.
        """
        using_static_ip: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Configure the interface to have static IP settings or use DHCP.
        """
        vlan: NotRequired[pulumi.Input[_builtins.int]]
        """
        The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
        """
        wan_enabled: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
        """
elif False:
    ManagementInterfaceWan2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementInterfaceWan2Args:
    def __init__(__self__, *,
                 static_dns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 static_gateway_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 static_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 static_subnet_mask: Optional[pulumi.Input[_builtins.str]] = None,
                 using_static_ip: Optional[pulumi.Input[_builtins.bool]] = None,
                 vlan: Optional[pulumi.Input[_builtins.int]] = None,
                 wan_enabled: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] static_dns: Up to two DNS IPs.
        :param pulumi.Input[_builtins.str] static_gateway_ip: The IP of the gateway on the WAN.
        :param pulumi.Input[_builtins.str] static_ip: The IP the device should use on the WAN.
        :param pulumi.Input[_builtins.str] static_subnet_mask: The subnet mask for the WAN.
        :param pulumi.Input[_builtins.bool] using_static_ip: Configure the interface to have static IP settings or use DHCP.
        :param pulumi.Input[_builtins.int] vlan: The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
        :param pulumi.Input[_builtins.str] wan_enabled: Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
        """
        if static_dns is not None:
            pulumi.set(__self__, "static_dns", static_dns)
        if static_gateway_ip is not None:
            pulumi.set(__self__, "static_gateway_ip", static_gateway_ip)
        if static_ip is not None:
            pulumi.set(__self__, "static_ip", static_ip)
        if static_subnet_mask is not None:
            pulumi.set(__self__, "static_subnet_mask", static_subnet_mask)
        if using_static_ip is not None:
            pulumi.set(__self__, "using_static_ip", using_static_ip)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)
        if wan_enabled is not None:
            pulumi.set(__self__, "wan_enabled", wan_enabled)

    @_builtins.property
    @pulumi.getter(name="staticDns")
    def static_dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Up to two DNS IPs.
        """
        return pulumi.get(self, "static_dns")

    @static_dns.setter
    def static_dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "static_dns", value)

    @_builtins.property
    @pulumi.getter(name="staticGatewayIp")
    def static_gateway_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP of the gateway on the WAN.
        """
        return pulumi.get(self, "static_gateway_ip")

    @static_gateway_ip.setter
    def static_gateway_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_gateway_ip", value)

    @_builtins.property
    @pulumi.getter(name="staticIp")
    def static_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP the device should use on the WAN.
        """
        return pulumi.get(self, "static_ip")

    @static_ip.setter
    def static_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_ip", value)

    @_builtins.property
    @pulumi.getter(name="staticSubnetMask")
    def static_subnet_mask(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet mask for the WAN.
        """
        return pulumi.get(self, "static_subnet_mask")

    @static_subnet_mask.setter
    def static_subnet_mask(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_subnet_mask", value)

    @_builtins.property
    @pulumi.getter(name="usingStaticIp")
    def using_static_ip(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Configure the interface to have static IP settings or use DHCP.
        """
        return pulumi.get(self, "using_static_ip")

    @using_static_ip.setter
    def using_static_ip(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "using_static_ip", value)

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan", value)

    @_builtins.property
    @pulumi.getter(name="wanEnabled")
    def wan_enabled(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
        """
        return pulumi.get(self, "wan_enabled")

    @wan_enabled.setter
    def wan_enabled(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wan_enabled", value)


if not MYPY:
    class SensorRelationshipsLivestreamArgsDict(TypedDict):
        related_devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['SensorRelationshipsLivestreamRelatedDeviceArgsDict']]]]
        """
        An array of the related devices for the role
        """
elif False:
    SensorRelationshipsLivestreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorRelationshipsLivestreamArgs:
    def __init__(__self__, *,
                 related_devices: Optional[pulumi.Input[Sequence[pulumi.Input['SensorRelationshipsLivestreamRelatedDeviceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SensorRelationshipsLivestreamRelatedDeviceArgs']]] related_devices: An array of the related devices for the role
        """
        if related_devices is not None:
            pulumi.set(__self__, "related_devices", related_devices)

    @_builtins.property
    @pulumi.getter(name="relatedDevices")
    def related_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SensorRelationshipsLivestreamRelatedDeviceArgs']]]]:
        """
        An array of the related devices for the role
        """
        return pulumi.get(self, "related_devices")

    @related_devices.setter
    def related_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SensorRelationshipsLivestreamRelatedDeviceArgs']]]]):
        pulumi.set(self, "related_devices", value)


if not MYPY:
    class SensorRelationshipsLivestreamRelatedDeviceArgsDict(TypedDict):
        product_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The product type of the related device
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        The serial of the related device
        """
elif False:
    SensorRelationshipsLivestreamRelatedDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorRelationshipsLivestreamRelatedDeviceArgs:
    def __init__(__self__, *,
                 product_type: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] product_type: The product type of the related device
        :param pulumi.Input[_builtins.str] serial: The serial of the related device
        """
        if product_type is not None:
            pulumi.set(__self__, "product_type", product_type)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The product type of the related device
        """
        return pulumi.get(self, "product_type")

    @product_type.setter
    def product_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "product_type", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The serial of the related device
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)


if not MYPY:
    class SensorRelationshipsLivestreamRequestArgsDict(TypedDict):
        related_devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['SensorRelationshipsLivestreamRequestRelatedDeviceArgsDict']]]]
        """
        An array of the related devices for the role
        """
elif False:
    SensorRelationshipsLivestreamRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorRelationshipsLivestreamRequestArgs:
    def __init__(__self__, *,
                 related_devices: Optional[pulumi.Input[Sequence[pulumi.Input['SensorRelationshipsLivestreamRequestRelatedDeviceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SensorRelationshipsLivestreamRequestRelatedDeviceArgs']]] related_devices: An array of the related devices for the role
        """
        if related_devices is not None:
            pulumi.set(__self__, "related_devices", related_devices)

    @_builtins.property
    @pulumi.getter(name="relatedDevices")
    def related_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SensorRelationshipsLivestreamRequestRelatedDeviceArgs']]]]:
        """
        An array of the related devices for the role
        """
        return pulumi.get(self, "related_devices")

    @related_devices.setter
    def related_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SensorRelationshipsLivestreamRequestRelatedDeviceArgs']]]]):
        pulumi.set(self, "related_devices", value)


if not MYPY:
    class SensorRelationshipsLivestreamRequestRelatedDeviceArgsDict(TypedDict):
        product_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The product type of the related device
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        The serial of the related device
        """
elif False:
    SensorRelationshipsLivestreamRequestRelatedDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorRelationshipsLivestreamRequestRelatedDeviceArgs:
    def __init__(__self__, *,
                 product_type: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] product_type: The product type of the related device
        :param pulumi.Input[_builtins.str] serial: The serial of the related device
        """
        if product_type is not None:
            pulumi.set(__self__, "product_type", product_type)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The product type of the related device
        """
        return pulumi.get(self, "product_type")

    @product_type.setter
    def product_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "product_type", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The serial of the related device
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)


if not MYPY:
    class SwitchPortsCycleItemArgsDict(TypedDict):
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of switch ports
        """
elif False:
    SwitchPortsCycleItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortsCycleItemArgs:
    def __init__(__self__, *,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ports: List of switch ports
        """
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of switch ports
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class SwitchPortsCycleParametersArgsDict(TypedDict):
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of switch ports
        """
elif False:
    SwitchPortsCycleParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortsCycleParametersArgs:
    def __init__(__self__, *,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ports: List of switch ports
        """
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of switch ports
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class SwitchPortsMirrorArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port mirror mode. Can be one of ('Destination port', 'Source port' or 'Not mirroring traffic').
        """
elif False:
    SwitchPortsMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortsMirrorArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The port mirror mode. Can be one of ('Destination port', 'Source port' or 'Not mirroring traffic').
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port mirror mode. Can be one of ('Destination port', 'Source port' or 'Not mirroring traffic').
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class SwitchPortsModuleArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The model of the expansion module.
        """
elif False:
    SwitchPortsModuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortsModuleArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The model of the expansion module.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The model of the expansion module.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)


if not MYPY:
    class SwitchPortsProfileArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When enabled, override this port's configuration with a port profile.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        When enabled, the ID of the port profile used to override the port's configuration.
        """
        iname: NotRequired[pulumi.Input[_builtins.str]]
        """
        When enabled, the IName of the profile.
        """
elif False:
    SwitchPortsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortsProfileArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 iname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: When enabled, override this port's configuration with a port profile.
        :param pulumi.Input[_builtins.str] id: When enabled, the ID of the port profile used to override the port's configuration.
        :param pulumi.Input[_builtins.str] iname: When enabled, the IName of the profile.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iname is not None:
            pulumi.set(__self__, "iname", iname)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When enabled, override this port's configuration with a port profile.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When enabled, the ID of the port profile used to override the port's configuration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def iname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When enabled, the IName of the profile.
        """
        return pulumi.get(self, "iname")

    @iname.setter
    def iname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iname", value)


if not MYPY:
    class SwitchRoutingInterfacesDhcpDhcpOptionArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The code for DHCP option which should be from 2 to 254
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the DHCP option
        """
elif False:
    SwitchRoutingInterfacesDhcpDhcpOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRoutingInterfacesDhcpDhcpOptionArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] code: The code for DHCP option which should be from 2 to 254
        :param pulumi.Input[_builtins.str] type: The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
        :param pulumi.Input[_builtins.str] value: The value of the DHCP option
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The code for DHCP option which should be from 2 to 254
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the DHCP option
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SwitchRoutingInterfacesDhcpFixedIpAssignmentArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the client which has fixed IP address assigned to it
        """
        mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MAC address of the client which has fixed IP address
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the client which has fixed IP address
        """
elif False:
    SwitchRoutingInterfacesDhcpFixedIpAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRoutingInterfacesDhcpFixedIpAssignmentArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 mac: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: The IP address of the client which has fixed IP address assigned to it
        :param pulumi.Input[_builtins.str] mac: The MAC address of the client which has fixed IP address
        :param pulumi.Input[_builtins.str] name: The name of the client which has fixed IP address
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the client which has fixed IP address assigned to it
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MAC address of the client which has fixed IP address
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the client which has fixed IP address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SwitchRoutingInterfacesDhcpReservedIpRangeArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        The comment for the reserved IP range
        """
        end: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ending IP address of the reserved IP range
        """
        start: NotRequired[pulumi.Input[_builtins.str]]
        """
        The starting IP address of the reserved IP range
        """
elif False:
    SwitchRoutingInterfacesDhcpReservedIpRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRoutingInterfacesDhcpReservedIpRangeArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 end: Optional[pulumi.Input[_builtins.str]] = None,
                 start: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: The comment for the reserved IP range
        :param pulumi.Input[_builtins.str] end: The ending IP address of the reserved IP range
        :param pulumi.Input[_builtins.str] start: The starting IP address of the reserved IP range
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The comment for the reserved IP range
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ending IP address of the reserved IP range
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The starting IP address of the reserved IP range
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class SwitchRoutingInterfacesIpv6ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv6 address
        """
        assignment_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Assignment mode
        """
        gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv6 gateway
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv6 subnet
        """
elif False:
    SwitchRoutingInterfacesIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRoutingInterfacesIpv6Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 assignment_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: IPv6 address
        :param pulumi.Input[_builtins.str] assignment_mode: Assignment mode
        :param pulumi.Input[_builtins.str] gateway: IPv6 gateway
        :param pulumi.Input[_builtins.str] prefix: IPv6 subnet
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if assignment_mode is not None:
            pulumi.set(__self__, "assignment_mode", assignment_mode)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv6 address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="assignmentMode")
    def assignment_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Assignment mode
        """
        return pulumi.get(self, "assignment_mode")

    @assignment_mode.setter
    def assignment_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "assignment_mode", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv6 gateway
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv6 subnet
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class SwitchRoutingInterfacesOspfSettingsArgsDict(TypedDict):
        area: NotRequired[pulumi.Input[_builtins.str]]
        """
        Area id
        """
        cost: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF Cost
        """
        is_passive_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable sending Hello packets on this interface's IPv4 area
        """
elif False:
    SwitchRoutingInterfacesOspfSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRoutingInterfacesOspfSettingsArgs:
    def __init__(__self__, *,
                 area: Optional[pulumi.Input[_builtins.str]] = None,
                 cost: Optional[pulumi.Input[_builtins.int]] = None,
                 is_passive_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] area: Area id
        :param pulumi.Input[_builtins.int] cost: OSPF Cost
        :param pulumi.Input[_builtins.bool] is_passive_enabled: Disable sending Hello packets on this interface's IPv4 area
        """
        if area is not None:
            pulumi.set(__self__, "area", area)
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if is_passive_enabled is not None:
            pulumi.set(__self__, "is_passive_enabled", is_passive_enabled)

    @_builtins.property
    @pulumi.getter
    def area(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Area id
        """
        return pulumi.get(self, "area")

    @area.setter
    def area(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "area", value)

    @_builtins.property
    @pulumi.getter
    def cost(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF Cost
        """
        return pulumi.get(self, "cost")

    @cost.setter
    def cost(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cost", value)

    @_builtins.property
    @pulumi.getter(name="isPassiveEnabled")
    def is_passive_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable sending Hello packets on this interface's IPv4 area
        """
        return pulumi.get(self, "is_passive_enabled")

    @is_passive_enabled.setter
    def is_passive_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_passive_enabled", value)


if not MYPY:
    class SwitchRoutingInterfacesOspfV3ArgsDict(TypedDict):
        area: NotRequired[pulumi.Input[_builtins.str]]
        """
        Area id
        """
        cost: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF Cost
        """
        is_passive_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable sending Hello packets on this interface's IPv6 area
        """
elif False:
    SwitchRoutingInterfacesOspfV3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRoutingInterfacesOspfV3Args:
    def __init__(__self__, *,
                 area: Optional[pulumi.Input[_builtins.str]] = None,
                 cost: Optional[pulumi.Input[_builtins.int]] = None,
                 is_passive_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] area: Area id
        :param pulumi.Input[_builtins.int] cost: OSPF Cost
        :param pulumi.Input[_builtins.bool] is_passive_enabled: Disable sending Hello packets on this interface's IPv6 area
        """
        if area is not None:
            pulumi.set(__self__, "area", area)
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if is_passive_enabled is not None:
            pulumi.set(__self__, "is_passive_enabled", is_passive_enabled)

    @_builtins.property
    @pulumi.getter
    def area(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Area id
        """
        return pulumi.get(self, "area")

    @area.setter
    def area(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "area", value)

    @_builtins.property
    @pulumi.getter
    def cost(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF Cost
        """
        return pulumi.get(self, "cost")

    @cost.setter
    def cost(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cost", value)

    @_builtins.property
    @pulumi.getter(name="isPassiveEnabled")
    def is_passive_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable sending Hello packets on this interface's IPv6 area
        """
        return pulumi.get(self, "is_passive_enabled")

    @is_passive_enabled.setter
    def is_passive_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_passive_enabled", value)


if not MYPY:
    class WirelessAlternateManagementInterfaceIpv6ItemArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ItemAddressArgsDict']]]]
        """
        configured alternate management interface addresses
        """
elif False:
    WirelessAlternateManagementInterfaceIpv6ItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessAlternateManagementInterfaceIpv6ItemArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ItemAddressArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ItemAddressArgs']]] addresses: configured alternate management interface addresses
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ItemAddressArgs']]]]:
        """
        configured alternate management interface addresses
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ItemAddressArgs']]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class WirelessAlternateManagementInterfaceIpv6ItemAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address configured for the alternate management interface
        """
        assignment_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of address assignment. Either static or dynamic.
        """
        gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        The gateway address configured for the alternate managment interface
        """
        nameservers: NotRequired[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ItemAddressNameserversArgsDict']]
        """
        The DNS servers settings for this address.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv6 prefix of the interface. Required if IPv6 object is included.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP protocol used for the address
        """
elif False:
    WirelessAlternateManagementInterfaceIpv6ItemAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessAlternateManagementInterfaceIpv6ItemAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 assignment_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 nameservers: Optional[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ItemAddressNameserversArgs']] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The IP address configured for the alternate management interface
        :param pulumi.Input[_builtins.str] assignment_mode: The type of address assignment. Either static or dynamic.
        :param pulumi.Input[_builtins.str] gateway: The gateway address configured for the alternate managment interface
        :param pulumi.Input['WirelessAlternateManagementInterfaceIpv6ItemAddressNameserversArgs'] nameservers: The DNS servers settings for this address.
        :param pulumi.Input[_builtins.str] prefix: The IPv6 prefix of the interface. Required if IPv6 object is included.
        :param pulumi.Input[_builtins.str] protocol: The IP protocol used for the address
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if assignment_mode is not None:
            pulumi.set(__self__, "assignment_mode", assignment_mode)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address configured for the alternate management interface
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="assignmentMode")
    def assignment_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of address assignment. Either static or dynamic.
        """
        return pulumi.get(self, "assignment_mode")

    @assignment_mode.setter
    def assignment_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "assignment_mode", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The gateway address configured for the alternate managment interface
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def nameservers(self) -> Optional[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ItemAddressNameserversArgs']]:
        """
        The DNS servers settings for this address.
        """
        return pulumi.get(self, "nameservers")

    @nameservers.setter
    def nameservers(self, value: Optional[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ItemAddressNameserversArgs']]):
        pulumi.set(self, "nameservers", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv6 prefix of the interface. Required if IPv6 object is included.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP protocol used for the address
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class WirelessAlternateManagementInterfaceIpv6ItemAddressNameserversArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
elif False:
    WirelessAlternateManagementInterfaceIpv6ItemAddressNameserversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessAlternateManagementInterfaceIpv6ItemAddressNameserversArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] addresses: Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class WirelessAlternateManagementInterfaceIpv6ParametersArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ParametersAddressArgsDict']]]]
        """
        configured alternate management interface addresses
        """
elif False:
    WirelessAlternateManagementInterfaceIpv6ParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessAlternateManagementInterfaceIpv6ParametersArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ParametersAddressArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ParametersAddressArgs']]] addresses: configured alternate management interface addresses
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ParametersAddressArgs']]]]:
        """
        configured alternate management interface addresses
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ParametersAddressArgs']]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class WirelessAlternateManagementInterfaceIpv6ParametersAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address configured for the alternate management interface
        """
        assignment_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of address assignment. Either static or dynamic.
        """
        gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        The gateway address configured for the alternate managment interface
        """
        nameservers: NotRequired[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ParametersAddressNameserversArgsDict']]
        """
        The DNS servers settings for this address.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv6 prefix length of the IPv6 interface. Required if IPv6 object is included.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP protocol used for the address
        """
elif False:
    WirelessAlternateManagementInterfaceIpv6ParametersAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessAlternateManagementInterfaceIpv6ParametersAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 assignment_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 nameservers: Optional[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ParametersAddressNameserversArgs']] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The IP address configured for the alternate management interface
        :param pulumi.Input[_builtins.str] assignment_mode: The type of address assignment. Either static or dynamic.
        :param pulumi.Input[_builtins.str] gateway: The gateway address configured for the alternate managment interface
        :param pulumi.Input['WirelessAlternateManagementInterfaceIpv6ParametersAddressNameserversArgs'] nameservers: The DNS servers settings for this address.
        :param pulumi.Input[_builtins.str] prefix: The IPv6 prefix length of the IPv6 interface. Required if IPv6 object is included.
        :param pulumi.Input[_builtins.str] protocol: The IP protocol used for the address
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if assignment_mode is not None:
            pulumi.set(__self__, "assignment_mode", assignment_mode)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address configured for the alternate management interface
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="assignmentMode")
    def assignment_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of address assignment. Either static or dynamic.
        """
        return pulumi.get(self, "assignment_mode")

    @assignment_mode.setter
    def assignment_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "assignment_mode", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The gateway address configured for the alternate managment interface
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def nameservers(self) -> Optional[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ParametersAddressNameserversArgs']]:
        """
        The DNS servers settings for this address.
        """
        return pulumi.get(self, "nameservers")

    @nameservers.setter
    def nameservers(self, value: Optional[pulumi.Input['WirelessAlternateManagementInterfaceIpv6ParametersAddressNameserversArgs']]):
        pulumi.set(self, "nameservers", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv6 prefix length of the IPv6 interface. Required if IPv6 object is included.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP protocol used for the address
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class WirelessAlternateManagementInterfaceIpv6ParametersAddressNameserversArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
elif False:
    WirelessAlternateManagementInterfaceIpv6ParametersAddressNameserversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessAlternateManagementInterfaceIpv6ParametersAddressNameserversArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] addresses: Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class WirelessRadioSettingsFiveGhzSettingsArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets a manual channel for 5 GHz. Can be '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161', '165', '169', '173' or '177' or null for using auto channel.
        """
        channel_width: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sets a manual channel for 5 GHz. Can be '0', '20', '40', '80' or '160' or null for using auto channel width.
        """
        target_power: NotRequired[pulumi.Input[_builtins.int]]
        """
        Set a manual target power for 5 GHz. Can be between '8' or '30' or null for using auto power range.
        """
elif False:
    WirelessRadioSettingsFiveGhzSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRadioSettingsFiveGhzSettingsArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.int]] = None,
                 channel_width: Optional[pulumi.Input[_builtins.str]] = None,
                 target_power: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] channel: Sets a manual channel for 5 GHz. Can be '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161', '165', '169', '173' or '177' or null for using auto channel.
        :param pulumi.Input[_builtins.str] channel_width: Sets a manual channel for 5 GHz. Can be '0', '20', '40', '80' or '160' or null for using auto channel width.
        :param pulumi.Input[_builtins.int] target_power: Set a manual target power for 5 GHz. Can be between '8' or '30' or null for using auto power range.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channel_width is not None:
            pulumi.set(__self__, "channel_width", channel_width)
        if target_power is not None:
            pulumi.set(__self__, "target_power", target_power)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets a manual channel for 5 GHz. Can be '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161', '165', '169', '173' or '177' or null for using auto channel.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="channelWidth")
    def channel_width(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sets a manual channel for 5 GHz. Can be '0', '20', '40', '80' or '160' or null for using auto channel width.
        """
        return pulumi.get(self, "channel_width")

    @channel_width.setter
    def channel_width(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_width", value)

    @_builtins.property
    @pulumi.getter(name="targetPower")
    def target_power(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Set a manual target power for 5 GHz. Can be between '8' or '30' or null for using auto power range.
        """
        return pulumi.get(self, "target_power")

    @target_power.setter
    def target_power(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_power", value)


if not MYPY:
    class WirelessRadioSettingsTwoFourGhzSettingsArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets a manual channel for 2.4 GHz. Can be '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13' or '14' or null for using auto channel.
        """
        target_power: NotRequired[pulumi.Input[_builtins.int]]
        """
        Set a manual target power for 2.4 GHz. Can be between '5' or '30' or null for using auto power range.
        """
elif False:
    WirelessRadioSettingsTwoFourGhzSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRadioSettingsTwoFourGhzSettingsArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.int]] = None,
                 target_power: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] channel: Sets a manual channel for 2.4 GHz. Can be '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13' or '14' or null for using auto channel.
        :param pulumi.Input[_builtins.int] target_power: Set a manual target power for 2.4 GHz. Can be between '5' or '30' or null for using auto power range.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if target_power is not None:
            pulumi.set(__self__, "target_power", target_power)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets a manual channel for 2.4 GHz. Can be '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13' or '14' or null for using auto channel.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="targetPower")
    def target_power(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Set a manual target power for 2.4 GHz. Can be between '5' or '30' or null for using auto power range.
        """
        return pulumi.get(self, "target_power")

    @target_power.setter
    def target_power(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_power", value)


if not MYPY:
    class BaseDetailArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional property name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional property value
        """
elif False:
    BaseDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaseDetailArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Additional property name
        :param pulumi.Input[_builtins.str] value: Additional property value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional property name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional property value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


