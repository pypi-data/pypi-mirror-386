# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AlertsSettingsAlertArgs',
    'AlertsSettingsAlertArgsDict',
    'AlertsSettingsAlertAlertDestinationsArgs',
    'AlertsSettingsAlertAlertDestinationsArgsDict',
    'AlertsSettingsAlertFiltersArgs',
    'AlertsSettingsAlertFiltersArgsDict',
    'AlertsSettingsAlertsResponseArgs',
    'AlertsSettingsAlertsResponseArgsDict',
    'AlertsSettingsAlertsResponseAlertDestinationsArgs',
    'AlertsSettingsAlertsResponseAlertDestinationsArgsDict',
    'AlertsSettingsAlertsResponseFiltersArgs',
    'AlertsSettingsAlertsResponseFiltersArgsDict',
    'AlertsSettingsDefaultDestinationsArgs',
    'AlertsSettingsDefaultDestinationsArgsDict',
    'AlertsSettingsMutingArgs',
    'AlertsSettingsMutingArgsDict',
    'AlertsSettingsMutingByPortSchedulesArgs',
    'AlertsSettingsMutingByPortSchedulesArgsDict',
    'ApplianceConnectivityMonitoringDestinationsDestinationArgs',
    'ApplianceConnectivityMonitoringDestinationsDestinationArgsDict',
    'ApplianceContentFilteringBlockedUrlCategoriesResponseArgs',
    'ApplianceContentFilteringBlockedUrlCategoriesResponseArgsDict',
    'ApplianceFirewallCellularFirewallRulesRuleArgs',
    'ApplianceFirewallCellularFirewallRulesRuleArgsDict',
    'ApplianceFirewallInboundFirewallRulesRuleArgs',
    'ApplianceFirewallInboundFirewallRulesRuleArgsDict',
    'ApplianceFirewallInboundFirewallRulesRulesResponseArgs',
    'ApplianceFirewallInboundFirewallRulesRulesResponseArgsDict',
    'ApplianceFirewallL3FirewallRulesRuleArgs',
    'ApplianceFirewallL3FirewallRulesRuleArgsDict',
    'ApplianceFirewallL3FirewallRulesRulesResponseArgs',
    'ApplianceFirewallL3FirewallRulesRulesResponseArgsDict',
    'ApplianceFirewallL7FirewallRulesRuleArgs',
    'ApplianceFirewallL7FirewallRulesRuleArgsDict',
    'ApplianceFirewallL7FirewallRulesRuleValueObjArgs',
    'ApplianceFirewallL7FirewallRulesRuleValueObjArgsDict',
    'ApplianceFirewallL7FirewallRulesRulesResponseArgs',
    'ApplianceFirewallL7FirewallRulesRulesResponseArgsDict',
    'ApplianceFirewallL7FirewallRulesRulesResponseValueObjArgs',
    'ApplianceFirewallL7FirewallRulesRulesResponseValueObjArgsDict',
    'ApplianceFirewallOneToManyNatRulesRuleArgs',
    'ApplianceFirewallOneToManyNatRulesRuleArgsDict',
    'ApplianceFirewallOneToManyNatRulesRulePortRuleArgs',
    'ApplianceFirewallOneToManyNatRulesRulePortRuleArgsDict',
    'ApplianceFirewallOneToOneNatRulesRuleArgs',
    'ApplianceFirewallOneToOneNatRulesRuleArgsDict',
    'ApplianceFirewallOneToOneNatRulesRuleAllowedInboundArgs',
    'ApplianceFirewallOneToOneNatRulesRuleAllowedInboundArgsDict',
    'ApplianceFirewallPortForwardingRulesRuleArgs',
    'ApplianceFirewallPortForwardingRulesRuleArgsDict',
    'ApplianceFirewallSettingsSpoofingProtectionArgs',
    'ApplianceFirewallSettingsSpoofingProtectionArgsDict',
    'ApplianceFirewallSettingsSpoofingProtectionIpSourceGuardArgs',
    'ApplianceFirewallSettingsSpoofingProtectionIpSourceGuardArgsDict',
    'AppliancePrefixesDelegatedStaticsOriginArgs',
    'AppliancePrefixesDelegatedStaticsOriginArgsDict',
    'ApplianceRfProfilesFiveGhzSettingsArgs',
    'ApplianceRfProfilesFiveGhzSettingsArgsDict',
    'ApplianceRfProfilesPerSsidSettingsArgs',
    'ApplianceRfProfilesPerSsidSettingsArgsDict',
    'ApplianceRfProfilesPerSsidSettingsStatus1Args',
    'ApplianceRfProfilesPerSsidSettingsStatus1ArgsDict',
    'ApplianceRfProfilesPerSsidSettingsStatus2Args',
    'ApplianceRfProfilesPerSsidSettingsStatus2ArgsDict',
    'ApplianceRfProfilesPerSsidSettingsStatus3Args',
    'ApplianceRfProfilesPerSsidSettingsStatus3ArgsDict',
    'ApplianceRfProfilesPerSsidSettingsStatus4Args',
    'ApplianceRfProfilesPerSsidSettingsStatus4ArgsDict',
    'ApplianceRfProfilesTwoFourGhzSettingsArgs',
    'ApplianceRfProfilesTwoFourGhzSettingsArgsDict',
    'ApplianceSecurityIntrusionProtectedNetworksArgs',
    'ApplianceSecurityIntrusionProtectedNetworksArgsDict',
    'ApplianceSecurityMalwareAllowedFileArgs',
    'ApplianceSecurityMalwareAllowedFileArgsDict',
    'ApplianceSecurityMalwareAllowedUrlArgs',
    'ApplianceSecurityMalwareAllowedUrlArgsDict',
    'ApplianceSettingsDynamicDnsArgs',
    'ApplianceSettingsDynamicDnsArgsDict',
    'ApplianceSingleLanIpv6Args',
    'ApplianceSingleLanIpv6ArgsDict',
    'ApplianceSingleLanIpv6PrefixAssignmentArgs',
    'ApplianceSingleLanIpv6PrefixAssignmentArgsDict',
    'ApplianceSingleLanIpv6PrefixAssignmentOriginArgs',
    'ApplianceSingleLanIpv6PrefixAssignmentOriginArgsDict',
    'ApplianceSingleLanMandatoryDhcpArgs',
    'ApplianceSingleLanMandatoryDhcpArgsDict',
    'ApplianceSsidsDhcpEnforcedDeauthenticationArgs',
    'ApplianceSsidsDhcpEnforcedDeauthenticationArgsDict',
    'ApplianceSsidsDot11wArgs',
    'ApplianceSsidsDot11wArgsDict',
    'ApplianceSsidsRadiusServerArgs',
    'ApplianceSsidsRadiusServerArgsDict',
    'ApplianceSsidsRadiusServersResponseArgs',
    'ApplianceSsidsRadiusServersResponseArgsDict',
    'ApplianceTrafficShapingCustomPerformanceClassesParametersArgs',
    'ApplianceTrafficShapingCustomPerformanceClassesParametersArgsDict',
    'ApplianceTrafficShapingGlobalBandwidthLimitsArgs',
    'ApplianceTrafficShapingGlobalBandwidthLimitsArgsDict',
    'ApplianceTrafficShapingRulesRuleArgs',
    'ApplianceTrafficShapingRulesRuleArgsDict',
    'ApplianceTrafficShapingRulesRuleDefinitionArgs',
    'ApplianceTrafficShapingRulesRuleDefinitionArgsDict',
    'ApplianceTrafficShapingRulesRuleDefinitionValueObjArgs',
    'ApplianceTrafficShapingRulesRuleDefinitionValueObjArgsDict',
    'ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsArgs',
    'ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsArgsDict',
    'ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs',
    'ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgsDict',
    'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsArgs',
    'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsArgsDict',
    'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellularArgs',
    'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellularArgsDict',
    'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1Args',
    'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1ArgsDict',
    'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2Args',
    'ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2ArgsDict',
    'ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackArgs',
    'ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackArgsDict',
    'ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediateArgs',
    'ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediateArgsDict',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceArgs',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceArgsDict',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClassArgs',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClassArgsDict',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterArgs',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterArgsDict',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueArgs',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueArgsDict',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestinationArgs',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestinationArgsDict',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSourceArgs',
    'ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSourceArgsDict',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceArgs',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceArgsDict',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterArgs',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterArgsDict',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueArgs',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueArgsDict',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestinationArgs',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestinationArgsDict',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSourceArgs',
    'ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSourceArgsDict',
    'ApplianceTrafficShapingVpnExclusionsItemArgs',
    'ApplianceTrafficShapingVpnExclusionsItemArgsDict',
    'ApplianceTrafficShapingVpnExclusionsItemCustomArgs',
    'ApplianceTrafficShapingVpnExclusionsItemCustomArgsDict',
    'ApplianceTrafficShapingVpnExclusionsItemMajorApplicationArgs',
    'ApplianceTrafficShapingVpnExclusionsItemMajorApplicationArgsDict',
    'ApplianceTrafficShapingVpnExclusionsParametersArgs',
    'ApplianceTrafficShapingVpnExclusionsParametersArgsDict',
    'ApplianceTrafficShapingVpnExclusionsParametersCustomArgs',
    'ApplianceTrafficShapingVpnExclusionsParametersCustomArgsDict',
    'ApplianceTrafficShapingVpnExclusionsParametersMajorApplicationArgs',
    'ApplianceTrafficShapingVpnExclusionsParametersMajorApplicationArgsDict',
    'ApplianceVlansDhcpOptionArgs',
    'ApplianceVlansDhcpOptionArgsDict',
    'ApplianceVlansIpv6Args',
    'ApplianceVlansIpv6ArgsDict',
    'ApplianceVlansIpv6PrefixAssignmentArgs',
    'ApplianceVlansIpv6PrefixAssignmentArgsDict',
    'ApplianceVlansIpv6PrefixAssignmentOriginArgs',
    'ApplianceVlansIpv6PrefixAssignmentOriginArgsDict',
    'ApplianceVlansMandatoryDhcpArgs',
    'ApplianceVlansMandatoryDhcpArgsDict',
    'ApplianceVlansReservedIpRangeArgs',
    'ApplianceVlansReservedIpRangeArgsDict',
    'ApplianceVpnBgpNeighborArgs',
    'ApplianceVpnBgpNeighborArgsDict',
    'ApplianceVpnBgpNeighborAuthenticationArgs',
    'ApplianceVpnBgpNeighborAuthenticationArgsDict',
    'ApplianceVpnBgpNeighborIpv6Args',
    'ApplianceVpnBgpNeighborIpv6ArgsDict',
    'ApplianceVpnBgpNeighborTtlSecurityArgs',
    'ApplianceVpnBgpNeighborTtlSecurityArgsDict',
    'ApplianceVpnSiteToSiteVpnHubArgs',
    'ApplianceVpnSiteToSiteVpnHubArgsDict',
    'ApplianceVpnSiteToSiteVpnSubnetArgs',
    'ApplianceVpnSiteToSiteVpnSubnetArgsDict',
    'ApplianceWarmSpareWan1Args',
    'ApplianceWarmSpareWan1ArgsDict',
    'ApplianceWarmSpareWan2Args',
    'ApplianceWarmSpareWan2ArgsDict',
    'BindItemArgs',
    'BindItemArgsDict',
    'BindParametersArgs',
    'BindParametersArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsArgs',
    'CameraQualityRetentionProfilesVideoSettingsArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72Args',
    'CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72ArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsMV12WeArgs',
    'CameraQualityRetentionProfilesVideoSettingsMV12WeArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsMV13Args',
    'CameraQualityRetentionProfilesVideoSettingsMV13ArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsMV21MV71Args',
    'CameraQualityRetentionProfilesVideoSettingsMV21MV71ArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsMV22Xmv72XArgs',
    'CameraQualityRetentionProfilesVideoSettingsMV22Xmv72XArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsMV32Args',
    'CameraQualityRetentionProfilesVideoSettingsMV32ArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsMV33Args',
    'CameraQualityRetentionProfilesVideoSettingsMV33ArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsMV52Args',
    'CameraQualityRetentionProfilesVideoSettingsMV52ArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsMV63Args',
    'CameraQualityRetentionProfilesVideoSettingsMV63ArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsMV63XArgs',
    'CameraQualityRetentionProfilesVideoSettingsMV63XArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsMV93Args',
    'CameraQualityRetentionProfilesVideoSettingsMV93ArgsDict',
    'CameraQualityRetentionProfilesVideoSettingsMV93XArgs',
    'CameraQualityRetentionProfilesVideoSettingsMV93XArgsDict',
    'CameraWirelessProfilesIdentityArgs',
    'CameraWirelessProfilesIdentityArgsDict',
    'CameraWirelessProfilesSsidArgs',
    'CameraWirelessProfilesSsidArgsDict',
    'CellularGatewayConnectivityMonitoringDestinationsDestinationArgs',
    'CellularGatewayConnectivityMonitoringDestinationsDestinationArgsDict',
    'CellularGatewaySubnetPoolSubnetArgs',
    'CellularGatewaySubnetPoolSubnetArgsDict',
    'CellularGatewayUplinkBandwidthLimitsArgs',
    'CellularGatewayUplinkBandwidthLimitsArgsDict',
    'ClientsProvisionItemArgs',
    'ClientsProvisionItemArgsDict',
    'ClientsProvisionItemClientArgs',
    'ClientsProvisionItemClientArgsDict',
    'ClientsProvisionParametersArgs',
    'ClientsProvisionParametersArgsDict',
    'ClientsProvisionParametersClientArgs',
    'ClientsProvisionParametersClientArgsDict',
    'ClientsProvisionParametersPoliciesBySecurityApplianceArgs',
    'ClientsProvisionParametersPoliciesBySecurityApplianceArgsDict',
    'ClientsProvisionParametersPoliciesBySsidArgs',
    'ClientsProvisionParametersPoliciesBySsidArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus0Args',
    'ClientsProvisionParametersPoliciesBySsidStatus0ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus10Args',
    'ClientsProvisionParametersPoliciesBySsidStatus10ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus11Args',
    'ClientsProvisionParametersPoliciesBySsidStatus11ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus12Args',
    'ClientsProvisionParametersPoliciesBySsidStatus12ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus13Args',
    'ClientsProvisionParametersPoliciesBySsidStatus13ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus14Args',
    'ClientsProvisionParametersPoliciesBySsidStatus14ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus1Args',
    'ClientsProvisionParametersPoliciesBySsidStatus1ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus2Args',
    'ClientsProvisionParametersPoliciesBySsidStatus2ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus3Args',
    'ClientsProvisionParametersPoliciesBySsidStatus3ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus4Args',
    'ClientsProvisionParametersPoliciesBySsidStatus4ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus5Args',
    'ClientsProvisionParametersPoliciesBySsidStatus5ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus6Args',
    'ClientsProvisionParametersPoliciesBySsidStatus6ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus7Args',
    'ClientsProvisionParametersPoliciesBySsidStatus7ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus8Args',
    'ClientsProvisionParametersPoliciesBySsidStatus8ArgsDict',
    'ClientsProvisionParametersPoliciesBySsidStatus9Args',
    'ClientsProvisionParametersPoliciesBySsidStatus9ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsArgs',
    'ClientsSplashAuthorizationStatusSsidsArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus0Args',
    'ClientsSplashAuthorizationStatusSsidsStatus0ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus10Args',
    'ClientsSplashAuthorizationStatusSsidsStatus10ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus11Args',
    'ClientsSplashAuthorizationStatusSsidsStatus11ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus12Args',
    'ClientsSplashAuthorizationStatusSsidsStatus12ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus13Args',
    'ClientsSplashAuthorizationStatusSsidsStatus13ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus14Args',
    'ClientsSplashAuthorizationStatusSsidsStatus14ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus1Args',
    'ClientsSplashAuthorizationStatusSsidsStatus1ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus2Args',
    'ClientsSplashAuthorizationStatusSsidsStatus2ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus3Args',
    'ClientsSplashAuthorizationStatusSsidsStatus3ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus4Args',
    'ClientsSplashAuthorizationStatusSsidsStatus4ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus5Args',
    'ClientsSplashAuthorizationStatusSsidsStatus5ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus6Args',
    'ClientsSplashAuthorizationStatusSsidsStatus6ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus7Args',
    'ClientsSplashAuthorizationStatusSsidsStatus7ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus8Args',
    'ClientsSplashAuthorizationStatusSsidsStatus8ArgsDict',
    'ClientsSplashAuthorizationStatusSsidsStatus9Args',
    'ClientsSplashAuthorizationStatusSsidsStatus9ArgsDict',
    'DevicesClaimItemArgs',
    'DevicesClaimItemArgsDict',
    'DevicesClaimParametersArgs',
    'DevicesClaimParametersArgsDict',
    'DevicesClaimVmxItemArgs',
    'DevicesClaimVmxItemArgsDict',
    'DevicesClaimVmxItemDetailArgs',
    'DevicesClaimVmxItemDetailArgsDict',
    'DevicesClaimVmxParametersArgs',
    'DevicesClaimVmxParametersArgsDict',
    'DevicesRemoveParametersArgs',
    'DevicesRemoveParametersArgsDict',
    'FirmwareUpgradesProductsArgs',
    'FirmwareUpgradesProductsArgsDict',
    'FirmwareUpgradesProductsApplianceArgs',
    'FirmwareUpgradesProductsApplianceArgsDict',
    'FirmwareUpgradesProductsApplianceAvailableVersionArgs',
    'FirmwareUpgradesProductsApplianceAvailableVersionArgsDict',
    'FirmwareUpgradesProductsApplianceCurrentVersionArgs',
    'FirmwareUpgradesProductsApplianceCurrentVersionArgsDict',
    'FirmwareUpgradesProductsApplianceLastUpgradeArgs',
    'FirmwareUpgradesProductsApplianceLastUpgradeArgsDict',
    'FirmwareUpgradesProductsApplianceLastUpgradeFromVersionArgs',
    'FirmwareUpgradesProductsApplianceLastUpgradeFromVersionArgsDict',
    'FirmwareUpgradesProductsApplianceLastUpgradeToVersionArgs',
    'FirmwareUpgradesProductsApplianceLastUpgradeToVersionArgsDict',
    'FirmwareUpgradesProductsApplianceNextUpgradeArgs',
    'FirmwareUpgradesProductsApplianceNextUpgradeArgsDict',
    'FirmwareUpgradesProductsApplianceNextUpgradeToVersionArgs',
    'FirmwareUpgradesProductsApplianceNextUpgradeToVersionArgsDict',
    'FirmwareUpgradesProductsCameraArgs',
    'FirmwareUpgradesProductsCameraArgsDict',
    'FirmwareUpgradesProductsCameraAvailableVersionArgs',
    'FirmwareUpgradesProductsCameraAvailableVersionArgsDict',
    'FirmwareUpgradesProductsCameraCurrentVersionArgs',
    'FirmwareUpgradesProductsCameraCurrentVersionArgsDict',
    'FirmwareUpgradesProductsCameraLastUpgradeArgs',
    'FirmwareUpgradesProductsCameraLastUpgradeArgsDict',
    'FirmwareUpgradesProductsCameraLastUpgradeFromVersionArgs',
    'FirmwareUpgradesProductsCameraLastUpgradeFromVersionArgsDict',
    'FirmwareUpgradesProductsCameraLastUpgradeToVersionArgs',
    'FirmwareUpgradesProductsCameraLastUpgradeToVersionArgsDict',
    'FirmwareUpgradesProductsCameraNextUpgradeArgs',
    'FirmwareUpgradesProductsCameraNextUpgradeArgsDict',
    'FirmwareUpgradesProductsCameraNextUpgradeToVersionArgs',
    'FirmwareUpgradesProductsCameraNextUpgradeToVersionArgsDict',
    'FirmwareUpgradesProductsCellularGatewayArgs',
    'FirmwareUpgradesProductsCellularGatewayArgsDict',
    'FirmwareUpgradesProductsCellularGatewayAvailableVersionArgs',
    'FirmwareUpgradesProductsCellularGatewayAvailableVersionArgsDict',
    'FirmwareUpgradesProductsCellularGatewayCurrentVersionArgs',
    'FirmwareUpgradesProductsCellularGatewayCurrentVersionArgsDict',
    'FirmwareUpgradesProductsCellularGatewayLastUpgradeArgs',
    'FirmwareUpgradesProductsCellularGatewayLastUpgradeArgsDict',
    'FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersionArgs',
    'FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersionArgsDict',
    'FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersionArgs',
    'FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersionArgsDict',
    'FirmwareUpgradesProductsCellularGatewayNextUpgradeArgs',
    'FirmwareUpgradesProductsCellularGatewayNextUpgradeArgsDict',
    'FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersionArgs',
    'FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersionArgsDict',
    'FirmwareUpgradesProductsSensorArgs',
    'FirmwareUpgradesProductsSensorArgsDict',
    'FirmwareUpgradesProductsSensorAvailableVersionArgs',
    'FirmwareUpgradesProductsSensorAvailableVersionArgsDict',
    'FirmwareUpgradesProductsSensorCurrentVersionArgs',
    'FirmwareUpgradesProductsSensorCurrentVersionArgsDict',
    'FirmwareUpgradesProductsSensorLastUpgradeArgs',
    'FirmwareUpgradesProductsSensorLastUpgradeArgsDict',
    'FirmwareUpgradesProductsSensorLastUpgradeFromVersionArgs',
    'FirmwareUpgradesProductsSensorLastUpgradeFromVersionArgsDict',
    'FirmwareUpgradesProductsSensorLastUpgradeToVersionArgs',
    'FirmwareUpgradesProductsSensorLastUpgradeToVersionArgsDict',
    'FirmwareUpgradesProductsSensorNextUpgradeArgs',
    'FirmwareUpgradesProductsSensorNextUpgradeArgsDict',
    'FirmwareUpgradesProductsSensorNextUpgradeToVersionArgs',
    'FirmwareUpgradesProductsSensorNextUpgradeToVersionArgsDict',
    'FirmwareUpgradesProductsSwitchArgs',
    'FirmwareUpgradesProductsSwitchArgsDict',
    'FirmwareUpgradesProductsSwitchAvailableVersionArgs',
    'FirmwareUpgradesProductsSwitchAvailableVersionArgsDict',
    'FirmwareUpgradesProductsSwitchCatalystArgs',
    'FirmwareUpgradesProductsSwitchCatalystArgsDict',
    'FirmwareUpgradesProductsSwitchCatalystNextUpgradeArgs',
    'FirmwareUpgradesProductsSwitchCatalystNextUpgradeArgsDict',
    'FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersionArgs',
    'FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersionArgsDict',
    'FirmwareUpgradesProductsSwitchCurrentVersionArgs',
    'FirmwareUpgradesProductsSwitchCurrentVersionArgsDict',
    'FirmwareUpgradesProductsSwitchLastUpgradeArgs',
    'FirmwareUpgradesProductsSwitchLastUpgradeArgsDict',
    'FirmwareUpgradesProductsSwitchLastUpgradeFromVersionArgs',
    'FirmwareUpgradesProductsSwitchLastUpgradeFromVersionArgsDict',
    'FirmwareUpgradesProductsSwitchLastUpgradeToVersionArgs',
    'FirmwareUpgradesProductsSwitchLastUpgradeToVersionArgsDict',
    'FirmwareUpgradesProductsSwitchNextUpgradeArgs',
    'FirmwareUpgradesProductsSwitchNextUpgradeArgsDict',
    'FirmwareUpgradesProductsSwitchNextUpgradeToVersionArgs',
    'FirmwareUpgradesProductsSwitchNextUpgradeToVersionArgsDict',
    'FirmwareUpgradesProductsWirelessArgs',
    'FirmwareUpgradesProductsWirelessArgsDict',
    'FirmwareUpgradesProductsWirelessAvailableVersionArgs',
    'FirmwareUpgradesProductsWirelessAvailableVersionArgsDict',
    'FirmwareUpgradesProductsWirelessCurrentVersionArgs',
    'FirmwareUpgradesProductsWirelessCurrentVersionArgsDict',
    'FirmwareUpgradesProductsWirelessLastUpgradeArgs',
    'FirmwareUpgradesProductsWirelessLastUpgradeArgsDict',
    'FirmwareUpgradesProductsWirelessLastUpgradeFromVersionArgs',
    'FirmwareUpgradesProductsWirelessLastUpgradeFromVersionArgsDict',
    'FirmwareUpgradesProductsWirelessLastUpgradeToVersionArgs',
    'FirmwareUpgradesProductsWirelessLastUpgradeToVersionArgsDict',
    'FirmwareUpgradesProductsWirelessNextUpgradeArgs',
    'FirmwareUpgradesProductsWirelessNextUpgradeArgsDict',
    'FirmwareUpgradesProductsWirelessNextUpgradeToVersionArgs',
    'FirmwareUpgradesProductsWirelessNextUpgradeToVersionArgsDict',
    'FirmwareUpgradesRollbacksItemArgs',
    'FirmwareUpgradesRollbacksItemArgsDict',
    'FirmwareUpgradesRollbacksItemReasonArgs',
    'FirmwareUpgradesRollbacksItemReasonArgsDict',
    'FirmwareUpgradesRollbacksItemToVersionArgs',
    'FirmwareUpgradesRollbacksItemToVersionArgsDict',
    'FirmwareUpgradesRollbacksParametersArgs',
    'FirmwareUpgradesRollbacksParametersArgsDict',
    'FirmwareUpgradesRollbacksParametersReasonArgs',
    'FirmwareUpgradesRollbacksParametersReasonArgsDict',
    'FirmwareUpgradesRollbacksParametersToVersionArgs',
    'FirmwareUpgradesRollbacksParametersToVersionArgsDict',
    'FirmwareUpgradesStagedEventsDeferItemArgs',
    'FirmwareUpgradesStagedEventsDeferItemArgsDict',
    'FirmwareUpgradesStagedEventsDeferItemProductsArgs',
    'FirmwareUpgradesStagedEventsDeferItemProductsArgsDict',
    'FirmwareUpgradesStagedEventsDeferItemProductsSwitchArgs',
    'FirmwareUpgradesStagedEventsDeferItemProductsSwitchArgsDict',
    'FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeArgs',
    'FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeArgsDict',
    'FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersionArgs',
    'FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersionArgsDict',
    'FirmwareUpgradesStagedEventsDeferItemReasonArgs',
    'FirmwareUpgradesStagedEventsDeferItemReasonArgsDict',
    'FirmwareUpgradesStagedEventsDeferItemStageArgs',
    'FirmwareUpgradesStagedEventsDeferItemStageArgsDict',
    'FirmwareUpgradesStagedEventsDeferItemStageGroupArgs',
    'FirmwareUpgradesStagedEventsDeferItemStageGroupArgsDict',
    'FirmwareUpgradesStagedEventsDeferItemStageMilestonesArgs',
    'FirmwareUpgradesStagedEventsDeferItemStageMilestonesArgsDict',
    'FirmwareUpgradesStagedEventsProductsArgs',
    'FirmwareUpgradesStagedEventsProductsArgsDict',
    'FirmwareUpgradesStagedEventsProductsSwitchArgs',
    'FirmwareUpgradesStagedEventsProductsSwitchArgsDict',
    'FirmwareUpgradesStagedEventsProductsSwitchCatalystArgs',
    'FirmwareUpgradesStagedEventsProductsSwitchCatalystArgsDict',
    'FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeArgs',
    'FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeArgsDict',
    'FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersionArgs',
    'FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersionArgsDict',
    'FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeArgs',
    'FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeArgsDict',
    'FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersionArgs',
    'FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersionArgsDict',
    'FirmwareUpgradesStagedEventsReasonArgs',
    'FirmwareUpgradesStagedEventsReasonArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksItemArgs',
    'FirmwareUpgradesStagedEventsRollbacksItemArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksItemProductsArgs',
    'FirmwareUpgradesStagedEventsRollbacksItemProductsArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchArgs',
    'FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeArgs',
    'FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersionArgs',
    'FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersionArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksItemReasonArgs',
    'FirmwareUpgradesStagedEventsRollbacksItemReasonArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksItemStageArgs',
    'FirmwareUpgradesStagedEventsRollbacksItemStageArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksItemStageGroupArgs',
    'FirmwareUpgradesStagedEventsRollbacksItemStageGroupArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksItemStageMilestonesArgs',
    'FirmwareUpgradesStagedEventsRollbacksItemStageMilestonesArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksParametersArgs',
    'FirmwareUpgradesStagedEventsRollbacksParametersArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksParametersReasonArgs',
    'FirmwareUpgradesStagedEventsRollbacksParametersReasonArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksParametersStageArgs',
    'FirmwareUpgradesStagedEventsRollbacksParametersStageArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksParametersStageGroupArgs',
    'FirmwareUpgradesStagedEventsRollbacksParametersStageGroupArgsDict',
    'FirmwareUpgradesStagedEventsRollbacksParametersStageMilestonesArgs',
    'FirmwareUpgradesStagedEventsRollbacksParametersStageMilestonesArgsDict',
    'FirmwareUpgradesStagedEventsStageArgs',
    'FirmwareUpgradesStagedEventsStageArgsDict',
    'FirmwareUpgradesStagedEventsStageGroupArgs',
    'FirmwareUpgradesStagedEventsStageGroupArgsDict',
    'FirmwareUpgradesStagedEventsStageMilestonesArgs',
    'FirmwareUpgradesStagedEventsStageMilestonesArgsDict',
    'FirmwareUpgradesStagedGroupsAssignedDevicesArgs',
    'FirmwareUpgradesStagedGroupsAssignedDevicesArgsDict',
    'FirmwareUpgradesStagedGroupsAssignedDevicesDeviceArgs',
    'FirmwareUpgradesStagedGroupsAssignedDevicesDeviceArgsDict',
    'FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStackArgs',
    'FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStackArgsDict',
    'FirmwareUpgradesStagedStagesGroupArgs',
    'FirmwareUpgradesStagedStagesGroupArgsDict',
    'FirmwareUpgradesStagedStagesJsonArgs',
    'FirmwareUpgradesStagedStagesJsonArgsDict',
    'FirmwareUpgradesStagedStagesJsonGroupArgs',
    'FirmwareUpgradesStagedStagesJsonGroupArgsDict',
    'FirmwareUpgradesUpgradeWindowArgs',
    'FirmwareUpgradesUpgradeWindowArgsDict',
    'FloorPlansBottomLeftCornerArgs',
    'FloorPlansBottomLeftCornerArgsDict',
    'FloorPlansBottomRightCornerArgs',
    'FloorPlansBottomRightCornerArgsDict',
    'FloorPlansCenterArgs',
    'FloorPlansCenterArgsDict',
    'FloorPlansDeviceArgs',
    'FloorPlansDeviceArgsDict',
    'FloorPlansDeviceDetailArgs',
    'FloorPlansDeviceDetailArgsDict',
    'FloorPlansTopLeftCornerArgs',
    'FloorPlansTopLeftCornerArgsDict',
    'FloorPlansTopRightCornerArgs',
    'FloorPlansTopRightCornerArgsDict',
    'GroupPoliciesBandwidthArgs',
    'GroupPoliciesBandwidthArgsDict',
    'GroupPoliciesBandwidthBandwidthLimitsArgs',
    'GroupPoliciesBandwidthBandwidthLimitsArgsDict',
    'GroupPoliciesBonjourForwardingArgs',
    'GroupPoliciesBonjourForwardingArgsDict',
    'GroupPoliciesBonjourForwardingRuleArgs',
    'GroupPoliciesBonjourForwardingRuleArgsDict',
    'GroupPoliciesContentFilteringArgs',
    'GroupPoliciesContentFilteringArgsDict',
    'GroupPoliciesContentFilteringAllowedUrlPatternsArgs',
    'GroupPoliciesContentFilteringAllowedUrlPatternsArgsDict',
    'GroupPoliciesContentFilteringBlockedUrlCategoriesArgs',
    'GroupPoliciesContentFilteringBlockedUrlCategoriesArgsDict',
    'GroupPoliciesContentFilteringBlockedUrlPatternsArgs',
    'GroupPoliciesContentFilteringBlockedUrlPatternsArgsDict',
    'GroupPoliciesFirewallAndTrafficShapingArgs',
    'GroupPoliciesFirewallAndTrafficShapingArgsDict',
    'GroupPoliciesFirewallAndTrafficShapingL3FirewallRuleArgs',
    'GroupPoliciesFirewallAndTrafficShapingL3FirewallRuleArgsDict',
    'GroupPoliciesFirewallAndTrafficShapingL7FirewallRuleArgs',
    'GroupPoliciesFirewallAndTrafficShapingL7FirewallRuleArgsDict',
    'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleArgs',
    'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleArgsDict',
    'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinitionArgs',
    'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinitionArgsDict',
    'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsArgs',
    'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsArgsDict',
    'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsArgs',
    'GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsArgsDict',
    'GroupPoliciesSchedulingArgs',
    'GroupPoliciesSchedulingArgsDict',
    'GroupPoliciesSchedulingFridayArgs',
    'GroupPoliciesSchedulingFridayArgsDict',
    'GroupPoliciesSchedulingMondayArgs',
    'GroupPoliciesSchedulingMondayArgsDict',
    'GroupPoliciesSchedulingSaturdayArgs',
    'GroupPoliciesSchedulingSaturdayArgsDict',
    'GroupPoliciesSchedulingSundayArgs',
    'GroupPoliciesSchedulingSundayArgsDict',
    'GroupPoliciesSchedulingThursdayArgs',
    'GroupPoliciesSchedulingThursdayArgsDict',
    'GroupPoliciesSchedulingTuesdayArgs',
    'GroupPoliciesSchedulingTuesdayArgsDict',
    'GroupPoliciesSchedulingWednesdayArgs',
    'GroupPoliciesSchedulingWednesdayArgsDict',
    'GroupPoliciesVlanTaggingArgs',
    'GroupPoliciesVlanTaggingArgsDict',
    'MerakiAuthUsersAuthorizationArgs',
    'MerakiAuthUsersAuthorizationArgsDict',
    'MqttBrokersItemArgs',
    'MqttBrokersItemArgsDict',
    'MqttBrokersItemAuthenticationArgs',
    'MqttBrokersItemAuthenticationArgsDict',
    'MqttBrokersItemSecurityArgs',
    'MqttBrokersItemSecurityArgsDict',
    'MqttBrokersItemSecurityTlsArgs',
    'MqttBrokersItemSecurityTlsArgsDict',
    'MqttBrokersParametersArgs',
    'MqttBrokersParametersArgsDict',
    'MqttBrokersParametersAuthenticationArgs',
    'MqttBrokersParametersAuthenticationArgsDict',
    'MqttBrokersParametersSecurityArgs',
    'MqttBrokersParametersSecurityArgsDict',
    'MqttBrokersParametersSecurityTlsArgs',
    'MqttBrokersParametersSecurityTlsArgsDict',
    'SensorAlertsProfilesConditionArgs',
    'SensorAlertsProfilesConditionArgsDict',
    'SensorAlertsProfilesConditionThresholdArgs',
    'SensorAlertsProfilesConditionThresholdArgsDict',
    'SensorAlertsProfilesConditionThresholdApparentPowerArgs',
    'SensorAlertsProfilesConditionThresholdApparentPowerArgsDict',
    'SensorAlertsProfilesConditionThresholdCurrentArgs',
    'SensorAlertsProfilesConditionThresholdCurrentArgsDict',
    'SensorAlertsProfilesConditionThresholdDoorArgs',
    'SensorAlertsProfilesConditionThresholdDoorArgsDict',
    'SensorAlertsProfilesConditionThresholdFrequencyArgs',
    'SensorAlertsProfilesConditionThresholdFrequencyArgsDict',
    'SensorAlertsProfilesConditionThresholdHumidityArgs',
    'SensorAlertsProfilesConditionThresholdHumidityArgsDict',
    'SensorAlertsProfilesConditionThresholdIndoorAirQualityArgs',
    'SensorAlertsProfilesConditionThresholdIndoorAirQualityArgsDict',
    'SensorAlertsProfilesConditionThresholdNoiseArgs',
    'SensorAlertsProfilesConditionThresholdNoiseArgsDict',
    'SensorAlertsProfilesConditionThresholdNoiseAmbientArgs',
    'SensorAlertsProfilesConditionThresholdNoiseAmbientArgsDict',
    'SensorAlertsProfilesConditionThresholdPm25Args',
    'SensorAlertsProfilesConditionThresholdPm25ArgsDict',
    'SensorAlertsProfilesConditionThresholdPowerFactorArgs',
    'SensorAlertsProfilesConditionThresholdPowerFactorArgsDict',
    'SensorAlertsProfilesConditionThresholdRealPowerArgs',
    'SensorAlertsProfilesConditionThresholdRealPowerArgsDict',
    'SensorAlertsProfilesConditionThresholdTemperatureArgs',
    'SensorAlertsProfilesConditionThresholdTemperatureArgsDict',
    'SensorAlertsProfilesConditionThresholdTvocArgs',
    'SensorAlertsProfilesConditionThresholdTvocArgsDict',
    'SensorAlertsProfilesConditionThresholdUpstreamPowerArgs',
    'SensorAlertsProfilesConditionThresholdUpstreamPowerArgsDict',
    'SensorAlertsProfilesConditionThresholdVoltageArgs',
    'SensorAlertsProfilesConditionThresholdVoltageArgsDict',
    'SensorAlertsProfilesConditionThresholdWaterArgs',
    'SensorAlertsProfilesConditionThresholdWaterArgsDict',
    'SensorAlertsProfilesConditionsResponseArgs',
    'SensorAlertsProfilesConditionsResponseArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdArgs',
    'SensorAlertsProfilesConditionsResponseThresholdArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdApparentPowerArgs',
    'SensorAlertsProfilesConditionsResponseThresholdApparentPowerArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdCurrentArgs',
    'SensorAlertsProfilesConditionsResponseThresholdCurrentArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdDoorArgs',
    'SensorAlertsProfilesConditionsResponseThresholdDoorArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdFrequencyArgs',
    'SensorAlertsProfilesConditionsResponseThresholdFrequencyArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdHumidityArgs',
    'SensorAlertsProfilesConditionsResponseThresholdHumidityArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdIndoorAirQualityArgs',
    'SensorAlertsProfilesConditionsResponseThresholdIndoorAirQualityArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdNoiseArgs',
    'SensorAlertsProfilesConditionsResponseThresholdNoiseArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdNoiseAmbientArgs',
    'SensorAlertsProfilesConditionsResponseThresholdNoiseAmbientArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdPm25Args',
    'SensorAlertsProfilesConditionsResponseThresholdPm25ArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdPowerFactorArgs',
    'SensorAlertsProfilesConditionsResponseThresholdPowerFactorArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdRealPowerArgs',
    'SensorAlertsProfilesConditionsResponseThresholdRealPowerArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdTemperatureArgs',
    'SensorAlertsProfilesConditionsResponseThresholdTemperatureArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdTvocArgs',
    'SensorAlertsProfilesConditionsResponseThresholdTvocArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdUpstreamPowerArgs',
    'SensorAlertsProfilesConditionsResponseThresholdUpstreamPowerArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdVoltageArgs',
    'SensorAlertsProfilesConditionsResponseThresholdVoltageArgsDict',
    'SensorAlertsProfilesConditionsResponseThresholdWaterArgs',
    'SensorAlertsProfilesConditionsResponseThresholdWaterArgsDict',
    'SensorAlertsProfilesRecipientsArgs',
    'SensorAlertsProfilesRecipientsArgsDict',
    'SensorAlertsProfilesScheduleArgs',
    'SensorAlertsProfilesScheduleArgsDict',
    'SettingsFipsArgs',
    'SettingsFipsArgsDict',
    'SettingsLocalStatusPageArgs',
    'SettingsLocalStatusPageArgsDict',
    'SettingsLocalStatusPageAuthenticationArgs',
    'SettingsLocalStatusPageAuthenticationArgsDict',
    'SettingsNamedVlansArgs',
    'SettingsNamedVlansArgsDict',
    'SettingsSecurePortArgs',
    'SettingsSecurePortArgsDict',
    'SmBypassActivationLockAttemptsDataArgs',
    'SmBypassActivationLockAttemptsDataArgsDict',
    'SmBypassActivationLockAttemptsDataStatus2090938209Args',
    'SmBypassActivationLockAttemptsDataStatus2090938209ArgsDict',
    'SmBypassActivationLockAttemptsDataStatus38290139892Args',
    'SmBypassActivationLockAttemptsDataStatus38290139892ArgsDict',
    'SmDevicesCheckinItemArgs',
    'SmDevicesCheckinItemArgsDict',
    'SmDevicesCheckinParametersArgs',
    'SmDevicesCheckinParametersArgsDict',
    'SmDevicesFieldsItemArgs',
    'SmDevicesFieldsItemArgsDict',
    'SmDevicesFieldsParametersArgs',
    'SmDevicesFieldsParametersArgsDict',
    'SmDevicesFieldsParametersDeviceFieldsArgs',
    'SmDevicesFieldsParametersDeviceFieldsArgsDict',
    'SmDevicesInstallAppsParametersArgs',
    'SmDevicesInstallAppsParametersArgsDict',
    'SmDevicesLockItemArgs',
    'SmDevicesLockItemArgsDict',
    'SmDevicesLockParametersArgs',
    'SmDevicesLockParametersArgsDict',
    'SmDevicesModifyTagsItemArgs',
    'SmDevicesModifyTagsItemArgsDict',
    'SmDevicesModifyTagsParametersArgs',
    'SmDevicesModifyTagsParametersArgsDict',
    'SmDevicesMoveItemArgs',
    'SmDevicesMoveItemArgsDict',
    'SmDevicesMoveParametersArgs',
    'SmDevicesMoveParametersArgsDict',
    'SmDevicesRebootItemArgs',
    'SmDevicesRebootItemArgsDict',
    'SmDevicesRebootParametersArgs',
    'SmDevicesRebootParametersArgsDict',
    'SmDevicesShutdownItemArgs',
    'SmDevicesShutdownItemArgsDict',
    'SmDevicesShutdownParametersArgs',
    'SmDevicesShutdownParametersArgsDict',
    'SmDevicesUnenrollItemArgs',
    'SmDevicesUnenrollItemArgsDict',
    'SmDevicesUninstallAppsParametersArgs',
    'SmDevicesUninstallAppsParametersArgsDict',
    'SmDevicesWipeItemArgs',
    'SmDevicesWipeItemArgsDict',
    'SmDevicesWipeParametersArgs',
    'SmDevicesWipeParametersArgsDict',
    'SnmpUserArgs',
    'SnmpUserArgsDict',
    'SplitItemArgs',
    'SplitItemArgsDict',
    'SplitItemResultingNetworkArgs',
    'SplitItemResultingNetworkArgsDict',
    'SwitchAccessControlListsRuleArgs',
    'SwitchAccessControlListsRuleArgsDict',
    'SwitchAccessControlListsRulesResponseArgs',
    'SwitchAccessControlListsRulesResponseArgsDict',
    'SwitchAccessPoliciesCountsArgs',
    'SwitchAccessPoliciesCountsArgsDict',
    'SwitchAccessPoliciesCountsPortsArgs',
    'SwitchAccessPoliciesCountsPortsArgsDict',
    'SwitchAccessPoliciesDot1xArgs',
    'SwitchAccessPoliciesDot1xArgsDict',
    'SwitchAccessPoliciesRadiusArgs',
    'SwitchAccessPoliciesRadiusArgsDict',
    'SwitchAccessPoliciesRadiusAccountingServerArgs',
    'SwitchAccessPoliciesRadiusAccountingServerArgsDict',
    'SwitchAccessPoliciesRadiusAccountingServersResponseArgs',
    'SwitchAccessPoliciesRadiusAccountingServersResponseArgsDict',
    'SwitchAccessPoliciesRadiusCriticalAuthArgs',
    'SwitchAccessPoliciesRadiusCriticalAuthArgsDict',
    'SwitchAccessPoliciesRadiusServerArgs',
    'SwitchAccessPoliciesRadiusServerArgsDict',
    'SwitchAccessPoliciesRadiusServersResponseArgs',
    'SwitchAccessPoliciesRadiusServersResponseArgsDict',
    'SwitchAlternateManagementInterfaceSwitchArgs',
    'SwitchAlternateManagementInterfaceSwitchArgsDict',
    'SwitchDhcpServerPolicyAlertsArgs',
    'SwitchDhcpServerPolicyAlertsArgsDict',
    'SwitchDhcpServerPolicyAlertsEmailArgs',
    'SwitchDhcpServerPolicyAlertsEmailArgsDict',
    'SwitchDhcpServerPolicyArpInspectionArgs',
    'SwitchDhcpServerPolicyArpInspectionArgsDict',
    'SwitchDhcpServerPolicyArpInspectionTrustedServersIpv4Args',
    'SwitchDhcpServerPolicyArpInspectionTrustedServersIpv4ArgsDict',
    'SwitchDscpToCosMappingsMappingArgs',
    'SwitchDscpToCosMappingsMappingArgsDict',
    'SwitchLinkAggregationsSwitchPortArgs',
    'SwitchLinkAggregationsSwitchPortArgsDict',
    'SwitchLinkAggregationsSwitchProfilePortArgs',
    'SwitchLinkAggregationsSwitchProfilePortArgsDict',
    'SwitchMtuOverrideArgs',
    'SwitchMtuOverrideArgsDict',
    'SwitchPortSchedulesPortScheduleArgs',
    'SwitchPortSchedulesPortScheduleArgsDict',
    'SwitchPortSchedulesPortScheduleFridayArgs',
    'SwitchPortSchedulesPortScheduleFridayArgsDict',
    'SwitchPortSchedulesPortScheduleMondayArgs',
    'SwitchPortSchedulesPortScheduleMondayArgsDict',
    'SwitchPortSchedulesPortScheduleSaturdayArgs',
    'SwitchPortSchedulesPortScheduleSaturdayArgsDict',
    'SwitchPortSchedulesPortScheduleSundayArgs',
    'SwitchPortSchedulesPortScheduleSundayArgsDict',
    'SwitchPortSchedulesPortScheduleThursdayArgs',
    'SwitchPortSchedulesPortScheduleThursdayArgsDict',
    'SwitchPortSchedulesPortScheduleTuesdayArgs',
    'SwitchPortSchedulesPortScheduleTuesdayArgsDict',
    'SwitchPortSchedulesPortScheduleWednesdayArgs',
    'SwitchPortSchedulesPortScheduleWednesdayArgsDict',
    'SwitchRoutingMulticastDefaultSettingsArgs',
    'SwitchRoutingMulticastDefaultSettingsArgsDict',
    'SwitchRoutingMulticastOverrideArgs',
    'SwitchRoutingMulticastOverrideArgsDict',
    'SwitchRoutingOspfAreaArgs',
    'SwitchRoutingOspfAreaArgsDict',
    'SwitchRoutingOspfMd5AuthenticationKeyArgs',
    'SwitchRoutingOspfMd5AuthenticationKeyArgsDict',
    'SwitchRoutingOspfV3Args',
    'SwitchRoutingOspfV3ArgsDict',
    'SwitchRoutingOspfV3AreaArgs',
    'SwitchRoutingOspfV3AreaArgsDict',
    'SwitchSettingsMacBlocklistArgs',
    'SwitchSettingsMacBlocklistArgsDict',
    'SwitchSettingsPowerExceptionArgs',
    'SwitchSettingsPowerExceptionArgsDict',
    'SwitchSettingsUplinkClientSamplingArgs',
    'SwitchSettingsUplinkClientSamplingArgsDict',
    'SwitchStacksAddItemArgs',
    'SwitchStacksAddItemArgsDict',
    'SwitchStacksAddParametersArgs',
    'SwitchStacksAddParametersArgsDict',
    'SwitchStacksRemoveItemArgs',
    'SwitchStacksRemoveItemArgsDict',
    'SwitchStacksRemoveParametersArgs',
    'SwitchStacksRemoveParametersArgsDict',
    'SwitchStacksRoutingInterfacesDhcpDhcpOptionArgs',
    'SwitchStacksRoutingInterfacesDhcpDhcpOptionArgsDict',
    'SwitchStacksRoutingInterfacesDhcpFixedIpAssignmentArgs',
    'SwitchStacksRoutingInterfacesDhcpFixedIpAssignmentArgsDict',
    'SwitchStacksRoutingInterfacesDhcpReservedIpRangeArgs',
    'SwitchStacksRoutingInterfacesDhcpReservedIpRangeArgsDict',
    'SwitchStacksRoutingInterfacesIpv6Args',
    'SwitchStacksRoutingInterfacesIpv6ArgsDict',
    'SwitchStacksRoutingInterfacesOspfSettingsArgs',
    'SwitchStacksRoutingInterfacesOspfSettingsArgsDict',
    'SwitchStacksRoutingInterfacesOspfV3Args',
    'SwitchStacksRoutingInterfacesOspfV3ArgsDict',
    'SwitchStpStpBridgePriorityArgs',
    'SwitchStpStpBridgePriorityArgsDict',
    'SwitchStpStpBridgePriorityResponseArgs',
    'SwitchStpStpBridgePriorityResponseArgsDict',
    'SyslogServersServerArgs',
    'SyslogServersServerArgsDict',
    'TrafficAnalysisCustomPieChartItemArgs',
    'TrafficAnalysisCustomPieChartItemArgsDict',
    'UnbindItemArgs',
    'UnbindItemArgsDict',
    'UnbindParametersArgs',
    'UnbindParametersArgsDict',
    'VlanProfilesAssignmentsReassignItemArgs',
    'VlanProfilesAssignmentsReassignItemArgsDict',
    'VlanProfilesAssignmentsReassignItemVlanProfileArgs',
    'VlanProfilesAssignmentsReassignItemVlanProfileArgsDict',
    'VlanProfilesAssignmentsReassignParametersArgs',
    'VlanProfilesAssignmentsReassignParametersArgsDict',
    'VlanProfilesAssignmentsReassignParametersVlanProfileArgs',
    'VlanProfilesAssignmentsReassignParametersVlanProfileArgsDict',
    'VlanProfilesVlanGroupArgs',
    'VlanProfilesVlanGroupArgsDict',
    'VlanProfilesVlanNameArgs',
    'VlanProfilesVlanNameArgsDict',
    'VlanProfilesVlanNameAdaptivePolicyGroupArgs',
    'VlanProfilesVlanNameAdaptivePolicyGroupArgsDict',
    'WebhooksHttpServersPayloadTemplateArgs',
    'WebhooksHttpServersPayloadTemplateArgsDict',
    'WebhooksPayloadTemplatesHeaderArgs',
    'WebhooksPayloadTemplatesHeaderArgsDict',
    'WebhooksPayloadTemplatesSharingArgs',
    'WebhooksPayloadTemplatesSharingArgsDict',
    'WebhooksPayloadTemplatesSharingByNetworkArgs',
    'WebhooksPayloadTemplatesSharingByNetworkArgsDict',
    'WirelessAlternateManagementInterfaceAccessPointArgs',
    'WirelessAlternateManagementInterfaceAccessPointArgsDict',
    'WirelessBillingPlanArgs',
    'WirelessBillingPlanArgsDict',
    'WirelessBillingPlanBandwidthLimitsArgs',
    'WirelessBillingPlanBandwidthLimitsArgsDict',
    'WirelessEthernetPortsProfilesAssignItemArgs',
    'WirelessEthernetPortsProfilesAssignItemArgsDict',
    'WirelessEthernetPortsProfilesAssignParametersArgs',
    'WirelessEthernetPortsProfilesAssignParametersArgsDict',
    'WirelessEthernetPortsProfilesPortArgs',
    'WirelessEthernetPortsProfilesPortArgsDict',
    'WirelessEthernetPortsProfilesSetDefaultItemArgs',
    'WirelessEthernetPortsProfilesSetDefaultItemArgsDict',
    'WirelessEthernetPortsProfilesSetDefaultParametersArgs',
    'WirelessEthernetPortsProfilesSetDefaultParametersArgsDict',
    'WirelessEthernetPortsProfilesUsbPortArgs',
    'WirelessEthernetPortsProfilesUsbPortArgsDict',
    'WirelessRfProfilesApBandSettingsArgs',
    'WirelessRfProfilesApBandSettingsArgsDict',
    'WirelessRfProfilesApBandSettingsBandsArgs',
    'WirelessRfProfilesApBandSettingsBandsArgsDict',
    'WirelessRfProfilesFiveGhzSettingsArgs',
    'WirelessRfProfilesFiveGhzSettingsArgsDict',
    'WirelessRfProfilesFlexRadiosArgs',
    'WirelessRfProfilesFlexRadiosArgsDict',
    'WirelessRfProfilesFlexRadiosByModelArgs',
    'WirelessRfProfilesFlexRadiosByModelArgsDict',
    'WirelessRfProfilesPerSsidSettingsArgs',
    'WirelessRfProfilesPerSsidSettingsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus0Args',
    'WirelessRfProfilesPerSsidSettingsStatus0ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus0BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus0BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus10Args',
    'WirelessRfProfilesPerSsidSettingsStatus10ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus10BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus10BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus11Args',
    'WirelessRfProfilesPerSsidSettingsStatus11ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus11BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus11BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus12Args',
    'WirelessRfProfilesPerSsidSettingsStatus12ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus12BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus12BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus13Args',
    'WirelessRfProfilesPerSsidSettingsStatus13ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus13BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus13BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus14Args',
    'WirelessRfProfilesPerSsidSettingsStatus14ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus14BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus14BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus1Args',
    'WirelessRfProfilesPerSsidSettingsStatus1ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus1BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus1BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus2Args',
    'WirelessRfProfilesPerSsidSettingsStatus2ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus2BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus2BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus3Args',
    'WirelessRfProfilesPerSsidSettingsStatus3ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus3BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus3BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus4Args',
    'WirelessRfProfilesPerSsidSettingsStatus4ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus4BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus4BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus5Args',
    'WirelessRfProfilesPerSsidSettingsStatus5ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus5BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus5BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus6Args',
    'WirelessRfProfilesPerSsidSettingsStatus6ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus6BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus6BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus7Args',
    'WirelessRfProfilesPerSsidSettingsStatus7ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus7BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus7BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus8Args',
    'WirelessRfProfilesPerSsidSettingsStatus8ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus8BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus8BandsArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus9Args',
    'WirelessRfProfilesPerSsidSettingsStatus9ArgsDict',
    'WirelessRfProfilesPerSsidSettingsStatus9BandsArgs',
    'WirelessRfProfilesPerSsidSettingsStatus9BandsArgsDict',
    'WirelessRfProfilesSixGhzSettingsArgs',
    'WirelessRfProfilesSixGhzSettingsArgsDict',
    'WirelessRfProfilesTransmissionArgs',
    'WirelessRfProfilesTransmissionArgsDict',
    'WirelessRfProfilesTwoFourGhzSettingsArgs',
    'WirelessRfProfilesTwoFourGhzSettingsArgsDict',
    'WirelessSettingsNamedVlansArgs',
    'WirelessSettingsNamedVlansArgsDict',
    'WirelessSettingsNamedVlansPoolDhcpMonitoringArgs',
    'WirelessSettingsNamedVlansPoolDhcpMonitoringArgsDict',
    'WirelessSettingsRegulatoryDomainArgs',
    'WirelessSettingsRegulatoryDomainArgsDict',
    'WirelessSsidsActiveDirectoryArgs',
    'WirelessSsidsActiveDirectoryArgsDict',
    'WirelessSsidsActiveDirectoryCredentialsArgs',
    'WirelessSsidsActiveDirectoryCredentialsArgsDict',
    'WirelessSsidsActiveDirectoryServerArgs',
    'WirelessSsidsActiveDirectoryServerArgsDict',
    'WirelessSsidsApTagsAndVlanIdArgs',
    'WirelessSsidsApTagsAndVlanIdArgsDict',
    'WirelessSsidsBonjourForwardingExceptionArgs',
    'WirelessSsidsBonjourForwardingExceptionArgsDict',
    'WirelessSsidsBonjourForwardingRuleArgs',
    'WirelessSsidsBonjourForwardingRuleArgsDict',
    'WirelessSsidsDeviceTypeGroupPoliciesDeviceTypePolicyArgs',
    'WirelessSsidsDeviceTypeGroupPoliciesDeviceTypePolicyArgsDict',
    'WirelessSsidsDnsRewriteArgs',
    'WirelessSsidsDnsRewriteArgsDict',
    'WirelessSsidsDot11rArgs',
    'WirelessSsidsDot11rArgsDict',
    'WirelessSsidsDot11wArgs',
    'WirelessSsidsDot11wArgsDict',
    'WirelessSsidsEapOverrideEapolKeyArgs',
    'WirelessSsidsEapOverrideEapolKeyArgsDict',
    'WirelessSsidsEapOverrideIdentityArgs',
    'WirelessSsidsEapOverrideIdentityArgsDict',
    'WirelessSsidsFirewallL3FirewallRulesRuleArgs',
    'WirelessSsidsFirewallL3FirewallRulesRuleArgsDict',
    'WirelessSsidsFirewallL3FirewallRulesRulesResponseArgs',
    'WirelessSsidsFirewallL3FirewallRulesRulesResponseArgsDict',
    'WirelessSsidsFirewallL7FirewallRulesRuleArgs',
    'WirelessSsidsFirewallL7FirewallRulesRuleArgsDict',
    'WirelessSsidsFirewallL7FirewallRulesRuleValueObjArgs',
    'WirelessSsidsFirewallL7FirewallRulesRuleValueObjArgsDict',
    'WirelessSsidsGreArgs',
    'WirelessSsidsGreArgsDict',
    'WirelessSsidsGreConcentratorArgs',
    'WirelessSsidsGreConcentratorArgsDict',
    'WirelessSsidsHotspot20MccMncArgs',
    'WirelessSsidsHotspot20MccMncArgsDict',
    'WirelessSsidsHotspot20NaiRealmArgs',
    'WirelessSsidsHotspot20NaiRealmArgsDict',
    'WirelessSsidsHotspot20NaiRealmMethodArgs',
    'WirelessSsidsHotspot20NaiRealmMethodArgsDict',
    'WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypesArgs',
    'WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypesArgsDict',
    'WirelessSsidsHotspot20OperatorArgs',
    'WirelessSsidsHotspot20OperatorArgsDict',
    'WirelessSsidsHotspot20VenueArgs',
    'WirelessSsidsHotspot20VenueArgsDict',
    'WirelessSsidsLdapArgs',
    'WirelessSsidsLdapArgsDict',
    'WirelessSsidsLdapCredentialsArgs',
    'WirelessSsidsLdapCredentialsArgsDict',
    'WirelessSsidsLdapServerArgs',
    'WirelessSsidsLdapServerArgsDict',
    'WirelessSsidsLdapServerCaCertificateArgs',
    'WirelessSsidsLdapServerCaCertificateArgsDict',
    'WirelessSsidsLocalRadiusArgs',
    'WirelessSsidsLocalRadiusArgsDict',
    'WirelessSsidsLocalRadiusCertificateAuthenticationArgs',
    'WirelessSsidsLocalRadiusCertificateAuthenticationArgsDict',
    'WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificateArgs',
    'WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificateArgsDict',
    'WirelessSsidsLocalRadiusPasswordAuthenticationArgs',
    'WirelessSsidsLocalRadiusPasswordAuthenticationArgsDict',
    'WirelessSsidsNamedVlansArgs',
    'WirelessSsidsNamedVlansArgsDict',
    'WirelessSsidsNamedVlansRadiusArgs',
    'WirelessSsidsNamedVlansRadiusArgsDict',
    'WirelessSsidsNamedVlansRadiusGuestVlanArgs',
    'WirelessSsidsNamedVlansRadiusGuestVlanArgsDict',
    'WirelessSsidsNamedVlansTaggingArgs',
    'WirelessSsidsNamedVlansTaggingArgsDict',
    'WirelessSsidsNamedVlansTaggingByApTagArgs',
    'WirelessSsidsNamedVlansTaggingByApTagArgsDict',
    'WirelessSsidsOauthArgs',
    'WirelessSsidsOauthArgsDict',
    'WirelessSsidsRadiusAccountingServerArgs',
    'WirelessSsidsRadiusAccountingServerArgsDict',
    'WirelessSsidsRadiusAccountingServersResponseArgs',
    'WirelessSsidsRadiusAccountingServersResponseArgsDict',
    'WirelessSsidsRadiusServerArgs',
    'WirelessSsidsRadiusServerArgsDict',
    'WirelessSsidsRadiusServersResponseArgs',
    'WirelessSsidsRadiusServersResponseArgsDict',
    'WirelessSsidsSchedulesRangeArgs',
    'WirelessSsidsSchedulesRangeArgsDict',
    'WirelessSsidsSchedulesRangesInSecondArgs',
    'WirelessSsidsSchedulesRangesInSecondArgsDict',
    'WirelessSsidsSpeedBurstArgs',
    'WirelessSsidsSpeedBurstArgsDict',
    'WirelessSsidsSplashSettingsBillingArgs',
    'WirelessSsidsSplashSettingsBillingArgsDict',
    'WirelessSsidsSplashSettingsBillingFreeAccessArgs',
    'WirelessSsidsSplashSettingsBillingFreeAccessArgsDict',
    'WirelessSsidsSplashSettingsGuestSponsorshipArgs',
    'WirelessSsidsSplashSettingsGuestSponsorshipArgsDict',
    'WirelessSsidsSplashSettingsSelfRegistrationArgs',
    'WirelessSsidsSplashSettingsSelfRegistrationArgsDict',
    'WirelessSsidsSplashSettingsSentryEnrollmentArgs',
    'WirelessSsidsSplashSettingsSentryEnrollmentArgsDict',
    'WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetworkArgs',
    'WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetworkArgsDict',
    'WirelessSsidsSplashSettingsSplashImageArgs',
    'WirelessSsidsSplashSettingsSplashImageArgsDict',
    'WirelessSsidsSplashSettingsSplashImageImageArgs',
    'WirelessSsidsSplashSettingsSplashImageImageArgsDict',
    'WirelessSsidsSplashSettingsSplashLogoArgs',
    'WirelessSsidsSplashSettingsSplashLogoArgsDict',
    'WirelessSsidsSplashSettingsSplashLogoImageArgs',
    'WirelessSsidsSplashSettingsSplashLogoImageArgsDict',
    'WirelessSsidsSplashSettingsSplashPrepaidFrontArgs',
    'WirelessSsidsSplashSettingsSplashPrepaidFrontArgsDict',
    'WirelessSsidsSplashSettingsSplashPrepaidFrontImageArgs',
    'WirelessSsidsSplashSettingsSplashPrepaidFrontImageArgsDict',
    'WirelessSsidsTrafficShapingRulesRuleArgs',
    'WirelessSsidsTrafficShapingRulesRuleArgsDict',
    'WirelessSsidsTrafficShapingRulesRuleDefinitionArgs',
    'WirelessSsidsTrafficShapingRulesRuleDefinitionArgsDict',
    'WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsArgs',
    'WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsArgsDict',
    'WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs',
    'WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgsDict',
    'WirelessSsidsVpnConcentratorArgs',
    'WirelessSsidsVpnConcentratorArgsDict',
    'WirelessSsidsVpnFailoverArgs',
    'WirelessSsidsVpnFailoverArgsDict',
    'WirelessSsidsVpnSplitTunnelArgs',
    'WirelessSsidsVpnSplitTunnelArgsDict',
    'WirelessSsidsVpnSplitTunnelRuleArgs',
    'WirelessSsidsVpnSplitTunnelRuleArgsDict',
]

MYPY = False

if not MYPY:
    class AlertsSettingsAlertArgsDict(TypedDict):
        alert_destinations: NotRequired[pulumi.Input['AlertsSettingsAlertAlertDestinationsArgsDict']]
        """
        A hash of destinations for this specific alert
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A boolean depicting if the alert is turned on or off
        """
        filters: NotRequired[pulumi.Input['AlertsSettingsAlertFiltersArgsDict']]
        """
        A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of alert
        """
elif False:
    AlertsSettingsAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsSettingsAlertArgs:
    def __init__(__self__, *,
                 alert_destinations: Optional[pulumi.Input['AlertsSettingsAlertAlertDestinationsArgs']] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 filters: Optional[pulumi.Input['AlertsSettingsAlertFiltersArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AlertsSettingsAlertAlertDestinationsArgs'] alert_destinations: A hash of destinations for this specific alert
        :param pulumi.Input[_builtins.bool] enabled: A boolean depicting if the alert is turned on or off
        :param pulumi.Input['AlertsSettingsAlertFiltersArgs'] filters: A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
        :param pulumi.Input[_builtins.str] type: The type of alert
        """
        if alert_destinations is not None:
            pulumi.set(__self__, "alert_destinations", alert_destinations)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="alertDestinations")
    def alert_destinations(self) -> Optional[pulumi.Input['AlertsSettingsAlertAlertDestinationsArgs']]:
        """
        A hash of destinations for this specific alert
        """
        return pulumi.get(self, "alert_destinations")

    @alert_destinations.setter
    def alert_destinations(self, value: Optional[pulumi.Input['AlertsSettingsAlertAlertDestinationsArgs']]):
        pulumi.set(self, "alert_destinations", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A boolean depicting if the alert is turned on or off
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input['AlertsSettingsAlertFiltersArgs']]:
        """
        A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input['AlertsSettingsAlertFiltersArgs']]):
        pulumi.set(self, "filters", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of alert
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlertsSettingsAlertAlertDestinationsArgsDict(TypedDict):
        all_admins: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, then all network admins will receive emails for this alert
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of emails that will receive information about the alert
        """
        http_server_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of HTTP server IDs to send a Webhook to for this alert
        """
        snmp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
        """
elif False:
    AlertsSettingsAlertAlertDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsSettingsAlertAlertDestinationsArgs:
    def __init__(__self__, *,
                 all_admins: Optional[pulumi.Input[_builtins.bool]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 http_server_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 snmp: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] all_admins: If true, then all network admins will receive emails for this alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: A list of emails that will receive information about the alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] http_server_ids: A list of HTTP server IDs to send a Webhook to for this alert
        :param pulumi.Input[_builtins.bool] snmp: If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
        """
        if all_admins is not None:
            pulumi.set(__self__, "all_admins", all_admins)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_server_ids is not None:
            pulumi.set(__self__, "http_server_ids", http_server_ids)
        if snmp is not None:
            pulumi.set(__self__, "snmp", snmp)

    @_builtins.property
    @pulumi.getter(name="allAdmins")
    def all_admins(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, then all network admins will receive emails for this alert
        """
        return pulumi.get(self, "all_admins")

    @all_admins.setter
    def all_admins(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all_admins", value)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of emails that will receive information about the alert
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter(name="httpServerIds")
    def http_server_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of HTTP server IDs to send a Webhook to for this alert
        """
        return pulumi.get(self, "http_server_ids")

    @http_server_ids.setter
    def http_server_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_server_ids", value)

    @_builtins.property
    @pulumi.getter
    def snmp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
        """
        return pulumi.get(self, "snmp")

    @snmp.setter
    def snmp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "snmp", value)


if not MYPY:
    class AlertsSettingsAlertFiltersArgsDict(TypedDict):
        period: NotRequired[pulumi.Input[_builtins.int]]
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        timeout: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    AlertsSettingsAlertFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsSettingsAlertFiltersArgs:
    def __init__(__self__, *,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        if period is not None:
            pulumi.set(__self__, "period", period)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertsSettingsAlertsResponseArgsDict(TypedDict):
        alert_destinations: NotRequired[pulumi.Input['AlertsSettingsAlertsResponseAlertDestinationsArgsDict']]
        """
        A hash of destinations for this specific alert
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A boolean depicting if the alert is turned on or off
        """
        filters: NotRequired[pulumi.Input['AlertsSettingsAlertsResponseFiltersArgsDict']]
        """
        A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of alert
        """
elif False:
    AlertsSettingsAlertsResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsSettingsAlertsResponseArgs:
    def __init__(__self__, *,
                 alert_destinations: Optional[pulumi.Input['AlertsSettingsAlertsResponseAlertDestinationsArgs']] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 filters: Optional[pulumi.Input['AlertsSettingsAlertsResponseFiltersArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AlertsSettingsAlertsResponseAlertDestinationsArgs'] alert_destinations: A hash of destinations for this specific alert
        :param pulumi.Input[_builtins.bool] enabled: A boolean depicting if the alert is turned on or off
        :param pulumi.Input['AlertsSettingsAlertsResponseFiltersArgs'] filters: A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
        :param pulumi.Input[_builtins.str] type: The type of alert
        """
        if alert_destinations is not None:
            pulumi.set(__self__, "alert_destinations", alert_destinations)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="alertDestinations")
    def alert_destinations(self) -> Optional[pulumi.Input['AlertsSettingsAlertsResponseAlertDestinationsArgs']]:
        """
        A hash of destinations for this specific alert
        """
        return pulumi.get(self, "alert_destinations")

    @alert_destinations.setter
    def alert_destinations(self, value: Optional[pulumi.Input['AlertsSettingsAlertsResponseAlertDestinationsArgs']]):
        pulumi.set(self, "alert_destinations", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A boolean depicting if the alert is turned on or off
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input['AlertsSettingsAlertsResponseFiltersArgs']]:
        """
        A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input['AlertsSettingsAlertsResponseFiltersArgs']]):
        pulumi.set(self, "filters", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of alert
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlertsSettingsAlertsResponseAlertDestinationsArgsDict(TypedDict):
        all_admins: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, then all network admins will receive emails for this alert
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of emails that will receive information about the alert
        """
        http_server_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of HTTP server IDs to send a Webhook to for this alert
        """
        snmp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
        """
elif False:
    AlertsSettingsAlertsResponseAlertDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsSettingsAlertsResponseAlertDestinationsArgs:
    def __init__(__self__, *,
                 all_admins: Optional[pulumi.Input[_builtins.bool]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 http_server_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 snmp: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] all_admins: If true, then all network admins will receive emails for this alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: A list of emails that will receive information about the alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] http_server_ids: A list of HTTP server IDs to send a Webhook to for this alert
        :param pulumi.Input[_builtins.bool] snmp: If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
        """
        if all_admins is not None:
            pulumi.set(__self__, "all_admins", all_admins)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_server_ids is not None:
            pulumi.set(__self__, "http_server_ids", http_server_ids)
        if snmp is not None:
            pulumi.set(__self__, "snmp", snmp)

    @_builtins.property
    @pulumi.getter(name="allAdmins")
    def all_admins(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, then all network admins will receive emails for this alert
        """
        return pulumi.get(self, "all_admins")

    @all_admins.setter
    def all_admins(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all_admins", value)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of emails that will receive information about the alert
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter(name="httpServerIds")
    def http_server_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of HTTP server IDs to send a Webhook to for this alert
        """
        return pulumi.get(self, "http_server_ids")

    @http_server_ids.setter
    def http_server_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_server_ids", value)

    @_builtins.property
    @pulumi.getter
    def snmp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
        """
        return pulumi.get(self, "snmp")

    @snmp.setter
    def snmp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "snmp", value)


if not MYPY:
    class AlertsSettingsAlertsResponseFiltersArgsDict(TypedDict):
        period: NotRequired[pulumi.Input[_builtins.int]]
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        timeout: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    AlertsSettingsAlertsResponseFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsSettingsAlertsResponseFiltersArgs:
    def __init__(__self__, *,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        if period is not None:
            pulumi.set(__self__, "period", period)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AlertsSettingsDefaultDestinationsArgsDict(TypedDict):
        all_admins: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, then all network admins will receive emails.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of emails that will receive the alert(s).
        """
        http_server_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of HTTP server IDs to send a Webhook to
        """
        snmp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network.
        """
elif False:
    AlertsSettingsDefaultDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsSettingsDefaultDestinationsArgs:
    def __init__(__self__, *,
                 all_admins: Optional[pulumi.Input[_builtins.bool]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 http_server_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 snmp: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] all_admins: If true, then all network admins will receive emails.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: A list of emails that will receive the alert(s).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] http_server_ids: A list of HTTP server IDs to send a Webhook to
        :param pulumi.Input[_builtins.bool] snmp: If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network.
        """
        if all_admins is not None:
            pulumi.set(__self__, "all_admins", all_admins)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_server_ids is not None:
            pulumi.set(__self__, "http_server_ids", http_server_ids)
        if snmp is not None:
            pulumi.set(__self__, "snmp", snmp)

    @_builtins.property
    @pulumi.getter(name="allAdmins")
    def all_admins(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, then all network admins will receive emails.
        """
        return pulumi.get(self, "all_admins")

    @all_admins.setter
    def all_admins(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all_admins", value)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of emails that will receive the alert(s).
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter(name="httpServerIds")
    def http_server_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of HTTP server IDs to send a Webhook to
        """
        return pulumi.get(self, "http_server_ids")

    @http_server_ids.setter
    def http_server_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_server_ids", value)

    @_builtins.property
    @pulumi.getter
    def snmp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network.
        """
        return pulumi.get(self, "snmp")

    @snmp.setter
    def snmp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "snmp", value)


if not MYPY:
    class AlertsSettingsMutingArgsDict(TypedDict):
        by_port_schedules: NotRequired[pulumi.Input['AlertsSettingsMutingByPortSchedulesArgsDict']]
        """
        by_port_schedules
        """
elif False:
    AlertsSettingsMutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsSettingsMutingArgs:
    def __init__(__self__, *,
                 by_port_schedules: Optional[pulumi.Input['AlertsSettingsMutingByPortSchedulesArgs']] = None):
        """
        :param pulumi.Input['AlertsSettingsMutingByPortSchedulesArgs'] by_port_schedules: by_port_schedules
        """
        if by_port_schedules is not None:
            pulumi.set(__self__, "by_port_schedules", by_port_schedules)

    @_builtins.property
    @pulumi.getter(name="byPortSchedules")
    def by_port_schedules(self) -> Optional[pulumi.Input['AlertsSettingsMutingByPortSchedulesArgs']]:
        """
        by_port_schedules
        """
        return pulumi.get(self, "by_port_schedules")

    @by_port_schedules.setter
    def by_port_schedules(self, value: Optional[pulumi.Input['AlertsSettingsMutingByPortSchedulesArgs']]):
        pulumi.set(self, "by_port_schedules", value)


if not MYPY:
    class AlertsSettingsMutingByPortSchedulesArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enabled
        """
elif False:
    AlertsSettingsMutingByPortSchedulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsSettingsMutingByPortSchedulesArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: enabled
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApplianceConnectivityMonitoringDestinationsDestinationArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the testing destination. Optional, defaults to null
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address to test connectivity with
        """
elif False:
    ApplianceConnectivityMonitoringDestinationsDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceConnectivityMonitoringDestinationsDestinationArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] default: Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
        :param pulumi.Input[_builtins.str] description: Description of the testing destination. Optional, defaults to null
        :param pulumi.Input[_builtins.str] ip: The IP address to test connectivity with
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the testing destination. Optional, defaults to null
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address to test connectivity with
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ApplianceContentFilteringBlockedUrlCategoriesResponseArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplianceContentFilteringBlockedUrlCategoriesResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceContentFilteringBlockedUrlCategoriesResponseArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ApplianceFirewallCellularFirewallRulesRuleArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the rule (optional)
        """
        dest_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        dest_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'allow' or 'deny' traffic specified by this rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        src_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        src_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        syslog_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
elif False:
    ApplianceFirewallCellularFirewallRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallCellularFirewallRulesRuleArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_port: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 src_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 src_port: Optional[pulumi.Input[_builtins.str]] = None,
                 syslog_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Description of the rule (optional)
        :param pulumi.Input[_builtins.str] dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param pulumi.Input[_builtins.str] dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.str] policy: 'allow' or 'deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        :param pulumi.Input[_builtins.str] src_cidr: Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        :param pulumi.Input[_builtins.str] src_port: Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.bool] syslog_enabled: Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if syslog_enabled is not None:
            pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @dest_cidr.setter
    def dest_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_cidr", value)

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @dest_port.setter
    def dest_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_port", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        return pulumi.get(self, "src_cidr")

    @src_cidr.setter
    def src_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_cidr", value)

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "src_port")

    @src_port.setter
    def src_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_port", value)

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        return pulumi.get(self, "syslog_enabled")

    @syslog_enabled.setter
    def syslog_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "syslog_enabled", value)


if not MYPY:
    class ApplianceFirewallInboundFirewallRulesRuleArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the rule (optional)
        """
        dest_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        dest_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'allow' or 'deny' traffic specified by this rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        src_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        src_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        syslog_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
elif False:
    ApplianceFirewallInboundFirewallRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallInboundFirewallRulesRuleArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_port: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 src_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 src_port: Optional[pulumi.Input[_builtins.str]] = None,
                 syslog_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Description of the rule (optional)
        :param pulumi.Input[_builtins.str] dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param pulumi.Input[_builtins.str] dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.str] policy: 'allow' or 'deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        :param pulumi.Input[_builtins.str] src_cidr: Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        :param pulumi.Input[_builtins.str] src_port: Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.bool] syslog_enabled: Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if syslog_enabled is not None:
            pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @dest_cidr.setter
    def dest_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_cidr", value)

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @dest_port.setter
    def dest_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_port", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        return pulumi.get(self, "src_cidr")

    @src_cidr.setter
    def src_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_cidr", value)

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "src_port")

    @src_port.setter
    def src_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_port", value)

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        return pulumi.get(self, "syslog_enabled")

    @syslog_enabled.setter
    def syslog_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "syslog_enabled", value)


if not MYPY:
    class ApplianceFirewallInboundFirewallRulesRulesResponseArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the rule (optional)
        """
        dest_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        dest_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'allow' or 'deny' traffic specified by this rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        src_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        src_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        syslog_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
elif False:
    ApplianceFirewallInboundFirewallRulesRulesResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallInboundFirewallRulesRulesResponseArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_port: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 src_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 src_port: Optional[pulumi.Input[_builtins.str]] = None,
                 syslog_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Description of the rule (optional)
        :param pulumi.Input[_builtins.str] dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param pulumi.Input[_builtins.str] dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.str] policy: 'allow' or 'deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        :param pulumi.Input[_builtins.str] src_cidr: Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        :param pulumi.Input[_builtins.str] src_port: Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.bool] syslog_enabled: Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if syslog_enabled is not None:
            pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @dest_cidr.setter
    def dest_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_cidr", value)

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @dest_port.setter
    def dest_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_port", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        return pulumi.get(self, "src_cidr")

    @src_cidr.setter
    def src_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_cidr", value)

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "src_port")

    @src_port.setter
    def src_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_port", value)

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        return pulumi.get(self, "syslog_enabled")

    @syslog_enabled.setter
    def syslog_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "syslog_enabled", value)


if not MYPY:
    class ApplianceFirewallL3FirewallRulesRuleArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the rule (optional)
        """
        dest_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        dest_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'allow' or 'deny' traffic specified by this rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        src_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        src_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        syslog_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
elif False:
    ApplianceFirewallL3FirewallRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallL3FirewallRulesRuleArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_port: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 src_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 src_port: Optional[pulumi.Input[_builtins.str]] = None,
                 syslog_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Description of the rule (optional)
        :param pulumi.Input[_builtins.str] dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param pulumi.Input[_builtins.str] dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.str] policy: 'allow' or 'deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        :param pulumi.Input[_builtins.str] src_cidr: Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        :param pulumi.Input[_builtins.str] src_port: Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.bool] syslog_enabled: Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if syslog_enabled is not None:
            pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @dest_cidr.setter
    def dest_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_cidr", value)

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @dest_port.setter
    def dest_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_port", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        return pulumi.get(self, "src_cidr")

    @src_cidr.setter
    def src_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_cidr", value)

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "src_port")

    @src_port.setter
    def src_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_port", value)

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        return pulumi.get(self, "syslog_enabled")

    @syslog_enabled.setter
    def syslog_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "syslog_enabled", value)


if not MYPY:
    class ApplianceFirewallL3FirewallRulesRulesResponseArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the rule (optional)
        """
        dest_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        dest_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'allow' or 'deny' traffic specified by this rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        src_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        src_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        syslog_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
elif False:
    ApplianceFirewallL3FirewallRulesRulesResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallL3FirewallRulesRulesResponseArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_port: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 src_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 src_port: Optional[pulumi.Input[_builtins.str]] = None,
                 syslog_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Description of the rule (optional)
        :param pulumi.Input[_builtins.str] dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param pulumi.Input[_builtins.str] dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.str] policy: 'allow' or 'deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        :param pulumi.Input[_builtins.str] src_cidr: Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        :param pulumi.Input[_builtins.str] src_port: Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.bool] syslog_enabled: Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if syslog_enabled is not None:
            pulumi.set(__self__, "syslog_enabled", syslog_enabled)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @dest_cidr.setter
    def dest_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_cidr", value)

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @dest_port.setter
    def dest_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_port", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
        """
        return pulumi.get(self, "src_cidr")

    @src_cidr.setter
    def src_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_cidr", value)

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "src_port")

    @src_port.setter
    def src_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_port", value)

    @_builtins.property
    @pulumi.getter(name="syslogEnabled")
    def syslog_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
        """
        return pulumi.get(self, "syslog_enabled")

    @syslog_enabled.setter
    def syslog_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "syslog_enabled", value)


if not MYPY:
    class ApplianceFirewallL7FirewallRulesRuleArgsDict(TypedDict):
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'Deny' traffic specified by this rule
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. Send a string to request.
        """
        value_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The 'value_list' of what you want to block. Send a lis of string in request.
        """
        value_obj: NotRequired[pulumi.Input['ApplianceFirewallL7FirewallRulesRuleValueObjArgsDict']]
        """
        The 'value_obj' of what you want to block. Send a dict in request.
        """
elif False:
    ApplianceFirewallL7FirewallRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallL7FirewallRulesRuleArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 value_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 value_obj: Optional[pulumi.Input['ApplianceFirewallL7FirewallRulesRuleValueObjArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] policy: 'Deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] type: Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        :param pulumi.Input[_builtins.str] value: The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. Send a string to request.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] value_lists: The 'value_list' of what you want to block. Send a lis of string in request.
        :param pulumi.Input['ApplianceFirewallL7FirewallRulesRuleValueObjArgs'] value_obj: The 'value_obj' of what you want to block. Send a dict in request.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)
        if value_obj is not None:
            pulumi.set(__self__, "value_obj", value_obj)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'Deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. Send a string to request.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The 'value_list' of what you want to block. Send a lis of string in request.
        """
        return pulumi.get(self, "value_lists")

    @value_lists.setter
    def value_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value_lists", value)

    @_builtins.property
    @pulumi.getter(name="valueObj")
    def value_obj(self) -> Optional[pulumi.Input['ApplianceFirewallL7FirewallRulesRuleValueObjArgs']]:
        """
        The 'value_obj' of what you want to block. Send a dict in request.
        """
        return pulumi.get(self, "value_obj")

    @value_obj.setter
    def value_obj(self, value: Optional[pulumi.Input['ApplianceFirewallL7FirewallRulesRuleValueObjArgs']]):
        pulumi.set(self, "value_obj", value)


if not MYPY:
    class ApplianceFirewallL7FirewallRulesRuleValueObjArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplianceFirewallL7FirewallRulesRuleValueObjArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallL7FirewallRulesRuleValueObjArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ApplianceFirewallL7FirewallRulesRulesResponseArgsDict(TypedDict):
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'Deny' traffic specified by this rule
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format.
        """
        value_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The 'value_list' of what you want to block. Send a list in request
        """
        value_obj: NotRequired[pulumi.Input['ApplianceFirewallL7FirewallRulesRulesResponseValueObjArgsDict']]
        """
        The 'value_obj' of what you want to block. Send a dict in request
        """
elif False:
    ApplianceFirewallL7FirewallRulesRulesResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallL7FirewallRulesRulesResponseArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 value_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 value_obj: Optional[pulumi.Input['ApplianceFirewallL7FirewallRulesRulesResponseValueObjArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] policy: 'Deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] type: Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        :param pulumi.Input[_builtins.str] value: The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] value_lists: The 'value_list' of what you want to block. Send a list in request
        :param pulumi.Input['ApplianceFirewallL7FirewallRulesRulesResponseValueObjArgs'] value_obj: The 'value_obj' of what you want to block. Send a dict in request
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)
        if value_obj is not None:
            pulumi.set(__self__, "value_obj", value_obj)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'Deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The 'value_list' of what you want to block. Send a list in request
        """
        return pulumi.get(self, "value_lists")

    @value_lists.setter
    def value_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value_lists", value)

    @_builtins.property
    @pulumi.getter(name="valueObj")
    def value_obj(self) -> Optional[pulumi.Input['ApplianceFirewallL7FirewallRulesRulesResponseValueObjArgs']]:
        """
        The 'value_obj' of what you want to block. Send a dict in request
        """
        return pulumi.get(self, "value_obj")

    @value_obj.setter
    def value_obj(self, value: Optional[pulumi.Input['ApplianceFirewallL7FirewallRulesRulesResponseValueObjArgs']]):
        pulumi.set(self, "value_obj", value)


if not MYPY:
    class ApplianceFirewallL7FirewallRulesRulesResponseValueObjArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplianceFirewallL7FirewallRulesRulesResponseValueObjArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallL7FirewallRulesRulesResponseValueObjArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ApplianceFirewallOneToManyNatRulesRuleArgsDict(TypedDict):
        port_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplianceFirewallOneToManyNatRulesRulePortRuleArgsDict']]]]
        """
        An array of associated forwarding rules
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address that will be used to access the internal resource from the WAN
        """
        uplink: NotRequired[pulumi.Input[_builtins.str]]
        """
        The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
        """
elif False:
    ApplianceFirewallOneToManyNatRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallOneToManyNatRulesRuleArgs:
    def __init__(__self__, *,
                 port_rules: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceFirewallOneToManyNatRulesRulePortRuleArgs']]]] = None,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 uplink: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApplianceFirewallOneToManyNatRulesRulePortRuleArgs']]] port_rules: An array of associated forwarding rules
        :param pulumi.Input[_builtins.str] public_ip: The IP address that will be used to access the internal resource from the WAN
        :param pulumi.Input[_builtins.str] uplink: The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
        """
        if port_rules is not None:
            pulumi.set(__self__, "port_rules", port_rules)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if uplink is not None:
            pulumi.set(__self__, "uplink", uplink)

    @_builtins.property
    @pulumi.getter(name="portRules")
    def port_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceFirewallOneToManyNatRulesRulePortRuleArgs']]]]:
        """
        An array of associated forwarding rules
        """
        return pulumi.get(self, "port_rules")

    @port_rules.setter
    def port_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceFirewallOneToManyNatRulesRulePortRuleArgs']]]]):
        pulumi.set(self, "port_rules", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address that will be used to access the internal resource from the WAN
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter
    def uplink(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
        """
        return pulumi.get(self, "uplink")

    @uplink.setter
    def uplink(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uplink", value)


if not MYPY:
    class ApplianceFirewallOneToManyNatRulesRulePortRuleArgsDict(TypedDict):
        allowed_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Remote IP addresses or ranges that are permitted to access the internal resource via this port forwarding rule, or 'any'
        """
        local_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Local IP address to which traffic will be forwarded
        """
        local_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        'tcp' or 'udp'
        """
        public_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination port of the traffic that is arriving on the WAN
        """
elif False:
    ApplianceFirewallOneToManyNatRulesRulePortRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallOneToManyNatRulesRulePortRuleArgs:
    def __init__(__self__, *,
                 allowed_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 local_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 local_port: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 public_port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ips: Remote IP addresses or ranges that are permitted to access the internal resource via this port forwarding rule, or 'any'
        :param pulumi.Input[_builtins.str] local_ip: Local IP address to which traffic will be forwarded
        :param pulumi.Input[_builtins.str] local_port: Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port
        :param pulumi.Input[_builtins.str] name: A description of the rule
        :param pulumi.Input[_builtins.str] protocol: 'tcp' or 'udp'
        :param pulumi.Input[_builtins.str] public_port: Destination port of the traffic that is arriving on the WAN
        """
        if allowed_ips is not None:
            pulumi.set(__self__, "allowed_ips", allowed_ips)
        if local_ip is not None:
            pulumi.set(__self__, "local_ip", local_ip)
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_port is not None:
            pulumi.set(__self__, "public_port", public_port)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Remote IP addresses or ranges that are permitted to access the internal resource via this port forwarding rule, or 'any'
        """
        return pulumi.get(self, "allowed_ips")

    @allowed_ips.setter
    def allowed_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_ips", value)

    @_builtins.property
    @pulumi.getter(name="localIp")
    def local_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Local IP address to which traffic will be forwarded
        """
        return pulumi.get(self, "local_ip")

    @local_ip.setter
    def local_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_ip", value)

    @_builtins.property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port
        """
        return pulumi.get(self, "local_port")

    @local_port.setter
    def local_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_port", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'tcp' or 'udp'
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="publicPort")
    def public_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination port of the traffic that is arriving on the WAN
        """
        return pulumi.get(self, "public_port")

    @public_port.setter
    def public_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_port", value)


if not MYPY:
    class ApplianceFirewallOneToOneNatRulesRuleArgsDict(TypedDict):
        allowed_inbounds: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplianceFirewallOneToOneNatRulesRuleAllowedInboundArgsDict']]]]
        """
        The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource
        """
        lan_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A descriptive name for the rule
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address that will be used to access the internal resource from the WAN
        """
        uplink: NotRequired[pulumi.Input[_builtins.str]]
        """
        The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
        """
elif False:
    ApplianceFirewallOneToOneNatRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallOneToOneNatRulesRuleArgs:
    def __init__(__self__, *,
                 allowed_inbounds: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceFirewallOneToOneNatRulesRuleAllowedInboundArgs']]]] = None,
                 lan_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 uplink: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApplianceFirewallOneToOneNatRulesRuleAllowedInboundArgs']]] allowed_inbounds: The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource
        :param pulumi.Input[_builtins.str] lan_ip: The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        :param pulumi.Input[_builtins.str] name: A descriptive name for the rule
        :param pulumi.Input[_builtins.str] public_ip: The IP address that will be used to access the internal resource from the WAN
        :param pulumi.Input[_builtins.str] uplink: The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
        """
        if allowed_inbounds is not None:
            pulumi.set(__self__, "allowed_inbounds", allowed_inbounds)
        if lan_ip is not None:
            pulumi.set(__self__, "lan_ip", lan_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if uplink is not None:
            pulumi.set(__self__, "uplink", uplink)

    @_builtins.property
    @pulumi.getter(name="allowedInbounds")
    def allowed_inbounds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceFirewallOneToOneNatRulesRuleAllowedInboundArgs']]]]:
        """
        The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource
        """
        return pulumi.get(self, "allowed_inbounds")

    @allowed_inbounds.setter
    def allowed_inbounds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceFirewallOneToOneNatRulesRuleAllowedInboundArgs']]]]):
        pulumi.set(self, "allowed_inbounds", value)

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        """
        return pulumi.get(self, "lan_ip")

    @lan_ip.setter
    def lan_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lan_ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A descriptive name for the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address that will be used to access the internal resource from the WAN
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter
    def uplink(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
        """
        return pulumi.get(self, "uplink")

    @uplink.setter
    def uplink(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uplink", value)


if not MYPY:
    class ApplianceFirewallOneToOneNatRulesRuleAllowedInboundArgsDict(TypedDict):
        allowed_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any'
        """
        destination_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of ports or port ranges that will be forwarded to the host on the LAN
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
        """
elif False:
    ApplianceFirewallOneToOneNatRulesRuleAllowedInboundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallOneToOneNatRulesRuleAllowedInboundArgs:
    def __init__(__self__, *,
                 allowed_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ips: An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any'
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] destination_ports: An array of ports or port ranges that will be forwarded to the host on the LAN
        :param pulumi.Input[_builtins.str] protocol: Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
        """
        if allowed_ips is not None:
            pulumi.set(__self__, "allowed_ips", allowed_ips)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any'
        """
        return pulumi.get(self, "allowed_ips")

    @allowed_ips.setter
    def allowed_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_ips", value)

    @_builtins.property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of ports or port ranges that will be forwarded to the host on the LAN
        """
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "destination_ports", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class ApplianceFirewallPortForwardingRulesRuleArgsDict(TypedDict):
        allowed_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges (or any)
        """
        lan_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        """
        local_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        A port or port ranges that will receive the forwarded traffic from the WAN
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A descriptive name for the rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        TCP or UDP
        """
        public_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        A port or port ranges that will be forwarded to the host on the LAN
        """
        uplink: NotRequired[pulumi.Input[_builtins.str]]
        """
        The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both')
        """
elif False:
    ApplianceFirewallPortForwardingRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallPortForwardingRulesRuleArgs:
    def __init__(__self__, *,
                 allowed_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 lan_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 local_port: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 public_port: Optional[pulumi.Input[_builtins.str]] = None,
                 uplink: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ips: An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges (or any)
        :param pulumi.Input[_builtins.str] lan_ip: The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        :param pulumi.Input[_builtins.str] local_port: A port or port ranges that will receive the forwarded traffic from the WAN
        :param pulumi.Input[_builtins.str] name: A descriptive name for the rule
        :param pulumi.Input[_builtins.str] protocol: TCP or UDP
        :param pulumi.Input[_builtins.str] public_port: A port or port ranges that will be forwarded to the host on the LAN
        :param pulumi.Input[_builtins.str] uplink: The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both')
        """
        if allowed_ips is not None:
            pulumi.set(__self__, "allowed_ips", allowed_ips)
        if lan_ip is not None:
            pulumi.set(__self__, "lan_ip", lan_ip)
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_port is not None:
            pulumi.set(__self__, "public_port", public_port)
        if uplink is not None:
            pulumi.set(__self__, "uplink", uplink)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges (or any)
        """
        return pulumi.get(self, "allowed_ips")

    @allowed_ips.setter
    def allowed_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_ips", value)

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
        """
        return pulumi.get(self, "lan_ip")

    @lan_ip.setter
    def lan_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lan_ip", value)

    @_builtins.property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A port or port ranges that will receive the forwarded traffic from the WAN
        """
        return pulumi.get(self, "local_port")

    @local_port.setter
    def local_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_port", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A descriptive name for the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        TCP or UDP
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="publicPort")
    def public_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A port or port ranges that will be forwarded to the host on the LAN
        """
        return pulumi.get(self, "public_port")

    @public_port.setter
    def public_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_port", value)

    @_builtins.property
    @pulumi.getter
    def uplink(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both')
        """
        return pulumi.get(self, "uplink")

    @uplink.setter
    def uplink(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uplink", value)


if not MYPY:
    class ApplianceFirewallSettingsSpoofingProtectionArgsDict(TypedDict):
        ip_source_guard: NotRequired[pulumi.Input['ApplianceFirewallSettingsSpoofingProtectionIpSourceGuardArgsDict']]
        """
        IP source address spoofing settings
        """
elif False:
    ApplianceFirewallSettingsSpoofingProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallSettingsSpoofingProtectionArgs:
    def __init__(__self__, *,
                 ip_source_guard: Optional[pulumi.Input['ApplianceFirewallSettingsSpoofingProtectionIpSourceGuardArgs']] = None):
        """
        :param pulumi.Input['ApplianceFirewallSettingsSpoofingProtectionIpSourceGuardArgs'] ip_source_guard: IP source address spoofing settings
        """
        if ip_source_guard is not None:
            pulumi.set(__self__, "ip_source_guard", ip_source_guard)

    @_builtins.property
    @pulumi.getter(name="ipSourceGuard")
    def ip_source_guard(self) -> Optional[pulumi.Input['ApplianceFirewallSettingsSpoofingProtectionIpSourceGuardArgs']]:
        """
        IP source address spoofing settings
        """
        return pulumi.get(self, "ip_source_guard")

    @ip_source_guard.setter
    def ip_source_guard(self, value: Optional[pulumi.Input['ApplianceFirewallSettingsSpoofingProtectionIpSourceGuardArgs']]):
        pulumi.set(self, "ip_source_guard", value)


if not MYPY:
    class ApplianceFirewallSettingsSpoofingProtectionIpSourceGuardArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mode of protection
        """
elif False:
    ApplianceFirewallSettingsSpoofingProtectionIpSourceGuardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceFirewallSettingsSpoofingProtectionIpSourceGuardArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Mode of protection
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mode of protection
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class AppliancePrefixesDelegatedStaticsOriginArgsDict(TypedDict):
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Uplink provided or independent
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Origin type
        """
elif False:
    AppliancePrefixesDelegatedStaticsOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppliancePrefixesDelegatedStaticsOriginArgs:
    def __init__(__self__, *,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] interfaces: Uplink provided or independent
        :param pulumi.Input[_builtins.str] type: Origin type
        """
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Uplink provided or independent
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "interfaces", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Origin type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApplianceRfProfilesFiveGhzSettingsArgsDict(TypedDict):
        ax_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether ax radio on 5Ghz band is on or off.
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Min bitrate (Mbps) of 2.4Ghz band.
        """
elif False:
    ApplianceRfProfilesFiveGhzSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceRfProfilesFiveGhzSettingsArgs:
    def __init__(__self__, *,
                 ax_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] ax_enabled: Whether ax radio on 5Ghz band is on or off.
        :param pulumi.Input[_builtins.int] min_bitrate: Min bitrate (Mbps) of 2.4Ghz band.
        """
        if ax_enabled is not None:
            pulumi.set(__self__, "ax_enabled", ax_enabled)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)

    @_builtins.property
    @pulumi.getter(name="axEnabled")
    def ax_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether ax radio on 5Ghz band is on or off.
        """
        return pulumi.get(self, "ax_enabled")

    @ax_enabled.setter
    def ax_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ax_enabled", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Min bitrate (Mbps) of 2.4Ghz band.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)


if not MYPY:
    class ApplianceRfProfilesPerSsidSettingsArgsDict(TypedDict):
        status1: NotRequired[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus1ArgsDict']]
        """
        Settings for SSID 1.
        """
        status2: NotRequired[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus2ArgsDict']]
        """
        Settings for SSID 2.
        """
        status3: NotRequired[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus3ArgsDict']]
        """
        Settings for SSID 3.
        """
        status4: NotRequired[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus4ArgsDict']]
        """
        Settings for SSID 4.
        """
elif False:
    ApplianceRfProfilesPerSsidSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceRfProfilesPerSsidSettingsArgs:
    def __init__(__self__, *,
                 status1: Optional[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus1Args']] = None,
                 status2: Optional[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus2Args']] = None,
                 status3: Optional[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus3Args']] = None,
                 status4: Optional[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus4Args']] = None):
        """
        :param pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus1Args'] status1: Settings for SSID 1.
        :param pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus2Args'] status2: Settings for SSID 2.
        :param pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus3Args'] status3: Settings for SSID 3.
        :param pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus4Args'] status4: Settings for SSID 4.
        """
        if status1 is not None:
            pulumi.set(__self__, "status1", status1)
        if status2 is not None:
            pulumi.set(__self__, "status2", status2)
        if status3 is not None:
            pulumi.set(__self__, "status3", status3)
        if status4 is not None:
            pulumi.set(__self__, "status4", status4)

    @_builtins.property
    @pulumi.getter
    def status1(self) -> Optional[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus1Args']]:
        """
        Settings for SSID 1.
        """
        return pulumi.get(self, "status1")

    @status1.setter
    def status1(self, value: Optional[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus1Args']]):
        pulumi.set(self, "status1", value)

    @_builtins.property
    @pulumi.getter
    def status2(self) -> Optional[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus2Args']]:
        """
        Settings for SSID 2.
        """
        return pulumi.get(self, "status2")

    @status2.setter
    def status2(self, value: Optional[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus2Args']]):
        pulumi.set(self, "status2", value)

    @_builtins.property
    @pulumi.getter
    def status3(self) -> Optional[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus3Args']]:
        """
        Settings for SSID 3.
        """
        return pulumi.get(self, "status3")

    @status3.setter
    def status3(self, value: Optional[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus3Args']]):
        pulumi.set(self, "status3", value)

    @_builtins.property
    @pulumi.getter
    def status4(self) -> Optional[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus4Args']]:
        """
        Settings for SSID 4.
        """
        return pulumi.get(self, "status4")

    @status4.setter
    def status4(self, value: Optional[pulumi.Input['ApplianceRfProfilesPerSsidSettingsStatus4Args']]):
        pulumi.set(self, "status4", value)


if not MYPY:
    class ApplianceRfProfilesPerSsidSettingsStatus1ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Band mode of this SSID
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
elif False:
    ApplianceRfProfilesPerSsidSettingsStatus1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceRfProfilesPerSsidSettingsStatus1Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Band mode of this SSID
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Band mode of this SSID
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)


if not MYPY:
    class ApplianceRfProfilesPerSsidSettingsStatus2ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Band mode of this SSID
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
elif False:
    ApplianceRfProfilesPerSsidSettingsStatus2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceRfProfilesPerSsidSettingsStatus2Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Band mode of this SSID
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Band mode of this SSID
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)


if not MYPY:
    class ApplianceRfProfilesPerSsidSettingsStatus3ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Band mode of this SSID
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
elif False:
    ApplianceRfProfilesPerSsidSettingsStatus3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceRfProfilesPerSsidSettingsStatus3Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Band mode of this SSID
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Band mode of this SSID
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)


if not MYPY:
    class ApplianceRfProfilesPerSsidSettingsStatus4ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Band mode of this SSID
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
elif False:
    ApplianceRfProfilesPerSsidSettingsStatus4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceRfProfilesPerSsidSettingsStatus4Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Band mode of this SSID
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Band mode of this SSID
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)


if not MYPY:
    class ApplianceRfProfilesTwoFourGhzSettingsArgsDict(TypedDict):
        ax_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether ax radio on 2.4Ghz band is on or off.
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.float]]
        """
        Min bitrate (Mbps) of 2.4Ghz band.
        """
elif False:
    ApplianceRfProfilesTwoFourGhzSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceRfProfilesTwoFourGhzSettingsArgs:
    def __init__(__self__, *,
                 ax_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.bool] ax_enabled: Whether ax radio on 2.4Ghz band is on or off.
        :param pulumi.Input[_builtins.float] min_bitrate: Min bitrate (Mbps) of 2.4Ghz band.
        """
        if ax_enabled is not None:
            pulumi.set(__self__, "ax_enabled", ax_enabled)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)

    @_builtins.property
    @pulumi.getter(name="axEnabled")
    def ax_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether ax radio on 2.4Ghz band is on or off.
        """
        return pulumi.get(self, "ax_enabled")

    @ax_enabled.setter
    def ax_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ax_enabled", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Min bitrate (Mbps) of 2.4Ghz band.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min_bitrate", value)


if not MYPY:
    class ApplianceSecurityIntrusionProtectedNetworksArgsDict(TypedDict):
        excluded_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IP addresses or subnets being excluded from protection
        """
        included_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IP addresses or subnets being protected
        """
        use_default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether special IPv4 addresses should be used (see: https://tools.ietf.org/html/rfc5735)
        """
elif False:
    ApplianceSecurityIntrusionProtectedNetworksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSecurityIntrusionProtectedNetworksArgs:
    def __init__(__self__, *,
                 excluded_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 use_default: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_cidrs: List of IP addresses or subnets being excluded from protection
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] included_cidrs: List of IP addresses or subnets being protected
        :param pulumi.Input[_builtins.bool] use_default: Whether special IPv4 addresses should be used (see: https://tools.ietf.org/html/rfc5735)
        """
        if excluded_cidrs is not None:
            pulumi.set(__self__, "excluded_cidrs", excluded_cidrs)
        if included_cidrs is not None:
            pulumi.set(__self__, "included_cidrs", included_cidrs)
        if use_default is not None:
            pulumi.set(__self__, "use_default", use_default)

    @_builtins.property
    @pulumi.getter(name="excludedCidrs")
    def excluded_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IP addresses or subnets being excluded from protection
        """
        return pulumi.get(self, "excluded_cidrs")

    @excluded_cidrs.setter
    def excluded_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cidrs", value)

    @_builtins.property
    @pulumi.getter(name="includedCidrs")
    def included_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IP addresses or subnets being protected
        """
        return pulumi.get(self, "included_cidrs")

    @included_cidrs.setter
    def included_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cidrs", value)

    @_builtins.property
    @pulumi.getter(name="useDefault")
    def use_default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether special IPv4 addresses should be used (see: https://tools.ietf.org/html/rfc5735)
        """
        return pulumi.get(self, "use_default")

    @use_default.setter
    def use_default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_default", value)


if not MYPY:
    class ApplianceSecurityMalwareAllowedFileArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment about the allowed file
        """
        sha256: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sha256 digest of allowed file
        """
elif False:
    ApplianceSecurityMalwareAllowedFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSecurityMalwareAllowedFileArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 sha256: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Comment about the allowed file
        :param pulumi.Input[_builtins.str] sha256: The sha256 digest of allowed file
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment about the allowed file
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sha256 digest of allowed file
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sha256", value)


if not MYPY:
    class ApplianceSecurityMalwareAllowedUrlArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment about the allowed URL
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The allowed URL
        """
elif False:
    ApplianceSecurityMalwareAllowedUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSecurityMalwareAllowedUrlArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Comment about the allowed URL
        :param pulumi.Input[_builtins.str] url: The allowed URL
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment about the allowed URL
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The allowed URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ApplianceSettingsDynamicDnsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Dynamic DNS enabled
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dynamic DNS url prefix. DDNS must be enabled to update
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dynamic DNS url. DDNS must be enabled to update
        """
elif False:
    ApplianceSettingsDynamicDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSettingsDynamicDnsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Dynamic DNS enabled
        :param pulumi.Input[_builtins.str] prefix: Dynamic DNS url prefix. DDNS must be enabled to update
        :param pulumi.Input[_builtins.str] url: Dynamic DNS url. DDNS must be enabled to update
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Dynamic DNS enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dynamic DNS url prefix. DDNS must be enabled to update
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dynamic DNS url. DDNS must be enabled to update
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ApplianceSingleLanIpv6ArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable IPv6 on single LAN
        """
        prefix_assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplianceSingleLanIpv6PrefixAssignmentArgsDict']]]]
        """
        Prefix assignments on the single LAN
        """
elif False:
    ApplianceSingleLanIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSingleLanIpv6Args:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix_assignments: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceSingleLanIpv6PrefixAssignmentArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable IPv6 on single LAN
        :param pulumi.Input[Sequence[pulumi.Input['ApplianceSingleLanIpv6PrefixAssignmentArgs']]] prefix_assignments: Prefix assignments on the single LAN
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if prefix_assignments is not None:
            pulumi.set(__self__, "prefix_assignments", prefix_assignments)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable IPv6 on single LAN
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="prefixAssignments")
    def prefix_assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceSingleLanIpv6PrefixAssignmentArgs']]]]:
        """
        Prefix assignments on the single LAN
        """
        return pulumi.get(self, "prefix_assignments")

    @prefix_assignments.setter
    def prefix_assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceSingleLanIpv6PrefixAssignmentArgs']]]]):
        pulumi.set(self, "prefix_assignments", value)


if not MYPY:
    class ApplianceSingleLanIpv6PrefixAssignmentArgsDict(TypedDict):
        autonomous: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Auto assign a /64 prefix from the origin to the single LAN
        """
        origin: NotRequired[pulumi.Input['ApplianceSingleLanIpv6PrefixAssignmentOriginArgsDict']]
        """
        The origin of the prefix
        """
        static_appliance_ip6: NotRequired[pulumi.Input[_builtins.str]]
        """
        Manual configuration of the IPv6 Appliance IP
        """
        static_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Manual configuration of a /64 prefix on the single LAN
        """
elif False:
    ApplianceSingleLanIpv6PrefixAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSingleLanIpv6PrefixAssignmentArgs:
    def __init__(__self__, *,
                 autonomous: Optional[pulumi.Input[_builtins.bool]] = None,
                 origin: Optional[pulumi.Input['ApplianceSingleLanIpv6PrefixAssignmentOriginArgs']] = None,
                 static_appliance_ip6: Optional[pulumi.Input[_builtins.str]] = None,
                 static_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] autonomous: Auto assign a /64 prefix from the origin to the single LAN
        :param pulumi.Input['ApplianceSingleLanIpv6PrefixAssignmentOriginArgs'] origin: The origin of the prefix
        :param pulumi.Input[_builtins.str] static_appliance_ip6: Manual configuration of the IPv6 Appliance IP
        :param pulumi.Input[_builtins.str] static_prefix: Manual configuration of a /64 prefix on the single LAN
        """
        if autonomous is not None:
            pulumi.set(__self__, "autonomous", autonomous)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if static_appliance_ip6 is not None:
            pulumi.set(__self__, "static_appliance_ip6", static_appliance_ip6)
        if static_prefix is not None:
            pulumi.set(__self__, "static_prefix", static_prefix)

    @_builtins.property
    @pulumi.getter
    def autonomous(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Auto assign a /64 prefix from the origin to the single LAN
        """
        return pulumi.get(self, "autonomous")

    @autonomous.setter
    def autonomous(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "autonomous", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input['ApplianceSingleLanIpv6PrefixAssignmentOriginArgs']]:
        """
        The origin of the prefix
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input['ApplianceSingleLanIpv6PrefixAssignmentOriginArgs']]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter(name="staticApplianceIp6")
    def static_appliance_ip6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Manual configuration of the IPv6 Appliance IP
        """
        return pulumi.get(self, "static_appliance_ip6")

    @static_appliance_ip6.setter
    def static_appliance_ip6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_appliance_ip6", value)

    @_builtins.property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Manual configuration of a /64 prefix on the single LAN
        """
        return pulumi.get(self, "static_prefix")

    @static_prefix.setter
    def static_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_prefix", value)


if not MYPY:
    class ApplianceSingleLanIpv6PrefixAssignmentOriginArgsDict(TypedDict):
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Interfaces associated with the prefix
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the origin
        """
elif False:
    ApplianceSingleLanIpv6PrefixAssignmentOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSingleLanIpv6PrefixAssignmentOriginArgs:
    def __init__(__self__, *,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] interfaces: Interfaces associated with the prefix
        :param pulumi.Input[_builtins.str] type: Type of the origin
        """
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Interfaces associated with the prefix
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "interfaces", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the origin
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApplianceSingleLanMandatoryDhcpArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Mandatory DHCP on single LAN.
        """
elif False:
    ApplianceSingleLanMandatoryDhcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSingleLanMandatoryDhcpArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable Mandatory DHCP on single LAN.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Mandatory DHCP on single LAN.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApplianceSsidsDhcpEnforcedDeauthenticationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable DCHP Enforced Deauthentication on the SSID.
        """
elif False:
    ApplianceSsidsDhcpEnforcedDeauthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSsidsDhcpEnforcedDeauthenticationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable DCHP Enforced Deauthentication on the SSID.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable DCHP Enforced Deauthentication on the SSID.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApplianceSsidsDot11wArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether 802.11w is enabled or not.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Optional) Whether 802.11w is required or not.
        """
elif False:
    ApplianceSsidsDot11wArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSsidsDot11wArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether 802.11w is enabled or not.
        :param pulumi.Input[_builtins.bool] required: (Optional) Whether 802.11w is required or not.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether 802.11w is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Optional) Whether 802.11w is required or not.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class ApplianceSsidsRadiusServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of your RADIUS server.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The UDP port your RADIUS servers listens on for Access-requests.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The RADIUS client shared secret.
        """
elif False:
    ApplianceSsidsRadiusServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSsidsRadiusServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The IP address of your RADIUS server.
        :param pulumi.Input[_builtins.int] port: The UDP port your RADIUS servers listens on for Access-requests.
        :param pulumi.Input[_builtins.str] secret: The RADIUS client shared secret.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of your RADIUS server.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The UDP port your RADIUS servers listens on for Access-requests.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The RADIUS client shared secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class ApplianceSsidsRadiusServersResponseArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of your RADIUS server.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The UDP port your RADIUS servers listens on for Access-requests.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The RADIUS client shared secret.
        """
elif False:
    ApplianceSsidsRadiusServersResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceSsidsRadiusServersResponseArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The IP address of your RADIUS server.
        :param pulumi.Input[_builtins.int] port: The UDP port your RADIUS servers listens on for Access-requests.
        :param pulumi.Input[_builtins.str] secret: The RADIUS client shared secret.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of your RADIUS server.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The UDP port your RADIUS servers listens on for Access-requests.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The RADIUS client shared secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class ApplianceTrafficShapingCustomPerformanceClassesParametersArgsDict(TypedDict):
        max_jitter: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum jitter in milliseconds
        """
        max_latency: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum latency in milliseconds
        """
        max_loss_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum percentage of packet loss
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the custom performance class
        """
elif False:
    ApplianceTrafficShapingCustomPerformanceClassesParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingCustomPerformanceClassesParametersArgs:
    def __init__(__self__, *,
                 max_jitter: Optional[pulumi.Input[_builtins.int]] = None,
                 max_latency: Optional[pulumi.Input[_builtins.int]] = None,
                 max_loss_percentage: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] max_jitter: Maximum jitter in milliseconds
        :param pulumi.Input[_builtins.int] max_latency: Maximum latency in milliseconds
        :param pulumi.Input[_builtins.int] max_loss_percentage: Maximum percentage of packet loss
        :param pulumi.Input[_builtins.str] name: Name of the custom performance class
        """
        if max_jitter is not None:
            pulumi.set(__self__, "max_jitter", max_jitter)
        if max_latency is not None:
            pulumi.set(__self__, "max_latency", max_latency)
        if max_loss_percentage is not None:
            pulumi.set(__self__, "max_loss_percentage", max_loss_percentage)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="maxJitter")
    def max_jitter(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum jitter in milliseconds
        """
        return pulumi.get(self, "max_jitter")

    @max_jitter.setter
    def max_jitter(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_jitter", value)

    @_builtins.property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum latency in milliseconds
        """
        return pulumi.get(self, "max_latency")

    @max_latency.setter
    def max_latency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_latency", value)

    @_builtins.property
    @pulumi.getter(name="maxLossPercentage")
    def max_loss_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum percentage of packet loss
        """
        return pulumi.get(self, "max_loss_percentage")

    @max_loss_percentage.setter
    def max_loss_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_loss_percentage", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the custom performance class
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ApplianceTrafficShapingGlobalBandwidthLimitsArgsDict(TypedDict):
        limit_down: NotRequired[pulumi.Input[_builtins.int]]
        """
        The download bandwidth limit in Kbps. (0 represents no limit.)
        """
        limit_up: NotRequired[pulumi.Input[_builtins.int]]
        """
        The upload bandwidth limit in Kbps. (0 represents no limit.)
        """
elif False:
    ApplianceTrafficShapingGlobalBandwidthLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingGlobalBandwidthLimitsArgs:
    def __init__(__self__, *,
                 limit_down: Optional[pulumi.Input[_builtins.int]] = None,
                 limit_up: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] limit_down: The download bandwidth limit in Kbps. (0 represents no limit.)
        :param pulumi.Input[_builtins.int] limit_up: The upload bandwidth limit in Kbps. (0 represents no limit.)
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The download bandwidth limit in Kbps. (0 represents no limit.)
        """
        return pulumi.get(self, "limit_down")

    @limit_down.setter
    def limit_down(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_down", value)

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The upload bandwidth limit in Kbps. (0 represents no limit.)
        """
        return pulumi.get(self, "limit_up")

    @limit_up.setter
    def limit_up(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_up", value)


if not MYPY:
    class ApplianceTrafficShapingRulesRuleArgsDict(TypedDict):
        definitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingRulesRuleDefinitionArgsDict']]]]
        """
        A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        """
        dscp_tag_value: NotRequired[pulumi.Input[_builtins.int]]
        """
        The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        """
        per_client_bandwidth_limits: NotRequired[pulumi.Input['ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsArgsDict']]
        """
        An object describing the bandwidth settings for your rule.
        """
        priority: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string, indicating the priority level for packets bound to your rule.
        Can be 'low', 'normal' or 'high'.
        """
elif False:
    ApplianceTrafficShapingRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingRulesRuleArgs:
    def __init__(__self__, *,
                 definitions: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingRulesRuleDefinitionArgs']]]] = None,
                 dscp_tag_value: Optional[pulumi.Input[_builtins.int]] = None,
                 per_client_bandwidth_limits: Optional[pulumi.Input['ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsArgs']] = None,
                 priority: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingRulesRuleDefinitionArgs']]] definitions: A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        :param pulumi.Input[_builtins.int] dscp_tag_value: The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
               For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        :param pulumi.Input['ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsArgs'] per_client_bandwidth_limits: An object describing the bandwidth settings for your rule.
        :param pulumi.Input[_builtins.str] priority: A string, indicating the priority level for packets bound to your rule.
               Can be 'low', 'normal' or 'high'.
        """
        if definitions is not None:
            pulumi.set(__self__, "definitions", definitions)
        if dscp_tag_value is not None:
            pulumi.set(__self__, "dscp_tag_value", dscp_tag_value)
        if per_client_bandwidth_limits is not None:
            pulumi.set(__self__, "per_client_bandwidth_limits", per_client_bandwidth_limits)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingRulesRuleDefinitionArgs']]]]:
        """
        A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        """
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingRulesRuleDefinitionArgs']]]]):
        pulumi.set(self, "definitions", value)

    @_builtins.property
    @pulumi.getter(name="dscpTagValue")
    def dscp_tag_value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        """
        return pulumi.get(self, "dscp_tag_value")

    @dscp_tag_value.setter
    def dscp_tag_value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dscp_tag_value", value)

    @_builtins.property
    @pulumi.getter(name="perClientBandwidthLimits")
    def per_client_bandwidth_limits(self) -> Optional[pulumi.Input['ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsArgs']]:
        """
        An object describing the bandwidth settings for your rule.
        """
        return pulumi.get(self, "per_client_bandwidth_limits")

    @per_client_bandwidth_limits.setter
    def per_client_bandwidth_limits(self, value: Optional[pulumi.Input['ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsArgs']]):
        pulumi.set(self, "per_client_bandwidth_limits", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string, indicating the priority level for packets bound to your rule.
        Can be 'low', 'normal' or 'high'.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class ApplianceTrafficShapingRulesRuleDefinitionArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
        a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
        "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
        custom ports.
         If "type" is 'application' or 'applicationCategory', then "value" must be an object
        with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
        application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
        endpoint).
        """
        value_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The 'value_list' of what you want to block. Send a list in request
        """
        value_obj: NotRequired[pulumi.Input['ApplianceTrafficShapingRulesRuleDefinitionValueObjArgsDict']]
        """
        The 'value_obj' of what you want to block. Send a dict in request
        """
elif False:
    ApplianceTrafficShapingRulesRuleDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingRulesRuleDefinitionArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 value_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 value_obj: Optional[pulumi.Input['ApplianceTrafficShapingRulesRuleDefinitionValueObjArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        :param pulumi.Input[_builtins.str] value: If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
               a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
               "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
               custom ports.
                If "type" is 'application' or 'applicationCategory', then "value" must be an object
               with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
               application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
               endpoint).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] value_lists: The 'value_list' of what you want to block. Send a list in request
        :param pulumi.Input['ApplianceTrafficShapingRulesRuleDefinitionValueObjArgs'] value_obj: The 'value_obj' of what you want to block. Send a dict in request
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)
        if value_obj is not None:
            pulumi.set(__self__, "value_obj", value_obj)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
        a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
        "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
        custom ports.
         If "type" is 'application' or 'applicationCategory', then "value" must be an object
        with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
        application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
        endpoint).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The 'value_list' of what you want to block. Send a list in request
        """
        return pulumi.get(self, "value_lists")

    @value_lists.setter
    def value_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value_lists", value)

    @_builtins.property
    @pulumi.getter(name="valueObj")
    def value_obj(self) -> Optional[pulumi.Input['ApplianceTrafficShapingRulesRuleDefinitionValueObjArgs']]:
        """
        The 'value_obj' of what you want to block. Send a dict in request
        """
        return pulumi.get(self, "value_obj")

    @value_obj.setter
    def value_obj(self, value: Optional[pulumi.Input['ApplianceTrafficShapingRulesRuleDefinitionValueObjArgs']]):
        pulumi.set(self, "value_obj", value)


if not MYPY:
    class ApplianceTrafficShapingRulesRuleDefinitionValueObjArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplianceTrafficShapingRulesRuleDefinitionValueObjArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingRulesRuleDefinitionValueObjArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsArgsDict(TypedDict):
        bandwidth_limits: NotRequired[pulumi.Input['ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgsDict']]
        """
        The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        """
        settings: NotRequired[pulumi.Input[_builtins.str]]
        """
        How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
elif False:
    ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsArgs:
    def __init__(__self__, *,
                 bandwidth_limits: Optional[pulumi.Input['ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs']] = None,
                 settings: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs'] bandwidth_limits: The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        :param pulumi.Input[_builtins.str] settings: How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        if bandwidth_limits is not None:
            pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> Optional[pulumi.Input['ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs']]:
        """
        The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "bandwidth_limits")

    @bandwidth_limits.setter
    def bandwidth_limits(self, value: Optional[pulumi.Input['ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs']]):
        pulumi.set(self, "bandwidth_limits", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgsDict(TypedDict):
        limit_down: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum download limit (integer, in Kbps).
        """
        limit_up: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum upload limit (integer, in Kbps).
        """
elif False:
    ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs:
    def __init__(__self__, *,
                 limit_down: Optional[pulumi.Input[_builtins.int]] = None,
                 limit_up: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] limit_down: The maximum download limit (integer, in Kbps).
        :param pulumi.Input[_builtins.int] limit_up: The maximum upload limit (integer, in Kbps).
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum download limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_down")

    @limit_down.setter
    def limit_down(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_down", value)

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum upload limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_up")

    @limit_up.setter
    def limit_up(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_up", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsArgsDict(TypedDict):
        cellular: NotRequired[pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellularArgsDict']]
        """
        uplink cellular configured limits [optional]
        """
        wan1: NotRequired[pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1ArgsDict']]
        """
        uplink wan1 configured limits [optional]
        """
        wan2: NotRequired[pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2ArgsDict']]
        """
        uplink wan2 configured limits [optional]
        """
elif False:
    ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsArgs:
    def __init__(__self__, *,
                 cellular: Optional[pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellularArgs']] = None,
                 wan1: Optional[pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1Args']] = None,
                 wan2: Optional[pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2Args']] = None):
        """
        :param pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellularArgs'] cellular: uplink cellular configured limits [optional]
        :param pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1Args'] wan1: uplink wan1 configured limits [optional]
        :param pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2Args'] wan2: uplink wan2 configured limits [optional]
        """
        if cellular is not None:
            pulumi.set(__self__, "cellular", cellular)
        if wan1 is not None:
            pulumi.set(__self__, "wan1", wan1)
        if wan2 is not None:
            pulumi.set(__self__, "wan2", wan2)

    @_builtins.property
    @pulumi.getter
    def cellular(self) -> Optional[pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellularArgs']]:
        """
        uplink cellular configured limits [optional]
        """
        return pulumi.get(self, "cellular")

    @cellular.setter
    def cellular(self, value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellularArgs']]):
        pulumi.set(self, "cellular", value)

    @_builtins.property
    @pulumi.getter
    def wan1(self) -> Optional[pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1Args']]:
        """
        uplink wan1 configured limits [optional]
        """
        return pulumi.get(self, "wan1")

    @wan1.setter
    def wan1(self, value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1Args']]):
        pulumi.set(self, "wan1", value)

    @_builtins.property
    @pulumi.getter
    def wan2(self) -> Optional[pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2Args']]:
        """
        uplink wan2 configured limits [optional]
        """
        return pulumi.get(self, "wan2")

    @wan2.setter
    def wan2(self, value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2Args']]):
        pulumi.set(self, "wan2", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellularArgsDict(TypedDict):
        limit_down: NotRequired[pulumi.Input[_builtins.int]]
        """
        configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        """
        limit_up: NotRequired[pulumi.Input[_builtins.int]]
        """
        configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
elif False:
    ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellularArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellularArgs:
    def __init__(__self__, *,
                 limit_down: Optional[pulumi.Input[_builtins.int]] = None,
                 limit_up: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] limit_down: configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        :param pulumi.Input[_builtins.int] limit_up: configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_down")

    @limit_down.setter
    def limit_down(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_down", value)

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_up")

    @limit_up.setter
    def limit_up(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_up", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1ArgsDict(TypedDict):
        limit_down: NotRequired[pulumi.Input[_builtins.int]]
        """
        configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        """
        limit_up: NotRequired[pulumi.Input[_builtins.int]]
        """
        configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
elif False:
    ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1Args:
    def __init__(__self__, *,
                 limit_down: Optional[pulumi.Input[_builtins.int]] = None,
                 limit_up: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] limit_down: configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        :param pulumi.Input[_builtins.int] limit_up: configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_down")

    @limit_down.setter
    def limit_down(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_down", value)

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_up")

    @limit_up.setter
    def limit_up(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_up", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2ArgsDict(TypedDict):
        limit_down: NotRequired[pulumi.Input[_builtins.int]]
        """
        configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        """
        limit_up: NotRequired[pulumi.Input[_builtins.int]]
        """
        configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
elif False:
    ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2Args:
    def __init__(__self__, *,
                 limit_down: Optional[pulumi.Input[_builtins.int]] = None,
                 limit_up: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] limit_down: configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        :param pulumi.Input[_builtins.int] limit_up: configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_down")

    @limit_down.setter
    def limit_down(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_down", value)

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        configured UP limit for the uplink (in Kbps).  Null indicated unlimited
        """
        return pulumi.get(self, "limit_up")

    @limit_up.setter
    def limit_up(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_up", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackArgsDict(TypedDict):
        immediate: NotRequired[pulumi.Input['ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediateArgsDict']]
        """
        Immediate WAN failover and failback
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackArgs:
    def __init__(__self__, *,
                 immediate: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediateArgs']] = None):
        """
        :param pulumi.Input['ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediateArgs'] immediate: Immediate WAN failover and failback
        """
        if immediate is not None:
            pulumi.set(__self__, "immediate", immediate)

    @_builtins.property
    @pulumi.getter
    def immediate(self) -> Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediateArgs']]:
        """
        Immediate WAN failover and failback
        """
        return pulumi.get(self, "immediate")

    @immediate.setter
    def immediate(self, value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediateArgs']]):
        pulumi.set(self, "immediate", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediateArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether immediate WAN failover and failback is enabled
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediateArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether immediate WAN failover and failback is enabled
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether immediate WAN failover and failback is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceArgsDict(TypedDict):
        fail_over_criterion: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
        """
        performance_class: NotRequired[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClassArgsDict']]
        """
        Performance class setting for uplink preference rule
        """
        preferred_uplink: NotRequired[pulumi.Input[_builtins.str]]
        """
        Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
        """
        traffic_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterArgsDict']]]]
        """
        Traffic filters
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceArgs:
    def __init__(__self__, *,
                 fail_over_criterion: Optional[pulumi.Input[_builtins.str]] = None,
                 performance_class: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClassArgs']] = None,
                 preferred_uplink: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] fail_over_criterion: Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
        :param pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClassArgs'] performance_class: Performance class setting for uplink preference rule
        :param pulumi.Input[_builtins.str] preferred_uplink: Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
        :param pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterArgs']]] traffic_filters: Traffic filters
        """
        if fail_over_criterion is not None:
            pulumi.set(__self__, "fail_over_criterion", fail_over_criterion)
        if performance_class is not None:
            pulumi.set(__self__, "performance_class", performance_class)
        if preferred_uplink is not None:
            pulumi.set(__self__, "preferred_uplink", preferred_uplink)
        if traffic_filters is not None:
            pulumi.set(__self__, "traffic_filters", traffic_filters)

    @_builtins.property
    @pulumi.getter(name="failOverCriterion")
    def fail_over_criterion(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
        """
        return pulumi.get(self, "fail_over_criterion")

    @fail_over_criterion.setter
    def fail_over_criterion(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fail_over_criterion", value)

    @_builtins.property
    @pulumi.getter(name="performanceClass")
    def performance_class(self) -> Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClassArgs']]:
        """
        Performance class setting for uplink preference rule
        """
        return pulumi.get(self, "performance_class")

    @performance_class.setter
    def performance_class(self, value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClassArgs']]):
        pulumi.set(self, "performance_class", value)

    @_builtins.property
    @pulumi.getter(name="preferredUplink")
    def preferred_uplink(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
        """
        return pulumi.get(self, "preferred_uplink")

    @preferred_uplink.setter
    def preferred_uplink(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preferred_uplink", value)

    @_builtins.property
    @pulumi.getter(name="trafficFilters")
    def traffic_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterArgs']]]]:
        """
        Traffic filters
        """
        return pulumi.get(self, "traffic_filters")

    @traffic_filters.setter
    def traffic_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterArgs']]]]):
        pulumi.set(self, "traffic_filters", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClassArgsDict(TypedDict):
        builtin_performance_class_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'
        """
        custom_performance_class_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of created custom performance class, must be present when performanceClass type is "custom"
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of this performance class. Must be one of: 'builtin' or 'custom'
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClassArgs:
    def __init__(__self__, *,
                 builtin_performance_class_name: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_performance_class_id: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] builtin_performance_class_name: Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'
        :param pulumi.Input[_builtins.str] custom_performance_class_id: ID of created custom performance class, must be present when performanceClass type is "custom"
        :param pulumi.Input[_builtins.str] type: Type of this performance class. Must be one of: 'builtin' or 'custom'
        """
        if builtin_performance_class_name is not None:
            pulumi.set(__self__, "builtin_performance_class_name", builtin_performance_class_name)
        if custom_performance_class_id is not None:
            pulumi.set(__self__, "custom_performance_class_id", custom_performance_class_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="builtinPerformanceClassName")
    def builtin_performance_class_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'
        """
        return pulumi.get(self, "builtin_performance_class_name")

    @builtin_performance_class_name.setter
    def builtin_performance_class_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "builtin_performance_class_name", value)

    @_builtins.property
    @pulumi.getter(name="customPerformanceClassId")
    def custom_performance_class_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of created custom performance class, must be present when performanceClass type is "custom"
        """
        return pulumi.get(self, "custom_performance_class_id")

    @custom_performance_class_id.setter
    def custom_performance_class_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_performance_class_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of this performance class. Must be one of: 'builtin' or 'custom'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
        """
        value: NotRequired[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueArgsDict']]
        """
        Value of traffic filter
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
        :param pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueArgs'] value: Value of traffic filter
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueArgs']]:
        """
        Value of traffic filter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestinationArgsDict']]
        """
        Destination of 'custom' type traffic filter
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of 'applicationCategory' or 'application' type traffic filter
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
        """
        source: NotRequired[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSourceArgsDict']]
        """
        Source of 'custom' type traffic filter
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestinationArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSourceArgs']] = None):
        """
        :param pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestinationArgs'] destination: Destination of 'custom' type traffic filter
        :param pulumi.Input[_builtins.str] id: ID of 'applicationCategory' or 'application' type traffic filter
        :param pulumi.Input[_builtins.str] protocol: Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
        :param pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSourceArgs'] source: Source of 'custom' type traffic filter
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestinationArgs']]:
        """
        Destination of 'custom' type traffic filter
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of 'applicationCategory' or 'application' type traffic filter
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSourceArgs']]:
        """
        Source of 'custom' type traffic filter
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestinationArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property
        """
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com"
        """
        host: NotRequired[pulumi.Input[_builtins.int]]
        """
        Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        """
        network: NotRequired[pulumi.Input[_builtins.str]]
        """
        Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        vlan: NotRequired[pulumi.Input[_builtins.int]]
        """
        VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network.
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestinationArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.int]] = None,
                 network: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] cidr: CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property
        :param pulumi.Input[_builtins.str] fqdn: FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com"
        :param pulumi.Input[_builtins.int] host: Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        :param pulumi.Input[_builtins.str] network: Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        :param pulumi.Input[_builtins.str] port: E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        :param pulumi.Input[_builtins.int] vlan: VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr", value)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com"
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network.
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSourceArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        """
        host: NotRequired[pulumi.Input[_builtins.int]]
        """
        Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        """
        network: NotRequired[pulumi.Input[_builtins.str]]
        """
        Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        vlan: NotRequired[pulumi.Input[_builtins.int]]
        """
        VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSourceArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.int]] = None,
                 network: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] cidr: CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        :param pulumi.Input[_builtins.int] host: Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        :param pulumi.Input[_builtins.str] network: Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        :param pulumi.Input[_builtins.str] port: E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        :param pulumi.Input[_builtins.int] vlan: VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceArgsDict(TypedDict):
        preferred_uplink: NotRequired[pulumi.Input[_builtins.str]]
        """
        Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
        """
        traffic_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterArgsDict']]]]
        """
        Traffic filters
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceArgs:
    def __init__(__self__, *,
                 preferred_uplink: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] preferred_uplink: Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
        :param pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterArgs']]] traffic_filters: Traffic filters
        """
        if preferred_uplink is not None:
            pulumi.set(__self__, "preferred_uplink", preferred_uplink)
        if traffic_filters is not None:
            pulumi.set(__self__, "traffic_filters", traffic_filters)

    @_builtins.property
    @pulumi.getter(name="preferredUplink")
    def preferred_uplink(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
        """
        return pulumi.get(self, "preferred_uplink")

    @preferred_uplink.setter
    def preferred_uplink(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preferred_uplink", value)

    @_builtins.property
    @pulumi.getter(name="trafficFilters")
    def traffic_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterArgs']]]]:
        """
        Traffic filters
        """
        return pulumi.get(self, "traffic_filters")

    @traffic_filters.setter
    def traffic_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterArgs']]]]):
        pulumi.set(self, "traffic_filters", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Traffic filter type. Must be "custom"
        """
        value: NotRequired[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueArgsDict']]
        """
        Value of traffic filter
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Traffic filter type. Must be "custom"
        :param pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueArgs'] value: Value of traffic filter
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Traffic filter type. Must be "custom"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueArgs']]:
        """
        Value of traffic filter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestinationArgsDict']]
        """
        Destination of 'custom' type traffic filter
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
        """
        source: NotRequired[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSourceArgsDict']]
        """
        Source of 'custom' type traffic filter
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestinationArgs']] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSourceArgs']] = None):
        """
        :param pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestinationArgs'] destination: Destination of 'custom' type traffic filter
        :param pulumi.Input[_builtins.str] protocol: Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
        :param pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSourceArgs'] source: Source of 'custom' type traffic filter
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestinationArgs']]:
        """
        Destination of 'custom' type traffic filter
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSourceArgs']]:
        """
        Source of 'custom' type traffic filter
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestinationArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any"
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestinationArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cidr: CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any"
        :param pulumi.Input[_builtins.str] port: E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any"
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSourceArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        """
        host: NotRequired[pulumi.Input[_builtins.int]]
        """
        Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        vlan: NotRequired[pulumi.Input[_builtins.int]]
        """
        VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
elif False:
    ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSourceArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] cidr: CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        :param pulumi.Input[_builtins.int] host: Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        :param pulumi.Input[_builtins.str] port: E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        :param pulumi.Input[_builtins.int] vlan: VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        E.g.: "any", "0" (also means "any"), "8080", "1-1024"
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan", value)


if not MYPY:
    class ApplianceTrafficShapingVpnExclusionsItemArgsDict(TypedDict):
        customs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsItemCustomArgsDict']]]]
        """
        Custom VPN exclusion rules.
        """
        major_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsItemMajorApplicationArgsDict']]]]
        """
        Major Application based VPN exclusion rules.
        """
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the network whose VPN exclusion rules are returned.
        """
        network_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the network whose VPN exclusion rules are returned.
        """
elif False:
    ApplianceTrafficShapingVpnExclusionsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingVpnExclusionsItemArgs:
    def __init__(__self__, *,
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsItemCustomArgs']]]] = None,
                 major_applications: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsItemMajorApplicationArgs']]]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 network_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsItemCustomArgs']]] customs: Custom VPN exclusion rules.
        :param pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsItemMajorApplicationArgs']]] major_applications: Major Application based VPN exclusion rules.
        :param pulumi.Input[_builtins.str] network_id: ID of the network whose VPN exclusion rules are returned.
        :param pulumi.Input[_builtins.str] network_name: Name of the network whose VPN exclusion rules are returned.
        """
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if major_applications is not None:
            pulumi.set(__self__, "major_applications", major_applications)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if network_name is not None:
            pulumi.set(__self__, "network_name", network_name)

    @_builtins.property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsItemCustomArgs']]]]:
        """
        Custom VPN exclusion rules.
        """
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsItemCustomArgs']]]]):
        pulumi.set(self, "customs", value)

    @_builtins.property
    @pulumi.getter(name="majorApplications")
    def major_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsItemMajorApplicationArgs']]]]:
        """
        Major Application based VPN exclusion rules.
        """
        return pulumi.get(self, "major_applications")

    @major_applications.setter
    def major_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsItemMajorApplicationArgs']]]]):
        pulumi.set(self, "major_applications", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the network whose VPN exclusion rules are returned.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the network whose VPN exclusion rules are returned.
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_name", value)


if not MYPY:
    class ApplianceTrafficShapingVpnExclusionsItemCustomArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination address; hostname required for DNS, IPv4 otherwise.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination port.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol.
        """
elif False:
    ApplianceTrafficShapingVpnExclusionsItemCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingVpnExclusionsItemCustomArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination: Destination address; hostname required for DNS, IPv4 otherwise.
        :param pulumi.Input[_builtins.str] port: Destination port.
        :param pulumi.Input[_builtins.str] protocol: Protocol.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination address; hostname required for DNS, IPv4 otherwise.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class ApplianceTrafficShapingVpnExclusionsItemMajorApplicationArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Application's Meraki ID.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Application's name.
        """
elif False:
    ApplianceTrafficShapingVpnExclusionsItemMajorApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingVpnExclusionsItemMajorApplicationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Application's Meraki ID.
        :param pulumi.Input[_builtins.str] name: Application's name.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Application's Meraki ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Application's name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ApplianceTrafficShapingVpnExclusionsParametersArgsDict(TypedDict):
        customs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsParametersCustomArgsDict']]]]
        """
        Custom VPN exclusion rules. Pass an empty array to clear existing rules.
        """
        major_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsParametersMajorApplicationArgsDict']]]]
        """
        Major Application based VPN exclusion rules. Pass an empty array to clear existing rules.
        """
elif False:
    ApplianceTrafficShapingVpnExclusionsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingVpnExclusionsParametersArgs:
    def __init__(__self__, *,
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsParametersCustomArgs']]]] = None,
                 major_applications: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsParametersMajorApplicationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsParametersCustomArgs']]] customs: Custom VPN exclusion rules. Pass an empty array to clear existing rules.
        :param pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsParametersMajorApplicationArgs']]] major_applications: Major Application based VPN exclusion rules. Pass an empty array to clear existing rules.
        """
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if major_applications is not None:
            pulumi.set(__self__, "major_applications", major_applications)

    @_builtins.property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsParametersCustomArgs']]]]:
        """
        Custom VPN exclusion rules. Pass an empty array to clear existing rules.
        """
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsParametersCustomArgs']]]]):
        pulumi.set(self, "customs", value)

    @_builtins.property
    @pulumi.getter(name="majorApplications")
    def major_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsParametersMajorApplicationArgs']]]]:
        """
        Major Application based VPN exclusion rules. Pass an empty array to clear existing rules.
        """
        return pulumi.get(self, "major_applications")

    @major_applications.setter
    def major_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceTrafficShapingVpnExclusionsParametersMajorApplicationArgs']]]]):
        pulumi.set(self, "major_applications", value)


if not MYPY:
    class ApplianceTrafficShapingVpnExclusionsParametersCustomArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination address; hostname required for DNS, IPv4 otherwise.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination port.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol.
        """
elif False:
    ApplianceTrafficShapingVpnExclusionsParametersCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingVpnExclusionsParametersCustomArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination: Destination address; hostname required for DNS, IPv4 otherwise.
        :param pulumi.Input[_builtins.str] port: Destination port.
        :param pulumi.Input[_builtins.str] protocol: Protocol.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination address; hostname required for DNS, IPv4 otherwise.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class ApplianceTrafficShapingVpnExclusionsParametersMajorApplicationArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Application's Meraki ID.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Application's name.
        """
elif False:
    ApplianceTrafficShapingVpnExclusionsParametersMajorApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceTrafficShapingVpnExclusionsParametersMajorApplicationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Application's Meraki ID.
        :param pulumi.Input[_builtins.str] name: Application's name.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Application's Meraki ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Application's name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ApplianceVlansDhcpOptionArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The code for the DHCP option. This should be an integer between 2 and 254.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value for the DHCP option
        """
elif False:
    ApplianceVlansDhcpOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVlansDhcpOptionArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] code: The code for the DHCP option. This should be an integer between 2 and 254.
        :param pulumi.Input[_builtins.str] type: The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
        :param pulumi.Input[_builtins.str] value: The value for the DHCP option
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The code for the DHCP option. This should be an integer between 2 and 254.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value for the DHCP option
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApplianceVlansIpv6ArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable IPv6 on VLAN
        """
        prefix_assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplianceVlansIpv6PrefixAssignmentArgsDict']]]]
        """
        Prefix assignments on the VLAN
        """
elif False:
    ApplianceVlansIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVlansIpv6Args:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix_assignments: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceVlansIpv6PrefixAssignmentArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable IPv6 on VLAN
        :param pulumi.Input[Sequence[pulumi.Input['ApplianceVlansIpv6PrefixAssignmentArgs']]] prefix_assignments: Prefix assignments on the VLAN
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if prefix_assignments is not None:
            pulumi.set(__self__, "prefix_assignments", prefix_assignments)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable IPv6 on VLAN
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="prefixAssignments")
    def prefix_assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceVlansIpv6PrefixAssignmentArgs']]]]:
        """
        Prefix assignments on the VLAN
        """
        return pulumi.get(self, "prefix_assignments")

    @prefix_assignments.setter
    def prefix_assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplianceVlansIpv6PrefixAssignmentArgs']]]]):
        pulumi.set(self, "prefix_assignments", value)


if not MYPY:
    class ApplianceVlansIpv6PrefixAssignmentArgsDict(TypedDict):
        autonomous: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Auto assign a /64 prefix from the origin to the VLAN
        """
        origin: NotRequired[pulumi.Input['ApplianceVlansIpv6PrefixAssignmentOriginArgsDict']]
        """
        The origin of the prefix
        """
        static_appliance_ip6: NotRequired[pulumi.Input[_builtins.str]]
        """
        Manual configuration of the IPv6 Appliance IP
        """
        static_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Manual configuration of a /64 prefix on the VLAN
        """
elif False:
    ApplianceVlansIpv6PrefixAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVlansIpv6PrefixAssignmentArgs:
    def __init__(__self__, *,
                 autonomous: Optional[pulumi.Input[_builtins.bool]] = None,
                 origin: Optional[pulumi.Input['ApplianceVlansIpv6PrefixAssignmentOriginArgs']] = None,
                 static_appliance_ip6: Optional[pulumi.Input[_builtins.str]] = None,
                 static_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] autonomous: Auto assign a /64 prefix from the origin to the VLAN
        :param pulumi.Input['ApplianceVlansIpv6PrefixAssignmentOriginArgs'] origin: The origin of the prefix
        :param pulumi.Input[_builtins.str] static_appliance_ip6: Manual configuration of the IPv6 Appliance IP
        :param pulumi.Input[_builtins.str] static_prefix: Manual configuration of a /64 prefix on the VLAN
        """
        if autonomous is not None:
            pulumi.set(__self__, "autonomous", autonomous)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if static_appliance_ip6 is not None:
            pulumi.set(__self__, "static_appliance_ip6", static_appliance_ip6)
        if static_prefix is not None:
            pulumi.set(__self__, "static_prefix", static_prefix)

    @_builtins.property
    @pulumi.getter
    def autonomous(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Auto assign a /64 prefix from the origin to the VLAN
        """
        return pulumi.get(self, "autonomous")

    @autonomous.setter
    def autonomous(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "autonomous", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input['ApplianceVlansIpv6PrefixAssignmentOriginArgs']]:
        """
        The origin of the prefix
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input['ApplianceVlansIpv6PrefixAssignmentOriginArgs']]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter(name="staticApplianceIp6")
    def static_appliance_ip6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Manual configuration of the IPv6 Appliance IP
        """
        return pulumi.get(self, "static_appliance_ip6")

    @static_appliance_ip6.setter
    def static_appliance_ip6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_appliance_ip6", value)

    @_builtins.property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Manual configuration of a /64 prefix on the VLAN
        """
        return pulumi.get(self, "static_prefix")

    @static_prefix.setter
    def static_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_prefix", value)


if not MYPY:
    class ApplianceVlansIpv6PrefixAssignmentOriginArgsDict(TypedDict):
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Interfaces associated with the prefix
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the origin
        """
elif False:
    ApplianceVlansIpv6PrefixAssignmentOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVlansIpv6PrefixAssignmentOriginArgs:
    def __init__(__self__, *,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] interfaces: Interfaces associated with the prefix
        :param pulumi.Input[_builtins.str] type: Type of the origin
        """
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Interfaces associated with the prefix
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "interfaces", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the origin
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApplianceVlansMandatoryDhcpArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Mandatory DHCP on VLAN.
        """
elif False:
    ApplianceVlansMandatoryDhcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVlansMandatoryDhcpArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable Mandatory DHCP on VLAN.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Mandatory DHCP on VLAN.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApplianceVlansReservedIpRangeArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        A text comment for the reserved range
        """
        end: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last IP in the reserved range
        """
        start: NotRequired[pulumi.Input[_builtins.str]]
        """
        The first IP in the reserved range
        """
elif False:
    ApplianceVlansReservedIpRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVlansReservedIpRangeArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 end: Optional[pulumi.Input[_builtins.str]] = None,
                 start: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: A text comment for the reserved range
        :param pulumi.Input[_builtins.str] end: The last IP in the reserved range
        :param pulumi.Input[_builtins.str] start: The first IP in the reserved range
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A text comment for the reserved range
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last IP in the reserved range
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The first IP in the reserved range
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class ApplianceVpnBgpNeighborArgsDict(TypedDict):
        allow_transit: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false.
        """
        authentication: NotRequired[pulumi.Input['ApplianceVpnBgpNeighborAuthenticationArgsDict']]
        """
        Authentication settings between BGP peers.
        """
        ebgp_hold_timer: NotRequired[pulumi.Input[_builtins.int]]
        """
        The eBGP hold timer in seconds for each neighbor. The eBGP hold timer must be an integer between 12 and 240.
        """
        ebgp_multihop: NotRequired[pulumi.Input[_builtins.int]]
        """
        Configure this if the neighbor is not adjacent. The eBGP multi-hop must be an integer between 1 and 255.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv4 address of the neighbor
        """
        ipv6: NotRequired[pulumi.Input['ApplianceVpnBgpNeighborIpv6ArgsDict']]
        """
        Information regarding IPv6 address of the neighbor, Required if *ip* is not present.
        """
        next_hop_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv4 address of the remote BGP peer that will establish a TCP session with the local MX.
        """
        receive_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0.
        """
        remote_as_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
        """
        source_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The output interface for peering with the remote BGP peer. Valid values are: 'wan1', 'wan2' or 'vlan{VLAN ID}'(e.g. 'vlan123').
        """
        ttl_security: NotRequired[pulumi.Input['ApplianceVpnBgpNeighborTtlSecurityArgsDict']]
        """
        Settings for BGP TTL security to protect BGP peering sessions from forged IP attacks.
        """
elif False:
    ApplianceVpnBgpNeighborArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVpnBgpNeighborArgs:
    def __init__(__self__, *,
                 allow_transit: Optional[pulumi.Input[_builtins.bool]] = None,
                 authentication: Optional[pulumi.Input['ApplianceVpnBgpNeighborAuthenticationArgs']] = None,
                 ebgp_hold_timer: Optional[pulumi.Input[_builtins.int]] = None,
                 ebgp_multihop: Optional[pulumi.Input[_builtins.int]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6: Optional[pulumi.Input['ApplianceVpnBgpNeighborIpv6Args']] = None,
                 next_hop_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 receive_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 remote_as_number: Optional[pulumi.Input[_builtins.int]] = None,
                 source_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ttl_security: Optional[pulumi.Input['ApplianceVpnBgpNeighborTtlSecurityArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_transit: When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false.
        :param pulumi.Input['ApplianceVpnBgpNeighborAuthenticationArgs'] authentication: Authentication settings between BGP peers.
        :param pulumi.Input[_builtins.int] ebgp_hold_timer: The eBGP hold timer in seconds for each neighbor. The eBGP hold timer must be an integer between 12 and 240.
        :param pulumi.Input[_builtins.int] ebgp_multihop: Configure this if the neighbor is not adjacent. The eBGP multi-hop must be an integer between 1 and 255.
        :param pulumi.Input[_builtins.str] ip: The IPv4 address of the neighbor
        :param pulumi.Input['ApplianceVpnBgpNeighborIpv6Args'] ipv6: Information regarding IPv6 address of the neighbor, Required if *ip* is not present.
        :param pulumi.Input[_builtins.str] next_hop_ip: The IPv4 address of the remote BGP peer that will establish a TCP session with the local MX.
        :param pulumi.Input[_builtins.int] receive_limit: The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0.
        :param pulumi.Input[_builtins.int] remote_as_number: Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
        :param pulumi.Input[_builtins.str] source_interface: The output interface for peering with the remote BGP peer. Valid values are: 'wan1', 'wan2' or 'vlan{VLAN ID}'(e.g. 'vlan123').
        :param pulumi.Input['ApplianceVpnBgpNeighborTtlSecurityArgs'] ttl_security: Settings for BGP TTL security to protect BGP peering sessions from forged IP attacks.
        """
        if allow_transit is not None:
            pulumi.set(__self__, "allow_transit", allow_transit)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if ebgp_hold_timer is not None:
            pulumi.set(__self__, "ebgp_hold_timer", ebgp_hold_timer)
        if ebgp_multihop is not None:
            pulumi.set(__self__, "ebgp_multihop", ebgp_multihop)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if next_hop_ip is not None:
            pulumi.set(__self__, "next_hop_ip", next_hop_ip)
        if receive_limit is not None:
            pulumi.set(__self__, "receive_limit", receive_limit)
        if remote_as_number is not None:
            pulumi.set(__self__, "remote_as_number", remote_as_number)
        if source_interface is not None:
            pulumi.set(__self__, "source_interface", source_interface)
        if ttl_security is not None:
            pulumi.set(__self__, "ttl_security", ttl_security)

    @_builtins.property
    @pulumi.getter(name="allowTransit")
    def allow_transit(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false.
        """
        return pulumi.get(self, "allow_transit")

    @allow_transit.setter
    def allow_transit(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_transit", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ApplianceVpnBgpNeighborAuthenticationArgs']]:
        """
        Authentication settings between BGP peers.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ApplianceVpnBgpNeighborAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter(name="ebgpHoldTimer")
    def ebgp_hold_timer(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The eBGP hold timer in seconds for each neighbor. The eBGP hold timer must be an integer between 12 and 240.
        """
        return pulumi.get(self, "ebgp_hold_timer")

    @ebgp_hold_timer.setter
    def ebgp_hold_timer(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ebgp_hold_timer", value)

    @_builtins.property
    @pulumi.getter(name="ebgpMultihop")
    def ebgp_multihop(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Configure this if the neighbor is not adjacent. The eBGP multi-hop must be an integer between 1 and 255.
        """
        return pulumi.get(self, "ebgp_multihop")

    @ebgp_multihop.setter
    def ebgp_multihop(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ebgp_multihop", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv4 address of the neighbor
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['ApplianceVpnBgpNeighborIpv6Args']]:
        """
        Information regarding IPv6 address of the neighbor, Required if *ip* is not present.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['ApplianceVpnBgpNeighborIpv6Args']]):
        pulumi.set(self, "ipv6", value)

    @_builtins.property
    @pulumi.getter(name="nextHopIp")
    def next_hop_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv4 address of the remote BGP peer that will establish a TCP session with the local MX.
        """
        return pulumi.get(self, "next_hop_ip")

    @next_hop_ip.setter
    def next_hop_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_hop_ip", value)

    @_builtins.property
    @pulumi.getter(name="receiveLimit")
    def receive_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0.
        """
        return pulumi.get(self, "receive_limit")

    @receive_limit.setter
    def receive_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "receive_limit", value)

    @_builtins.property
    @pulumi.getter(name="remoteAsNumber")
    def remote_as_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
        """
        return pulumi.get(self, "remote_as_number")

    @remote_as_number.setter
    def remote_as_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "remote_as_number", value)

    @_builtins.property
    @pulumi.getter(name="sourceInterface")
    def source_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The output interface for peering with the remote BGP peer. Valid values are: 'wan1', 'wan2' or 'vlan{VLAN ID}'(e.g. 'vlan123').
        """
        return pulumi.get(self, "source_interface")

    @source_interface.setter
    def source_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_interface", value)

    @_builtins.property
    @pulumi.getter(name="ttlSecurity")
    def ttl_security(self) -> Optional[pulumi.Input['ApplianceVpnBgpNeighborTtlSecurityArgs']]:
        """
        Settings for BGP TTL security to protect BGP peering sessions from forged IP attacks.
        """
        return pulumi.get(self, "ttl_security")

    @ttl_security.setter
    def ttl_security(self, value: Optional[pulumi.Input['ApplianceVpnBgpNeighborTtlSecurityArgs']]):
        pulumi.set(self, "ttl_security", value)


if not MYPY:
    class ApplianceVpnBgpNeighborAuthenticationArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password to configure MD5 authentication between BGP peers.
        """
elif False:
    ApplianceVpnBgpNeighborAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVpnBgpNeighborAuthenticationArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password: Password to configure MD5 authentication between BGP peers.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password to configure MD5 authentication between BGP peers.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class ApplianceVpnBgpNeighborIpv6ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv6 address of the neighbor.
        """
elif False:
    ApplianceVpnBgpNeighborIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVpnBgpNeighborIpv6Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The IPv6 address of the neighbor.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv6 address of the neighbor.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)


if not MYPY:
    class ApplianceVpnBgpNeighborTtlSecurityArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean value to enable or disable BGP TTL security.
        """
elif False:
    ApplianceVpnBgpNeighborTtlSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVpnBgpNeighborTtlSecurityArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Boolean value to enable or disable BGP TTL security.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean value to enable or disable BGP TTL security.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApplianceVpnSiteToSiteVpnHubArgsDict(TypedDict):
        hub_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The network ID of the hub.
        """
        use_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether default route traffic should be sent to this hub.
        """
elif False:
    ApplianceVpnSiteToSiteVpnHubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVpnSiteToSiteVpnHubArgs:
    def __init__(__self__, *,
                 hub_id: Optional[pulumi.Input[_builtins.str]] = None,
                 use_default_route: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] hub_id: The network ID of the hub.
        :param pulumi.Input[_builtins.bool] use_default_route: Indicates whether default route traffic should be sent to this hub.
        """
        if hub_id is not None:
            pulumi.set(__self__, "hub_id", hub_id)
        if use_default_route is not None:
            pulumi.set(__self__, "use_default_route", use_default_route)

    @_builtins.property
    @pulumi.getter(name="hubId")
    def hub_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The network ID of the hub.
        """
        return pulumi.get(self, "hub_id")

    @hub_id.setter
    def hub_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hub_id", value)

    @_builtins.property
    @pulumi.getter(name="useDefaultRoute")
    def use_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether default route traffic should be sent to this hub.
        """
        return pulumi.get(self, "use_default_route")

    @use_default_route.setter
    def use_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_default_route", value)


if not MYPY:
    class ApplianceVpnSiteToSiteVpnSubnetArgsDict(TypedDict):
        local_subnet: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR notation subnet used within the VPN
        """
        use_vpn: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates the presence of the subnet in the VPN
        """
elif False:
    ApplianceVpnSiteToSiteVpnSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceVpnSiteToSiteVpnSubnetArgs:
    def __init__(__self__, *,
                 local_subnet: Optional[pulumi.Input[_builtins.str]] = None,
                 use_vpn: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] local_subnet: The CIDR notation subnet used within the VPN
        :param pulumi.Input[_builtins.bool] use_vpn: Indicates the presence of the subnet in the VPN
        """
        if local_subnet is not None:
            pulumi.set(__self__, "local_subnet", local_subnet)
        if use_vpn is not None:
            pulumi.set(__self__, "use_vpn", use_vpn)

    @_builtins.property
    @pulumi.getter(name="localSubnet")
    def local_subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR notation subnet used within the VPN
        """
        return pulumi.get(self, "local_subnet")

    @local_subnet.setter
    def local_subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_subnet", value)

    @_builtins.property
    @pulumi.getter(name="useVpn")
    def use_vpn(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates the presence of the subnet in the VPN
        """
        return pulumi.get(self, "use_vpn")

    @use_vpn.setter
    def use_vpn(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_vpn", value)


if not MYPY:
    class ApplianceWarmSpareWan1ArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        subnet: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplianceWarmSpareWan1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceWarmSpareWan1Args:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet: Optional[pulumi.Input[_builtins.str]] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class ApplianceWarmSpareWan2ArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        subnet: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplianceWarmSpareWan2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplianceWarmSpareWan2Args:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet: Optional[pulumi.Input[_builtins.str]] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class BindItemArgsDict(TypedDict):
        config_template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the config template the network is being bound to
        """
        enrollment_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enrollment string for the network
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network ID
        """
        is_bound_to_config_template: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the network is bound to a config template
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network name
        """
        notes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notes for the network
        """
        organization_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization ID
        """
        product_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of the product types that the network supports
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Network tags
        """
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timezone of the network
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL to the network Dashboard UI
        """
elif False:
    BindItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BindItemArgs:
    def __init__(__self__, *,
                 config_template_id: Optional[pulumi.Input[_builtins.str]] = None,
                 enrollment_string: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_bound_to_config_template: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 organization_id: Optional[pulumi.Input[_builtins.str]] = None,
                 product_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config_template_id: ID of the config template the network is being bound to
        :param pulumi.Input[_builtins.str] enrollment_string: Enrollment string for the network
        :param pulumi.Input[_builtins.str] id: Network ID
        :param pulumi.Input[_builtins.bool] is_bound_to_config_template: If the network is bound to a config template
        :param pulumi.Input[_builtins.str] name: Network name
        :param pulumi.Input[_builtins.str] notes: Notes for the network
        :param pulumi.Input[_builtins.str] organization_id: Organization ID
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] product_types: List of the product types that the network supports
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: Network tags
        :param pulumi.Input[_builtins.str] time_zone: Timezone of the network
        :param pulumi.Input[_builtins.str] url: URL to the network Dashboard UI
        """
        if config_template_id is not None:
            pulumi.set(__self__, "config_template_id", config_template_id)
        if enrollment_string is not None:
            pulumi.set(__self__, "enrollment_string", enrollment_string)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_bound_to_config_template is not None:
            pulumi.set(__self__, "is_bound_to_config_template", is_bound_to_config_template)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)
        if product_types is not None:
            pulumi.set(__self__, "product_types", product_types)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="configTemplateId")
    def config_template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the config template the network is being bound to
        """
        return pulumi.get(self, "config_template_id")

    @config_template_id.setter
    def config_template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_template_id", value)

    @_builtins.property
    @pulumi.getter(name="enrollmentString")
    def enrollment_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enrollment string for the network
        """
        return pulumi.get(self, "enrollment_string")

    @enrollment_string.setter
    def enrollment_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enrollment_string", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isBoundToConfigTemplate")
    def is_bound_to_config_template(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the network is bound to a config template
        """
        return pulumi.get(self, "is_bound_to_config_template")

    @is_bound_to_config_template.setter
    def is_bound_to_config_template(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_bound_to_config_template", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notes for the network
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization ID
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_id", value)

    @_builtins.property
    @pulumi.getter(name="productTypes")
    def product_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of the product types that the network supports
        """
        return pulumi.get(self, "product_types")

    @product_types.setter
    def product_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "product_types", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Network tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timezone of the network
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL to the network Dashboard UI
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class BindParametersArgsDict(TypedDict):
        auto_bind: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
        """
        config_template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the template to which the network should be bound.
        """
elif False:
    BindParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BindParametersArgs:
    def __init__(__self__, *,
                 auto_bind: Optional[pulumi.Input[_builtins.bool]] = None,
                 config_template_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] auto_bind: Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
        :param pulumi.Input[_builtins.str] config_template_id: The ID of the template to which the network should be bound.
        """
        if auto_bind is not None:
            pulumi.set(__self__, "auto_bind", auto_bind)
        if config_template_id is not None:
            pulumi.set(__self__, "config_template_id", config_template_id)

    @_builtins.property
    @pulumi.getter(name="autoBind")
    def auto_bind(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
        """
        return pulumi.get(self, "auto_bind")

    @auto_bind.setter
    def auto_bind(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_bind", value)

    @_builtins.property
    @pulumi.getter(name="configTemplateId")
    def config_template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the template to which the network should be bound.
        """
        return pulumi.get(self, "config_template_id")

    @config_template_id.setter
    def config_template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_template_id", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsArgsDict(TypedDict):
        m_v12_mv22_mv72: NotRequired[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72ArgsDict']]
        """
        Quality and resolution for MV12/MV22/MV72 camera models.
        """
        m_v12_we: NotRequired[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV12WeArgsDict']]
        """
        Quality and resolution for MV12WE camera models.
        """
        m_v13: NotRequired[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV13ArgsDict']]
        """
        Quality and resolution for MV13 camera models.
        """
        m_v21_mv71: NotRequired[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV21MV71ArgsDict']]
        """
        Quality and resolution for MV21/MV71 camera models.
        """
        m_v22_xmv72_x: NotRequired[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV22Xmv72XArgsDict']]
        """
        Quality and resolution for MV22X/MV72X camera models.
        """
        m_v32: NotRequired[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV32ArgsDict']]
        """
        Quality and resolution for MV32 camera models.
        """
        m_v33: NotRequired[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV33ArgsDict']]
        """
        Quality and resolution for MV33 camera models.
        """
        m_v52: NotRequired[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV52ArgsDict']]
        """
        Quality and resolution for MV52 camera models.
        """
        m_v63: NotRequired[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV63ArgsDict']]
        """
        Quality and resolution for MV63 camera models.
        """
        m_v63_x: NotRequired[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV63XArgsDict']]
        """
        Quality and resolution for MV63X camera models.
        """
        m_v93: NotRequired[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV93ArgsDict']]
        """
        Quality and resolution for MV93 camera models.
        """
        m_v93_x: NotRequired[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV93XArgsDict']]
        """
        Quality and resolution for MV93X camera models.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsArgs:
    def __init__(__self__, *,
                 m_v12_mv22_mv72: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72Args']] = None,
                 m_v12_we: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV12WeArgs']] = None,
                 m_v13: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV13Args']] = None,
                 m_v21_mv71: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV21MV71Args']] = None,
                 m_v22_xmv72_x: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV22Xmv72XArgs']] = None,
                 m_v32: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV32Args']] = None,
                 m_v33: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV33Args']] = None,
                 m_v52: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV52Args']] = None,
                 m_v63: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV63Args']] = None,
                 m_v63_x: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV63XArgs']] = None,
                 m_v93: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV93Args']] = None,
                 m_v93_x: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV93XArgs']] = None):
        """
        :param pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72Args'] m_v12_mv22_mv72: Quality and resolution for MV12/MV22/MV72 camera models.
        :param pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV12WeArgs'] m_v12_we: Quality and resolution for MV12WE camera models.
        :param pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV13Args'] m_v13: Quality and resolution for MV13 camera models.
        :param pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV21MV71Args'] m_v21_mv71: Quality and resolution for MV21/MV71 camera models.
        :param pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV22Xmv72XArgs'] m_v22_xmv72_x: Quality and resolution for MV22X/MV72X camera models.
        :param pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV32Args'] m_v32: Quality and resolution for MV32 camera models.
        :param pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV33Args'] m_v33: Quality and resolution for MV33 camera models.
        :param pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV52Args'] m_v52: Quality and resolution for MV52 camera models.
        :param pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV63Args'] m_v63: Quality and resolution for MV63 camera models.
        :param pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV63XArgs'] m_v63_x: Quality and resolution for MV63X camera models.
        :param pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV93Args'] m_v93: Quality and resolution for MV93 camera models.
        :param pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV93XArgs'] m_v93_x: Quality and resolution for MV93X camera models.
        """
        if m_v12_mv22_mv72 is not None:
            pulumi.set(__self__, "m_v12_mv22_mv72", m_v12_mv22_mv72)
        if m_v12_we is not None:
            pulumi.set(__self__, "m_v12_we", m_v12_we)
        if m_v13 is not None:
            pulumi.set(__self__, "m_v13", m_v13)
        if m_v21_mv71 is not None:
            pulumi.set(__self__, "m_v21_mv71", m_v21_mv71)
        if m_v22_xmv72_x is not None:
            pulumi.set(__self__, "m_v22_xmv72_x", m_v22_xmv72_x)
        if m_v32 is not None:
            pulumi.set(__self__, "m_v32", m_v32)
        if m_v33 is not None:
            pulumi.set(__self__, "m_v33", m_v33)
        if m_v52 is not None:
            pulumi.set(__self__, "m_v52", m_v52)
        if m_v63 is not None:
            pulumi.set(__self__, "m_v63", m_v63)
        if m_v63_x is not None:
            pulumi.set(__self__, "m_v63_x", m_v63_x)
        if m_v93 is not None:
            pulumi.set(__self__, "m_v93", m_v93)
        if m_v93_x is not None:
            pulumi.set(__self__, "m_v93_x", m_v93_x)

    @_builtins.property
    @pulumi.getter(name="mV12MV22MV72")
    def m_v12_mv22_mv72(self) -> Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72Args']]:
        """
        Quality and resolution for MV12/MV22/MV72 camera models.
        """
        return pulumi.get(self, "m_v12_mv22_mv72")

    @m_v12_mv22_mv72.setter
    def m_v12_mv22_mv72(self, value: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72Args']]):
        pulumi.set(self, "m_v12_mv22_mv72", value)

    @_builtins.property
    @pulumi.getter(name="mV12We")
    def m_v12_we(self) -> Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV12WeArgs']]:
        """
        Quality and resolution for MV12WE camera models.
        """
        return pulumi.get(self, "m_v12_we")

    @m_v12_we.setter
    def m_v12_we(self, value: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV12WeArgs']]):
        pulumi.set(self, "m_v12_we", value)

    @_builtins.property
    @pulumi.getter(name="mV13")
    def m_v13(self) -> Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV13Args']]:
        """
        Quality and resolution for MV13 camera models.
        """
        return pulumi.get(self, "m_v13")

    @m_v13.setter
    def m_v13(self, value: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV13Args']]):
        pulumi.set(self, "m_v13", value)

    @_builtins.property
    @pulumi.getter(name="mV21MV71")
    def m_v21_mv71(self) -> Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV21MV71Args']]:
        """
        Quality and resolution for MV21/MV71 camera models.
        """
        return pulumi.get(self, "m_v21_mv71")

    @m_v21_mv71.setter
    def m_v21_mv71(self, value: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV21MV71Args']]):
        pulumi.set(self, "m_v21_mv71", value)

    @_builtins.property
    @pulumi.getter(name="mV22Xmv72X")
    def m_v22_xmv72_x(self) -> Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV22Xmv72XArgs']]:
        """
        Quality and resolution for MV22X/MV72X camera models.
        """
        return pulumi.get(self, "m_v22_xmv72_x")

    @m_v22_xmv72_x.setter
    def m_v22_xmv72_x(self, value: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV22Xmv72XArgs']]):
        pulumi.set(self, "m_v22_xmv72_x", value)

    @_builtins.property
    @pulumi.getter(name="mV32")
    def m_v32(self) -> Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV32Args']]:
        """
        Quality and resolution for MV32 camera models.
        """
        return pulumi.get(self, "m_v32")

    @m_v32.setter
    def m_v32(self, value: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV32Args']]):
        pulumi.set(self, "m_v32", value)

    @_builtins.property
    @pulumi.getter(name="mV33")
    def m_v33(self) -> Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV33Args']]:
        """
        Quality and resolution for MV33 camera models.
        """
        return pulumi.get(self, "m_v33")

    @m_v33.setter
    def m_v33(self, value: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV33Args']]):
        pulumi.set(self, "m_v33", value)

    @_builtins.property
    @pulumi.getter(name="mV52")
    def m_v52(self) -> Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV52Args']]:
        """
        Quality and resolution for MV52 camera models.
        """
        return pulumi.get(self, "m_v52")

    @m_v52.setter
    def m_v52(self, value: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV52Args']]):
        pulumi.set(self, "m_v52", value)

    @_builtins.property
    @pulumi.getter(name="mV63")
    def m_v63(self) -> Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV63Args']]:
        """
        Quality and resolution for MV63 camera models.
        """
        return pulumi.get(self, "m_v63")

    @m_v63.setter
    def m_v63(self, value: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV63Args']]):
        pulumi.set(self, "m_v63", value)

    @_builtins.property
    @pulumi.getter(name="mV63X")
    def m_v63_x(self) -> Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV63XArgs']]:
        """
        Quality and resolution for MV63X camera models.
        """
        return pulumi.get(self, "m_v63_x")

    @m_v63_x.setter
    def m_v63_x(self, value: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV63XArgs']]):
        pulumi.set(self, "m_v63_x", value)

    @_builtins.property
    @pulumi.getter(name="mV93")
    def m_v93(self) -> Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV93Args']]:
        """
        Quality and resolution for MV93 camera models.
        """
        return pulumi.get(self, "m_v93")

    @m_v93.setter
    def m_v93(self, value: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV93Args']]):
        pulumi.set(self, "m_v93", value)

    @_builtins.property
    @pulumi.getter(name="mV93X")
    def m_v93_x(self) -> Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV93XArgs']]:
        """
        Quality and resolution for MV93X camera models.
        """
        return pulumi.get(self, "m_v93_x")

    @m_v93_x.setter
    def m_v93_x(self, value: Optional[pulumi.Input['CameraQualityRetentionProfilesVideoSettingsMV93XArgs']]):
        pulumi.set(self, "m_v93_x", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72ArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        resolution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72Args:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param pulumi.Input[_builtins.str] resolution: Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsMV12WeArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        resolution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsMV12WeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsMV12WeArgs:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param pulumi.Input[_builtins.str] resolution: Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsMV13ArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        resolution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsMV13ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsMV13Args:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param pulumi.Input[_builtins.str] resolution: Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsMV21MV71ArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        resolution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution of the camera. Can be one of '1280x720'.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsMV21MV71ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsMV21MV71Args:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param pulumi.Input[_builtins.str] resolution: Resolution of the camera. Can be one of '1280x720'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution of the camera. Can be one of '1280x720'.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsMV22Xmv72XArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        resolution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsMV22Xmv72XArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsMV22Xmv72XArgs:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param pulumi.Input[_builtins.str] resolution: Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsMV32ArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        resolution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsMV32ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsMV32Args:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param pulumi.Input[_builtins.str] resolution: Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsMV33ArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        resolution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsMV33ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsMV33Args:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param pulumi.Input[_builtins.str] resolution: Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsMV52ArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        resolution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsMV52ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsMV52Args:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param pulumi.Input[_builtins.str] resolution: Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsMV63ArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        resolution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsMV63ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsMV63Args:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param pulumi.Input[_builtins.str] resolution: Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsMV63XArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        resolution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsMV63XArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsMV63XArgs:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param pulumi.Input[_builtins.str] resolution: Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsMV93ArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        resolution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsMV93ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsMV93Args:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param pulumi.Input[_builtins.str] resolution: Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution", value)


if not MYPY:
    class CameraQualityRetentionProfilesVideoSettingsMV93XArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        resolution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
        """
elif False:
    CameraQualityRetentionProfilesVideoSettingsMV93XArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraQualityRetentionProfilesVideoSettingsMV93XArgs:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        :param pulumi.Input[_builtins.str] resolution: Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution", value)


if not MYPY:
    class CameraWirelessProfilesIdentityArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password of the identity.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username of the identity.
        """
elif False:
    CameraWirelessProfilesIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraWirelessProfilesIdentityArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password: The password of the identity.
        :param pulumi.Input[_builtins.str] username: The username of the identity.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password of the identity.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username of the identity.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class CameraWirelessProfilesSsidArgsDict(TypedDict):
        auth_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The auth mode of the SSID. It can be set to ('psk', '8021x-radius').
        """
        encryption_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius'
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the SSID.
        """
        psk: NotRequired[pulumi.Input[_builtins.str]]
        """
        The pre-shared key of the SSID.
        """
elif False:
    CameraWirelessProfilesSsidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CameraWirelessProfilesSsidArgs:
    def __init__(__self__, *,
                 auth_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 encryption_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 psk: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_mode: The auth mode of the SSID. It can be set to ('psk', '8021x-radius').
        :param pulumi.Input[_builtins.str] encryption_mode: The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius'
        :param pulumi.Input[_builtins.str] name: The name of the SSID.
        :param pulumi.Input[_builtins.str] psk: The pre-shared key of the SSID.
        """
        if auth_mode is not None:
            pulumi.set(__self__, "auth_mode", auth_mode)
        if encryption_mode is not None:
            pulumi.set(__self__, "encryption_mode", encryption_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if psk is not None:
            pulumi.set(__self__, "psk", psk)

    @_builtins.property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The auth mode of the SSID. It can be set to ('psk', '8021x-radius').
        """
        return pulumi.get(self, "auth_mode")

    @auth_mode.setter
    def auth_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_mode", value)

    @_builtins.property
    @pulumi.getter(name="encryptionMode")
    def encryption_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius'
        """
        return pulumi.get(self, "encryption_mode")

    @encryption_mode.setter
    def encryption_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_mode", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the SSID.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def psk(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The pre-shared key of the SSID.
        """
        return pulumi.get(self, "psk")

    @psk.setter
    def psk(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "psk", value)


if not MYPY:
    class CellularGatewayConnectivityMonitoringDestinationsDestinationArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the testing destination. Optional, defaults to an empty string
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address to test connectivity with
        """
elif False:
    CellularGatewayConnectivityMonitoringDestinationsDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CellularGatewayConnectivityMonitoringDestinationsDestinationArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] default: Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
        :param pulumi.Input[_builtins.str] description: Description of the testing destination. Optional, defaults to an empty string
        :param pulumi.Input[_builtins.str] ip: The IP address to test connectivity with
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the testing destination. Optional, defaults to an empty string
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address to test connectivity with
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class CellularGatewaySubnetPoolSubnetArgsDict(TypedDict):
        appliance_ip: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        serial: NotRequired[pulumi.Input[_builtins.str]]
        subnet: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CellularGatewaySubnetPoolSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CellularGatewaySubnetPoolSubnetArgs:
    def __init__(__self__, *,
                 appliance_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet: Optional[pulumi.Input[_builtins.str]] = None):
        if appliance_ip is not None:
            pulumi.set(__self__, "appliance_ip", appliance_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter(name="applianceIp")
    def appliance_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "appliance_ip")

    @appliance_ip.setter
    def appliance_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "appliance_ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class CellularGatewayUplinkBandwidthLimitsArgsDict(TypedDict):
        limit_down: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum download limit (integer, in Kbps). 'null' indicates no limit.
        """
        limit_up: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum upload limit (integer, in Kbps). 'null' indicates no limit.
        """
elif False:
    CellularGatewayUplinkBandwidthLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CellularGatewayUplinkBandwidthLimitsArgs:
    def __init__(__self__, *,
                 limit_down: Optional[pulumi.Input[_builtins.int]] = None,
                 limit_up: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] limit_down: The maximum download limit (integer, in Kbps). 'null' indicates no limit.
        :param pulumi.Input[_builtins.int] limit_up: The maximum upload limit (integer, in Kbps). 'null' indicates no limit.
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum download limit (integer, in Kbps). 'null' indicates no limit.
        """
        return pulumi.get(self, "limit_down")

    @limit_down.setter
    def limit_down(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_down", value)

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum upload limit (integer, in Kbps). 'null' indicates no limit.
        """
        return pulumi.get(self, "limit_up")

    @limit_up.setter
    def limit_up(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_up", value)


if not MYPY:
    class ClientsProvisionItemArgsDict(TypedDict):
        clients: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClientsProvisionItemClientArgsDict']]]]
        """
        The list of clients to provision
        """
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the client's policy
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The group policy identifier of the client
        """
elif False:
    ClientsProvisionItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionItemArgs:
    def __init__(__self__, *,
                 clients: Optional[pulumi.Input[Sequence[pulumi.Input['ClientsProvisionItemClientArgs']]]] = None,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClientsProvisionItemClientArgs']]] clients: The list of clients to provision
        :param pulumi.Input[_builtins.str] device_policy: The name of the client's policy
        :param pulumi.Input[_builtins.str] group_policy_id: The group policy identifier of the client
        """
        if clients is not None:
            pulumi.set(__self__, "clients", clients)
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClientsProvisionItemClientArgs']]]]:
        """
        The list of clients to provision
        """
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClientsProvisionItemClientArgs']]]]):
        pulumi.set(self, "clients", value)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the client's policy
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The group policy identifier of the client
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionItemClientArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the client
        """
        mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MAC address of the client
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client's display message if its group policy is 'Blocked'
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the client
        """
elif False:
    ClientsProvisionItemClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionItemClientArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mac: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: The identifier of the client
        :param pulumi.Input[_builtins.str] mac: The MAC address of the client
        :param pulumi.Input[_builtins.str] message: The client's display message if its group policy is 'Blocked'
        :param pulumi.Input[_builtins.str] name: The name of the client
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the client
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MAC address of the client
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client's display message if its group policy is 'Blocked'
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the client
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClientsProvisionParametersArgsDict(TypedDict):
        clients: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClientsProvisionParametersClientArgsDict']]]]
        """
        The array of clients to provision
        """
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        policies_by_security_appliance: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySecurityApplianceArgsDict']]
        """
        An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
        """
        policies_by_ssid: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidArgsDict']]
        """
        An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
        """
elif False:
    ClientsProvisionParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersArgs:
    def __init__(__self__, *,
                 clients: Optional[pulumi.Input[Sequence[pulumi.Input['ClientsProvisionParametersClientArgs']]]] = None,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 policies_by_security_appliance: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySecurityApplianceArgs']] = None,
                 policies_by_ssid: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClientsProvisionParametersClientArgs']]] clients: The array of clients to provision
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySecurityApplianceArgs'] policies_by_security_appliance: An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidArgs'] policies_by_ssid: An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
        """
        if clients is not None:
            pulumi.set(__self__, "clients", clients)
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)
        if policies_by_security_appliance is not None:
            pulumi.set(__self__, "policies_by_security_appliance", policies_by_security_appliance)
        if policies_by_ssid is not None:
            pulumi.set(__self__, "policies_by_ssid", policies_by_ssid)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClientsProvisionParametersClientArgs']]]]:
        """
        The array of clients to provision
        """
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClientsProvisionParametersClientArgs']]]]):
        pulumi.set(self, "clients", value)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="policiesBySecurityAppliance")
    def policies_by_security_appliance(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySecurityApplianceArgs']]:
        """
        An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
        """
        return pulumi.get(self, "policies_by_security_appliance")

    @policies_by_security_appliance.setter
    def policies_by_security_appliance(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySecurityApplianceArgs']]):
        pulumi.set(self, "policies_by_security_appliance", value)

    @_builtins.property
    @pulumi.getter(name="policiesBySsid")
    def policies_by_ssid(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidArgs']]:
        """
        An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
        """
        return pulumi.get(self, "policies_by_ssid")

    @policies_by_ssid.setter
    def policies_by_ssid(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidArgs']]):
        pulumi.set(self, "policies_by_ssid", value)


if not MYPY:
    class ClientsProvisionParametersClientArgsDict(TypedDict):
        mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MAC address of the client. Required.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name for the client. Optional. Limited to 255 bytes.
        """
elif False:
    ClientsProvisionParametersClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersClientArgs:
    def __init__(__self__, *,
                 mac: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mac: The MAC address of the client. Required.
        :param pulumi.Input[_builtins.str] name: The display name for the client. Optional. Limited to 255 bytes.
        """
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MAC address of the client. Required.
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name for the client. Optional. Limited to 255 bytes.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySecurityApplianceArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked' or 'Normal'. Required.
        """
elif False:
    ClientsProvisionParametersPoliciesBySecurityApplianceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySecurityApplianceArgs:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked' or 'Normal'. Required.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked' or 'Normal'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidArgsDict(TypedDict):
        status0: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus0ArgsDict']]
        """
        The number for the SSID
        """
        status1: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus1ArgsDict']]
        """
        The number for the SSID
        """
        status10: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus10ArgsDict']]
        """
        The number for the SSID
        """
        status11: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus11ArgsDict']]
        """
        The number for the SSID
        """
        status12: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus12ArgsDict']]
        """
        The number for the SSID
        """
        status13: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus13ArgsDict']]
        """
        The number for the SSID
        """
        status14: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus14ArgsDict']]
        """
        The number for the SSID
        """
        status2: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus2ArgsDict']]
        """
        The number for the SSID
        """
        status3: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus3ArgsDict']]
        """
        The number for the SSID
        """
        status4: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus4ArgsDict']]
        """
        The number for the SSID
        """
        status5: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus5ArgsDict']]
        """
        The number for the SSID
        """
        status6: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus6ArgsDict']]
        """
        The number for the SSID
        """
        status7: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus7ArgsDict']]
        """
        The number for the SSID
        """
        status8: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus8ArgsDict']]
        """
        The number for the SSID
        """
        status9: NotRequired[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus9ArgsDict']]
        """
        The number for the SSID
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidArgs:
    def __init__(__self__, *,
                 status0: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus0Args']] = None,
                 status1: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus1Args']] = None,
                 status10: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus10Args']] = None,
                 status11: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus11Args']] = None,
                 status12: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus12Args']] = None,
                 status13: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus13Args']] = None,
                 status14: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus14Args']] = None,
                 status2: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus2Args']] = None,
                 status3: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus3Args']] = None,
                 status4: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus4Args']] = None,
                 status5: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus5Args']] = None,
                 status6: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus6Args']] = None,
                 status7: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus7Args']] = None,
                 status8: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus8Args']] = None,
                 status9: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus9Args']] = None):
        """
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus0Args'] status0: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus1Args'] status1: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus10Args'] status10: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus11Args'] status11: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus12Args'] status12: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus13Args'] status13: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus14Args'] status14: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus2Args'] status2: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus3Args'] status3: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus4Args'] status4: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus5Args'] status5: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus6Args'] status6: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus7Args'] status7: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus8Args'] status8: The number for the SSID
        :param pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus9Args'] status9: The number for the SSID
        """
        if status0 is not None:
            pulumi.set(__self__, "status0", status0)
        if status1 is not None:
            pulumi.set(__self__, "status1", status1)
        if status10 is not None:
            pulumi.set(__self__, "status10", status10)
        if status11 is not None:
            pulumi.set(__self__, "status11", status11)
        if status12 is not None:
            pulumi.set(__self__, "status12", status12)
        if status13 is not None:
            pulumi.set(__self__, "status13", status13)
        if status14 is not None:
            pulumi.set(__self__, "status14", status14)
        if status2 is not None:
            pulumi.set(__self__, "status2", status2)
        if status3 is not None:
            pulumi.set(__self__, "status3", status3)
        if status4 is not None:
            pulumi.set(__self__, "status4", status4)
        if status5 is not None:
            pulumi.set(__self__, "status5", status5)
        if status6 is not None:
            pulumi.set(__self__, "status6", status6)
        if status7 is not None:
            pulumi.set(__self__, "status7", status7)
        if status8 is not None:
            pulumi.set(__self__, "status8", status8)
        if status9 is not None:
            pulumi.set(__self__, "status9", status9)

    @_builtins.property
    @pulumi.getter
    def status0(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus0Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status0")

    @status0.setter
    def status0(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus0Args']]):
        pulumi.set(self, "status0", value)

    @_builtins.property
    @pulumi.getter
    def status1(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus1Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status1")

    @status1.setter
    def status1(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus1Args']]):
        pulumi.set(self, "status1", value)

    @_builtins.property
    @pulumi.getter
    def status10(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus10Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status10")

    @status10.setter
    def status10(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus10Args']]):
        pulumi.set(self, "status10", value)

    @_builtins.property
    @pulumi.getter
    def status11(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus11Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status11")

    @status11.setter
    def status11(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus11Args']]):
        pulumi.set(self, "status11", value)

    @_builtins.property
    @pulumi.getter
    def status12(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus12Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status12")

    @status12.setter
    def status12(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus12Args']]):
        pulumi.set(self, "status12", value)

    @_builtins.property
    @pulumi.getter
    def status13(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus13Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status13")

    @status13.setter
    def status13(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus13Args']]):
        pulumi.set(self, "status13", value)

    @_builtins.property
    @pulumi.getter
    def status14(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus14Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status14")

    @status14.setter
    def status14(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus14Args']]):
        pulumi.set(self, "status14", value)

    @_builtins.property
    @pulumi.getter
    def status2(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus2Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status2")

    @status2.setter
    def status2(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus2Args']]):
        pulumi.set(self, "status2", value)

    @_builtins.property
    @pulumi.getter
    def status3(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus3Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status3")

    @status3.setter
    def status3(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus3Args']]):
        pulumi.set(self, "status3", value)

    @_builtins.property
    @pulumi.getter
    def status4(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus4Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status4")

    @status4.setter
    def status4(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus4Args']]):
        pulumi.set(self, "status4", value)

    @_builtins.property
    @pulumi.getter
    def status5(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus5Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status5")

    @status5.setter
    def status5(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus5Args']]):
        pulumi.set(self, "status5", value)

    @_builtins.property
    @pulumi.getter
    def status6(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus6Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status6")

    @status6.setter
    def status6(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus6Args']]):
        pulumi.set(self, "status6", value)

    @_builtins.property
    @pulumi.getter
    def status7(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus7Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status7")

    @status7.setter
    def status7(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus7Args']]):
        pulumi.set(self, "status7", value)

    @_builtins.property
    @pulumi.getter
    def status8(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus8Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status8")

    @status8.setter
    def status8(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus8Args']]):
        pulumi.set(self, "status8", value)

    @_builtins.property
    @pulumi.getter
    def status9(self) -> Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus9Args']]:
        """
        The number for the SSID
        """
        return pulumi.get(self, "status9")

    @status9.setter
    def status9(self, value: Optional[pulumi.Input['ClientsProvisionParametersPoliciesBySsidStatus9Args']]):
        pulumi.set(self, "status9", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus0ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus0ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus0Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus10ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus10ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus10Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus11ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus11ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus11Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus12ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus12ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus12Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus13ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus13ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus13Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus14ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus14ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus14Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus1ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus1Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus2ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus2Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus3ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus3Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus4ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus4Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus5ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus5Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus6ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus6Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus7ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus7ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus7Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus8ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus8ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus8Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsProvisionParametersPoliciesBySsidStatus9ArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
elif False:
    ClientsProvisionParametersPoliciesBySsidStatus9ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsProvisionParametersPoliciesBySsidStatus9Args:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        :param pulumi.Input[_builtins.str] group_policy_id: The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsArgsDict(TypedDict):
        status0: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus0ArgsDict']]
        """
        Splash authorization for SSID 0
        """
        status1: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus1ArgsDict']]
        """
        Splash authorization for SSID 1
        """
        status10: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus10ArgsDict']]
        """
        Splash authorization for SSID 10
        """
        status11: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus11ArgsDict']]
        """
        Splash authorization for SSID 11
        """
        status12: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus12ArgsDict']]
        """
        Splash authorization for SSID 12
        """
        status13: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus13ArgsDict']]
        """
        Splash authorization for SSID 13
        """
        status14: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus14ArgsDict']]
        """
        Splash authorization for SSID 14
        """
        status2: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus2ArgsDict']]
        """
        Splash authorization for SSID 2
        """
        status3: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus3ArgsDict']]
        """
        Splash authorization for SSID 3
        """
        status4: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus4ArgsDict']]
        """
        Splash authorization for SSID 4
        """
        status5: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus5ArgsDict']]
        """
        Splash authorization for SSID 5
        """
        status6: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus6ArgsDict']]
        """
        Splash authorization for SSID 6
        """
        status7: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus7ArgsDict']]
        """
        Splash authorization for SSID 7
        """
        status8: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus8ArgsDict']]
        """
        Splash authorization for SSID 8
        """
        status9: NotRequired[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus9ArgsDict']]
        """
        Splash authorization for SSID 9
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsArgs:
    def __init__(__self__, *,
                 status0: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus0Args']] = None,
                 status1: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus1Args']] = None,
                 status10: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus10Args']] = None,
                 status11: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus11Args']] = None,
                 status12: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus12Args']] = None,
                 status13: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus13Args']] = None,
                 status14: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus14Args']] = None,
                 status2: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus2Args']] = None,
                 status3: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus3Args']] = None,
                 status4: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus4Args']] = None,
                 status5: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus5Args']] = None,
                 status6: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus6Args']] = None,
                 status7: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus7Args']] = None,
                 status8: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus8Args']] = None,
                 status9: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus9Args']] = None):
        """
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus0Args'] status0: Splash authorization for SSID 0
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus1Args'] status1: Splash authorization for SSID 1
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus10Args'] status10: Splash authorization for SSID 10
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus11Args'] status11: Splash authorization for SSID 11
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus12Args'] status12: Splash authorization for SSID 12
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus13Args'] status13: Splash authorization for SSID 13
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus14Args'] status14: Splash authorization for SSID 14
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus2Args'] status2: Splash authorization for SSID 2
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus3Args'] status3: Splash authorization for SSID 3
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus4Args'] status4: Splash authorization for SSID 4
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus5Args'] status5: Splash authorization for SSID 5
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus6Args'] status6: Splash authorization for SSID 6
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus7Args'] status7: Splash authorization for SSID 7
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus8Args'] status8: Splash authorization for SSID 8
        :param pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus9Args'] status9: Splash authorization for SSID 9
        """
        if status0 is not None:
            pulumi.set(__self__, "status0", status0)
        if status1 is not None:
            pulumi.set(__self__, "status1", status1)
        if status10 is not None:
            pulumi.set(__self__, "status10", status10)
        if status11 is not None:
            pulumi.set(__self__, "status11", status11)
        if status12 is not None:
            pulumi.set(__self__, "status12", status12)
        if status13 is not None:
            pulumi.set(__self__, "status13", status13)
        if status14 is not None:
            pulumi.set(__self__, "status14", status14)
        if status2 is not None:
            pulumi.set(__self__, "status2", status2)
        if status3 is not None:
            pulumi.set(__self__, "status3", status3)
        if status4 is not None:
            pulumi.set(__self__, "status4", status4)
        if status5 is not None:
            pulumi.set(__self__, "status5", status5)
        if status6 is not None:
            pulumi.set(__self__, "status6", status6)
        if status7 is not None:
            pulumi.set(__self__, "status7", status7)
        if status8 is not None:
            pulumi.set(__self__, "status8", status8)
        if status9 is not None:
            pulumi.set(__self__, "status9", status9)

    @_builtins.property
    @pulumi.getter
    def status0(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus0Args']]:
        """
        Splash authorization for SSID 0
        """
        return pulumi.get(self, "status0")

    @status0.setter
    def status0(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus0Args']]):
        pulumi.set(self, "status0", value)

    @_builtins.property
    @pulumi.getter
    def status1(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus1Args']]:
        """
        Splash authorization for SSID 1
        """
        return pulumi.get(self, "status1")

    @status1.setter
    def status1(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus1Args']]):
        pulumi.set(self, "status1", value)

    @_builtins.property
    @pulumi.getter
    def status10(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus10Args']]:
        """
        Splash authorization for SSID 10
        """
        return pulumi.get(self, "status10")

    @status10.setter
    def status10(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus10Args']]):
        pulumi.set(self, "status10", value)

    @_builtins.property
    @pulumi.getter
    def status11(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus11Args']]:
        """
        Splash authorization for SSID 11
        """
        return pulumi.get(self, "status11")

    @status11.setter
    def status11(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus11Args']]):
        pulumi.set(self, "status11", value)

    @_builtins.property
    @pulumi.getter
    def status12(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus12Args']]:
        """
        Splash authorization for SSID 12
        """
        return pulumi.get(self, "status12")

    @status12.setter
    def status12(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus12Args']]):
        pulumi.set(self, "status12", value)

    @_builtins.property
    @pulumi.getter
    def status13(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus13Args']]:
        """
        Splash authorization for SSID 13
        """
        return pulumi.get(self, "status13")

    @status13.setter
    def status13(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus13Args']]):
        pulumi.set(self, "status13", value)

    @_builtins.property
    @pulumi.getter
    def status14(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus14Args']]:
        """
        Splash authorization for SSID 14
        """
        return pulumi.get(self, "status14")

    @status14.setter
    def status14(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus14Args']]):
        pulumi.set(self, "status14", value)

    @_builtins.property
    @pulumi.getter
    def status2(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus2Args']]:
        """
        Splash authorization for SSID 2
        """
        return pulumi.get(self, "status2")

    @status2.setter
    def status2(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus2Args']]):
        pulumi.set(self, "status2", value)

    @_builtins.property
    @pulumi.getter
    def status3(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus3Args']]:
        """
        Splash authorization for SSID 3
        """
        return pulumi.get(self, "status3")

    @status3.setter
    def status3(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus3Args']]):
        pulumi.set(self, "status3", value)

    @_builtins.property
    @pulumi.getter
    def status4(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus4Args']]:
        """
        Splash authorization for SSID 4
        """
        return pulumi.get(self, "status4")

    @status4.setter
    def status4(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus4Args']]):
        pulumi.set(self, "status4", value)

    @_builtins.property
    @pulumi.getter
    def status5(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus5Args']]:
        """
        Splash authorization for SSID 5
        """
        return pulumi.get(self, "status5")

    @status5.setter
    def status5(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus5Args']]):
        pulumi.set(self, "status5", value)

    @_builtins.property
    @pulumi.getter
    def status6(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus6Args']]:
        """
        Splash authorization for SSID 6
        """
        return pulumi.get(self, "status6")

    @status6.setter
    def status6(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus6Args']]):
        pulumi.set(self, "status6", value)

    @_builtins.property
    @pulumi.getter
    def status7(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus7Args']]:
        """
        Splash authorization for SSID 7
        """
        return pulumi.get(self, "status7")

    @status7.setter
    def status7(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus7Args']]):
        pulumi.set(self, "status7", value)

    @_builtins.property
    @pulumi.getter
    def status8(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus8Args']]:
        """
        Splash authorization for SSID 8
        """
        return pulumi.get(self, "status8")

    @status8.setter
    def status8(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus8Args']]):
        pulumi.set(self, "status8", value)

    @_builtins.property
    @pulumi.getter
    def status9(self) -> Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus9Args']]:
        """
        Splash authorization for SSID 9
        """
        return pulumi.get(self, "status9")

    @status9.setter
    def status9(self, value: Optional[pulumi.Input['ClientsSplashAuthorizationStatusSsidsStatus9Args']]):
        pulumi.set(self, "status9", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus0ArgsDict(TypedDict):
        authorized_at: NotRequired[pulumi.Input[_builtins.str]]
        expires_at: NotRequired[pulumi.Input[_builtins.str]]
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus0ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus0Args:
    def __init__(__self__, *,
                 authorized_at: Optional[pulumi.Input[_builtins.str]] = None,
                 expires_at: Optional[pulumi.Input[_builtins.str]] = None,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if authorized_at is not None:
            pulumi.set(__self__, "authorized_at", authorized_at)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="authorizedAt")
    def authorized_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "authorized_at")

    @authorized_at.setter
    def authorized_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorized_at", value)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expires_at", value)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus10ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus10ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus10Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus11ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus11ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus11Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus12ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus12ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus12Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus13ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus13ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus13Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus14ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus14ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus14Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus1ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus1Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus2ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus2Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus3ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus3Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus4ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus4Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus5ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus5Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus6ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus6Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus7ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus7ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus7Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus8ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus8ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus8Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class ClientsSplashAuthorizationStatusSsidsStatus9ArgsDict(TypedDict):
        is_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        New authorization status for the SSID (true, false).
        """
elif False:
    ClientsSplashAuthorizationStatusSsidsStatus9ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientsSplashAuthorizationStatusSsidsStatus9Args:
    def __init__(__self__, *,
                 is_authorized: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_authorized: New authorization status for the SSID (true, false).
        """
        if is_authorized is not None:
            pulumi.set(__self__, "is_authorized", is_authorized)

    @_builtins.property
    @pulumi.getter(name="isAuthorized")
    def is_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        New authorization status for the SSID (true, false).
        """
        return pulumi.get(self, "is_authorized")

    @is_authorized.setter
    def is_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authorized", value)


if not MYPY:
    class DevicesClaimItemArgsDict(TypedDict):
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The serials of the devices
        """
elif False:
    DevicesClaimItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicesClaimItemArgs:
    def __init__(__self__, *,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: The serials of the devices
        """
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The serials of the devices
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)


if not MYPY:
    class DevicesClaimParametersArgsDict(TypedDict):
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of serials of devices to claim
        """
elif False:
    DevicesClaimParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicesClaimParametersArgs:
    def __init__(__self__, *,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: A list of serials of devices to claim
        """
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of serials of devices to claim
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)


if not MYPY:
    class DevicesClaimVmxItemArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Physical address of the device
        """
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input['DevicesClaimVmxItemDetailArgsDict']]]]
        """
        Additional device information
        """
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version of the device
        """
        imei: NotRequired[pulumi.Input[_builtins.str]]
        """
        IMEI of the device, if applicable
        """
        lan_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        LAN IP address of the device
        """
        lat: NotRequired[pulumi.Input[_builtins.float]]
        """
        Latitude of the device
        """
        lng: NotRequired[pulumi.Input[_builtins.float]]
        """
        Longitude of the device
        """
        mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        MAC address of the device
        """
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        Model of the device
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the device
        """
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the network the device belongs to
        """
        notes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notes for the device, limited to 255 characters
        """
        product_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Product type of the device
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Serial number of the device
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of tags assigned to the device
        """
elif False:
    DevicesClaimVmxItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicesClaimVmxItemArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input['DevicesClaimVmxItemDetailArgs']]]] = None,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 imei: Optional[pulumi.Input[_builtins.str]] = None,
                 lan_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 lat: Optional[pulumi.Input[_builtins.float]] = None,
                 lng: Optional[pulumi.Input[_builtins.float]] = None,
                 mac: Optional[pulumi.Input[_builtins.str]] = None,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 product_type: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Physical address of the device
        :param pulumi.Input[Sequence[pulumi.Input['DevicesClaimVmxItemDetailArgs']]] details: Additional device information
        :param pulumi.Input[_builtins.str] firmware: Firmware version of the device
        :param pulumi.Input[_builtins.str] imei: IMEI of the device, if applicable
        :param pulumi.Input[_builtins.str] lan_ip: LAN IP address of the device
        :param pulumi.Input[_builtins.float] lat: Latitude of the device
        :param pulumi.Input[_builtins.float] lng: Longitude of the device
        :param pulumi.Input[_builtins.str] mac: MAC address of the device
        :param pulumi.Input[_builtins.str] model: Model of the device
        :param pulumi.Input[_builtins.str] name: Name of the device
        :param pulumi.Input[_builtins.str] network_id: ID of the network the device belongs to
        :param pulumi.Input[_builtins.str] notes: Notes for the device, limited to 255 characters
        :param pulumi.Input[_builtins.str] product_type: Product type of the device
        :param pulumi.Input[_builtins.str] serial: Serial number of the device
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: List of tags assigned to the device
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if imei is not None:
            pulumi.set(__self__, "imei", imei)
        if lan_ip is not None:
            pulumi.set(__self__, "lan_ip", lan_ip)
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if product_type is not None:
            pulumi.set(__self__, "product_type", product_type)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Physical address of the device
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevicesClaimVmxItemDetailArgs']]]]:
        """
        Additional device information
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevicesClaimVmxItemDetailArgs']]]]):
        pulumi.set(self, "details", value)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version of the device
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def imei(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IMEI of the device, if applicable
        """
        return pulumi.get(self, "imei")

    @imei.setter
    def imei(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "imei", value)

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        LAN IP address of the device
        """
        return pulumi.get(self, "lan_ip")

    @lan_ip.setter
    def lan_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lan_ip", value)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Latitude of the device
        """
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat", value)

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Longitude of the device
        """
        return pulumi.get(self, "lng")

    @lng.setter
    def lng(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lng", value)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        MAC address of the device
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Model of the device
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the device
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the network the device belongs to
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notes for the device, limited to 255 characters
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Product type of the device
        """
        return pulumi.get(self, "product_type")

    @product_type.setter
    def product_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "product_type", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Serial number of the device
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of tags assigned to the device
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class DevicesClaimVmxItemDetailArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional property name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional property value
        """
elif False:
    DevicesClaimVmxItemDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicesClaimVmxItemDetailArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Additional property name
        :param pulumi.Input[_builtins.str] value: Additional property value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional property name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional property value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DevicesClaimVmxParametersArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[_builtins.str]]
        """
        The size of the vMX you claim. It can be one of: small, medium, large, xlarge, 100
        """
elif False:
    DevicesClaimVmxParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicesClaimVmxParametersArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] size: The size of the vMX you claim. It can be one of: small, medium, large, xlarge, 100
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The size of the vMX you claim. It can be one of: small, medium, large, xlarge, 100
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class DevicesRemoveParametersArgsDict(TypedDict):
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        The serial of a device
        """
elif False:
    DevicesRemoveParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicesRemoveParametersArgs:
    def __init__(__self__, *,
                 serial: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] serial: The serial of a device
        """
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The serial of a device
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)


if not MYPY:
    class FirmwareUpgradesProductsArgsDict(TypedDict):
        appliance: NotRequired[pulumi.Input['FirmwareUpgradesProductsApplianceArgsDict']]
        """
        The network device to be updated
        """
        camera: NotRequired[pulumi.Input['FirmwareUpgradesProductsCameraArgsDict']]
        """
        The network device to be updated
        """
        cellular_gateway: NotRequired[pulumi.Input['FirmwareUpgradesProductsCellularGatewayArgsDict']]
        """
        The network device to be updated
        """
        sensor: NotRequired[pulumi.Input['FirmwareUpgradesProductsSensorArgsDict']]
        """
        The network device to be updated
        """
        switch: NotRequired[pulumi.Input['FirmwareUpgradesProductsSwitchArgsDict']]
        """
        The network device to be updated
        """
        switch_catalyst: NotRequired[pulumi.Input['FirmwareUpgradesProductsSwitchCatalystArgsDict']]
        """
        The network device to be updated
        """
        wireless: NotRequired[pulumi.Input['FirmwareUpgradesProductsWirelessArgsDict']]
        """
        The network device to be updated
        """
elif False:
    FirmwareUpgradesProductsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsArgs:
    def __init__(__self__, *,
                 appliance: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceArgs']] = None,
                 camera: Optional[pulumi.Input['FirmwareUpgradesProductsCameraArgs']] = None,
                 cellular_gateway: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayArgs']] = None,
                 sensor: Optional[pulumi.Input['FirmwareUpgradesProductsSensorArgs']] = None,
                 switch: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchArgs']] = None,
                 switch_catalyst: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchCatalystArgs']] = None,
                 wireless: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesProductsApplianceArgs'] appliance: The network device to be updated
        :param pulumi.Input['FirmwareUpgradesProductsCameraArgs'] camera: The network device to be updated
        :param pulumi.Input['FirmwareUpgradesProductsCellularGatewayArgs'] cellular_gateway: The network device to be updated
        :param pulumi.Input['FirmwareUpgradesProductsSensorArgs'] sensor: The network device to be updated
        :param pulumi.Input['FirmwareUpgradesProductsSwitchArgs'] switch: The network device to be updated
        :param pulumi.Input['FirmwareUpgradesProductsSwitchCatalystArgs'] switch_catalyst: The network device to be updated
        :param pulumi.Input['FirmwareUpgradesProductsWirelessArgs'] wireless: The network device to be updated
        """
        if appliance is not None:
            pulumi.set(__self__, "appliance", appliance)
        if camera is not None:
            pulumi.set(__self__, "camera", camera)
        if cellular_gateway is not None:
            pulumi.set(__self__, "cellular_gateway", cellular_gateway)
        if sensor is not None:
            pulumi.set(__self__, "sensor", sensor)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if switch_catalyst is not None:
            pulumi.set(__self__, "switch_catalyst", switch_catalyst)
        if wireless is not None:
            pulumi.set(__self__, "wireless", wireless)

    @_builtins.property
    @pulumi.getter
    def appliance(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsApplianceArgs']]:
        """
        The network device to be updated
        """
        return pulumi.get(self, "appliance")

    @appliance.setter
    def appliance(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceArgs']]):
        pulumi.set(self, "appliance", value)

    @_builtins.property
    @pulumi.getter
    def camera(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCameraArgs']]:
        """
        The network device to be updated
        """
        return pulumi.get(self, "camera")

    @camera.setter
    def camera(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCameraArgs']]):
        pulumi.set(self, "camera", value)

    @_builtins.property
    @pulumi.getter(name="cellularGateway")
    def cellular_gateway(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayArgs']]:
        """
        The network device to be updated
        """
        return pulumi.get(self, "cellular_gateway")

    @cellular_gateway.setter
    def cellular_gateway(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayArgs']]):
        pulumi.set(self, "cellular_gateway", value)

    @_builtins.property
    @pulumi.getter
    def sensor(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSensorArgs']]:
        """
        The network device to be updated
        """
        return pulumi.get(self, "sensor")

    @sensor.setter
    def sensor(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSensorArgs']]):
        pulumi.set(self, "sensor", value)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSwitchArgs']]:
        """
        The network device to be updated
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchArgs']]):
        pulumi.set(self, "switch", value)

    @_builtins.property
    @pulumi.getter(name="switchCatalyst")
    def switch_catalyst(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSwitchCatalystArgs']]:
        """
        The network device to be updated
        """
        return pulumi.get(self, "switch_catalyst")

    @switch_catalyst.setter
    def switch_catalyst(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchCatalystArgs']]):
        pulumi.set(self, "switch_catalyst", value)

    @_builtins.property
    @pulumi.getter
    def wireless(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsWirelessArgs']]:
        """
        The network device to be updated
        """
        return pulumi.get(self, "wireless")

    @wireless.setter
    def wireless(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessArgs']]):
        pulumi.set(self, "wireless", value)


if not MYPY:
    class FirmwareUpgradesProductsApplianceArgsDict(TypedDict):
        available_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsApplianceAvailableVersionArgsDict']]]]
        """
        Firmware versions available for upgrade
        """
        current_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsApplianceCurrentVersionArgsDict']]
        """
        Details of the current version on the device
        """
        last_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeArgsDict']]
        """
        Details of the last firmware upgrade on the device
        """
        next_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsApplianceNextUpgradeArgsDict']]
        """
        Details of the next firmware upgrade on the device
        """
        participate_in_next_beta_release: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not the network wants beta firmware
        """
elif False:
    FirmwareUpgradesProductsApplianceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsApplianceArgs:
    def __init__(__self__, *,
                 available_versions: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsApplianceAvailableVersionArgs']]]] = None,
                 current_version: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceCurrentVersionArgs']] = None,
                 last_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeArgs']] = None,
                 next_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceNextUpgradeArgs']] = None,
                 participate_in_next_beta_release: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsApplianceAvailableVersionArgs']]] available_versions: Firmware versions available for upgrade
        :param pulumi.Input['FirmwareUpgradesProductsApplianceCurrentVersionArgs'] current_version: Details of the current version on the device
        :param pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeArgs'] last_upgrade: Details of the last firmware upgrade on the device
        :param pulumi.Input['FirmwareUpgradesProductsApplianceNextUpgradeArgs'] next_upgrade: Details of the next firmware upgrade on the device
        :param pulumi.Input[_builtins.bool] participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if available_versions is not None:
            pulumi.set(__self__, "available_versions", available_versions)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if last_upgrade is not None:
            pulumi.set(__self__, "last_upgrade", last_upgrade)
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsApplianceAvailableVersionArgs']]]]:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @available_versions.setter
    def available_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsApplianceAvailableVersionArgs']]]]):
        pulumi.set(self, "available_versions", value)

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsApplianceCurrentVersionArgs']]:
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @current_version.setter
    def current_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceCurrentVersionArgs']]):
        pulumi.set(self, "current_version", value)

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeArgs']]:
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @last_upgrade.setter
    def last_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeArgs']]):
        pulumi.set(self, "last_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsApplianceNextUpgradeArgs']]:
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @next_upgrade.setter
    def next_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceNextUpgradeArgs']]):
        pulumi.set(self, "next_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")

    @participate_in_next_beta_release.setter
    def participate_in_next_beta_release(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "participate_in_next_beta_release", value)


if not MYPY:
    class FirmwareUpgradesProductsApplianceAvailableVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsApplianceAvailableVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsApplianceAvailableVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsApplianceCurrentVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsApplianceCurrentVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsApplianceCurrentVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsApplianceLastUpgradeArgsDict(TypedDict):
        from_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeFromVersionArgsDict']]
        """
        Details of the version the device upgraded from
        """
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the last successful firmware upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeToVersionArgsDict']]
        """
        Details of the version the device upgraded to
        """
elif False:
    FirmwareUpgradesProductsApplianceLastUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsApplianceLastUpgradeArgs:
    def __init__(__self__, *,
                 from_version: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeFromVersionArgs']] = None,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeFromVersionArgs'] from_version: Details of the version the device upgraded from
        :param pulumi.Input[_builtins.str] time: Timestamp of the last successful firmware upgrade
        :param pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeToVersionArgs'] to_version: Details of the version the device upgraded to
        """
        if from_version is not None:
            pulumi.set(__self__, "from_version", from_version)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeFromVersionArgs']]:
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @from_version.setter
    def from_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeFromVersionArgs']]):
        pulumi.set(self, "from_version", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeToVersionArgs']]:
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceLastUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsApplianceLastUpgradeFromVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsApplianceLastUpgradeFromVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsApplianceLastUpgradeFromVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsApplianceLastUpgradeToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsApplianceLastUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsApplianceLastUpgradeToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsApplianceNextUpgradeArgsDict(TypedDict):
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the next scheduled firmware upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsApplianceNextUpgradeToVersionArgsDict']]
        """
        Details of the version the device will upgrade to if it exists
        """
elif False:
    FirmwareUpgradesProductsApplianceNextUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsApplianceNextUpgradeArgs:
    def __init__(__self__, *,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceNextUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] time: Timestamp of the next scheduled firmware upgrade
        :param pulumi.Input['FirmwareUpgradesProductsApplianceNextUpgradeToVersionArgs'] to_version: Details of the version the device will upgrade to if it exists
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsApplianceNextUpgradeToVersionArgs']]:
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsApplianceNextUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsApplianceNextUpgradeToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsApplianceNextUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsApplianceNextUpgradeToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsCameraArgsDict(TypedDict):
        available_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsCameraAvailableVersionArgsDict']]]]
        """
        Firmware versions available for upgrade
        """
        current_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsCameraCurrentVersionArgsDict']]
        """
        Details of the current version on the device
        """
        last_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeArgsDict']]
        """
        Details of the last firmware upgrade on the device
        """
        next_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsCameraNextUpgradeArgsDict']]
        """
        Details of the next firmware upgrade on the device
        """
        participate_in_next_beta_release: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not the network wants beta firmware
        """
elif False:
    FirmwareUpgradesProductsCameraArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCameraArgs:
    def __init__(__self__, *,
                 available_versions: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsCameraAvailableVersionArgs']]]] = None,
                 current_version: Optional[pulumi.Input['FirmwareUpgradesProductsCameraCurrentVersionArgs']] = None,
                 last_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeArgs']] = None,
                 next_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsCameraNextUpgradeArgs']] = None,
                 participate_in_next_beta_release: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsCameraAvailableVersionArgs']]] available_versions: Firmware versions available for upgrade
        :param pulumi.Input['FirmwareUpgradesProductsCameraCurrentVersionArgs'] current_version: Details of the current version on the device
        :param pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeArgs'] last_upgrade: Details of the last firmware upgrade on the device
        :param pulumi.Input['FirmwareUpgradesProductsCameraNextUpgradeArgs'] next_upgrade: Details of the next firmware upgrade on the device
        :param pulumi.Input[_builtins.bool] participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if available_versions is not None:
            pulumi.set(__self__, "available_versions", available_versions)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if last_upgrade is not None:
            pulumi.set(__self__, "last_upgrade", last_upgrade)
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsCameraAvailableVersionArgs']]]]:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @available_versions.setter
    def available_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsCameraAvailableVersionArgs']]]]):
        pulumi.set(self, "available_versions", value)

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCameraCurrentVersionArgs']]:
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @current_version.setter
    def current_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCameraCurrentVersionArgs']]):
        pulumi.set(self, "current_version", value)

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeArgs']]:
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @last_upgrade.setter
    def last_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeArgs']]):
        pulumi.set(self, "last_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCameraNextUpgradeArgs']]:
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @next_upgrade.setter
    def next_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCameraNextUpgradeArgs']]):
        pulumi.set(self, "next_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")

    @participate_in_next_beta_release.setter
    def participate_in_next_beta_release(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "participate_in_next_beta_release", value)


if not MYPY:
    class FirmwareUpgradesProductsCameraAvailableVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsCameraAvailableVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCameraAvailableVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsCameraCurrentVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsCameraCurrentVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCameraCurrentVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsCameraLastUpgradeArgsDict(TypedDict):
        from_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeFromVersionArgsDict']]
        """
        Details of the version the device upgraded from
        """
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the last successful firmware upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeToVersionArgsDict']]
        """
        Details of the version the device upgraded to
        """
elif False:
    FirmwareUpgradesProductsCameraLastUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCameraLastUpgradeArgs:
    def __init__(__self__, *,
                 from_version: Optional[pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeFromVersionArgs']] = None,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeFromVersionArgs'] from_version: Details of the version the device upgraded from
        :param pulumi.Input[_builtins.str] time: Timestamp of the last successful firmware upgrade
        :param pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeToVersionArgs'] to_version: Details of the version the device upgraded to
        """
        if from_version is not None:
            pulumi.set(__self__, "from_version", from_version)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeFromVersionArgs']]:
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @from_version.setter
    def from_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeFromVersionArgs']]):
        pulumi.set(self, "from_version", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeToVersionArgs']]:
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCameraLastUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsCameraLastUpgradeFromVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsCameraLastUpgradeFromVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCameraLastUpgradeFromVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsCameraLastUpgradeToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsCameraLastUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCameraLastUpgradeToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsCameraNextUpgradeArgsDict(TypedDict):
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the next scheduled firmware upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsCameraNextUpgradeToVersionArgsDict']]
        """
        Details of the version the device will upgrade to if it exists
        """
elif False:
    FirmwareUpgradesProductsCameraNextUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCameraNextUpgradeArgs:
    def __init__(__self__, *,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsCameraNextUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] time: Timestamp of the next scheduled firmware upgrade
        :param pulumi.Input['FirmwareUpgradesProductsCameraNextUpgradeToVersionArgs'] to_version: Details of the version the device will upgrade to if it exists
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCameraNextUpgradeToVersionArgs']]:
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCameraNextUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsCameraNextUpgradeToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsCameraNextUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCameraNextUpgradeToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsCellularGatewayArgsDict(TypedDict):
        available_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsCellularGatewayAvailableVersionArgsDict']]]]
        """
        Firmware versions available for upgrade
        """
        current_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsCellularGatewayCurrentVersionArgsDict']]
        """
        Details of the current version on the device
        """
        last_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeArgsDict']]
        """
        Details of the last firmware upgrade on the device
        """
        next_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsCellularGatewayNextUpgradeArgsDict']]
        """
        Details of the next firmware upgrade on the device
        """
        participate_in_next_beta_release: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not the network wants beta firmware
        """
elif False:
    FirmwareUpgradesProductsCellularGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCellularGatewayArgs:
    def __init__(__self__, *,
                 available_versions: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsCellularGatewayAvailableVersionArgs']]]] = None,
                 current_version: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayCurrentVersionArgs']] = None,
                 last_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeArgs']] = None,
                 next_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayNextUpgradeArgs']] = None,
                 participate_in_next_beta_release: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsCellularGatewayAvailableVersionArgs']]] available_versions: Firmware versions available for upgrade
        :param pulumi.Input['FirmwareUpgradesProductsCellularGatewayCurrentVersionArgs'] current_version: Details of the current version on the device
        :param pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeArgs'] last_upgrade: Details of the last firmware upgrade on the device
        :param pulumi.Input['FirmwareUpgradesProductsCellularGatewayNextUpgradeArgs'] next_upgrade: Details of the next firmware upgrade on the device
        :param pulumi.Input[_builtins.bool] participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if available_versions is not None:
            pulumi.set(__self__, "available_versions", available_versions)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if last_upgrade is not None:
            pulumi.set(__self__, "last_upgrade", last_upgrade)
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsCellularGatewayAvailableVersionArgs']]]]:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @available_versions.setter
    def available_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsCellularGatewayAvailableVersionArgs']]]]):
        pulumi.set(self, "available_versions", value)

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayCurrentVersionArgs']]:
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @current_version.setter
    def current_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayCurrentVersionArgs']]):
        pulumi.set(self, "current_version", value)

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeArgs']]:
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @last_upgrade.setter
    def last_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeArgs']]):
        pulumi.set(self, "last_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayNextUpgradeArgs']]:
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @next_upgrade.setter
    def next_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayNextUpgradeArgs']]):
        pulumi.set(self, "next_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")

    @participate_in_next_beta_release.setter
    def participate_in_next_beta_release(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "participate_in_next_beta_release", value)


if not MYPY:
    class FirmwareUpgradesProductsCellularGatewayAvailableVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsCellularGatewayAvailableVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCellularGatewayAvailableVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsCellularGatewayCurrentVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsCellularGatewayCurrentVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCellularGatewayCurrentVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsCellularGatewayLastUpgradeArgsDict(TypedDict):
        from_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersionArgsDict']]
        """
        Details of the version the device upgraded from
        """
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the last successful firmware upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersionArgsDict']]
        """
        Details of the version the device upgraded to
        """
elif False:
    FirmwareUpgradesProductsCellularGatewayLastUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCellularGatewayLastUpgradeArgs:
    def __init__(__self__, *,
                 from_version: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersionArgs']] = None,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersionArgs'] from_version: Details of the version the device upgraded from
        :param pulumi.Input[_builtins.str] time: Timestamp of the last successful firmware upgrade
        :param pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersionArgs'] to_version: Details of the version the device upgraded to
        """
        if from_version is not None:
            pulumi.set(__self__, "from_version", from_version)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersionArgs']]:
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @from_version.setter
    def from_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersionArgs']]):
        pulumi.set(self, "from_version", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersionArgs']]:
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsCellularGatewayNextUpgradeArgsDict(TypedDict):
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the next scheduled firmware upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersionArgsDict']]
        """
        Details of the version the device will upgrade to if it exists
        """
elif False:
    FirmwareUpgradesProductsCellularGatewayNextUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCellularGatewayNextUpgradeArgs:
    def __init__(__self__, *,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] time: Timestamp of the next scheduled firmware upgrade
        :param pulumi.Input['FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersionArgs'] to_version: Details of the version the device will upgrade to if it exists
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersionArgs']]:
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsSensorArgsDict(TypedDict):
        available_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsSensorAvailableVersionArgsDict']]]]
        """
        Firmware versions available for upgrade
        """
        current_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsSensorCurrentVersionArgsDict']]
        """
        Details of the current version on the device
        """
        last_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeArgsDict']]
        """
        Details of the last firmware upgrade on the device
        """
        next_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsSensorNextUpgradeArgsDict']]
        """
        Details of the next firmware upgrade on the device
        """
        participate_in_next_beta_release: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not the network wants beta firmware
        """
elif False:
    FirmwareUpgradesProductsSensorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSensorArgs:
    def __init__(__self__, *,
                 available_versions: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsSensorAvailableVersionArgs']]]] = None,
                 current_version: Optional[pulumi.Input['FirmwareUpgradesProductsSensorCurrentVersionArgs']] = None,
                 last_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeArgs']] = None,
                 next_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsSensorNextUpgradeArgs']] = None,
                 participate_in_next_beta_release: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsSensorAvailableVersionArgs']]] available_versions: Firmware versions available for upgrade
        :param pulumi.Input['FirmwareUpgradesProductsSensorCurrentVersionArgs'] current_version: Details of the current version on the device
        :param pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeArgs'] last_upgrade: Details of the last firmware upgrade on the device
        :param pulumi.Input['FirmwareUpgradesProductsSensorNextUpgradeArgs'] next_upgrade: Details of the next firmware upgrade on the device
        :param pulumi.Input[_builtins.bool] participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if available_versions is not None:
            pulumi.set(__self__, "available_versions", available_versions)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if last_upgrade is not None:
            pulumi.set(__self__, "last_upgrade", last_upgrade)
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsSensorAvailableVersionArgs']]]]:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @available_versions.setter
    def available_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsSensorAvailableVersionArgs']]]]):
        pulumi.set(self, "available_versions", value)

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSensorCurrentVersionArgs']]:
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @current_version.setter
    def current_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSensorCurrentVersionArgs']]):
        pulumi.set(self, "current_version", value)

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeArgs']]:
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @last_upgrade.setter
    def last_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeArgs']]):
        pulumi.set(self, "last_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSensorNextUpgradeArgs']]:
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @next_upgrade.setter
    def next_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSensorNextUpgradeArgs']]):
        pulumi.set(self, "next_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")

    @participate_in_next_beta_release.setter
    def participate_in_next_beta_release(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "participate_in_next_beta_release", value)


if not MYPY:
    class FirmwareUpgradesProductsSensorAvailableVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsSensorAvailableVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSensorAvailableVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsSensorCurrentVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsSensorCurrentVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSensorCurrentVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsSensorLastUpgradeArgsDict(TypedDict):
        from_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeFromVersionArgsDict']]
        """
        Details of the version the device upgraded from
        """
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the last successful firmware upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeToVersionArgsDict']]
        """
        Details of the version the device upgraded to
        """
elif False:
    FirmwareUpgradesProductsSensorLastUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSensorLastUpgradeArgs:
    def __init__(__self__, *,
                 from_version: Optional[pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeFromVersionArgs']] = None,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeFromVersionArgs'] from_version: Details of the version the device upgraded from
        :param pulumi.Input[_builtins.str] time: Timestamp of the last successful firmware upgrade
        :param pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeToVersionArgs'] to_version: Details of the version the device upgraded to
        """
        if from_version is not None:
            pulumi.set(__self__, "from_version", from_version)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeFromVersionArgs']]:
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @from_version.setter
    def from_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeFromVersionArgs']]):
        pulumi.set(self, "from_version", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeToVersionArgs']]:
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSensorLastUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsSensorLastUpgradeFromVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsSensorLastUpgradeFromVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSensorLastUpgradeFromVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsSensorLastUpgradeToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsSensorLastUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSensorLastUpgradeToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsSensorNextUpgradeArgsDict(TypedDict):
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the next scheduled firmware upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsSensorNextUpgradeToVersionArgsDict']]
        """
        Details of the version the device will upgrade to if it exists
        """
elif False:
    FirmwareUpgradesProductsSensorNextUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSensorNextUpgradeArgs:
    def __init__(__self__, *,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsSensorNextUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] time: Timestamp of the next scheduled firmware upgrade
        :param pulumi.Input['FirmwareUpgradesProductsSensorNextUpgradeToVersionArgs'] to_version: Details of the version the device will upgrade to if it exists
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSensorNextUpgradeToVersionArgs']]:
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSensorNextUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsSensorNextUpgradeToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsSensorNextUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSensorNextUpgradeToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsSwitchArgsDict(TypedDict):
        available_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsSwitchAvailableVersionArgsDict']]]]
        """
        Firmware versions available for upgrade
        """
        current_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsSwitchCurrentVersionArgsDict']]
        """
        Details of the current version on the device
        """
        last_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeArgsDict']]
        """
        Details of the last firmware upgrade on the device
        """
        next_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsSwitchNextUpgradeArgsDict']]
        """
        Details of the next firmware upgrade on the device
        """
        participate_in_next_beta_release: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not the network wants beta firmware
        """
elif False:
    FirmwareUpgradesProductsSwitchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSwitchArgs:
    def __init__(__self__, *,
                 available_versions: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsSwitchAvailableVersionArgs']]]] = None,
                 current_version: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchCurrentVersionArgs']] = None,
                 last_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeArgs']] = None,
                 next_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchNextUpgradeArgs']] = None,
                 participate_in_next_beta_release: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsSwitchAvailableVersionArgs']]] available_versions: Firmware versions available for upgrade
        :param pulumi.Input['FirmwareUpgradesProductsSwitchCurrentVersionArgs'] current_version: Details of the current version on the device
        :param pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeArgs'] last_upgrade: Details of the last firmware upgrade on the device
        :param pulumi.Input['FirmwareUpgradesProductsSwitchNextUpgradeArgs'] next_upgrade: Details of the next firmware upgrade on the device
        :param pulumi.Input[_builtins.bool] participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if available_versions is not None:
            pulumi.set(__self__, "available_versions", available_versions)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if last_upgrade is not None:
            pulumi.set(__self__, "last_upgrade", last_upgrade)
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsSwitchAvailableVersionArgs']]]]:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @available_versions.setter
    def available_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsSwitchAvailableVersionArgs']]]]):
        pulumi.set(self, "available_versions", value)

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSwitchCurrentVersionArgs']]:
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @current_version.setter
    def current_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchCurrentVersionArgs']]):
        pulumi.set(self, "current_version", value)

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeArgs']]:
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @last_upgrade.setter
    def last_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeArgs']]):
        pulumi.set(self, "last_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSwitchNextUpgradeArgs']]:
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @next_upgrade.setter
    def next_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchNextUpgradeArgs']]):
        pulumi.set(self, "next_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")

    @participate_in_next_beta_release.setter
    def participate_in_next_beta_release(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "participate_in_next_beta_release", value)


if not MYPY:
    class FirmwareUpgradesProductsSwitchAvailableVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsSwitchAvailableVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSwitchAvailableVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsSwitchCatalystArgsDict(TypedDict):
        next_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsSwitchCatalystNextUpgradeArgsDict']]
        """
        The pending firmware upgrade if it exists
        """
        participate_in_next_beta_release: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not the network wants beta firmware
        """
elif False:
    FirmwareUpgradesProductsSwitchCatalystArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSwitchCatalystArgs:
    def __init__(__self__, *,
                 next_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchCatalystNextUpgradeArgs']] = None,
                 participate_in_next_beta_release: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['FirmwareUpgradesProductsSwitchCatalystNextUpgradeArgs'] next_upgrade: The pending firmware upgrade if it exists
        :param pulumi.Input[_builtins.bool] participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSwitchCatalystNextUpgradeArgs']]:
        """
        The pending firmware upgrade if it exists
        """
        return pulumi.get(self, "next_upgrade")

    @next_upgrade.setter
    def next_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchCatalystNextUpgradeArgs']]):
        pulumi.set(self, "next_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")

    @participate_in_next_beta_release.setter
    def participate_in_next_beta_release(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "participate_in_next_beta_release", value)


if not MYPY:
    class FirmwareUpgradesProductsSwitchCatalystNextUpgradeArgsDict(TypedDict):
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time of the last successful upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersionArgsDict']]
        """
        The version to be updated to
        """
elif False:
    FirmwareUpgradesProductsSwitchCatalystNextUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSwitchCatalystNextUpgradeArgs:
    def __init__(__self__, *,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] time: The time of the last successful upgrade
        :param pulumi.Input['FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersionArgs'] to_version: The version to be updated to
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time of the last successful upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersionArgs']]:
        """
        The version to be updated to
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersionArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version ID
        """
elif False:
    FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersionArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The version ID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FirmwareUpgradesProductsSwitchCurrentVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsSwitchCurrentVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSwitchCurrentVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsSwitchLastUpgradeArgsDict(TypedDict):
        from_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeFromVersionArgsDict']]
        """
        Details of the version the device upgraded from
        """
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the last successful firmware upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeToVersionArgsDict']]
        """
        Details of the version the device upgraded to
        """
elif False:
    FirmwareUpgradesProductsSwitchLastUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSwitchLastUpgradeArgs:
    def __init__(__self__, *,
                 from_version: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeFromVersionArgs']] = None,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeFromVersionArgs'] from_version: Details of the version the device upgraded from
        :param pulumi.Input[_builtins.str] time: Timestamp of the last successful firmware upgrade
        :param pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeToVersionArgs'] to_version: Details of the version the device upgraded to
        """
        if from_version is not None:
            pulumi.set(__self__, "from_version", from_version)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeFromVersionArgs']]:
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @from_version.setter
    def from_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeFromVersionArgs']]):
        pulumi.set(self, "from_version", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeToVersionArgs']]:
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchLastUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsSwitchLastUpgradeFromVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsSwitchLastUpgradeFromVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSwitchLastUpgradeFromVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsSwitchLastUpgradeToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsSwitchLastUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSwitchLastUpgradeToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsSwitchNextUpgradeArgsDict(TypedDict):
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the next scheduled firmware upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsSwitchNextUpgradeToVersionArgsDict']]
        """
        Details of the version the device will upgrade to if it exists
        """
elif False:
    FirmwareUpgradesProductsSwitchNextUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSwitchNextUpgradeArgs:
    def __init__(__self__, *,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchNextUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] time: Timestamp of the next scheduled firmware upgrade
        :param pulumi.Input['FirmwareUpgradesProductsSwitchNextUpgradeToVersionArgs'] to_version: Details of the version the device will upgrade to if it exists
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsSwitchNextUpgradeToVersionArgs']]:
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsSwitchNextUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsSwitchNextUpgradeToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsSwitchNextUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsSwitchNextUpgradeToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsWirelessArgsDict(TypedDict):
        available_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsWirelessAvailableVersionArgsDict']]]]
        """
        Firmware versions available for upgrade
        """
        current_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsWirelessCurrentVersionArgsDict']]
        """
        Details of the current version on the device
        """
        last_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeArgsDict']]
        """
        Details of the last firmware upgrade on the device
        """
        next_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesProductsWirelessNextUpgradeArgsDict']]
        """
        Details of the next firmware upgrade on the device
        """
        participate_in_next_beta_release: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not the network wants beta firmware
        """
elif False:
    FirmwareUpgradesProductsWirelessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsWirelessArgs:
    def __init__(__self__, *,
                 available_versions: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsWirelessAvailableVersionArgs']]]] = None,
                 current_version: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessCurrentVersionArgs']] = None,
                 last_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeArgs']] = None,
                 next_upgrade: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessNextUpgradeArgs']] = None,
                 participate_in_next_beta_release: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsWirelessAvailableVersionArgs']]] available_versions: Firmware versions available for upgrade
        :param pulumi.Input['FirmwareUpgradesProductsWirelessCurrentVersionArgs'] current_version: Details of the current version on the device
        :param pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeArgs'] last_upgrade: Details of the last firmware upgrade on the device
        :param pulumi.Input['FirmwareUpgradesProductsWirelessNextUpgradeArgs'] next_upgrade: Details of the next firmware upgrade on the device
        :param pulumi.Input[_builtins.bool] participate_in_next_beta_release: Whether or not the network wants beta firmware
        """
        if available_versions is not None:
            pulumi.set(__self__, "available_versions", available_versions)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if last_upgrade is not None:
            pulumi.set(__self__, "last_upgrade", last_upgrade)
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)
        if participate_in_next_beta_release is not None:
            pulumi.set(__self__, "participate_in_next_beta_release", participate_in_next_beta_release)

    @_builtins.property
    @pulumi.getter(name="availableVersions")
    def available_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsWirelessAvailableVersionArgs']]]]:
        """
        Firmware versions available for upgrade
        """
        return pulumi.get(self, "available_versions")

    @available_versions.setter
    def available_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesProductsWirelessAvailableVersionArgs']]]]):
        pulumi.set(self, "available_versions", value)

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsWirelessCurrentVersionArgs']]:
        """
        Details of the current version on the device
        """
        return pulumi.get(self, "current_version")

    @current_version.setter
    def current_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessCurrentVersionArgs']]):
        pulumi.set(self, "current_version", value)

    @_builtins.property
    @pulumi.getter(name="lastUpgrade")
    def last_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeArgs']]:
        """
        Details of the last firmware upgrade on the device
        """
        return pulumi.get(self, "last_upgrade")

    @last_upgrade.setter
    def last_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeArgs']]):
        pulumi.set(self, "last_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsWirelessNextUpgradeArgs']]:
        """
        Details of the next firmware upgrade on the device
        """
        return pulumi.get(self, "next_upgrade")

    @next_upgrade.setter
    def next_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessNextUpgradeArgs']]):
        pulumi.set(self, "next_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="participateInNextBetaRelease")
    def participate_in_next_beta_release(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the network wants beta firmware
        """
        return pulumi.get(self, "participate_in_next_beta_release")

    @participate_in_next_beta_release.setter
    def participate_in_next_beta_release(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "participate_in_next_beta_release", value)


if not MYPY:
    class FirmwareUpgradesProductsWirelessAvailableVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsWirelessAvailableVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsWirelessAvailableVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsWirelessCurrentVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsWirelessCurrentVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsWirelessCurrentVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsWirelessLastUpgradeArgsDict(TypedDict):
        from_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeFromVersionArgsDict']]
        """
        Details of the version the device upgraded from
        """
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the last successful firmware upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeToVersionArgsDict']]
        """
        Details of the version the device upgraded to
        """
elif False:
    FirmwareUpgradesProductsWirelessLastUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsWirelessLastUpgradeArgs:
    def __init__(__self__, *,
                 from_version: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeFromVersionArgs']] = None,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeFromVersionArgs'] from_version: Details of the version the device upgraded from
        :param pulumi.Input[_builtins.str] time: Timestamp of the last successful firmware upgrade
        :param pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeToVersionArgs'] to_version: Details of the version the device upgraded to
        """
        if from_version is not None:
            pulumi.set(__self__, "from_version", from_version)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="fromVersion")
    def from_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeFromVersionArgs']]:
        """
        Details of the version the device upgraded from
        """
        return pulumi.get(self, "from_version")

    @from_version.setter
    def from_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeFromVersionArgs']]):
        pulumi.set(self, "from_version", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the last successful firmware upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeToVersionArgs']]:
        """
        Details of the version the device upgraded to
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessLastUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsWirelessLastUpgradeFromVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsWirelessLastUpgradeFromVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsWirelessLastUpgradeFromVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsWirelessLastUpgradeToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsWirelessLastUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsWirelessLastUpgradeToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesProductsWirelessNextUpgradeArgsDict(TypedDict):
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of the next scheduled firmware upgrade
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesProductsWirelessNextUpgradeToVersionArgsDict']]
        """
        Details of the version the device will upgrade to if it exists
        """
elif False:
    FirmwareUpgradesProductsWirelessNextUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsWirelessNextUpgradeArgs:
    def __init__(__self__, *,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessNextUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] time: Timestamp of the next scheduled firmware upgrade
        :param pulumi.Input['FirmwareUpgradesProductsWirelessNextUpgradeToVersionArgs'] to_version: Details of the version the device will upgrade to if it exists
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of the next scheduled firmware upgrade
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesProductsWirelessNextUpgradeToVersionArgs']]:
        """
        Details of the version the device will upgrade to if it exists
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesProductsWirelessNextUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesProductsWirelessNextUpgradeToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesProductsWirelessNextUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesProductsWirelessNextUpgradeToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesRollbacksItemArgsDict(TypedDict):
        product: NotRequired[pulumi.Input[_builtins.str]]
        """
        Product type to rollback (if the network is a combined network)
        """
        reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesRollbacksItemReasonArgsDict']]]]
        """
        Reasons for the rollback
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the rollback
        """
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduled time for the rollback
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesRollbacksItemToVersionArgsDict']]
        """
        Version to downgrade to (if the network has firmware flexibility)
        """
        upgrade_batch_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Batch ID of the firmware rollback
        """
elif False:
    FirmwareUpgradesRollbacksItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesRollbacksItemArgs:
    def __init__(__self__, *,
                 product: Optional[pulumi.Input[_builtins.str]] = None,
                 reasons: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesRollbacksItemReasonArgs']]]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesRollbacksItemToVersionArgs']] = None,
                 upgrade_batch_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] product: Product type to rollback (if the network is a combined network)
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesRollbacksItemReasonArgs']]] reasons: Reasons for the rollback
        :param pulumi.Input[_builtins.str] status: Status of the rollback
        :param pulumi.Input[_builtins.str] time: Scheduled time for the rollback
        :param pulumi.Input['FirmwareUpgradesRollbacksItemToVersionArgs'] to_version: Version to downgrade to (if the network has firmware flexibility)
        :param pulumi.Input[_builtins.str] upgrade_batch_id: Batch ID of the firmware rollback
        """
        if product is not None:
            pulumi.set(__self__, "product", product)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)
        if upgrade_batch_id is not None:
            pulumi.set(__self__, "upgrade_batch_id", upgrade_batch_id)

    @_builtins.property
    @pulumi.getter
    def product(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Product type to rollback (if the network is a combined network)
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "product", value)

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesRollbacksItemReasonArgs']]]]:
        """
        Reasons for the rollback
        """
        return pulumi.get(self, "reasons")

    @reasons.setter
    def reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesRollbacksItemReasonArgs']]]]):
        pulumi.set(self, "reasons", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the rollback
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduled time for the rollback
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesRollbacksItemToVersionArgs']]:
        """
        Version to downgrade to (if the network has firmware flexibility)
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesRollbacksItemToVersionArgs']]):
        pulumi.set(self, "to_version", value)

    @_builtins.property
    @pulumi.getter(name="upgradeBatchId")
    def upgrade_batch_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Batch ID of the firmware rollback
        """
        return pulumi.get(self, "upgrade_batch_id")

    @upgrade_batch_id.setter
    def upgrade_batch_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upgrade_batch_id", value)


if not MYPY:
    class FirmwareUpgradesRollbacksItemReasonArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reason for the rollback
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional comment about the rollback
        """
elif False:
    FirmwareUpgradesRollbacksItemReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesRollbacksItemReasonArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] category: Reason for the rollback
        :param pulumi.Input[_builtins.str] comment: Additional comment about the rollback
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)


if not MYPY:
    class FirmwareUpgradesRollbacksItemToVersionArgsDict(TypedDict):
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the firmware version
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version identifier
        """
        release_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release date of the firmware version
        """
        release_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release type of the firmware version
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesRollbacksItemToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesRollbacksItemToVersionArgs:
    def __init__(__self__, *,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 release_date: Optional[pulumi.Input[_builtins.str]] = None,
                 release_type: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] firmware: Name of the firmware version
        :param pulumi.Input[_builtins.str] id: Firmware version identifier
        :param pulumi.Input[_builtins.str] release_date: Release date of the firmware version
        :param pulumi.Input[_builtins.str] release_type: Release type of the firmware version
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if release_date is not None:
            pulumi.set(__self__, "release_date", release_date)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the firmware version
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release date of the firmware version
        """
        return pulumi.get(self, "release_date")

    @release_date.setter
    def release_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_date", value)

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release type of the firmware version
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release_type", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesRollbacksParametersArgsDict(TypedDict):
        product: NotRequired[pulumi.Input[_builtins.str]]
        """
        Product type to rollback (if the network is a combined network)
        """
        reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesRollbacksParametersReasonArgsDict']]]]
        """
        Reasons for the rollback
        """
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduled time for the rollback
        """
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesRollbacksParametersToVersionArgsDict']]
        """
        Version to downgrade to (if the network has firmware flexibility)
        """
elif False:
    FirmwareUpgradesRollbacksParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesRollbacksParametersArgs:
    def __init__(__self__, *,
                 product: Optional[pulumi.Input[_builtins.str]] = None,
                 reasons: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesRollbacksParametersReasonArgs']]]] = None,
                 time: Optional[pulumi.Input[_builtins.str]] = None,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesRollbacksParametersToVersionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] product: Product type to rollback (if the network is a combined network)
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesRollbacksParametersReasonArgs']]] reasons: Reasons for the rollback
        :param pulumi.Input[_builtins.str] time: Scheduled time for the rollback
        :param pulumi.Input['FirmwareUpgradesRollbacksParametersToVersionArgs'] to_version: Version to downgrade to (if the network has firmware flexibility)
        """
        if product is not None:
            pulumi.set(__self__, "product", product)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter
    def product(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Product type to rollback (if the network is a combined network)
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "product", value)

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesRollbacksParametersReasonArgs']]]]:
        """
        Reasons for the rollback
        """
        return pulumi.get(self, "reasons")

    @reasons.setter
    def reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesRollbacksParametersReasonArgs']]]]):
        pulumi.set(self, "reasons", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduled time for the rollback
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesRollbacksParametersToVersionArgs']]:
        """
        Version to downgrade to (if the network has firmware flexibility)
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesRollbacksParametersToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesRollbacksParametersReasonArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reason for the rollback
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional comment about the rollback
        """
elif False:
    FirmwareUpgradesRollbacksParametersReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesRollbacksParametersReasonArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] category: Reason for the rollback
        :param pulumi.Input[_builtins.str] comment: Additional comment about the rollback
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)


if not MYPY:
    class FirmwareUpgradesRollbacksParametersToVersionArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version ID
        """
elif False:
    FirmwareUpgradesRollbacksParametersToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesRollbacksParametersToVersionArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The version ID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsDeferItemArgsDict(TypedDict):
        products: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsArgsDict']]
        """
        The network devices to be updated
        """
        reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemReasonArgsDict']]]]
        """
        Reasons for the rollback
        """
        stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageArgsDict']]]]
        """
        The ordered stages in the network
        """
elif False:
    FirmwareUpgradesStagedEventsDeferItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsDeferItemArgs:
    def __init__(__self__, *,
                 products: Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsArgs']] = None,
                 reasons: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemReasonArgs']]]] = None,
                 stages: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageArgs']]]] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsArgs'] products: The network devices to be updated
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemReasonArgs']]] reasons: Reasons for the rollback
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageArgs']]] stages: The ordered stages in the network
        """
        if products is not None:
            pulumi.set(__self__, "products", products)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if stages is not None:
            pulumi.set(__self__, "stages", stages)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsArgs']]:
        """
        The network devices to be updated
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsArgs']]):
        pulumi.set(self, "products", value)

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemReasonArgs']]]]:
        """
        Reasons for the rollback
        """
        return pulumi.get(self, "reasons")

    @reasons.setter
    def reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemReasonArgs']]]]):
        pulumi.set(self, "reasons", value)

    @_builtins.property
    @pulumi.getter
    def stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageArgs']]]]:
        """
        The ordered stages in the network
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageArgs']]]]):
        pulumi.set(self, "stages", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsDeferItemProductsArgsDict(TypedDict):
        switch: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchArgsDict']]
        """
        The Switch network to be updated
        """
elif False:
    FirmwareUpgradesStagedEventsDeferItemProductsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsDeferItemProductsArgs:
    def __init__(__self__, *,
                 switch: Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchArgs'] switch: The Switch network to be updated
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchArgs']]:
        """
        The Switch network to be updated
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchArgs']]):
        pulumi.set(self, "switch", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsDeferItemProductsSwitchArgsDict(TypedDict):
        next_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeArgsDict']]
        """
        Details of the next firmware upgrade
        """
elif False:
    FirmwareUpgradesStagedEventsDeferItemProductsSwitchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsDeferItemProductsSwitchArgs:
    def __init__(__self__, *,
                 next_upgrade: Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeArgs'] next_upgrade: Details of the next firmware upgrade
        """
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeArgs']]:
        """
        Details of the next firmware upgrade
        """
        return pulumi.get(self, "next_upgrade")

    @next_upgrade.setter
    def next_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeArgs']]):
        pulumi.set(self, "next_upgrade", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeArgsDict(TypedDict):
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersionArgsDict']]
        """
        Details of the version the device will upgrade to
        """
elif False:
    FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeArgs:
    def __init__(__self__, *,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersionArgs'] to_version: Details of the version the device will upgrade to
        """
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersionArgs']]:
        """
        Details of the version the device will upgrade to
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersionArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id of the Version being upgraded to
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersionArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Id of the Version being upgraded to
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id of the Version being upgraded to
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsDeferItemReasonArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reason for the rollback
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional comment about the rollback
        """
elif False:
    FirmwareUpgradesStagedEventsDeferItemReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsDeferItemReasonArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] category: Reason for the rollback
        :param pulumi.Input[_builtins.str] comment: Additional comment about the rollback
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsDeferItemStageArgsDict(TypedDict):
        group: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageGroupArgsDict']]
        """
        The staged upgrade group
        """
        milestones: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageMilestonesArgsDict']]
        """
        The Staged Upgrade Milestones for the stage
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Current upgrade status of the group
        """
elif False:
    FirmwareUpgradesStagedEventsDeferItemStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsDeferItemStageArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageGroupArgs']] = None,
                 milestones: Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageMilestonesArgs']] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageGroupArgs'] group: The staged upgrade group
        :param pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageMilestonesArgs'] milestones: The Staged Upgrade Milestones for the stage
        :param pulumi.Input[_builtins.str] status: Current upgrade status of the group
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if milestones is not None:
            pulumi.set(__self__, "milestones", milestones)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageGroupArgs']]:
        """
        The staged upgrade group
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def milestones(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageMilestonesArgs']]:
        """
        The Staged Upgrade Milestones for the stage
        """
        return pulumi.get(self, "milestones")

    @milestones.setter
    def milestones(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsDeferItemStageMilestonesArgs']]):
        pulumi.set(self, "milestones", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current upgrade status of the group
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsDeferItemStageGroupArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the Staged Upgrade Group
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id of the Staged Upgrade Group
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Staged Upgrade Group
        """
elif False:
    FirmwareUpgradesStagedEventsDeferItemStageGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsDeferItemStageGroupArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of the Staged Upgrade Group
        :param pulumi.Input[_builtins.str] id: Id of the Staged Upgrade Group
        :param pulumi.Input[_builtins.str] name: Name of the Staged Upgrade Group
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the Staged Upgrade Group
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Staged Upgrade Group
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsDeferItemStageMilestonesArgsDict(TypedDict):
        canceled_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time that the group was canceled
        """
        completed_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Finish time for the group
        """
        scheduled_for: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduled start time for the group
        """
        started_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time for the group
        """
elif False:
    FirmwareUpgradesStagedEventsDeferItemStageMilestonesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsDeferItemStageMilestonesArgs:
    def __init__(__self__, *,
                 canceled_at: Optional[pulumi.Input[_builtins.str]] = None,
                 completed_at: Optional[pulumi.Input[_builtins.str]] = None,
                 scheduled_for: Optional[pulumi.Input[_builtins.str]] = None,
                 started_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] canceled_at: Time that the group was canceled
        :param pulumi.Input[_builtins.str] completed_at: Finish time for the group
        :param pulumi.Input[_builtins.str] scheduled_for: Scheduled start time for the group
        :param pulumi.Input[_builtins.str] started_at: Start time for the group
        """
        if canceled_at is not None:
            pulumi.set(__self__, "canceled_at", canceled_at)
        if completed_at is not None:
            pulumi.set(__self__, "completed_at", completed_at)
        if scheduled_for is not None:
            pulumi.set(__self__, "scheduled_for", scheduled_for)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @_builtins.property
    @pulumi.getter(name="canceledAt")
    def canceled_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time that the group was canceled
        """
        return pulumi.get(self, "canceled_at")

    @canceled_at.setter
    def canceled_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "canceled_at", value)

    @_builtins.property
    @pulumi.getter(name="completedAt")
    def completed_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Finish time for the group
        """
        return pulumi.get(self, "completed_at")

    @completed_at.setter
    def completed_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "completed_at", value)

    @_builtins.property
    @pulumi.getter(name="scheduledFor")
    def scheduled_for(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduled start time for the group
        """
        return pulumi.get(self, "scheduled_for")

    @scheduled_for.setter
    def scheduled_for(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduled_for", value)

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time for the group
        """
        return pulumi.get(self, "started_at")

    @started_at.setter
    def started_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_at", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsProductsArgsDict(TypedDict):
        switch: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchArgsDict']]
        """
        The Switch network to be updated
        """
        switch_catalyst: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystArgsDict']]
        """
        Version information for the switch network being upgraded
        """
elif False:
    FirmwareUpgradesStagedEventsProductsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsProductsArgs:
    def __init__(__self__, *,
                 switch: Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchArgs']] = None,
                 switch_catalyst: Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchArgs'] switch: The Switch network to be updated
        :param pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystArgs'] switch_catalyst: Version information for the switch network being upgraded
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if switch_catalyst is not None:
            pulumi.set(__self__, "switch_catalyst", switch_catalyst)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchArgs']]:
        """
        The Switch network to be updated
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchArgs']]):
        pulumi.set(self, "switch", value)

    @_builtins.property
    @pulumi.getter(name="switchCatalyst")
    def switch_catalyst(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystArgs']]:
        """
        Version information for the switch network being upgraded
        """
        return pulumi.get(self, "switch_catalyst")

    @switch_catalyst.setter
    def switch_catalyst(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystArgs']]):
        pulumi.set(self, "switch_catalyst", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsProductsSwitchArgsDict(TypedDict):
        next_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeArgsDict']]
        """
        Details of the next firmware upgrade
        """
elif False:
    FirmwareUpgradesStagedEventsProductsSwitchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsProductsSwitchArgs:
    def __init__(__self__, *,
                 next_upgrade: Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeArgs'] next_upgrade: Details of the next firmware upgrade
        """
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeArgs']]:
        """
        Details of the next firmware upgrade
        """
        return pulumi.get(self, "next_upgrade")

    @next_upgrade.setter
    def next_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeArgs']]):
        pulumi.set(self, "next_upgrade", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsProductsSwitchCatalystArgsDict(TypedDict):
        next_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeArgsDict']]
        """
        The next upgrade version for the switch network
        """
elif False:
    FirmwareUpgradesStagedEventsProductsSwitchCatalystArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsProductsSwitchCatalystArgs:
    def __init__(__self__, *,
                 next_upgrade: Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeArgs'] next_upgrade: The next upgrade version for the switch network
        """
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeArgs']]:
        """
        The next upgrade version for the switch network
        """
        return pulumi.get(self, "next_upgrade")

    @next_upgrade.setter
    def next_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeArgs']]):
        pulumi.set(self, "next_upgrade", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeArgsDict(TypedDict):
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersionArgsDict']]
        """
        The version to be updated to for switch Catalyst devices
        """
elif False:
    FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeArgs:
    def __init__(__self__, *,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersionArgs'] to_version: The version to be updated to for switch Catalyst devices
        """
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersionArgs']]:
        """
        The version to be updated to for switch Catalyst devices
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersionArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version ID
        """
elif False:
    FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersionArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The version ID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeArgsDict(TypedDict):
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersionArgsDict']]
        """
        Details of the version the device will upgrade to
        """
elif False:
    FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeArgs:
    def __init__(__self__, *,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersionArgs'] to_version: Details of the version the device will upgrade to
        """
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersionArgs']]:
        """
        Details of the version the device will upgrade to
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersionArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id of the Version being upgraded to
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersionArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Id of the Version being upgraded to
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id of the Version being upgraded to
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsReasonArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reason for the rollback
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional comment about the rollback
        """
elif False:
    FirmwareUpgradesStagedEventsReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsReasonArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] category: Reason for the rollback
        :param pulumi.Input[_builtins.str] comment: Additional comment about the rollback
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksItemArgsDict(TypedDict):
        products: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsArgsDict']]
        """
        The network devices to be updated
        """
        reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemReasonArgsDict']]]]
        """
        Reasons for the rollback
        """
        stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageArgsDict']]]]
        """
        The ordered stages in the network
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksItemArgs:
    def __init__(__self__, *,
                 products: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsArgs']] = None,
                 reasons: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemReasonArgs']]]] = None,
                 stages: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageArgs']]]] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsArgs'] products: The network devices to be updated
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemReasonArgs']]] reasons: Reasons for the rollback
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageArgs']]] stages: The ordered stages in the network
        """
        if products is not None:
            pulumi.set(__self__, "products", products)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if stages is not None:
            pulumi.set(__self__, "stages", stages)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsArgs']]:
        """
        The network devices to be updated
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsArgs']]):
        pulumi.set(self, "products", value)

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemReasonArgs']]]]:
        """
        Reasons for the rollback
        """
        return pulumi.get(self, "reasons")

    @reasons.setter
    def reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemReasonArgs']]]]):
        pulumi.set(self, "reasons", value)

    @_builtins.property
    @pulumi.getter
    def stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageArgs']]]]:
        """
        The ordered stages in the network
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageArgs']]]]):
        pulumi.set(self, "stages", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksItemProductsArgsDict(TypedDict):
        switch: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchArgsDict']]
        """
        The Switch network to be updated
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksItemProductsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksItemProductsArgs:
    def __init__(__self__, *,
                 switch: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchArgs'] switch: The Switch network to be updated
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchArgs']]:
        """
        The Switch network to be updated
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchArgs']]):
        pulumi.set(self, "switch", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchArgsDict(TypedDict):
        next_upgrade: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeArgsDict']]
        """
        Details of the next firmware upgrade
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchArgs:
    def __init__(__self__, *,
                 next_upgrade: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeArgs'] next_upgrade: Details of the next firmware upgrade
        """
        if next_upgrade is not None:
            pulumi.set(__self__, "next_upgrade", next_upgrade)

    @_builtins.property
    @pulumi.getter(name="nextUpgrade")
    def next_upgrade(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeArgs']]:
        """
        Details of the next firmware upgrade
        """
        return pulumi.get(self, "next_upgrade")

    @next_upgrade.setter
    def next_upgrade(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeArgs']]):
        pulumi.set(self, "next_upgrade", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeArgsDict(TypedDict):
        to_version: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersionArgsDict']]
        """
        Details of the version the device will upgrade to
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeArgs:
    def __init__(__self__, *,
                 to_version: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersionArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersionArgs'] to_version: Details of the version the device will upgrade to
        """
        if to_version is not None:
            pulumi.set(__self__, "to_version", to_version)

    @_builtins.property
    @pulumi.getter(name="toVersion")
    def to_version(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersionArgs']]:
        """
        Details of the version the device will upgrade to
        """
        return pulumi.get(self, "to_version")

    @to_version.setter
    def to_version(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersionArgs']]):
        pulumi.set(self, "to_version", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersionArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id of the Version being upgraded to
        """
        short_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version short name
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersionArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 short_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Id of the Version being upgraded to
        :param pulumi.Input[_builtins.str] short_name: Firmware version short name
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if short_name is not None:
            pulumi.set(__self__, "short_name", short_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id of the Version being upgraded to
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="shortName")
    def short_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version short name
        """
        return pulumi.get(self, "short_name")

    @short_name.setter
    def short_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_name", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksItemReasonArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reason for the rollback
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional comment about the rollback
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksItemReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksItemReasonArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] category: Reason for the rollback
        :param pulumi.Input[_builtins.str] comment: Additional comment about the rollback
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksItemStageArgsDict(TypedDict):
        group: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageGroupArgsDict']]
        """
        The staged upgrade group
        """
        milestones: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageMilestonesArgsDict']]
        """
        The Staged Upgrade Milestones for the stage
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Current upgrade status of the group
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksItemStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksItemStageArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageGroupArgs']] = None,
                 milestones: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageMilestonesArgs']] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageGroupArgs'] group: The staged upgrade group
        :param pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageMilestonesArgs'] milestones: The Staged Upgrade Milestones for the stage
        :param pulumi.Input[_builtins.str] status: Current upgrade status of the group
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if milestones is not None:
            pulumi.set(__self__, "milestones", milestones)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageGroupArgs']]:
        """
        The staged upgrade group
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def milestones(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageMilestonesArgs']]:
        """
        The Staged Upgrade Milestones for the stage
        """
        return pulumi.get(self, "milestones")

    @milestones.setter
    def milestones(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksItemStageMilestonesArgs']]):
        pulumi.set(self, "milestones", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current upgrade status of the group
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksItemStageGroupArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the Staged Upgrade Group
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id of the Staged Upgrade Group
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Staged Upgrade Group
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksItemStageGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksItemStageGroupArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of the Staged Upgrade Group
        :param pulumi.Input[_builtins.str] id: Id of the Staged Upgrade Group
        :param pulumi.Input[_builtins.str] name: Name of the Staged Upgrade Group
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the Staged Upgrade Group
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Staged Upgrade Group
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksItemStageMilestonesArgsDict(TypedDict):
        canceled_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time that the group was canceled
        """
        completed_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Finish time for the group
        """
        scheduled_for: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduled start time for the group
        """
        started_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time for the group
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksItemStageMilestonesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksItemStageMilestonesArgs:
    def __init__(__self__, *,
                 canceled_at: Optional[pulumi.Input[_builtins.str]] = None,
                 completed_at: Optional[pulumi.Input[_builtins.str]] = None,
                 scheduled_for: Optional[pulumi.Input[_builtins.str]] = None,
                 started_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] canceled_at: Time that the group was canceled
        :param pulumi.Input[_builtins.str] completed_at: Finish time for the group
        :param pulumi.Input[_builtins.str] scheduled_for: Scheduled start time for the group
        :param pulumi.Input[_builtins.str] started_at: Start time for the group
        """
        if canceled_at is not None:
            pulumi.set(__self__, "canceled_at", canceled_at)
        if completed_at is not None:
            pulumi.set(__self__, "completed_at", completed_at)
        if scheduled_for is not None:
            pulumi.set(__self__, "scheduled_for", scheduled_for)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @_builtins.property
    @pulumi.getter(name="canceledAt")
    def canceled_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time that the group was canceled
        """
        return pulumi.get(self, "canceled_at")

    @canceled_at.setter
    def canceled_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "canceled_at", value)

    @_builtins.property
    @pulumi.getter(name="completedAt")
    def completed_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Finish time for the group
        """
        return pulumi.get(self, "completed_at")

    @completed_at.setter
    def completed_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "completed_at", value)

    @_builtins.property
    @pulumi.getter(name="scheduledFor")
    def scheduled_for(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduled start time for the group
        """
        return pulumi.get(self, "scheduled_for")

    @scheduled_for.setter
    def scheduled_for(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduled_for", value)

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time for the group
        """
        return pulumi.get(self, "started_at")

    @started_at.setter
    def started_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_at", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksParametersArgsDict(TypedDict):
        reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersReasonArgsDict']]]]
        """
        The reason for rolling back the staged upgrade
        """
        stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageArgsDict']]]]
        """
        All completed or in-progress stages in the network with their new start times. All pending stages will be canceled
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksParametersArgs:
    def __init__(__self__, *,
                 reasons: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersReasonArgs']]]] = None,
                 stages: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersReasonArgs']]] reasons: The reason for rolling back the staged upgrade
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageArgs']]] stages: All completed or in-progress stages in the network with their new start times. All pending stages will be canceled
        """
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if stages is not None:
            pulumi.set(__self__, "stages", stages)

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersReasonArgs']]]]:
        """
        The reason for rolling back the staged upgrade
        """
        return pulumi.get(self, "reasons")

    @reasons.setter
    def reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersReasonArgs']]]]):
        pulumi.set(self, "reasons", value)

    @_builtins.property
    @pulumi.getter
    def stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageArgs']]]]:
        """
        All completed or in-progress stages in the network with their new start times. All pending stages will be canceled
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageArgs']]]]):
        pulumi.set(self, "stages", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksParametersReasonArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reason for the rollback
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional comment about the rollback
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksParametersReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksParametersReasonArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] category: Reason for the rollback
        :param pulumi.Input[_builtins.str] comment: Additional comment about the rollback
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reason for the rollback
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional comment about the rollback
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksParametersStageArgsDict(TypedDict):
        group: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageGroupArgsDict']]
        """
        The Staged Upgrade Group containing the name and ID
        """
        milestones: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageMilestonesArgsDict']]
        """
        The Staged Upgrade Milestones for the specific stage
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksParametersStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksParametersStageArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageGroupArgs']] = None,
                 milestones: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageMilestonesArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageGroupArgs'] group: The Staged Upgrade Group containing the name and ID
        :param pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageMilestonesArgs'] milestones: The Staged Upgrade Milestones for the specific stage
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if milestones is not None:
            pulumi.set(__self__, "milestones", milestones)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageGroupArgs']]:
        """
        The Staged Upgrade Group containing the name and ID
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def milestones(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageMilestonesArgs']]:
        """
        The Staged Upgrade Milestones for the specific stage
        """
        return pulumi.get(self, "milestones")

    @milestones.setter
    def milestones(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsRollbacksParametersStageMilestonesArgs']]):
        pulumi.set(self, "milestones", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksParametersStageGroupArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the Staged Upgrade Group
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksParametersStageGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksParametersStageGroupArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the Staged Upgrade Group
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsRollbacksParametersStageMilestonesArgsDict(TypedDict):
        scheduled_for: NotRequired[pulumi.Input[_builtins.str]]
        """
        The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
        """
elif False:
    FirmwareUpgradesStagedEventsRollbacksParametersStageMilestonesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsRollbacksParametersStageMilestonesArgs:
    def __init__(__self__, *,
                 scheduled_for: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] scheduled_for: The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
        """
        if scheduled_for is not None:
            pulumi.set(__self__, "scheduled_for", scheduled_for)

    @_builtins.property
    @pulumi.getter(name="scheduledFor")
    def scheduled_for(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
        """
        return pulumi.get(self, "scheduled_for")

    @scheduled_for.setter
    def scheduled_for(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduled_for", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsStageArgsDict(TypedDict):
        group: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsStageGroupArgsDict']]
        """
        The staged upgrade group
        """
        milestones: NotRequired[pulumi.Input['FirmwareUpgradesStagedEventsStageMilestonesArgsDict']]
        """
        The Staged Upgrade Milestones for the stage
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Current upgrade status of the group
        """
elif False:
    FirmwareUpgradesStagedEventsStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsStageArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input['FirmwareUpgradesStagedEventsStageGroupArgs']] = None,
                 milestones: Optional[pulumi.Input['FirmwareUpgradesStagedEventsStageMilestonesArgs']] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedEventsStageGroupArgs'] group: The staged upgrade group
        :param pulumi.Input['FirmwareUpgradesStagedEventsStageMilestonesArgs'] milestones: The Staged Upgrade Milestones for the stage
        :param pulumi.Input[_builtins.str] status: Current upgrade status of the group
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if milestones is not None:
            pulumi.set(__self__, "milestones", milestones)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsStageGroupArgs']]:
        """
        The staged upgrade group
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsStageGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def milestones(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedEventsStageMilestonesArgs']]:
        """
        The Staged Upgrade Milestones for the stage
        """
        return pulumi.get(self, "milestones")

    @milestones.setter
    def milestones(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedEventsStageMilestonesArgs']]):
        pulumi.set(self, "milestones", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current upgrade status of the group
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsStageGroupArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the Staged Upgrade Group
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id of the Staged Upgrade Group
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Staged Upgrade Group
        """
elif False:
    FirmwareUpgradesStagedEventsStageGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsStageGroupArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of the Staged Upgrade Group
        :param pulumi.Input[_builtins.str] id: Id of the Staged Upgrade Group
        :param pulumi.Input[_builtins.str] name: Name of the Staged Upgrade Group
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the Staged Upgrade Group
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Staged Upgrade Group
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirmwareUpgradesStagedEventsStageMilestonesArgsDict(TypedDict):
        canceled_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time that the group was canceled
        """
        completed_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Finish time for the group
        """
        scheduled_for: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduled start time for the group
        """
        started_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time for the group
        """
elif False:
    FirmwareUpgradesStagedEventsStageMilestonesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedEventsStageMilestonesArgs:
    def __init__(__self__, *,
                 canceled_at: Optional[pulumi.Input[_builtins.str]] = None,
                 completed_at: Optional[pulumi.Input[_builtins.str]] = None,
                 scheduled_for: Optional[pulumi.Input[_builtins.str]] = None,
                 started_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] canceled_at: Time that the group was canceled
        :param pulumi.Input[_builtins.str] completed_at: Finish time for the group
        :param pulumi.Input[_builtins.str] scheduled_for: Scheduled start time for the group
        :param pulumi.Input[_builtins.str] started_at: Start time for the group
        """
        if canceled_at is not None:
            pulumi.set(__self__, "canceled_at", canceled_at)
        if completed_at is not None:
            pulumi.set(__self__, "completed_at", completed_at)
        if scheduled_for is not None:
            pulumi.set(__self__, "scheduled_for", scheduled_for)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @_builtins.property
    @pulumi.getter(name="canceledAt")
    def canceled_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time that the group was canceled
        """
        return pulumi.get(self, "canceled_at")

    @canceled_at.setter
    def canceled_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "canceled_at", value)

    @_builtins.property
    @pulumi.getter(name="completedAt")
    def completed_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Finish time for the group
        """
        return pulumi.get(self, "completed_at")

    @completed_at.setter
    def completed_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "completed_at", value)

    @_builtins.property
    @pulumi.getter(name="scheduledFor")
    def scheduled_for(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduled start time for the group
        """
        return pulumi.get(self, "scheduled_for")

    @scheduled_for.setter
    def scheduled_for(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduled_for", value)

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time for the group
        """
        return pulumi.get(self, "started_at")

    @started_at.setter
    def started_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_at", value)


if not MYPY:
    class FirmwareUpgradesStagedGroupsAssignedDevicesArgsDict(TypedDict):
        devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedGroupsAssignedDevicesDeviceArgsDict']]]]
        """
        Data Array of Devices containing the name and serial
        """
        switch_stacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStackArgsDict']]]]
        """
        Data Array of Switch Stacks containing the name and id
        """
elif False:
    FirmwareUpgradesStagedGroupsAssignedDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedGroupsAssignedDevicesArgs:
    def __init__(__self__, *,
                 devices: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedGroupsAssignedDevicesDeviceArgs']]]] = None,
                 switch_stacks: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStackArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedGroupsAssignedDevicesDeviceArgs']]] devices: Data Array of Devices containing the name and serial
        :param pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStackArgs']]] switch_stacks: Data Array of Switch Stacks containing the name and id
        """
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if switch_stacks is not None:
            pulumi.set(__self__, "switch_stacks", switch_stacks)

    @_builtins.property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedGroupsAssignedDevicesDeviceArgs']]]]:
        """
        Data Array of Devices containing the name and serial
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedGroupsAssignedDevicesDeviceArgs']]]]):
        pulumi.set(self, "devices", value)

    @_builtins.property
    @pulumi.getter(name="switchStacks")
    def switch_stacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStackArgs']]]]:
        """
        Data Array of Switch Stacks containing the name and id
        """
        return pulumi.get(self, "switch_stacks")

    @switch_stacks.setter
    def switch_stacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStackArgs']]]]):
        pulumi.set(self, "switch_stacks", value)


if not MYPY:
    class FirmwareUpgradesStagedGroupsAssignedDevicesDeviceArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the device
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Serial of the device
        """
elif False:
    FirmwareUpgradesStagedGroupsAssignedDevicesDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedGroupsAssignedDevicesDeviceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the device
        :param pulumi.Input[_builtins.str] serial: Serial of the device
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the device
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Serial of the device
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)


if not MYPY:
    class FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStackArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the Switch Stack
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Switch Stack
        """
elif False:
    FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStackArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the Switch Stack
        :param pulumi.Input[_builtins.str] name: Name of the Switch Stack
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the Switch Stack
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Switch Stack
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirmwareUpgradesStagedStagesGroupArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the Staged Upgrade Group
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id of the Staged Upgrade Group
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Staged Upgrade Group
        """
elif False:
    FirmwareUpgradesStagedStagesGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedStagesGroupArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of the Staged Upgrade Group
        :param pulumi.Input[_builtins.str] id: Id of the Staged Upgrade Group
        :param pulumi.Input[_builtins.str] name: Name of the Staged Upgrade Group
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the Staged Upgrade Group
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Staged Upgrade Group
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirmwareUpgradesStagedStagesJsonArgsDict(TypedDict):
        group: NotRequired[pulumi.Input['FirmwareUpgradesStagedStagesJsonGroupArgsDict']]
        """
        The Staged Upgrade Group
        """
elif False:
    FirmwareUpgradesStagedStagesJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedStagesJsonArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input['FirmwareUpgradesStagedStagesJsonGroupArgs']] = None):
        """
        :param pulumi.Input['FirmwareUpgradesStagedStagesJsonGroupArgs'] group: The Staged Upgrade Group
        """
        if group is not None:
            pulumi.set(__self__, "group", group)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['FirmwareUpgradesStagedStagesJsonGroupArgs']]:
        """
        The Staged Upgrade Group
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['FirmwareUpgradesStagedStagesJsonGroupArgs']]):
        pulumi.set(self, "group", value)


if not MYPY:
    class FirmwareUpgradesStagedStagesJsonGroupArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the Staged Upgrade Group
        """
elif False:
    FirmwareUpgradesStagedStagesJsonGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesStagedStagesJsonGroupArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the Staged Upgrade Group
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the Staged Upgrade Group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FirmwareUpgradesUpgradeWindowArgsDict(TypedDict):
        day_of_week: NotRequired[pulumi.Input[_builtins.str]]
        """
        Day of the week
        """
        hour_of_day: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hour of the day
        """
elif False:
    FirmwareUpgradesUpgradeWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirmwareUpgradesUpgradeWindowArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input[_builtins.str]] = None,
                 hour_of_day: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] day_of_week: Day of the week
        :param pulumi.Input[_builtins.str] hour_of_day: Hour of the day
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if hour_of_day is not None:
            pulumi.set(__self__, "hour_of_day", hour_of_day)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Day of the week
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "day_of_week", value)

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hour of the day
        """
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hour_of_day", value)


if not MYPY:
    class FloorPlansBottomLeftCornerArgsDict(TypedDict):
        lat: NotRequired[pulumi.Input[_builtins.float]]
        """
        Latitude
        """
        lng: NotRequired[pulumi.Input[_builtins.float]]
        """
        Longitude
        """
elif False:
    FloorPlansBottomLeftCornerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloorPlansBottomLeftCornerArgs:
    def __init__(__self__, *,
                 lat: Optional[pulumi.Input[_builtins.float]] = None,
                 lng: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] lat: Latitude
        :param pulumi.Input[_builtins.float] lng: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat", value)

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Longitude
        """
        return pulumi.get(self, "lng")

    @lng.setter
    def lng(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lng", value)


if not MYPY:
    class FloorPlansBottomRightCornerArgsDict(TypedDict):
        lat: NotRequired[pulumi.Input[_builtins.float]]
        """
        Latitude
        """
        lng: NotRequired[pulumi.Input[_builtins.float]]
        """
        Longitude
        """
elif False:
    FloorPlansBottomRightCornerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloorPlansBottomRightCornerArgs:
    def __init__(__self__, *,
                 lat: Optional[pulumi.Input[_builtins.float]] = None,
                 lng: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] lat: Latitude
        :param pulumi.Input[_builtins.float] lng: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat", value)

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Longitude
        """
        return pulumi.get(self, "lng")

    @lng.setter
    def lng(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lng", value)


if not MYPY:
    class FloorPlansCenterArgsDict(TypedDict):
        lat: NotRequired[pulumi.Input[_builtins.float]]
        """
        Latitude
        """
        lng: NotRequired[pulumi.Input[_builtins.float]]
        """
        Longitude
        """
elif False:
    FloorPlansCenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloorPlansCenterArgs:
    def __init__(__self__, *,
                 lat: Optional[pulumi.Input[_builtins.float]] = None,
                 lng: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] lat: Latitude
        :param pulumi.Input[_builtins.float] lng: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat", value)

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Longitude
        """
        return pulumi.get(self, "lng")

    @lng.setter
    def lng(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lng", value)


if not MYPY:
    class FloorPlansDeviceArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Physical address of the device
        """
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloorPlansDeviceDetailArgsDict']]]]
        """
        Additional device information
        """
        firmware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firmware version of the device
        """
        imei: NotRequired[pulumi.Input[_builtins.str]]
        """
        IMEI of the device, if applicable
        """
        lan_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        LAN IP address of the device
        """
        lat: NotRequired[pulumi.Input[_builtins.float]]
        """
        Latitude of the device
        """
        lng: NotRequired[pulumi.Input[_builtins.float]]
        """
        Longitude of the device
        """
        mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        MAC address of the device
        """
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        Model of the device
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the device
        """
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the network the device belongs to
        """
        notes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notes for the device, limited to 255 characters
        """
        product_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Product type of the device
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Serial number of the device
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of tags assigned to the device
        """
elif False:
    FloorPlansDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloorPlansDeviceArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input['FloorPlansDeviceDetailArgs']]]] = None,
                 firmware: Optional[pulumi.Input[_builtins.str]] = None,
                 imei: Optional[pulumi.Input[_builtins.str]] = None,
                 lan_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 lat: Optional[pulumi.Input[_builtins.float]] = None,
                 lng: Optional[pulumi.Input[_builtins.float]] = None,
                 mac: Optional[pulumi.Input[_builtins.str]] = None,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 product_type: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Physical address of the device
        :param pulumi.Input[Sequence[pulumi.Input['FloorPlansDeviceDetailArgs']]] details: Additional device information
        :param pulumi.Input[_builtins.str] firmware: Firmware version of the device
        :param pulumi.Input[_builtins.str] imei: IMEI of the device, if applicable
        :param pulumi.Input[_builtins.str] lan_ip: LAN IP address of the device
        :param pulumi.Input[_builtins.float] lat: Latitude of the device
        :param pulumi.Input[_builtins.float] lng: Longitude of the device
        :param pulumi.Input[_builtins.str] mac: MAC address of the device
        :param pulumi.Input[_builtins.str] model: Model of the device
        :param pulumi.Input[_builtins.str] name: Name of the device
        :param pulumi.Input[_builtins.str] network_id: ID of the network the device belongs to
        :param pulumi.Input[_builtins.str] notes: Notes for the device, limited to 255 characters
        :param pulumi.Input[_builtins.str] product_type: Product type of the device
        :param pulumi.Input[_builtins.str] serial: Serial number of the device
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: List of tags assigned to the device
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if imei is not None:
            pulumi.set(__self__, "imei", imei)
        if lan_ip is not None:
            pulumi.set(__self__, "lan_ip", lan_ip)
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if product_type is not None:
            pulumi.set(__self__, "product_type", product_type)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Physical address of the device
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloorPlansDeviceDetailArgs']]]]:
        """
        Additional device information
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloorPlansDeviceDetailArgs']]]]):
        pulumi.set(self, "details", value)

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firmware version of the device
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firmware", value)

    @_builtins.property
    @pulumi.getter
    def imei(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IMEI of the device, if applicable
        """
        return pulumi.get(self, "imei")

    @imei.setter
    def imei(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "imei", value)

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        LAN IP address of the device
        """
        return pulumi.get(self, "lan_ip")

    @lan_ip.setter
    def lan_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lan_ip", value)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Latitude of the device
        """
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat", value)

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Longitude of the device
        """
        return pulumi.get(self, "lng")

    @lng.setter
    def lng(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lng", value)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        MAC address of the device
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Model of the device
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the device
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the network the device belongs to
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notes for the device, limited to 255 characters
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Product type of the device
        """
        return pulumi.get(self, "product_type")

    @product_type.setter
    def product_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "product_type", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Serial number of the device
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of tags assigned to the device
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class FloorPlansDeviceDetailArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional property name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional property value
        """
elif False:
    FloorPlansDeviceDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloorPlansDeviceDetailArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Additional property name
        :param pulumi.Input[_builtins.str] value: Additional property value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional property name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional property value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloorPlansTopLeftCornerArgsDict(TypedDict):
        lat: NotRequired[pulumi.Input[_builtins.float]]
        """
        Latitude
        """
        lng: NotRequired[pulumi.Input[_builtins.float]]
        """
        Longitude
        """
elif False:
    FloorPlansTopLeftCornerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloorPlansTopLeftCornerArgs:
    def __init__(__self__, *,
                 lat: Optional[pulumi.Input[_builtins.float]] = None,
                 lng: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] lat: Latitude
        :param pulumi.Input[_builtins.float] lng: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat", value)

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Longitude
        """
        return pulumi.get(self, "lng")

    @lng.setter
    def lng(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lng", value)


if not MYPY:
    class FloorPlansTopRightCornerArgsDict(TypedDict):
        lat: NotRequired[pulumi.Input[_builtins.float]]
        """
        Latitude
        """
        lng: NotRequired[pulumi.Input[_builtins.float]]
        """
        Longitude
        """
elif False:
    FloorPlansTopRightCornerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloorPlansTopRightCornerArgs:
    def __init__(__self__, *,
                 lat: Optional[pulumi.Input[_builtins.float]] = None,
                 lng: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] lat: Latitude
        :param pulumi.Input[_builtins.float] lng: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lng is not None:
            pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat", value)

    @_builtins.property
    @pulumi.getter
    def lng(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Longitude
        """
        return pulumi.get(self, "lng")

    @lng.setter
    def lng(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lng", value)


if not MYPY:
    class GroupPoliciesBandwidthArgsDict(TypedDict):
        bandwidth_limits: NotRequired[pulumi.Input['GroupPoliciesBandwidthBandwidthLimitsArgsDict']]
        """
        The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
        """
        settings: NotRequired[pulumi.Input[_builtins.str]]
        """
        How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
        """
elif False:
    GroupPoliciesBandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesBandwidthArgs:
    def __init__(__self__, *,
                 bandwidth_limits: Optional[pulumi.Input['GroupPoliciesBandwidthBandwidthLimitsArgs']] = None,
                 settings: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['GroupPoliciesBandwidthBandwidthLimitsArgs'] bandwidth_limits: The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
        :param pulumi.Input[_builtins.str] settings: How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
        """
        if bandwidth_limits is not None:
            pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> Optional[pulumi.Input['GroupPoliciesBandwidthBandwidthLimitsArgs']]:
        """
        The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "bandwidth_limits")

    @bandwidth_limits.setter
    def bandwidth_limits(self, value: Optional[pulumi.Input['GroupPoliciesBandwidthBandwidthLimitsArgs']]):
        pulumi.set(self, "bandwidth_limits", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class GroupPoliciesBandwidthBandwidthLimitsArgsDict(TypedDict):
        limit_down: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum download limit (integer, in Kbps). null indicates no limit
        """
        limit_up: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum upload limit (integer, in Kbps). null indicates no limit
        """
elif False:
    GroupPoliciesBandwidthBandwidthLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesBandwidthBandwidthLimitsArgs:
    def __init__(__self__, *,
                 limit_down: Optional[pulumi.Input[_builtins.int]] = None,
                 limit_up: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] limit_down: The maximum download limit (integer, in Kbps). null indicates no limit
        :param pulumi.Input[_builtins.int] limit_up: The maximum upload limit (integer, in Kbps). null indicates no limit
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum download limit (integer, in Kbps). null indicates no limit
        """
        return pulumi.get(self, "limit_down")

    @limit_down.setter
    def limit_down(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_down", value)

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum upload limit (integer, in Kbps). null indicates no limit
        """
        return pulumi.get(self, "limit_up")

    @limit_up.setter
    def limit_up(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_up", value)


if not MYPY:
    class GroupPoliciesBonjourForwardingArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesBonjourForwardingRuleArgsDict']]]]
        """
        A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
        """
        settings: NotRequired[pulumi.Input[_builtins.str]]
        """
        How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
        """
elif False:
    GroupPoliciesBonjourForwardingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesBonjourForwardingArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesBonjourForwardingRuleArgs']]]] = None,
                 settings: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GroupPoliciesBonjourForwardingRuleArgs']]] rules: A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
        :param pulumi.Input[_builtins.str] settings: How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesBonjourForwardingRuleArgs']]]]:
        """
        A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesBonjourForwardingRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class GroupPoliciesBonjourForwardingRuleArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description for your Bonjour forwarding rule. Optional.
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        """
        vlan_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the service VLAN. Required.
        """
elif False:
    GroupPoliciesBonjourForwardingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesBonjourForwardingRuleArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vlan_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: A description for your Bonjour forwarding rule. Optional.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] services: A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        :param pulumi.Input[_builtins.str] vlan_id: The ID of the service VLAN. Required.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description for your Bonjour forwarding rule. Optional.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "services", value)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the service VLAN. Required.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class GroupPoliciesContentFilteringArgsDict(TypedDict):
        allowed_url_patterns: NotRequired[pulumi.Input['GroupPoliciesContentFilteringAllowedUrlPatternsArgsDict']]
        """
        Settings for allowed URL patterns
        """
        blocked_url_categories: NotRequired[pulumi.Input['GroupPoliciesContentFilteringBlockedUrlCategoriesArgsDict']]
        """
        Settings for blocked URL categories
        """
        blocked_url_patterns: NotRequired[pulumi.Input['GroupPoliciesContentFilteringBlockedUrlPatternsArgsDict']]
        """
        Settings for blocked URL patterns
        """
elif False:
    GroupPoliciesContentFilteringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesContentFilteringArgs:
    def __init__(__self__, *,
                 allowed_url_patterns: Optional[pulumi.Input['GroupPoliciesContentFilteringAllowedUrlPatternsArgs']] = None,
                 blocked_url_categories: Optional[pulumi.Input['GroupPoliciesContentFilteringBlockedUrlCategoriesArgs']] = None,
                 blocked_url_patterns: Optional[pulumi.Input['GroupPoliciesContentFilteringBlockedUrlPatternsArgs']] = None):
        """
        :param pulumi.Input['GroupPoliciesContentFilteringAllowedUrlPatternsArgs'] allowed_url_patterns: Settings for allowed URL patterns
        :param pulumi.Input['GroupPoliciesContentFilteringBlockedUrlCategoriesArgs'] blocked_url_categories: Settings for blocked URL categories
        :param pulumi.Input['GroupPoliciesContentFilteringBlockedUrlPatternsArgs'] blocked_url_patterns: Settings for blocked URL patterns
        """
        if allowed_url_patterns is not None:
            pulumi.set(__self__, "allowed_url_patterns", allowed_url_patterns)
        if blocked_url_categories is not None:
            pulumi.set(__self__, "blocked_url_categories", blocked_url_categories)
        if blocked_url_patterns is not None:
            pulumi.set(__self__, "blocked_url_patterns", blocked_url_patterns)

    @_builtins.property
    @pulumi.getter(name="allowedUrlPatterns")
    def allowed_url_patterns(self) -> Optional[pulumi.Input['GroupPoliciesContentFilteringAllowedUrlPatternsArgs']]:
        """
        Settings for allowed URL patterns
        """
        return pulumi.get(self, "allowed_url_patterns")

    @allowed_url_patterns.setter
    def allowed_url_patterns(self, value: Optional[pulumi.Input['GroupPoliciesContentFilteringAllowedUrlPatternsArgs']]):
        pulumi.set(self, "allowed_url_patterns", value)

    @_builtins.property
    @pulumi.getter(name="blockedUrlCategories")
    def blocked_url_categories(self) -> Optional[pulumi.Input['GroupPoliciesContentFilteringBlockedUrlCategoriesArgs']]:
        """
        Settings for blocked URL categories
        """
        return pulumi.get(self, "blocked_url_categories")

    @blocked_url_categories.setter
    def blocked_url_categories(self, value: Optional[pulumi.Input['GroupPoliciesContentFilteringBlockedUrlCategoriesArgs']]):
        pulumi.set(self, "blocked_url_categories", value)

    @_builtins.property
    @pulumi.getter(name="blockedUrlPatterns")
    def blocked_url_patterns(self) -> Optional[pulumi.Input['GroupPoliciesContentFilteringBlockedUrlPatternsArgs']]:
        """
        Settings for blocked URL patterns
        """
        return pulumi.get(self, "blocked_url_patterns")

    @blocked_url_patterns.setter
    def blocked_url_patterns(self, value: Optional[pulumi.Input['GroupPoliciesContentFilteringBlockedUrlPatternsArgs']]):
        pulumi.set(self, "blocked_url_patterns", value)


if not MYPY:
    class GroupPoliciesContentFilteringAllowedUrlPatternsArgsDict(TypedDict):
        patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of URL patterns that are allowed
        """
        settings: NotRequired[pulumi.Input[_builtins.str]]
        """
        How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
elif False:
    GroupPoliciesContentFilteringAllowedUrlPatternsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesContentFilteringAllowedUrlPatternsArgs:
    def __init__(__self__, *,
                 patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 settings: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] patterns: A list of URL patterns that are allowed
        :param pulumi.Input[_builtins.str] settings: How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of URL patterns that are allowed
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "patterns", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class GroupPoliciesContentFilteringBlockedUrlCategoriesArgsDict(TypedDict):
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of URL categories to block
        """
        settings: NotRequired[pulumi.Input[_builtins.str]]
        """
        How URL categories are applied. Can be 'network default', 'append' or 'override'.
        """
elif False:
    GroupPoliciesContentFilteringBlockedUrlCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesContentFilteringBlockedUrlCategoriesArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 settings: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] categories: A list of URL categories to block
        :param pulumi.Input[_builtins.str] settings: How URL categories are applied. Can be 'network default', 'append' or 'override'.
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of URL categories to block
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "categories", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How URL categories are applied. Can be 'network default', 'append' or 'override'.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class GroupPoliciesContentFilteringBlockedUrlPatternsArgsDict(TypedDict):
        patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of URL patterns that are blocked
        """
        settings: NotRequired[pulumi.Input[_builtins.str]]
        """
        How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
elif False:
    GroupPoliciesContentFilteringBlockedUrlPatternsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesContentFilteringBlockedUrlPatternsArgs:
    def __init__(__self__, *,
                 patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 settings: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] patterns: A list of URL patterns that are blocked
        :param pulumi.Input[_builtins.str] settings: How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of URL patterns that are blocked
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "patterns", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How URL patterns are applied. Can be 'network default', 'append' or 'override'.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class GroupPoliciesFirewallAndTrafficShapingArgsDict(TypedDict):
        l3_firewall_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingL3FirewallRuleArgsDict']]]]
        """
        An ordered array of the L3 firewall rules
        """
        l7_firewall_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingL7FirewallRuleArgsDict']]]]
        """
        An ordered array of L7 firewall rules
        """
        settings: NotRequired[pulumi.Input[_builtins.str]]
        """
        How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
        """
        traffic_shaping_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleArgsDict']]]]
        """
        An array of traffic shaping rules. Rules are applied in the order that
        they are specified in. An empty list (or null) means no rules. Note that
        you are allowed a maximum of 8 rules.
        """
elif False:
    GroupPoliciesFirewallAndTrafficShapingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesFirewallAndTrafficShapingArgs:
    def __init__(__self__, *,
                 l3_firewall_rules: Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingL3FirewallRuleArgs']]]] = None,
                 l7_firewall_rules: Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingL7FirewallRuleArgs']]]] = None,
                 settings: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic_shaping_rules: Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingL3FirewallRuleArgs']]] l3_firewall_rules: An ordered array of the L3 firewall rules
        :param pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingL7FirewallRuleArgs']]] l7_firewall_rules: An ordered array of L7 firewall rules
        :param pulumi.Input[_builtins.str] settings: How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
        :param pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleArgs']]] traffic_shaping_rules: An array of traffic shaping rules. Rules are applied in the order that
               they are specified in. An empty list (or null) means no rules. Note that
               you are allowed a maximum of 8 rules.
        """
        if l3_firewall_rules is not None:
            pulumi.set(__self__, "l3_firewall_rules", l3_firewall_rules)
        if l7_firewall_rules is not None:
            pulumi.set(__self__, "l7_firewall_rules", l7_firewall_rules)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if traffic_shaping_rules is not None:
            pulumi.set(__self__, "traffic_shaping_rules", traffic_shaping_rules)

    @_builtins.property
    @pulumi.getter(name="l3FirewallRules")
    def l3_firewall_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingL3FirewallRuleArgs']]]]:
        """
        An ordered array of the L3 firewall rules
        """
        return pulumi.get(self, "l3_firewall_rules")

    @l3_firewall_rules.setter
    def l3_firewall_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingL3FirewallRuleArgs']]]]):
        pulumi.set(self, "l3_firewall_rules", value)

    @_builtins.property
    @pulumi.getter(name="l7FirewallRules")
    def l7_firewall_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingL7FirewallRuleArgs']]]]:
        """
        An ordered array of L7 firewall rules
        """
        return pulumi.get(self, "l7_firewall_rules")

    @l7_firewall_rules.setter
    def l7_firewall_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingL7FirewallRuleArgs']]]]):
        pulumi.set(self, "l7_firewall_rules", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter(name="trafficShapingRules")
    def traffic_shaping_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleArgs']]]]:
        """
        An array of traffic shaping rules. Rules are applied in the order that
        they are specified in. An empty list (or null) means no rules. Note that
        you are allowed a maximum of 8 rules.
        """
        return pulumi.get(self, "traffic_shaping_rules")

    @traffic_shaping_rules.setter
    def traffic_shaping_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleArgs']]]]):
        pulumi.set(self, "traffic_shaping_rules", value)


if not MYPY:
    class GroupPoliciesFirewallAndTrafficShapingL3FirewallRuleArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the rule (optional)
        """
        dest_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
        """
        dest_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'allow' or 'deny' traffic specified by this rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
elif False:
    GroupPoliciesFirewallAndTrafficShapingL3FirewallRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesFirewallAndTrafficShapingL3FirewallRuleArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_port: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Description of the rule (optional)
        :param pulumi.Input[_builtins.str] dest_cidr: Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
        :param pulumi.Input[_builtins.str] dest_port: Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
        :param pulumi.Input[_builtins.str] policy: 'allow' or 'deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
        """
        return pulumi.get(self, "dest_cidr")

    @dest_cidr.setter
    def dest_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_cidr", value)

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @dest_port.setter
    def dest_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_port", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class GroupPoliciesFirewallAndTrafficShapingL7FirewallRuleArgsDict(TypedDict):
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy applied to matching traffic. Must be 'deny'.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
        """
elif False:
    GroupPoliciesFirewallAndTrafficShapingL7FirewallRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesFirewallAndTrafficShapingL7FirewallRuleArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] policy: The policy applied to matching traffic. Must be 'deny'.
        :param pulumi.Input[_builtins.str] type: Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
        :param pulumi.Input[_builtins.str] value: The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy applied to matching traffic. Must be 'deny'.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleArgsDict(TypedDict):
        definitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinitionArgsDict']]]]
        """
        A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        """
        dscp_tag_value: NotRequired[pulumi.Input[_builtins.int]]
        """
        The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        """
        pcp_tag_value: NotRequired[pulumi.Input[_builtins.int]]
        """
        The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
        null means 'Do not set PCP tag'.
        """
        per_client_bandwidth_limits: NotRequired[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsArgsDict']]
        """
        An object describing the bandwidth settings for your rule.
        """
        priority: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string, indicating the priority level for packets bound to your rule.
        Can be 'low', 'normal' or 'high'.
        """
elif False:
    GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleArgs:
    def __init__(__self__, *,
                 definitions: Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinitionArgs']]]] = None,
                 dscp_tag_value: Optional[pulumi.Input[_builtins.int]] = None,
                 pcp_tag_value: Optional[pulumi.Input[_builtins.int]] = None,
                 per_client_bandwidth_limits: Optional[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsArgs']] = None,
                 priority: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinitionArgs']]] definitions: A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        :param pulumi.Input[_builtins.int] dscp_tag_value: The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
               For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        :param pulumi.Input[_builtins.int] pcp_tag_value: The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
               null means 'Do not set PCP tag'.
        :param pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsArgs'] per_client_bandwidth_limits: An object describing the bandwidth settings for your rule.
        :param pulumi.Input[_builtins.str] priority: A string, indicating the priority level for packets bound to your rule.
               Can be 'low', 'normal' or 'high'.
        """
        if definitions is not None:
            pulumi.set(__self__, "definitions", definitions)
        if dscp_tag_value is not None:
            pulumi.set(__self__, "dscp_tag_value", dscp_tag_value)
        if pcp_tag_value is not None:
            pulumi.set(__self__, "pcp_tag_value", pcp_tag_value)
        if per_client_bandwidth_limits is not None:
            pulumi.set(__self__, "per_client_bandwidth_limits", per_client_bandwidth_limits)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinitionArgs']]]]:
        """
        A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        """
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinitionArgs']]]]):
        pulumi.set(self, "definitions", value)

    @_builtins.property
    @pulumi.getter(name="dscpTagValue")
    def dscp_tag_value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        """
        return pulumi.get(self, "dscp_tag_value")

    @dscp_tag_value.setter
    def dscp_tag_value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dscp_tag_value", value)

    @_builtins.property
    @pulumi.getter(name="pcpTagValue")
    def pcp_tag_value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
        null means 'Do not set PCP tag'.
        """
        return pulumi.get(self, "pcp_tag_value")

    @pcp_tag_value.setter
    def pcp_tag_value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "pcp_tag_value", value)

    @_builtins.property
    @pulumi.getter(name="perClientBandwidthLimits")
    def per_client_bandwidth_limits(self) -> Optional[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsArgs']]:
        """
        An object describing the bandwidth settings for your rule.
        """
        return pulumi.get(self, "per_client_bandwidth_limits")

    @per_client_bandwidth_limits.setter
    def per_client_bandwidth_limits(self, value: Optional[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsArgs']]):
        pulumi.set(self, "per_client_bandwidth_limits", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string, indicating the priority level for packets bound to your rule.
        Can be 'low', 'normal' or 'high'.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinitionArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
        a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
        "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
        custom ports.
         If "type" is 'application' or 'applicationCategory', then "value" must be an object
        with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
        application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
        endpoint).
        """
elif False:
    GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinitionArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        :param pulumi.Input[_builtins.str] value: If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
               a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
               "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
               custom ports.
                If "type" is 'application' or 'applicationCategory', then "value" must be an object
               with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
               application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
               endpoint).
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
        a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
        "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
        custom ports.
         If "type" is 'application' or 'applicationCategory', then "value" must be an object
        with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
        application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
        endpoint).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsArgsDict(TypedDict):
        bandwidth_limits: NotRequired[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsArgsDict']]
        """
        The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        """
        settings: NotRequired[pulumi.Input[_builtins.str]]
        """
        How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
elif False:
    GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsArgs:
    def __init__(__self__, *,
                 bandwidth_limits: Optional[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsArgs']] = None,
                 settings: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsArgs'] bandwidth_limits: The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        :param pulumi.Input[_builtins.str] settings: How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        if bandwidth_limits is not None:
            pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> Optional[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsArgs']]:
        """
        The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "bandwidth_limits")

    @bandwidth_limits.setter
    def bandwidth_limits(self, value: Optional[pulumi.Input['GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsArgs']]):
        pulumi.set(self, "bandwidth_limits", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsArgsDict(TypedDict):
        limit_down: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum download limit (integer, in Kbps).
        """
        limit_up: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum upload limit (integer, in Kbps).
        """
elif False:
    GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimitsArgs:
    def __init__(__self__, *,
                 limit_down: Optional[pulumi.Input[_builtins.int]] = None,
                 limit_up: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] limit_down: The maximum download limit (integer, in Kbps).
        :param pulumi.Input[_builtins.int] limit_up: The maximum upload limit (integer, in Kbps).
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum download limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_down")

    @limit_down.setter
    def limit_down(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_down", value)

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum upload limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_up")

    @limit_up.setter
    def limit_up(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_up", value)


if not MYPY:
    class GroupPoliciesSchedulingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
        """
        friday: NotRequired[pulumi.Input['GroupPoliciesSchedulingFridayArgsDict']]
        """
        The schedule object for Friday.
        """
        monday: NotRequired[pulumi.Input['GroupPoliciesSchedulingMondayArgsDict']]
        """
        The schedule object for Monday.
        """
        saturday: NotRequired[pulumi.Input['GroupPoliciesSchedulingSaturdayArgsDict']]
        """
        The schedule object for Saturday.
        """
        sunday: NotRequired[pulumi.Input['GroupPoliciesSchedulingSundayArgsDict']]
        """
        The schedule object for Sunday.
        """
        thursday: NotRequired[pulumi.Input['GroupPoliciesSchedulingThursdayArgsDict']]
        """
        The schedule object for Thursday.
        """
        tuesday: NotRequired[pulumi.Input['GroupPoliciesSchedulingTuesdayArgsDict']]
        """
        The schedule object for Tuesday.
        """
        wednesday: NotRequired[pulumi.Input['GroupPoliciesSchedulingWednesdayArgsDict']]
        """
        The schedule object for Wednesday.
        """
elif False:
    GroupPoliciesSchedulingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesSchedulingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 friday: Optional[pulumi.Input['GroupPoliciesSchedulingFridayArgs']] = None,
                 monday: Optional[pulumi.Input['GroupPoliciesSchedulingMondayArgs']] = None,
                 saturday: Optional[pulumi.Input['GroupPoliciesSchedulingSaturdayArgs']] = None,
                 sunday: Optional[pulumi.Input['GroupPoliciesSchedulingSundayArgs']] = None,
                 thursday: Optional[pulumi.Input['GroupPoliciesSchedulingThursdayArgs']] = None,
                 tuesday: Optional[pulumi.Input['GroupPoliciesSchedulingTuesdayArgs']] = None,
                 wednesday: Optional[pulumi.Input['GroupPoliciesSchedulingWednesdayArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
        :param pulumi.Input['GroupPoliciesSchedulingFridayArgs'] friday: The schedule object for Friday.
        :param pulumi.Input['GroupPoliciesSchedulingMondayArgs'] monday: The schedule object for Monday.
        :param pulumi.Input['GroupPoliciesSchedulingSaturdayArgs'] saturday: The schedule object for Saturday.
        :param pulumi.Input['GroupPoliciesSchedulingSundayArgs'] sunday: The schedule object for Sunday.
        :param pulumi.Input['GroupPoliciesSchedulingThursdayArgs'] thursday: The schedule object for Thursday.
        :param pulumi.Input['GroupPoliciesSchedulingTuesdayArgs'] tuesday: The schedule object for Tuesday.
        :param pulumi.Input['GroupPoliciesSchedulingWednesdayArgs'] wednesday: The schedule object for Wednesday.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if friday is not None:
            pulumi.set(__self__, "friday", friday)
        if monday is not None:
            pulumi.set(__self__, "monday", monday)
        if saturday is not None:
            pulumi.set(__self__, "saturday", saturday)
        if sunday is not None:
            pulumi.set(__self__, "sunday", sunday)
        if thursday is not None:
            pulumi.set(__self__, "thursday", thursday)
        if tuesday is not None:
            pulumi.set(__self__, "tuesday", tuesday)
        if wednesday is not None:
            pulumi.set(__self__, "wednesday", wednesday)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def friday(self) -> Optional[pulumi.Input['GroupPoliciesSchedulingFridayArgs']]:
        """
        The schedule object for Friday.
        """
        return pulumi.get(self, "friday")

    @friday.setter
    def friday(self, value: Optional[pulumi.Input['GroupPoliciesSchedulingFridayArgs']]):
        pulumi.set(self, "friday", value)

    @_builtins.property
    @pulumi.getter
    def monday(self) -> Optional[pulumi.Input['GroupPoliciesSchedulingMondayArgs']]:
        """
        The schedule object for Monday.
        """
        return pulumi.get(self, "monday")

    @monday.setter
    def monday(self, value: Optional[pulumi.Input['GroupPoliciesSchedulingMondayArgs']]):
        pulumi.set(self, "monday", value)

    @_builtins.property
    @pulumi.getter
    def saturday(self) -> Optional[pulumi.Input['GroupPoliciesSchedulingSaturdayArgs']]:
        """
        The schedule object for Saturday.
        """
        return pulumi.get(self, "saturday")

    @saturday.setter
    def saturday(self, value: Optional[pulumi.Input['GroupPoliciesSchedulingSaturdayArgs']]):
        pulumi.set(self, "saturday", value)

    @_builtins.property
    @pulumi.getter
    def sunday(self) -> Optional[pulumi.Input['GroupPoliciesSchedulingSundayArgs']]:
        """
        The schedule object for Sunday.
        """
        return pulumi.get(self, "sunday")

    @sunday.setter
    def sunday(self, value: Optional[pulumi.Input['GroupPoliciesSchedulingSundayArgs']]):
        pulumi.set(self, "sunday", value)

    @_builtins.property
    @pulumi.getter
    def thursday(self) -> Optional[pulumi.Input['GroupPoliciesSchedulingThursdayArgs']]:
        """
        The schedule object for Thursday.
        """
        return pulumi.get(self, "thursday")

    @thursday.setter
    def thursday(self, value: Optional[pulumi.Input['GroupPoliciesSchedulingThursdayArgs']]):
        pulumi.set(self, "thursday", value)

    @_builtins.property
    @pulumi.getter
    def tuesday(self) -> Optional[pulumi.Input['GroupPoliciesSchedulingTuesdayArgs']]:
        """
        The schedule object for Tuesday.
        """
        return pulumi.get(self, "tuesday")

    @tuesday.setter
    def tuesday(self, value: Optional[pulumi.Input['GroupPoliciesSchedulingTuesdayArgs']]):
        pulumi.set(self, "tuesday", value)

    @_builtins.property
    @pulumi.getter
    def wednesday(self) -> Optional[pulumi.Input['GroupPoliciesSchedulingWednesdayArgs']]:
        """
        The schedule object for Wednesday.
        """
        return pulumi.get(self, "wednesday")

    @wednesday.setter
    def wednesday(self, value: Optional[pulumi.Input['GroupPoliciesSchedulingWednesdayArgs']]):
        pulumi.set(self, "wednesday", value)


if not MYPY:
    class GroupPoliciesSchedulingFridayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    GroupPoliciesSchedulingFridayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesSchedulingFridayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class GroupPoliciesSchedulingMondayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    GroupPoliciesSchedulingMondayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesSchedulingMondayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class GroupPoliciesSchedulingSaturdayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    GroupPoliciesSchedulingSaturdayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesSchedulingSaturdayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class GroupPoliciesSchedulingSundayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    GroupPoliciesSchedulingSundayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesSchedulingSundayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class GroupPoliciesSchedulingThursdayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    GroupPoliciesSchedulingThursdayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesSchedulingThursdayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class GroupPoliciesSchedulingTuesdayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    GroupPoliciesSchedulingTuesdayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesSchedulingTuesdayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class GroupPoliciesSchedulingWednesdayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    GroupPoliciesSchedulingWednesdayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesSchedulingWednesdayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class GroupPoliciesVlanTaggingArgsDict(TypedDict):
        settings: NotRequired[pulumi.Input[_builtins.str]]
        """
        How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
        """
        vlan_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
        """
elif False:
    GroupPoliciesVlanTaggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPoliciesVlanTaggingArgs:
    def __init__(__self__, *,
                 settings: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] settings: How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
        :param pulumi.Input[_builtins.str] vlan_id: The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
        """
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class MerakiAuthUsersAuthorizationArgsDict(TypedDict):
        authorized_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        User is authorized by the account email address
        """
        authorized_by_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        User is authorized by the account name
        """
        authorized_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authorized zone of the user
        """
        expires_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authorization expiration time
        """
        ssid_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        SSID number
        """
elif False:
    MerakiAuthUsersAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MerakiAuthUsersAuthorizationArgs:
    def __init__(__self__, *,
                 authorized_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 authorized_by_name: Optional[pulumi.Input[_builtins.str]] = None,
                 authorized_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 expires_at: Optional[pulumi.Input[_builtins.str]] = None,
                 ssid_number: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] authorized_by_email: User is authorized by the account email address
        :param pulumi.Input[_builtins.str] authorized_by_name: User is authorized by the account name
        :param pulumi.Input[_builtins.str] authorized_zone: Authorized zone of the user
        :param pulumi.Input[_builtins.str] expires_at: Authorization expiration time
        :param pulumi.Input[_builtins.int] ssid_number: SSID number
        """
        if authorized_by_email is not None:
            pulumi.set(__self__, "authorized_by_email", authorized_by_email)
        if authorized_by_name is not None:
            pulumi.set(__self__, "authorized_by_name", authorized_by_name)
        if authorized_zone is not None:
            pulumi.set(__self__, "authorized_zone", authorized_zone)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if ssid_number is not None:
            pulumi.set(__self__, "ssid_number", ssid_number)

    @_builtins.property
    @pulumi.getter(name="authorizedByEmail")
    def authorized_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User is authorized by the account email address
        """
        return pulumi.get(self, "authorized_by_email")

    @authorized_by_email.setter
    def authorized_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorized_by_email", value)

    @_builtins.property
    @pulumi.getter(name="authorizedByName")
    def authorized_by_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User is authorized by the account name
        """
        return pulumi.get(self, "authorized_by_name")

    @authorized_by_name.setter
    def authorized_by_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorized_by_name", value)

    @_builtins.property
    @pulumi.getter(name="authorizedZone")
    def authorized_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authorized zone of the user
        """
        return pulumi.get(self, "authorized_zone")

    @authorized_zone.setter
    def authorized_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorized_zone", value)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authorization expiration time
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expires_at", value)

    @_builtins.property
    @pulumi.getter(name="ssidNumber")
    def ssid_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        SSID number
        """
        return pulumi.get(self, "ssid_number")

    @ssid_number.setter
    def ssid_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ssid_number", value)


if not MYPY:
    class MqttBrokersItemArgsDict(TypedDict):
        authentication: NotRequired[pulumi.Input['MqttBrokersItemAuthenticationArgsDict']]
        """
        Authentication settings of the MQTT broker
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host name/IP address where the MQTT broker runs.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the MQTT Broker.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the MQTT Broker.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Host port though which the MQTT broker can be reached.
        """
        security: NotRequired[pulumi.Input['MqttBrokersItemSecurityArgsDict']]
        """
        Security settings of the MQTT broker.
        """
elif False:
    MqttBrokersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MqttBrokersItemArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['MqttBrokersItemAuthenticationArgs']] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 security: Optional[pulumi.Input['MqttBrokersItemSecurityArgs']] = None):
        """
        :param pulumi.Input['MqttBrokersItemAuthenticationArgs'] authentication: Authentication settings of the MQTT broker
        :param pulumi.Input[_builtins.str] host: Host name/IP address where the MQTT broker runs.
        :param pulumi.Input[_builtins.str] id: ID of the MQTT Broker.
        :param pulumi.Input[_builtins.str] name: Name of the MQTT Broker.
        :param pulumi.Input[_builtins.int] port: Host port though which the MQTT broker can be reached.
        :param pulumi.Input['MqttBrokersItemSecurityArgs'] security: Security settings of the MQTT broker.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if security is not None:
            pulumi.set(__self__, "security", security)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['MqttBrokersItemAuthenticationArgs']]:
        """
        Authentication settings of the MQTT broker
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['MqttBrokersItemAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host name/IP address where the MQTT broker runs.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the MQTT Broker.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the MQTT Broker.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Host port though which the MQTT broker can be reached.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def security(self) -> Optional[pulumi.Input['MqttBrokersItemSecurityArgs']]:
        """
        Security settings of the MQTT broker.
        """
        return pulumi.get(self, "security")

    @security.setter
    def security(self, value: Optional[pulumi.Input['MqttBrokersItemSecurityArgs']]):
        pulumi.set(self, "security", value)


if not MYPY:
    class MqttBrokersItemAuthenticationArgsDict(TypedDict):
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        Username for the MQTT broker.
        """
elif False:
    MqttBrokersItemAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MqttBrokersItemAuthenticationArgs:
    def __init__(__self__, *,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] username: Username for the MQTT broker.
        """
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Username for the MQTT broker.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class MqttBrokersItemSecurityArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Security protocol of the MQTT broker.
        """
        tls: NotRequired[pulumi.Input['MqttBrokersItemSecurityTlsArgsDict']]
        """
        TLS settings of the MQTT broker.
        """
elif False:
    MqttBrokersItemSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MqttBrokersItemSecurityArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 tls: Optional[pulumi.Input['MqttBrokersItemSecurityTlsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Security protocol of the MQTT broker.
        :param pulumi.Input['MqttBrokersItemSecurityTlsArgs'] tls: TLS settings of the MQTT broker.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Security protocol of the MQTT broker.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['MqttBrokersItemSecurityTlsArgs']]:
        """
        TLS settings of the MQTT broker.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['MqttBrokersItemSecurityTlsArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class MqttBrokersItemSecurityTlsArgsDict(TypedDict):
        has_ca_certificate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the CA certificate is set
        """
        verify_hostnames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the TLS hostname verification is enabled for the MQTT broker.
        """
elif False:
    MqttBrokersItemSecurityTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MqttBrokersItemSecurityTlsArgs:
    def __init__(__self__, *,
                 has_ca_certificate: Optional[pulumi.Input[_builtins.bool]] = None,
                 verify_hostnames: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] has_ca_certificate: Indicates whether the CA certificate is set
        :param pulumi.Input[_builtins.bool] verify_hostnames: Whether the TLS hostname verification is enabled for the MQTT broker.
        """
        if has_ca_certificate is not None:
            pulumi.set(__self__, "has_ca_certificate", has_ca_certificate)
        if verify_hostnames is not None:
            pulumi.set(__self__, "verify_hostnames", verify_hostnames)

    @_builtins.property
    @pulumi.getter(name="hasCaCertificate")
    def has_ca_certificate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the CA certificate is set
        """
        return pulumi.get(self, "has_ca_certificate")

    @has_ca_certificate.setter
    def has_ca_certificate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "has_ca_certificate", value)

    @_builtins.property
    @pulumi.getter(name="verifyHostnames")
    def verify_hostnames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the TLS hostname verification is enabled for the MQTT broker.
        """
        return pulumi.get(self, "verify_hostnames")

    @verify_hostnames.setter
    def verify_hostnames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "verify_hostnames", value)


if not MYPY:
    class MqttBrokersParametersArgsDict(TypedDict):
        authentication: NotRequired[pulumi.Input['MqttBrokersParametersAuthenticationArgsDict']]
        """
        Authentication settings of the MQTT broker
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host name/IP address where the MQTT broker runs.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the MQTT broker.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Host port though which the MQTT broker can be reached.
        """
        security: NotRequired[pulumi.Input['MqttBrokersParametersSecurityArgsDict']]
        """
        Security settings of the MQTT broker.
        """
elif False:
    MqttBrokersParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MqttBrokersParametersArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['MqttBrokersParametersAuthenticationArgs']] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 security: Optional[pulumi.Input['MqttBrokersParametersSecurityArgs']] = None):
        """
        :param pulumi.Input['MqttBrokersParametersAuthenticationArgs'] authentication: Authentication settings of the MQTT broker
        :param pulumi.Input[_builtins.str] host: Host name/IP address where the MQTT broker runs.
        :param pulumi.Input[_builtins.str] name: Name of the MQTT broker.
        :param pulumi.Input[_builtins.int] port: Host port though which the MQTT broker can be reached.
        :param pulumi.Input['MqttBrokersParametersSecurityArgs'] security: Security settings of the MQTT broker.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if security is not None:
            pulumi.set(__self__, "security", security)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['MqttBrokersParametersAuthenticationArgs']]:
        """
        Authentication settings of the MQTT broker
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['MqttBrokersParametersAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host name/IP address where the MQTT broker runs.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the MQTT broker.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Host port though which the MQTT broker can be reached.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def security(self) -> Optional[pulumi.Input['MqttBrokersParametersSecurityArgs']]:
        """
        Security settings of the MQTT broker.
        """
        return pulumi.get(self, "security")

    @security.setter
    def security(self, value: Optional[pulumi.Input['MqttBrokersParametersSecurityArgs']]):
        pulumi.set(self, "security", value)


if not MYPY:
    class MqttBrokersParametersAuthenticationArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password for the MQTT broker.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        Username for the MQTT broker.
        """
elif False:
    MqttBrokersParametersAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MqttBrokersParametersAuthenticationArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password: Password for the MQTT broker.
        :param pulumi.Input[_builtins.str] username: Username for the MQTT broker.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password for the MQTT broker.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Username for the MQTT broker.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class MqttBrokersParametersSecurityArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Security protocol of the MQTT broker.
        """
        tls: NotRequired[pulumi.Input['MqttBrokersParametersSecurityTlsArgsDict']]
        """
        TLS settings of the MQTT broker.
        """
elif False:
    MqttBrokersParametersSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MqttBrokersParametersSecurityArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 tls: Optional[pulumi.Input['MqttBrokersParametersSecurityTlsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Security protocol of the MQTT broker.
        :param pulumi.Input['MqttBrokersParametersSecurityTlsArgs'] tls: TLS settings of the MQTT broker.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Security protocol of the MQTT broker.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['MqttBrokersParametersSecurityTlsArgs']]:
        """
        TLS settings of the MQTT broker.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['MqttBrokersParametersSecurityTlsArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class MqttBrokersParametersSecurityTlsArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        CA Certificate of the MQTT broker.
        """
        verify_hostnames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the TLS hostname verification is enabled for the MQTT broker.
        """
elif False:
    MqttBrokersParametersSecurityTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MqttBrokersParametersSecurityTlsArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 verify_hostnames: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] ca_certificate: CA Certificate of the MQTT broker.
        :param pulumi.Input[_builtins.bool] verify_hostnames: Whether the TLS hostname verification is enabled for the MQTT broker.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if verify_hostnames is not None:
            pulumi.set(__self__, "verify_hostnames", verify_hostnames)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CA Certificate of the MQTT broker.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_certificate", value)

    @_builtins.property
    @pulumi.getter(name="verifyHostnames")
    def verify_hostnames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the TLS hostname verification is enabled for the MQTT broker.
        """
        return pulumi.get(self, "verify_hostnames")

    @verify_hostnames.setter
    def verify_hostnames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "verify_hostnames", value)


if not MYPY:
    class SensorAlertsProfilesConditionArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
        """
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
        """
        metric: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
        """
        threshold: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdArgsDict']]
        """
        Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
        """
elif False:
    SensorAlertsProfilesConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[_builtins.str]] = None,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 metric: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] direction: If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
        :param pulumi.Input[_builtins.int] duration: Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
        :param pulumi.Input[_builtins.str] metric: The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdArgs'] threshold: Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdArgs']]:
        """
        Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdArgs']]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdArgsDict(TypedDict):
        apparent_power: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdApparentPowerArgsDict']]
        """
        Apparent power threshold. 'draw' must be provided.
        """
        current: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdCurrentArgsDict']]
        """
        Electrical current threshold. 'level' must be provided.
        """
        door: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdDoorArgsDict']]
        """
        Door open threshold. 'open' must be provided and set to true.
        """
        frequency: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdFrequencyArgsDict']]
        """
        Electrical frequency threshold. 'level' must be provided.
        """
        humidity: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdHumidityArgsDict']]
        """
        Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
        """
        indoor_air_quality: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdIndoorAirQualityArgsDict']]
        """
        Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
        """
        noise: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdNoiseArgsDict']]
        """
        Noise threshold. 'ambient' must be provided.
        """
        pm25: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdPm25ArgsDict']]
        """
        PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        power_factor: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdPowerFactorArgsDict']]
        """
        Power factor threshold. 'percentage' must be provided.
        """
        real_power: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdRealPowerArgsDict']]
        """
        Real power threshold. 'draw' must be provided.
        """
        temperature: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdTemperatureArgsDict']]
        """
        Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
        """
        tvoc: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdTvocArgsDict']]
        """
        TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        upstream_power: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdUpstreamPowerArgsDict']]
        """
        Upstream power threshold. 'outageDetected' must be provided and set to true.
        """
        voltage: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdVoltageArgsDict']]
        """
        Voltage threshold. 'level' must be provided.
        """
        water: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdWaterArgsDict']]
        """
        Water detection threshold. 'present' must be provided and set to true.
        """
elif False:
    SensorAlertsProfilesConditionThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdArgs:
    def __init__(__self__, *,
                 apparent_power: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdApparentPowerArgs']] = None,
                 current: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdCurrentArgs']] = None,
                 door: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdDoorArgs']] = None,
                 frequency: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdFrequencyArgs']] = None,
                 humidity: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdHumidityArgs']] = None,
                 indoor_air_quality: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdIndoorAirQualityArgs']] = None,
                 noise: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdNoiseArgs']] = None,
                 pm25: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdPm25Args']] = None,
                 power_factor: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdPowerFactorArgs']] = None,
                 real_power: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdRealPowerArgs']] = None,
                 temperature: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdTemperatureArgs']] = None,
                 tvoc: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdTvocArgs']] = None,
                 upstream_power: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdUpstreamPowerArgs']] = None,
                 voltage: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdVoltageArgs']] = None,
                 water: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdWaterArgs']] = None):
        """
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdApparentPowerArgs'] apparent_power: Apparent power threshold. 'draw' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdCurrentArgs'] current: Electrical current threshold. 'level' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdDoorArgs'] door: Door open threshold. 'open' must be provided and set to true.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdFrequencyArgs'] frequency: Electrical frequency threshold. 'level' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdHumidityArgs'] humidity: Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdIndoorAirQualityArgs'] indoor_air_quality: Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdNoiseArgs'] noise: Noise threshold. 'ambient' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdPm25Args'] pm25: PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdPowerFactorArgs'] power_factor: Power factor threshold. 'percentage' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdRealPowerArgs'] real_power: Real power threshold. 'draw' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdTemperatureArgs'] temperature: Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdTvocArgs'] tvoc: TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdUpstreamPowerArgs'] upstream_power: Upstream power threshold. 'outageDetected' must be provided and set to true.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdVoltageArgs'] voltage: Voltage threshold. 'level' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdWaterArgs'] water: Water detection threshold. 'present' must be provided and set to true.
        """
        if apparent_power is not None:
            pulumi.set(__self__, "apparent_power", apparent_power)
        if current is not None:
            pulumi.set(__self__, "current", current)
        if door is not None:
            pulumi.set(__self__, "door", door)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if humidity is not None:
            pulumi.set(__self__, "humidity", humidity)
        if indoor_air_quality is not None:
            pulumi.set(__self__, "indoor_air_quality", indoor_air_quality)
        if noise is not None:
            pulumi.set(__self__, "noise", noise)
        if pm25 is not None:
            pulumi.set(__self__, "pm25", pm25)
        if power_factor is not None:
            pulumi.set(__self__, "power_factor", power_factor)
        if real_power is not None:
            pulumi.set(__self__, "real_power", real_power)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if tvoc is not None:
            pulumi.set(__self__, "tvoc", tvoc)
        if upstream_power is not None:
            pulumi.set(__self__, "upstream_power", upstream_power)
        if voltage is not None:
            pulumi.set(__self__, "voltage", voltage)
        if water is not None:
            pulumi.set(__self__, "water", water)

    @_builtins.property
    @pulumi.getter(name="apparentPower")
    def apparent_power(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdApparentPowerArgs']]:
        """
        Apparent power threshold. 'draw' must be provided.
        """
        return pulumi.get(self, "apparent_power")

    @apparent_power.setter
    def apparent_power(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdApparentPowerArgs']]):
        pulumi.set(self, "apparent_power", value)

    @_builtins.property
    @pulumi.getter
    def current(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdCurrentArgs']]:
        """
        Electrical current threshold. 'level' must be provided.
        """
        return pulumi.get(self, "current")

    @current.setter
    def current(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdCurrentArgs']]):
        pulumi.set(self, "current", value)

    @_builtins.property
    @pulumi.getter
    def door(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdDoorArgs']]:
        """
        Door open threshold. 'open' must be provided and set to true.
        """
        return pulumi.get(self, "door")

    @door.setter
    def door(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdDoorArgs']]):
        pulumi.set(self, "door", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdFrequencyArgs']]:
        """
        Electrical frequency threshold. 'level' must be provided.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdFrequencyArgs']]):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter
    def humidity(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdHumidityArgs']]:
        """
        Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
        """
        return pulumi.get(self, "humidity")

    @humidity.setter
    def humidity(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdHumidityArgs']]):
        pulumi.set(self, "humidity", value)

    @_builtins.property
    @pulumi.getter(name="indoorAirQuality")
    def indoor_air_quality(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdIndoorAirQualityArgs']]:
        """
        Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
        """
        return pulumi.get(self, "indoor_air_quality")

    @indoor_air_quality.setter
    def indoor_air_quality(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdIndoorAirQualityArgs']]):
        pulumi.set(self, "indoor_air_quality", value)

    @_builtins.property
    @pulumi.getter
    def noise(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdNoiseArgs']]:
        """
        Noise threshold. 'ambient' must be provided.
        """
        return pulumi.get(self, "noise")

    @noise.setter
    def noise(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdNoiseArgs']]):
        pulumi.set(self, "noise", value)

    @_builtins.property
    @pulumi.getter
    def pm25(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdPm25Args']]:
        """
        PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        return pulumi.get(self, "pm25")

    @pm25.setter
    def pm25(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdPm25Args']]):
        pulumi.set(self, "pm25", value)

    @_builtins.property
    @pulumi.getter(name="powerFactor")
    def power_factor(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdPowerFactorArgs']]:
        """
        Power factor threshold. 'percentage' must be provided.
        """
        return pulumi.get(self, "power_factor")

    @power_factor.setter
    def power_factor(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdPowerFactorArgs']]):
        pulumi.set(self, "power_factor", value)

    @_builtins.property
    @pulumi.getter(name="realPower")
    def real_power(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdRealPowerArgs']]:
        """
        Real power threshold. 'draw' must be provided.
        """
        return pulumi.get(self, "real_power")

    @real_power.setter
    def real_power(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdRealPowerArgs']]):
        pulumi.set(self, "real_power", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdTemperatureArgs']]:
        """
        Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdTemperatureArgs']]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter
    def tvoc(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdTvocArgs']]:
        """
        TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        return pulumi.get(self, "tvoc")

    @tvoc.setter
    def tvoc(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdTvocArgs']]):
        pulumi.set(self, "tvoc", value)

    @_builtins.property
    @pulumi.getter(name="upstreamPower")
    def upstream_power(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdUpstreamPowerArgs']]:
        """
        Upstream power threshold. 'outageDetected' must be provided and set to true.
        """
        return pulumi.get(self, "upstream_power")

    @upstream_power.setter
    def upstream_power(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdUpstreamPowerArgs']]):
        pulumi.set(self, "upstream_power", value)

    @_builtins.property
    @pulumi.getter
    def voltage(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdVoltageArgs']]:
        """
        Voltage threshold. 'level' must be provided.
        """
        return pulumi.get(self, "voltage")

    @voltage.setter
    def voltage(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdVoltageArgs']]):
        pulumi.set(self, "voltage", value)

    @_builtins.property
    @pulumi.getter
    def water(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdWaterArgs']]:
        """
        Water detection threshold. 'present' must be provided and set to true.
        """
        return pulumi.get(self, "water")

    @water.setter
    def water(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdWaterArgs']]):
        pulumi.set(self, "water", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdApparentPowerArgsDict(TypedDict):
        draw: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in volt-amps. Must be between 0 and 3750.
        """
elif False:
    SensorAlertsProfilesConditionThresholdApparentPowerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdApparentPowerArgs:
    def __init__(__self__, *,
                 draw: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] draw: Alerting threshold in volt-amps. Must be between 0 and 3750.
        """
        if draw is not None:
            pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in volt-amps. Must be between 0 and 3750.
        """
        return pulumi.get(self, "draw")

    @draw.setter
    def draw(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "draw", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdCurrentArgsDict(TypedDict):
        draw: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in amps. Must be between 0 and 15.
        """
elif False:
    SensorAlertsProfilesConditionThresholdCurrentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdCurrentArgs:
    def __init__(__self__, *,
                 draw: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] draw: Alerting threshold in amps. Must be between 0 and 15.
        """
        if draw is not None:
            pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in amps. Must be between 0 and 15.
        """
        return pulumi.get(self, "draw")

    @draw.setter
    def draw(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "draw", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdDoorArgsDict(TypedDict):
        open: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Alerting threshold for a door open event. Must be set to true.
        """
elif False:
    SensorAlertsProfilesConditionThresholdDoorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdDoorArgs:
    def __init__(__self__, *,
                 open: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] open: Alerting threshold for a door open event. Must be set to true.
        """
        if open is not None:
            pulumi.set(__self__, "open", open)

    @_builtins.property
    @pulumi.getter
    def open(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Alerting threshold for a door open event. Must be set to true.
        """
        return pulumi.get(self, "open")

    @open.setter
    def open(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "open", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdFrequencyArgsDict(TypedDict):
        level: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in hertz. Must be between 0 and 60.
        """
elif False:
    SensorAlertsProfilesConditionThresholdFrequencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdFrequencyArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] level: Alerting threshold in hertz. Must be between 0 and 60.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in hertz. Must be between 0 and 60.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdHumidityArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alerting threshold as a qualitative humidity level.
        """
        relative_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alerting threshold in %RH.
        """
elif False:
    SensorAlertsProfilesConditionThresholdHumidityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdHumidityArgs:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 relative_percentage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Alerting threshold as a qualitative humidity level.
        :param pulumi.Input[_builtins.int] relative_percentage: Alerting threshold in %RH.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if relative_percentage is not None:
            pulumi.set(__self__, "relative_percentage", relative_percentage)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alerting threshold as a qualitative humidity level.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter(name="relativePercentage")
    def relative_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alerting threshold in %RH.
        """
        return pulumi.get(self, "relative_percentage")

    @relative_percentage.setter
    def relative_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "relative_percentage", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdIndoorAirQualityArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alerting threshold as a qualitative indoor air quality level.
        """
        score: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alerting threshold as indoor air quality score.
        """
elif False:
    SensorAlertsProfilesConditionThresholdIndoorAirQualityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdIndoorAirQualityArgs:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 score: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Alerting threshold as a qualitative indoor air quality level.
        :param pulumi.Input[_builtins.int] score: Alerting threshold as indoor air quality score.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if score is not None:
            pulumi.set(__self__, "score", score)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alerting threshold as a qualitative indoor air quality level.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def score(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alerting threshold as indoor air quality score.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "score", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdNoiseArgsDict(TypedDict):
        ambient: NotRequired[pulumi.Input['SensorAlertsProfilesConditionThresholdNoiseAmbientArgsDict']]
        """
        Ambient noise threshold. One of 'level' or 'quality' must be provided.
        """
elif False:
    SensorAlertsProfilesConditionThresholdNoiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdNoiseArgs:
    def __init__(__self__, *,
                 ambient: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdNoiseAmbientArgs']] = None):
        """
        :param pulumi.Input['SensorAlertsProfilesConditionThresholdNoiseAmbientArgs'] ambient: Ambient noise threshold. One of 'level' or 'quality' must be provided.
        """
        if ambient is not None:
            pulumi.set(__self__, "ambient", ambient)

    @_builtins.property
    @pulumi.getter
    def ambient(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdNoiseAmbientArgs']]:
        """
        Ambient noise threshold. One of 'level' or 'quality' must be provided.
        """
        return pulumi.get(self, "ambient")

    @ambient.setter
    def ambient(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionThresholdNoiseAmbientArgs']]):
        pulumi.set(self, "ambient", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdNoiseAmbientArgsDict(TypedDict):
        level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alerting threshold as adjusted decibels.
        """
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alerting threshold as a qualitative ambient noise level.
        """
elif False:
    SensorAlertsProfilesConditionThresholdNoiseAmbientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdNoiseAmbientArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[_builtins.int]] = None,
                 quality: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] level: Alerting threshold as adjusted decibels.
        :param pulumi.Input[_builtins.str] quality: Alerting threshold as a qualitative ambient noise level.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alerting threshold as adjusted decibels.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "level", value)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alerting threshold as a qualitative ambient noise level.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdPm25ArgsDict(TypedDict):
        concentration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alerting threshold as PM2.5 parts per million.
        """
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alerting threshold as a qualitative PM2.5 level.
        """
elif False:
    SensorAlertsProfilesConditionThresholdPm25ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdPm25Args:
    def __init__(__self__, *,
                 concentration: Optional[pulumi.Input[_builtins.int]] = None,
                 quality: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] concentration: Alerting threshold as PM2.5 parts per million.
        :param pulumi.Input[_builtins.str] quality: Alerting threshold as a qualitative PM2.5 level.
        """
        if concentration is not None:
            pulumi.set(__self__, "concentration", concentration)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def concentration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alerting threshold as PM2.5 parts per million.
        """
        return pulumi.get(self, "concentration")

    @concentration.setter
    def concentration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "concentration", value)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alerting threshold as a qualitative PM2.5 level.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdPowerFactorArgsDict(TypedDict):
        percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
        """
elif False:
    SensorAlertsProfilesConditionThresholdPowerFactorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdPowerFactorArgs:
    def __init__(__self__, *,
                 percentage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] percentage: Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
        """
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdRealPowerArgsDict(TypedDict):
        draw: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in watts. Must be between 0 and 3750.
        """
elif False:
    SensorAlertsProfilesConditionThresholdRealPowerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdRealPowerArgs:
    def __init__(__self__, *,
                 draw: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] draw: Alerting threshold in watts. Must be between 0 and 3750.
        """
        if draw is not None:
            pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in watts. Must be between 0 and 3750.
        """
        return pulumi.get(self, "draw")

    @draw.setter
    def draw(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "draw", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdTemperatureArgsDict(TypedDict):
        celsius: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in degrees Celsius.
        """
        fahrenheit: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in degrees Fahrenheit.
        """
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alerting threshold as a qualitative temperature level.
        """
elif False:
    SensorAlertsProfilesConditionThresholdTemperatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdTemperatureArgs:
    def __init__(__self__, *,
                 celsius: Optional[pulumi.Input[_builtins.float]] = None,
                 fahrenheit: Optional[pulumi.Input[_builtins.float]] = None,
                 quality: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] celsius: Alerting threshold in degrees Celsius.
        :param pulumi.Input[_builtins.float] fahrenheit: Alerting threshold in degrees Fahrenheit.
        :param pulumi.Input[_builtins.str] quality: Alerting threshold as a qualitative temperature level.
        """
        if celsius is not None:
            pulumi.set(__self__, "celsius", celsius)
        if fahrenheit is not None:
            pulumi.set(__self__, "fahrenheit", fahrenheit)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def celsius(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in degrees Celsius.
        """
        return pulumi.get(self, "celsius")

    @celsius.setter
    def celsius(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "celsius", value)

    @_builtins.property
    @pulumi.getter
    def fahrenheit(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in degrees Fahrenheit.
        """
        return pulumi.get(self, "fahrenheit")

    @fahrenheit.setter
    def fahrenheit(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "fahrenheit", value)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alerting threshold as a qualitative temperature level.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdTvocArgsDict(TypedDict):
        concentration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alerting threshold as TVOC micrograms per cubic meter.
        """
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alerting threshold as a qualitative TVOC level.
        """
elif False:
    SensorAlertsProfilesConditionThresholdTvocArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdTvocArgs:
    def __init__(__self__, *,
                 concentration: Optional[pulumi.Input[_builtins.int]] = None,
                 quality: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] concentration: Alerting threshold as TVOC micrograms per cubic meter.
        :param pulumi.Input[_builtins.str] quality: Alerting threshold as a qualitative TVOC level.
        """
        if concentration is not None:
            pulumi.set(__self__, "concentration", concentration)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def concentration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alerting threshold as TVOC micrograms per cubic meter.
        """
        return pulumi.get(self, "concentration")

    @concentration.setter
    def concentration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "concentration", value)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alerting threshold as a qualitative TVOC level.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdUpstreamPowerArgsDict(TypedDict):
        outage_detected: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Alerting threshold for an upstream power event. Must be set to true.
        """
elif False:
    SensorAlertsProfilesConditionThresholdUpstreamPowerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdUpstreamPowerArgs:
    def __init__(__self__, *,
                 outage_detected: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] outage_detected: Alerting threshold for an upstream power event. Must be set to true.
        """
        if outage_detected is not None:
            pulumi.set(__self__, "outage_detected", outage_detected)

    @_builtins.property
    @pulumi.getter(name="outageDetected")
    def outage_detected(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Alerting threshold for an upstream power event. Must be set to true.
        """
        return pulumi.get(self, "outage_detected")

    @outage_detected.setter
    def outage_detected(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "outage_detected", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdVoltageArgsDict(TypedDict):
        level: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in volts. Must be between 0 and 250.
        """
elif False:
    SensorAlertsProfilesConditionThresholdVoltageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdVoltageArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] level: Alerting threshold in volts. Must be between 0 and 250.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in volts. Must be between 0 and 250.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class SensorAlertsProfilesConditionThresholdWaterArgsDict(TypedDict):
        present: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Alerting threshold for a water detection event. Must be set to true.
        """
elif False:
    SensorAlertsProfilesConditionThresholdWaterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionThresholdWaterArgs:
    def __init__(__self__, *,
                 present: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] present: Alerting threshold for a water detection event. Must be set to true.
        """
        if present is not None:
            pulumi.set(__self__, "present", present)

    @_builtins.property
    @pulumi.getter
    def present(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Alerting threshold for a water detection event. Must be set to true.
        """
        return pulumi.get(self, "present")

    @present.setter
    def present(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "present", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
        """
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
        """
        metric: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
        """
        threshold: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdArgsDict']]
        """
        Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
        """
elif False:
    SensorAlertsProfilesConditionsResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[_builtins.str]] = None,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 metric: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] direction: If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
        :param pulumi.Input[_builtins.int] duration: Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
        :param pulumi.Input[_builtins.str] metric: The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdArgs'] threshold: Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdArgs']]:
        """
        Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdArgs']]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdArgsDict(TypedDict):
        apparent_power: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdApparentPowerArgsDict']]
        """
        Apparent power threshold. 'draw' must be provided.
        """
        current: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdCurrentArgsDict']]
        """
        Electrical current threshold. 'level' must be provided.
        """
        door: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdDoorArgsDict']]
        """
        Door open threshold. 'open' must be provided and set to true.
        """
        frequency: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdFrequencyArgsDict']]
        """
        Electrical frequency threshold. 'level' must be provided.
        """
        humidity: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdHumidityArgsDict']]
        """
        Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
        """
        indoor_air_quality: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdIndoorAirQualityArgsDict']]
        """
        Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
        """
        noise: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdNoiseArgsDict']]
        """
        Noise threshold. 'ambient' must be provided.
        """
        pm25: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdPm25ArgsDict']]
        """
        PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        power_factor: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdPowerFactorArgsDict']]
        """
        Power factor threshold. 'percentage' must be provided.
        """
        real_power: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdRealPowerArgsDict']]
        """
        Real power threshold. 'draw' must be provided.
        """
        temperature: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdTemperatureArgsDict']]
        """
        Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
        """
        tvoc: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdTvocArgsDict']]
        """
        TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        upstream_power: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdUpstreamPowerArgsDict']]
        """
        Upstream power threshold. 'outageDetected' must be provided and set to true.
        """
        voltage: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdVoltageArgsDict']]
        """
        Voltage threshold. 'level' must be provided.
        """
        water: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdWaterArgsDict']]
        """
        Water detection threshold. 'present' must be provided and set to true.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdArgs:
    def __init__(__self__, *,
                 apparent_power: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdApparentPowerArgs']] = None,
                 current: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdCurrentArgs']] = None,
                 door: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdDoorArgs']] = None,
                 frequency: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdFrequencyArgs']] = None,
                 humidity: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdHumidityArgs']] = None,
                 indoor_air_quality: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdIndoorAirQualityArgs']] = None,
                 noise: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdNoiseArgs']] = None,
                 pm25: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdPm25Args']] = None,
                 power_factor: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdPowerFactorArgs']] = None,
                 real_power: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdRealPowerArgs']] = None,
                 temperature: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdTemperatureArgs']] = None,
                 tvoc: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdTvocArgs']] = None,
                 upstream_power: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdUpstreamPowerArgs']] = None,
                 voltage: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdVoltageArgs']] = None,
                 water: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdWaterArgs']] = None):
        """
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdApparentPowerArgs'] apparent_power: Apparent power threshold. 'draw' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdCurrentArgs'] current: Electrical current threshold. 'level' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdDoorArgs'] door: Door open threshold. 'open' must be provided and set to true.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdFrequencyArgs'] frequency: Electrical frequency threshold. 'level' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdHumidityArgs'] humidity: Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdIndoorAirQualityArgs'] indoor_air_quality: Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdNoiseArgs'] noise: Noise threshold. 'ambient' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdPm25Args'] pm25: PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdPowerFactorArgs'] power_factor: Power factor threshold. 'percentage' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdRealPowerArgs'] real_power: Real power threshold. 'draw' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdTemperatureArgs'] temperature: Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdTvocArgs'] tvoc: TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdUpstreamPowerArgs'] upstream_power: Upstream power threshold. 'outageDetected' must be provided and set to true.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdVoltageArgs'] voltage: Voltage threshold. 'level' must be provided.
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdWaterArgs'] water: Water detection threshold. 'present' must be provided and set to true.
        """
        if apparent_power is not None:
            pulumi.set(__self__, "apparent_power", apparent_power)
        if current is not None:
            pulumi.set(__self__, "current", current)
        if door is not None:
            pulumi.set(__self__, "door", door)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if humidity is not None:
            pulumi.set(__self__, "humidity", humidity)
        if indoor_air_quality is not None:
            pulumi.set(__self__, "indoor_air_quality", indoor_air_quality)
        if noise is not None:
            pulumi.set(__self__, "noise", noise)
        if pm25 is not None:
            pulumi.set(__self__, "pm25", pm25)
        if power_factor is not None:
            pulumi.set(__self__, "power_factor", power_factor)
        if real_power is not None:
            pulumi.set(__self__, "real_power", real_power)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if tvoc is not None:
            pulumi.set(__self__, "tvoc", tvoc)
        if upstream_power is not None:
            pulumi.set(__self__, "upstream_power", upstream_power)
        if voltage is not None:
            pulumi.set(__self__, "voltage", voltage)
        if water is not None:
            pulumi.set(__self__, "water", water)

    @_builtins.property
    @pulumi.getter(name="apparentPower")
    def apparent_power(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdApparentPowerArgs']]:
        """
        Apparent power threshold. 'draw' must be provided.
        """
        return pulumi.get(self, "apparent_power")

    @apparent_power.setter
    def apparent_power(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdApparentPowerArgs']]):
        pulumi.set(self, "apparent_power", value)

    @_builtins.property
    @pulumi.getter
    def current(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdCurrentArgs']]:
        """
        Electrical current threshold. 'level' must be provided.
        """
        return pulumi.get(self, "current")

    @current.setter
    def current(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdCurrentArgs']]):
        pulumi.set(self, "current", value)

    @_builtins.property
    @pulumi.getter
    def door(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdDoorArgs']]:
        """
        Door open threshold. 'open' must be provided and set to true.
        """
        return pulumi.get(self, "door")

    @door.setter
    def door(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdDoorArgs']]):
        pulumi.set(self, "door", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdFrequencyArgs']]:
        """
        Electrical frequency threshold. 'level' must be provided.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdFrequencyArgs']]):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter
    def humidity(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdHumidityArgs']]:
        """
        Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
        """
        return pulumi.get(self, "humidity")

    @humidity.setter
    def humidity(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdHumidityArgs']]):
        pulumi.set(self, "humidity", value)

    @_builtins.property
    @pulumi.getter(name="indoorAirQuality")
    def indoor_air_quality(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdIndoorAirQualityArgs']]:
        """
        Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
        """
        return pulumi.get(self, "indoor_air_quality")

    @indoor_air_quality.setter
    def indoor_air_quality(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdIndoorAirQualityArgs']]):
        pulumi.set(self, "indoor_air_quality", value)

    @_builtins.property
    @pulumi.getter
    def noise(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdNoiseArgs']]:
        """
        Noise threshold. 'ambient' must be provided.
        """
        return pulumi.get(self, "noise")

    @noise.setter
    def noise(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdNoiseArgs']]):
        pulumi.set(self, "noise", value)

    @_builtins.property
    @pulumi.getter
    def pm25(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdPm25Args']]:
        """
        PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        return pulumi.get(self, "pm25")

    @pm25.setter
    def pm25(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdPm25Args']]):
        pulumi.set(self, "pm25", value)

    @_builtins.property
    @pulumi.getter(name="powerFactor")
    def power_factor(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdPowerFactorArgs']]:
        """
        Power factor threshold. 'percentage' must be provided.
        """
        return pulumi.get(self, "power_factor")

    @power_factor.setter
    def power_factor(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdPowerFactorArgs']]):
        pulumi.set(self, "power_factor", value)

    @_builtins.property
    @pulumi.getter(name="realPower")
    def real_power(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdRealPowerArgs']]:
        """
        Real power threshold. 'draw' must be provided.
        """
        return pulumi.get(self, "real_power")

    @real_power.setter
    def real_power(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdRealPowerArgs']]):
        pulumi.set(self, "real_power", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdTemperatureArgs']]:
        """
        Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdTemperatureArgs']]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter
    def tvoc(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdTvocArgs']]:
        """
        TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
        """
        return pulumi.get(self, "tvoc")

    @tvoc.setter
    def tvoc(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdTvocArgs']]):
        pulumi.set(self, "tvoc", value)

    @_builtins.property
    @pulumi.getter(name="upstreamPower")
    def upstream_power(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdUpstreamPowerArgs']]:
        """
        Upstream power threshold. 'outageDetected' must be provided and set to true.
        """
        return pulumi.get(self, "upstream_power")

    @upstream_power.setter
    def upstream_power(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdUpstreamPowerArgs']]):
        pulumi.set(self, "upstream_power", value)

    @_builtins.property
    @pulumi.getter
    def voltage(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdVoltageArgs']]:
        """
        Voltage threshold. 'level' must be provided.
        """
        return pulumi.get(self, "voltage")

    @voltage.setter
    def voltage(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdVoltageArgs']]):
        pulumi.set(self, "voltage", value)

    @_builtins.property
    @pulumi.getter
    def water(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdWaterArgs']]:
        """
        Water detection threshold. 'present' must be provided and set to true.
        """
        return pulumi.get(self, "water")

    @water.setter
    def water(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdWaterArgs']]):
        pulumi.set(self, "water", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdApparentPowerArgsDict(TypedDict):
        draw: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in volt-amps. Must be between 0 and 3750.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdApparentPowerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdApparentPowerArgs:
    def __init__(__self__, *,
                 draw: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] draw: Alerting threshold in volt-amps. Must be between 0 and 3750.
        """
        if draw is not None:
            pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in volt-amps. Must be between 0 and 3750.
        """
        return pulumi.get(self, "draw")

    @draw.setter
    def draw(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "draw", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdCurrentArgsDict(TypedDict):
        draw: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in amps. Must be between 0 and 15.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdCurrentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdCurrentArgs:
    def __init__(__self__, *,
                 draw: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] draw: Alerting threshold in amps. Must be between 0 and 15.
        """
        if draw is not None:
            pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in amps. Must be between 0 and 15.
        """
        return pulumi.get(self, "draw")

    @draw.setter
    def draw(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "draw", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdDoorArgsDict(TypedDict):
        open: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Alerting threshold for a door open event. Must be set to true.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdDoorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdDoorArgs:
    def __init__(__self__, *,
                 open: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] open: Alerting threshold for a door open event. Must be set to true.
        """
        if open is not None:
            pulumi.set(__self__, "open", open)

    @_builtins.property
    @pulumi.getter
    def open(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Alerting threshold for a door open event. Must be set to true.
        """
        return pulumi.get(self, "open")

    @open.setter
    def open(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "open", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdFrequencyArgsDict(TypedDict):
        level: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in hertz. Must be between 0 and 60.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdFrequencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdFrequencyArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] level: Alerting threshold in hertz. Must be between 0 and 60.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in hertz. Must be between 0 and 60.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdHumidityArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alerting threshold as a qualitative humidity level.
        """
        relative_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alerting threshold in %RH.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdHumidityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdHumidityArgs:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 relative_percentage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Alerting threshold as a qualitative humidity level.
        :param pulumi.Input[_builtins.int] relative_percentage: Alerting threshold in %RH.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if relative_percentage is not None:
            pulumi.set(__self__, "relative_percentage", relative_percentage)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alerting threshold as a qualitative humidity level.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter(name="relativePercentage")
    def relative_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alerting threshold in %RH.
        """
        return pulumi.get(self, "relative_percentage")

    @relative_percentage.setter
    def relative_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "relative_percentage", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdIndoorAirQualityArgsDict(TypedDict):
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alerting threshold as a qualitative indoor air quality level.
        """
        score: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alerting threshold as indoor air quality score.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdIndoorAirQualityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdIndoorAirQualityArgs:
    def __init__(__self__, *,
                 quality: Optional[pulumi.Input[_builtins.str]] = None,
                 score: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] quality: Alerting threshold as a qualitative indoor air quality level.
        :param pulumi.Input[_builtins.int] score: Alerting threshold as indoor air quality score.
        """
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if score is not None:
            pulumi.set(__self__, "score", score)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alerting threshold as a qualitative indoor air quality level.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter
    def score(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alerting threshold as indoor air quality score.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "score", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdNoiseArgsDict(TypedDict):
        ambient: NotRequired[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdNoiseAmbientArgsDict']]
        """
        Ambient noise threshold. One of 'level' or 'quality' must be provided.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdNoiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdNoiseArgs:
    def __init__(__self__, *,
                 ambient: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdNoiseAmbientArgs']] = None):
        """
        :param pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdNoiseAmbientArgs'] ambient: Ambient noise threshold. One of 'level' or 'quality' must be provided.
        """
        if ambient is not None:
            pulumi.set(__self__, "ambient", ambient)

    @_builtins.property
    @pulumi.getter
    def ambient(self) -> Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdNoiseAmbientArgs']]:
        """
        Ambient noise threshold. One of 'level' or 'quality' must be provided.
        """
        return pulumi.get(self, "ambient")

    @ambient.setter
    def ambient(self, value: Optional[pulumi.Input['SensorAlertsProfilesConditionsResponseThresholdNoiseAmbientArgs']]):
        pulumi.set(self, "ambient", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdNoiseAmbientArgsDict(TypedDict):
        level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alerting threshold as adjusted decibels.
        """
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alerting threshold as a qualitative ambient noise level.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdNoiseAmbientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdNoiseAmbientArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[_builtins.int]] = None,
                 quality: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] level: Alerting threshold as adjusted decibels.
        :param pulumi.Input[_builtins.str] quality: Alerting threshold as a qualitative ambient noise level.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alerting threshold as adjusted decibels.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "level", value)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alerting threshold as a qualitative ambient noise level.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdPm25ArgsDict(TypedDict):
        concentration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alerting threshold as PM2.5 parts per million.
        """
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alerting threshold as a qualitative PM2.5 level.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdPm25ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdPm25Args:
    def __init__(__self__, *,
                 concentration: Optional[pulumi.Input[_builtins.int]] = None,
                 quality: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] concentration: Alerting threshold as PM2.5 parts per million.
        :param pulumi.Input[_builtins.str] quality: Alerting threshold as a qualitative PM2.5 level.
        """
        if concentration is not None:
            pulumi.set(__self__, "concentration", concentration)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def concentration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alerting threshold as PM2.5 parts per million.
        """
        return pulumi.get(self, "concentration")

    @concentration.setter
    def concentration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "concentration", value)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alerting threshold as a qualitative PM2.5 level.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdPowerFactorArgsDict(TypedDict):
        percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdPowerFactorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdPowerFactorArgs:
    def __init__(__self__, *,
                 percentage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] percentage: Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
        """
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdRealPowerArgsDict(TypedDict):
        draw: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in watts. Must be between 0 and 3750.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdRealPowerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdRealPowerArgs:
    def __init__(__self__, *,
                 draw: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] draw: Alerting threshold in watts. Must be between 0 and 3750.
        """
        if draw is not None:
            pulumi.set(__self__, "draw", draw)

    @_builtins.property
    @pulumi.getter
    def draw(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in watts. Must be between 0 and 3750.
        """
        return pulumi.get(self, "draw")

    @draw.setter
    def draw(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "draw", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdTemperatureArgsDict(TypedDict):
        celsius: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in degrees Celsius.
        """
        fahrenheit: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in degrees Fahrenheit.
        """
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alerting threshold as a qualitative temperature level.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdTemperatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdTemperatureArgs:
    def __init__(__self__, *,
                 celsius: Optional[pulumi.Input[_builtins.float]] = None,
                 fahrenheit: Optional[pulumi.Input[_builtins.float]] = None,
                 quality: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] celsius: Alerting threshold in degrees Celsius.
        :param pulumi.Input[_builtins.float] fahrenheit: Alerting threshold in degrees Fahrenheit.
        :param pulumi.Input[_builtins.str] quality: Alerting threshold as a qualitative temperature level.
        """
        if celsius is not None:
            pulumi.set(__self__, "celsius", celsius)
        if fahrenheit is not None:
            pulumi.set(__self__, "fahrenheit", fahrenheit)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def celsius(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in degrees Celsius.
        """
        return pulumi.get(self, "celsius")

    @celsius.setter
    def celsius(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "celsius", value)

    @_builtins.property
    @pulumi.getter
    def fahrenheit(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in degrees Fahrenheit.
        """
        return pulumi.get(self, "fahrenheit")

    @fahrenheit.setter
    def fahrenheit(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "fahrenheit", value)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alerting threshold as a qualitative temperature level.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdTvocArgsDict(TypedDict):
        concentration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alerting threshold as TVOC micrograms per cubic meter.
        """
        quality: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alerting threshold as a qualitative TVOC level.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdTvocArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdTvocArgs:
    def __init__(__self__, *,
                 concentration: Optional[pulumi.Input[_builtins.int]] = None,
                 quality: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] concentration: Alerting threshold as TVOC micrograms per cubic meter.
        :param pulumi.Input[_builtins.str] quality: Alerting threshold as a qualitative TVOC level.
        """
        if concentration is not None:
            pulumi.set(__self__, "concentration", concentration)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @_builtins.property
    @pulumi.getter
    def concentration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alerting threshold as TVOC micrograms per cubic meter.
        """
        return pulumi.get(self, "concentration")

    @concentration.setter
    def concentration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "concentration", value)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alerting threshold as a qualitative TVOC level.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quality", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdUpstreamPowerArgsDict(TypedDict):
        outage_detected: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Alerting threshold for an upstream power event. Must be set to true.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdUpstreamPowerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdUpstreamPowerArgs:
    def __init__(__self__, *,
                 outage_detected: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] outage_detected: Alerting threshold for an upstream power event. Must be set to true.
        """
        if outage_detected is not None:
            pulumi.set(__self__, "outage_detected", outage_detected)

    @_builtins.property
    @pulumi.getter(name="outageDetected")
    def outage_detected(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Alerting threshold for an upstream power event. Must be set to true.
        """
        return pulumi.get(self, "outage_detected")

    @outage_detected.setter
    def outage_detected(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "outage_detected", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdVoltageArgsDict(TypedDict):
        level: NotRequired[pulumi.Input[_builtins.float]]
        """
        Alerting threshold in volts. Must be between 0 and 250.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdVoltageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdVoltageArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] level: Alerting threshold in volts. Must be between 0 and 250.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Alerting threshold in volts. Must be between 0 and 250.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class SensorAlertsProfilesConditionsResponseThresholdWaterArgsDict(TypedDict):
        present: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Alerting threshold for a water detection event. Must be set to true.
        """
elif False:
    SensorAlertsProfilesConditionsResponseThresholdWaterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesConditionsResponseThresholdWaterArgs:
    def __init__(__self__, *,
                 present: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] present: Alerting threshold for a water detection event. Must be set to true.
        """
        if present is not None:
            pulumi.set(__self__, "present", present)

    @_builtins.property
    @pulumi.getter
    def present(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Alerting threshold for a water detection event. Must be set to true.
        """
        return pulumi.get(self, "present")

    @present.setter
    def present(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "present", value)


if not MYPY:
    class SensorAlertsProfilesRecipientsArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of emails that will receive information about the alert.
        """
        http_server_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of webhook endpoint IDs that will receive information about the alert.
        """
        sms_numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of SMS numbers that will receive information about the alert.
        """
elif False:
    SensorAlertsProfilesRecipientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesRecipientsArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 http_server_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 sms_numbers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: A list of emails that will receive information about the alert.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] http_server_ids: A list of webhook endpoint IDs that will receive information about the alert.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] sms_numbers: A list of SMS numbers that will receive information about the alert.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_server_ids is not None:
            pulumi.set(__self__, "http_server_ids", http_server_ids)
        if sms_numbers is not None:
            pulumi.set(__self__, "sms_numbers", sms_numbers)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of emails that will receive information about the alert.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter(name="httpServerIds")
    def http_server_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of webhook endpoint IDs that will receive information about the alert.
        """
        return pulumi.get(self, "http_server_ids")

    @http_server_ids.setter
    def http_server_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_server_ids", value)

    @_builtins.property
    @pulumi.getter(name="smsNumbers")
    def sms_numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of SMS numbers that will receive information about the alert.
        """
        return pulumi.get(self, "sms_numbers")

    @sms_numbers.setter
    def sms_numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "sms_numbers", value)


if not MYPY:
    class SensorAlertsProfilesScheduleArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the sensor schedule to use with the alert profile.
        """
elif False:
    SensorAlertsProfilesScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensorAlertsProfilesScheduleArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
        :param pulumi.Input[_builtins.str] name: Name of the sensor schedule to use with the alert profile.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the sensor schedule to use with the alert profile.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SettingsFipsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables / disables FIPS on the network.
        """
elif False:
    SettingsFipsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingsFipsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enables / disables FIPS on the network.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables / disables FIPS on the network.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SettingsLocalStatusPageArgsDict(TypedDict):
        authentication: NotRequired[pulumi.Input['SettingsLocalStatusPageAuthenticationArgsDict']]
        """
        A hash of Local Status page(s)' authentication options applied to the Network.
        """
elif False:
    SettingsLocalStatusPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingsLocalStatusPageArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['SettingsLocalStatusPageAuthenticationArgs']] = None):
        """
        :param pulumi.Input['SettingsLocalStatusPageAuthenticationArgs'] authentication: A hash of Local Status page(s)' authentication options applied to the Network.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['SettingsLocalStatusPageAuthenticationArgs']]:
        """
        A hash of Local Status page(s)' authentication options applied to the Network.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['SettingsLocalStatusPageAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)


if not MYPY:
    class SettingsLocalStatusPageAuthenticationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables / disables the authentication on Local Status page(s).
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password used for Local Status Page(s). Set this to null to clear the password.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username used for Local Status Page(s).
        """
elif False:
    SettingsLocalStatusPageAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingsLocalStatusPageAuthenticationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enables / disables the authentication on Local Status page(s).
        :param pulumi.Input[_builtins.str] password: The password used for Local Status Page(s). Set this to null to clear the password.
        :param pulumi.Input[_builtins.str] username: The username used for Local Status Page(s).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables / disables the authentication on Local Status page(s).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password used for Local Status Page(s). Set this to null to clear the password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username used for Local Status Page(s).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class SettingsNamedVlansArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables / disables Named VLANs on the Network.
        """
elif False:
    SettingsNamedVlansArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingsNamedVlansArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enables / disables Named VLANs on the Network.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables / disables Named VLANs on the Network.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SettingsSecurePortArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables / disables SecureConnect on the network. Optional.
        """
elif False:
    SettingsSecurePortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingsSecurePortArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enables / disables SecureConnect on the network. Optional.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables / disables SecureConnect on the network. Optional.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SmBypassActivationLockAttemptsDataArgsDict(TypedDict):
        status2090938209: NotRequired[pulumi.Input['SmBypassActivationLockAttemptsDataStatus2090938209ArgsDict']]
        status38290139892: NotRequired[pulumi.Input['SmBypassActivationLockAttemptsDataStatus38290139892ArgsDict']]
elif False:
    SmBypassActivationLockAttemptsDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmBypassActivationLockAttemptsDataArgs:
    def __init__(__self__, *,
                 status2090938209: Optional[pulumi.Input['SmBypassActivationLockAttemptsDataStatus2090938209Args']] = None,
                 status38290139892: Optional[pulumi.Input['SmBypassActivationLockAttemptsDataStatus38290139892Args']] = None):
        if status2090938209 is not None:
            pulumi.set(__self__, "status2090938209", status2090938209)
        if status38290139892 is not None:
            pulumi.set(__self__, "status38290139892", status38290139892)

    @_builtins.property
    @pulumi.getter
    def status2090938209(self) -> Optional[pulumi.Input['SmBypassActivationLockAttemptsDataStatus2090938209Args']]:
        return pulumi.get(self, "status2090938209")

    @status2090938209.setter
    def status2090938209(self, value: Optional[pulumi.Input['SmBypassActivationLockAttemptsDataStatus2090938209Args']]):
        pulumi.set(self, "status2090938209", value)

    @_builtins.property
    @pulumi.getter
    def status38290139892(self) -> Optional[pulumi.Input['SmBypassActivationLockAttemptsDataStatus38290139892Args']]:
        return pulumi.get(self, "status38290139892")

    @status38290139892.setter
    def status38290139892(self, value: Optional[pulumi.Input['SmBypassActivationLockAttemptsDataStatus38290139892Args']]):
        pulumi.set(self, "status38290139892", value)


if not MYPY:
    class SmBypassActivationLockAttemptsDataStatus2090938209ArgsDict(TypedDict):
        errors: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        success: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    SmBypassActivationLockAttemptsDataStatus2090938209ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmBypassActivationLockAttemptsDataStatus2090938209Args:
    def __init__(__self__, *,
                 errors: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 success: Optional[pulumi.Input[_builtins.bool]] = None):
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if success is not None:
            pulumi.set(__self__, "success", success)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "errors", value)

    @_builtins.property
    @pulumi.getter
    def success(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "success")

    @success.setter
    def success(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "success", value)


if not MYPY:
    class SmBypassActivationLockAttemptsDataStatus38290139892ArgsDict(TypedDict):
        success: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    SmBypassActivationLockAttemptsDataStatus38290139892ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmBypassActivationLockAttemptsDataStatus38290139892Args:
    def __init__(__self__, *,
                 success: Optional[pulumi.Input[_builtins.bool]] = None):
        if success is not None:
            pulumi.set(__self__, "success", success)

    @_builtins.property
    @pulumi.getter
    def success(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "success")

    @success.setter
    def success(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "success", value)


if not MYPY:
    class SmDevicesCheckinItemArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The Meraki Ids of the set of devices.
        """
elif False:
    SmDevicesCheckinItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesCheckinItemArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: The Meraki Ids of the set of devices.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Meraki Ids of the set of devices.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SmDevicesCheckinParametersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The ids of the devices to be checked-in.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The serials of the devices to be checked-in.
        """
        wifi_macs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The wifiMacs of the devices to be checked-in.
        """
elif False:
    SmDevicesCheckinParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesCheckinParametersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 wifi_macs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: The ids of the devices to be checked-in.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: The serials of the devices to be checked-in.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] wifi_macs: The wifiMacs of the devices to be checked-in.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if wifi_macs is not None:
            pulumi.set(__self__, "wifi_macs", wifi_macs)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The ids of the devices to be checked-in.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The serials of the devices to be checked-in.
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)

    @_builtins.property
    @pulumi.getter(name="wifiMacs")
    def wifi_macs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The wifiMacs of the devices to be checked-in.
        """
        return pulumi.get(self, "wifi_macs")

    @wifi_macs.setter
    def wifi_macs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "wifi_macs", value)


if not MYPY:
    class SmDevicesFieldsItemArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Meraki Id of the device record.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the device.
        """
        notes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notes associated with the device.
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device serial.
        """
        wifi_mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MAC of the device.
        """
elif False:
    SmDevicesFieldsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesFieldsItemArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None,
                 wifi_mac: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The Meraki Id of the device record.
        :param pulumi.Input[_builtins.str] name: The name of the device.
        :param pulumi.Input[_builtins.str] notes: Notes associated with the device.
        :param pulumi.Input[_builtins.str] serial: The device serial.
        :param pulumi.Input[_builtins.str] wifi_mac: The MAC of the device.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if wifi_mac is not None:
            pulumi.set(__self__, "wifi_mac", wifi_mac)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Meraki Id of the device record.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the device.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notes associated with the device.
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device serial.
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)

    @_builtins.property
    @pulumi.getter(name="wifiMac")
    def wifi_mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MAC of the device.
        """
        return pulumi.get(self, "wifi_mac")

    @wifi_mac.setter
    def wifi_mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wifi_mac", value)


if not MYPY:
    class SmDevicesFieldsParametersArgsDict(TypedDict):
        device_fields: NotRequired[pulumi.Input['SmDevicesFieldsParametersDeviceFieldsArgsDict']]
        """
        The new fields of the device. Each field of this object is optional.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the device to be modified.
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        The serial of the device to be modified.
        """
        wifi_mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        The wifiMac of the device to be modified.
        """
elif False:
    SmDevicesFieldsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesFieldsParametersArgs:
    def __init__(__self__, *,
                 device_fields: Optional[pulumi.Input['SmDevicesFieldsParametersDeviceFieldsArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None,
                 wifi_mac: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['SmDevicesFieldsParametersDeviceFieldsArgs'] device_fields: The new fields of the device. Each field of this object is optional.
        :param pulumi.Input[_builtins.str] id: The id of the device to be modified.
        :param pulumi.Input[_builtins.str] serial: The serial of the device to be modified.
        :param pulumi.Input[_builtins.str] wifi_mac: The wifiMac of the device to be modified.
        """
        if device_fields is not None:
            pulumi.set(__self__, "device_fields", device_fields)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if wifi_mac is not None:
            pulumi.set(__self__, "wifi_mac", wifi_mac)

    @_builtins.property
    @pulumi.getter(name="deviceFields")
    def device_fields(self) -> Optional[pulumi.Input['SmDevicesFieldsParametersDeviceFieldsArgs']]:
        """
        The new fields of the device. Each field of this object is optional.
        """
        return pulumi.get(self, "device_fields")

    @device_fields.setter
    def device_fields(self, value: Optional[pulumi.Input['SmDevicesFieldsParametersDeviceFieldsArgs']]):
        pulumi.set(self, "device_fields", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the device to be modified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The serial of the device to be modified.
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)

    @_builtins.property
    @pulumi.getter(name="wifiMac")
    def wifi_mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The wifiMac of the device to be modified.
        """
        return pulumi.get(self, "wifi_mac")

    @wifi_mac.setter
    def wifi_mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wifi_mac", value)


if not MYPY:
    class SmDevicesFieldsParametersDeviceFieldsArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        New name for the device
        """
        notes: NotRequired[pulumi.Input[_builtins.str]]
        """
        New notes for the device
        """
elif False:
    SmDevicesFieldsParametersDeviceFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesFieldsParametersDeviceFieldsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: New name for the device
        :param pulumi.Input[_builtins.str] notes: New notes for the device
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        New name for the device
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        New notes for the device
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)


if not MYPY:
    class SmDevicesInstallAppsParametersArgsDict(TypedDict):
        app_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        ids of applications to be installed
        """
        force: NotRequired[pulumi.Input[_builtins.bool]]
        """
        By default, installation of an app which is believed to already be present on the device will be skipped. If you'd like to force the installation of the app, set this parameter to true.
        """
elif False:
    SmDevicesInstallAppsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesInstallAppsParametersArgs:
    def __init__(__self__, *,
                 app_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 force: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] app_ids: ids of applications to be installed
        :param pulumi.Input[_builtins.bool] force: By default, installation of an app which is believed to already be present on the device will be skipped. If you'd like to force the installation of the app, set this parameter to true.
        """
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)
        if force is not None:
            pulumi.set(__self__, "force", force)

    @_builtins.property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        ids of applications to be installed
        """
        return pulumi.get(self, "app_ids")

    @app_ids.setter
    def app_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "app_ids", value)

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        By default, installation of an app which is believed to already be present on the device will be skipped. If you'd like to force the installation of the app, set this parameter to true.
        """
        return pulumi.get(self, "force")

    @force.setter
    def force(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force", value)


if not MYPY:
    class SmDevicesLockItemArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The Meraki Ids of the set of devices.
        """
elif False:
    SmDevicesLockItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesLockItemArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: The Meraki Ids of the set of devices.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Meraki Ids of the set of devices.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SmDevicesLockParametersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The ids of the devices to be locked.
        """
        pin: NotRequired[pulumi.Input[_builtins.int]]
        """
        The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The serials of the devices to be locked.
        """
        wifi_macs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The wifiMacs of the devices to be locked.
        """
elif False:
    SmDevicesLockParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesLockParametersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pin: Optional[pulumi.Input[_builtins.int]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 wifi_macs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: The ids of the devices to be locked.
        :param pulumi.Input[_builtins.int] pin: The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: The serials of the devices to be locked.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] wifi_macs: The wifiMacs of the devices to be locked.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if pin is not None:
            pulumi.set(__self__, "pin", pin)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if wifi_macs is not None:
            pulumi.set(__self__, "wifi_macs", wifi_macs)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The ids of the devices to be locked.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)

    @_builtins.property
    @pulumi.getter
    def pin(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
        """
        return pulumi.get(self, "pin")

    @pin.setter
    def pin(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "pin", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The serials of the devices to be locked.
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)

    @_builtins.property
    @pulumi.getter(name="wifiMacs")
    def wifi_macs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The wifiMacs of the devices to be locked.
        """
        return pulumi.get(self, "wifi_macs")

    @wifi_macs.setter
    def wifi_macs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "wifi_macs", value)


if not MYPY:
    class SmDevicesModifyTagsItemArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Meraki Id of the device record.
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device serial.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of tags associated with the device.
        """
        wifi_mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MAC of the device.
        """
elif False:
    SmDevicesModifyTagsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesModifyTagsItemArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 wifi_mac: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The Meraki Id of the device record.
        :param pulumi.Input[_builtins.str] serial: The device serial.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: An array of tags associated with the device.
        :param pulumi.Input[_builtins.str] wifi_mac: The MAC of the device.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if wifi_mac is not None:
            pulumi.set(__self__, "wifi_mac", wifi_mac)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Meraki Id of the device record.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device serial.
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of tags associated with the device.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="wifiMac")
    def wifi_mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MAC of the device.
        """
        return pulumi.get(self, "wifi_mac")

    @wifi_mac.setter
    def wifi_mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wifi_mac", value)


if not MYPY:
    class SmDevicesModifyTagsParametersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The ids of the devices to be modified.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The serials of the devices to be modified.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The tags to be added, deleted, or updated.
        """
        update_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        One of add, delete, or update. Only devices that have been modified will be returned.
        """
        wifi_macs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The wifiMacs of the devices to be modified.
        """
elif False:
    SmDevicesModifyTagsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesModifyTagsParametersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 update_action: Optional[pulumi.Input[_builtins.str]] = None,
                 wifi_macs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: The ids of the devices to be modified.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: The serials of the devices to be modified.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: The tags to be added, deleted, or updated.
        :param pulumi.Input[_builtins.str] update_action: One of add, delete, or update. Only devices that have been modified will be returned.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] wifi_macs: The wifiMacs of the devices to be modified.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if update_action is not None:
            pulumi.set(__self__, "update_action", update_action)
        if wifi_macs is not None:
            pulumi.set(__self__, "wifi_macs", wifi_macs)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The ids of the devices to be modified.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The serials of the devices to be modified.
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The tags to be added, deleted, or updated.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="updateAction")
    def update_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        One of add, delete, or update. Only devices that have been modified will be returned.
        """
        return pulumi.get(self, "update_action")

    @update_action.setter
    def update_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_action", value)

    @_builtins.property
    @pulumi.getter(name="wifiMacs")
    def wifi_macs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The wifiMacs of the devices to be modified.
        """
        return pulumi.get(self, "wifi_macs")

    @wifi_macs.setter
    def wifi_macs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "wifi_macs", value)


if not MYPY:
    class SmDevicesMoveItemArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The Meraki Ids of the set of devices.
        """
        new_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The network to which the devices was moved.
        """
elif False:
    SmDevicesMoveItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesMoveItemArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 new_network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: The Meraki Ids of the set of devices.
        :param pulumi.Input[_builtins.str] new_network: The network to which the devices was moved.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if new_network is not None:
            pulumi.set(__self__, "new_network", new_network)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Meraki Ids of the set of devices.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)

    @_builtins.property
    @pulumi.getter(name="newNetwork")
    def new_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The network to which the devices was moved.
        """
        return pulumi.get(self, "new_network")

    @new_network.setter
    def new_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "new_network", value)


if not MYPY:
    class SmDevicesMoveParametersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The ids of the devices to be moved.
        """
        new_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The new network to which the devices will be moved.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved.
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The serials of the devices to be moved.
        """
        wifi_macs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The wifiMacs of the devices to be moved.
        """
elif False:
    SmDevicesMoveParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesMoveParametersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 new_network: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 wifi_macs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: The ids of the devices to be moved.
        :param pulumi.Input[_builtins.str] new_network: The new network to which the devices will be moved.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: The serials of the devices to be moved.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] wifi_macs: The wifiMacs of the devices to be moved.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if new_network is not None:
            pulumi.set(__self__, "new_network", new_network)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if wifi_macs is not None:
            pulumi.set(__self__, "wifi_macs", wifi_macs)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The ids of the devices to be moved.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)

    @_builtins.property
    @pulumi.getter(name="newNetwork")
    def new_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The new network to which the devices will be moved.
        """
        return pulumi.get(self, "new_network")

    @new_network.setter
    def new_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "new_network", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The serials of the devices to be moved.
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)

    @_builtins.property
    @pulumi.getter(name="wifiMacs")
    def wifi_macs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The wifiMacs of the devices to be moved.
        """
        return pulumi.get(self, "wifi_macs")

    @wifi_macs.setter
    def wifi_macs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "wifi_macs", value)


if not MYPY:
    class SmDevicesRebootItemArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The Meraki Ids of the set of endpoints.
        """
elif False:
    SmDevicesRebootItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesRebootItemArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: The Meraki Ids of the set of endpoints.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Meraki Ids of the set of endpoints.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SmDevicesRebootParametersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The ids of the endpoints to be rebooted.
        """
        kext_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The KextPaths of the endpoints to be rebooted. Available for macOS 11+
        """
        notify_user: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to notify the user before rebooting the endpoint. Available for macOS 11.3+
        """
        rebuild_kernel_cache: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to rebuild the kernel cache when rebooting the endpoint. Available for macOS 11+
        """
        request_requires_network_tether: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not the request requires network tethering. Available for macOS and supervised iOS or tvOS
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be rebooted.
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The serials of the endpoints to be rebooted.
        """
        wifi_macs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The wifiMacs of the endpoints to be rebooted.
        """
elif False:
    SmDevicesRebootParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesRebootParametersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 kext_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 notify_user: Optional[pulumi.Input[_builtins.bool]] = None,
                 rebuild_kernel_cache: Optional[pulumi.Input[_builtins.bool]] = None,
                 request_requires_network_tether: Optional[pulumi.Input[_builtins.bool]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 wifi_macs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: The ids of the endpoints to be rebooted.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] kext_paths: The KextPaths of the endpoints to be rebooted. Available for macOS 11+
        :param pulumi.Input[_builtins.bool] notify_user: Whether or not to notify the user before rebooting the endpoint. Available for macOS 11.3+
        :param pulumi.Input[_builtins.bool] rebuild_kernel_cache: Whether or not to rebuild the kernel cache when rebooting the endpoint. Available for macOS 11+
        :param pulumi.Input[_builtins.bool] request_requires_network_tether: Whether or not the request requires network tethering. Available for macOS and supervised iOS or tvOS
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be rebooted.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: The serials of the endpoints to be rebooted.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] wifi_macs: The wifiMacs of the endpoints to be rebooted.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if kext_paths is not None:
            pulumi.set(__self__, "kext_paths", kext_paths)
        if notify_user is not None:
            pulumi.set(__self__, "notify_user", notify_user)
        if rebuild_kernel_cache is not None:
            pulumi.set(__self__, "rebuild_kernel_cache", rebuild_kernel_cache)
        if request_requires_network_tether is not None:
            pulumi.set(__self__, "request_requires_network_tether", request_requires_network_tether)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if wifi_macs is not None:
            pulumi.set(__self__, "wifi_macs", wifi_macs)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The ids of the endpoints to be rebooted.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)

    @_builtins.property
    @pulumi.getter(name="kextPaths")
    def kext_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The KextPaths of the endpoints to be rebooted. Available for macOS 11+
        """
        return pulumi.get(self, "kext_paths")

    @kext_paths.setter
    def kext_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "kext_paths", value)

    @_builtins.property
    @pulumi.getter(name="notifyUser")
    def notify_user(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to notify the user before rebooting the endpoint. Available for macOS 11.3+
        """
        return pulumi.get(self, "notify_user")

    @notify_user.setter
    def notify_user(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notify_user", value)

    @_builtins.property
    @pulumi.getter(name="rebuildKernelCache")
    def rebuild_kernel_cache(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to rebuild the kernel cache when rebooting the endpoint. Available for macOS 11+
        """
        return pulumi.get(self, "rebuild_kernel_cache")

    @rebuild_kernel_cache.setter
    def rebuild_kernel_cache(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "rebuild_kernel_cache", value)

    @_builtins.property
    @pulumi.getter(name="requestRequiresNetworkTether")
    def request_requires_network_tether(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the request requires network tethering. Available for macOS and supervised iOS or tvOS
        """
        return pulumi.get(self, "request_requires_network_tether")

    @request_requires_network_tether.setter
    def request_requires_network_tether(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "request_requires_network_tether", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be rebooted.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The serials of the endpoints to be rebooted.
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)

    @_builtins.property
    @pulumi.getter(name="wifiMacs")
    def wifi_macs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The wifiMacs of the endpoints to be rebooted.
        """
        return pulumi.get(self, "wifi_macs")

    @wifi_macs.setter
    def wifi_macs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "wifi_macs", value)


if not MYPY:
    class SmDevicesShutdownItemArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The Meraki Ids of the set of endpoints.
        """
elif False:
    SmDevicesShutdownItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesShutdownItemArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: The Meraki Ids of the set of endpoints.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Meraki Ids of the set of endpoints.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SmDevicesShutdownParametersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The ids of the endpoints to be shutdown.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be shutdown.
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The serials of the endpoints to be shutdown.
        """
        wifi_macs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The wifiMacs of the endpoints to be shutdown.
        """
elif False:
    SmDevicesShutdownParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesShutdownParametersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 wifi_macs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: The ids of the endpoints to be shutdown.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be shutdown.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: The serials of the endpoints to be shutdown.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] wifi_macs: The wifiMacs of the endpoints to be shutdown.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if wifi_macs is not None:
            pulumi.set(__self__, "wifi_macs", wifi_macs)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The ids of the endpoints to be shutdown.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be shutdown.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The serials of the endpoints to be shutdown.
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)

    @_builtins.property
    @pulumi.getter(name="wifiMacs")
    def wifi_macs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The wifiMacs of the endpoints to be shutdown.
        """
        return pulumi.get(self, "wifi_macs")

    @wifi_macs.setter
    def wifi_macs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "wifi_macs", value)


if not MYPY:
    class SmDevicesUnenrollItemArgsDict(TypedDict):
        success: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean indicating whether the operation was completed successfully.
        """
elif False:
    SmDevicesUnenrollItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesUnenrollItemArgs:
    def __init__(__self__, *,
                 success: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] success: Boolean indicating whether the operation was completed successfully.
        """
        if success is not None:
            pulumi.set(__self__, "success", success)

    @_builtins.property
    @pulumi.getter
    def success(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean indicating whether the operation was completed successfully.
        """
        return pulumi.get(self, "success")

    @success.setter
    def success(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "success", value)


if not MYPY:
    class SmDevicesUninstallAppsParametersArgsDict(TypedDict):
        app_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        ids of applications to be uninstalled
        """
elif False:
    SmDevicesUninstallAppsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesUninstallAppsParametersArgs:
    def __init__(__self__, *,
                 app_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] app_ids: ids of applications to be uninstalled
        """
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)

    @_builtins.property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        ids of applications to be uninstalled
        """
        return pulumi.get(self, "app_ids")

    @app_ids.setter
    def app_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "app_ids", value)


if not MYPY:
    class SmDevicesWipeItemArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Meraki Id of the devices.
        """
elif False:
    SmDevicesWipeItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesWipeItemArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The Meraki Id of the devices.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Meraki Id of the devices.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class SmDevicesWipeParametersArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the device to be wiped.
        """
        pin: NotRequired[pulumi.Input[_builtins.int]]
        """
        The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        The serial of the device to be wiped.
        """
        wifi_mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        The wifiMac of the device to be wiped.
        """
elif False:
    SmDevicesWipeParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmDevicesWipeParametersArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 pin: Optional[pulumi.Input[_builtins.int]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None,
                 wifi_mac: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The id of the device to be wiped.
        :param pulumi.Input[_builtins.int] pin: The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
        :param pulumi.Input[_builtins.str] serial: The serial of the device to be wiped.
        :param pulumi.Input[_builtins.str] wifi_mac: The wifiMac of the device to be wiped.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pin is not None:
            pulumi.set(__self__, "pin", pin)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if wifi_mac is not None:
            pulumi.set(__self__, "wifi_mac", wifi_mac)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the device to be wiped.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def pin(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
        """
        return pulumi.get(self, "pin")

    @pin.setter
    def pin(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "pin", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The serial of the device to be wiped.
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)

    @_builtins.property
    @pulumi.getter(name="wifiMac")
    def wifi_mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The wifiMac of the device to be wiped.
        """
        return pulumi.get(self, "wifi_mac")

    @wifi_mac.setter
    def wifi_mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wifi_mac", value)


if not MYPY:
    class SnmpUserArgsDict(TypedDict):
        passphrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        The passphrase for the SNMP user.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username for the SNMP user.
        """
elif False:
    SnmpUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnmpUserArgs:
    def __init__(__self__, *,
                 passphrase: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] passphrase: The passphrase for the SNMP user.
        :param pulumi.Input[_builtins.str] username: The username for the SNMP user.
        """
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The passphrase for the SNMP user.
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "passphrase", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username for the SNMP user.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class SplitItemArgsDict(TypedDict):
        resulting_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['SplitItemResultingNetworkArgsDict']]]]
        """
        Networks after the split
        """
elif False:
    SplitItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SplitItemArgs:
    def __init__(__self__, *,
                 resulting_networks: Optional[pulumi.Input[Sequence[pulumi.Input['SplitItemResultingNetworkArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SplitItemResultingNetworkArgs']]] resulting_networks: Networks after the split
        """
        if resulting_networks is not None:
            pulumi.set(__self__, "resulting_networks", resulting_networks)

    @_builtins.property
    @pulumi.getter(name="resultingNetworks")
    def resulting_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SplitItemResultingNetworkArgs']]]]:
        """
        Networks after the split
        """
        return pulumi.get(self, "resulting_networks")

    @resulting_networks.setter
    def resulting_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SplitItemResultingNetworkArgs']]]]):
        pulumi.set(self, "resulting_networks", value)


if not MYPY:
    class SplitItemResultingNetworkArgsDict(TypedDict):
        enrollment_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enrollment string for the network
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network ID
        """
        is_bound_to_config_template: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the network is bound to a config template
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network name
        """
        notes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notes for the network
        """
        organization_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization ID
        """
        product_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of the product types that the network supports
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Network tags
        """
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timezone of the network
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL to the network Dashboard UI
        """
elif False:
    SplitItemResultingNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SplitItemResultingNetworkArgs:
    def __init__(__self__, *,
                 enrollment_string: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_bound_to_config_template: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 organization_id: Optional[pulumi.Input[_builtins.str]] = None,
                 product_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] enrollment_string: Enrollment string for the network
        :param pulumi.Input[_builtins.str] id: Network ID
        :param pulumi.Input[_builtins.bool] is_bound_to_config_template: If the network is bound to a config template
        :param pulumi.Input[_builtins.str] name: Network name
        :param pulumi.Input[_builtins.str] notes: Notes for the network
        :param pulumi.Input[_builtins.str] organization_id: Organization ID
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] product_types: List of the product types that the network supports
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: Network tags
        :param pulumi.Input[_builtins.str] time_zone: Timezone of the network
        :param pulumi.Input[_builtins.str] url: URL to the network Dashboard UI
        """
        if enrollment_string is not None:
            pulumi.set(__self__, "enrollment_string", enrollment_string)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_bound_to_config_template is not None:
            pulumi.set(__self__, "is_bound_to_config_template", is_bound_to_config_template)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)
        if product_types is not None:
            pulumi.set(__self__, "product_types", product_types)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="enrollmentString")
    def enrollment_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enrollment string for the network
        """
        return pulumi.get(self, "enrollment_string")

    @enrollment_string.setter
    def enrollment_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enrollment_string", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isBoundToConfigTemplate")
    def is_bound_to_config_template(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the network is bound to a config template
        """
        return pulumi.get(self, "is_bound_to_config_template")

    @is_bound_to_config_template.setter
    def is_bound_to_config_template(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_bound_to_config_template", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notes for the network
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization ID
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_id", value)

    @_builtins.property
    @pulumi.getter(name="productTypes")
    def product_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of the product types that the network supports
        """
        return pulumi.get(self, "product_types")

    @product_types.setter
    def product_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "product_types", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Network tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timezone of the network
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL to the network Dashboard UI
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class SwitchAccessControlListsRuleArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the rule (optional)
        """
        dst_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination IP address (in IP or CIDR notation)
        """
        dst_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination port
        """
        ip_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address version
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'allow' or 'deny' traffic specified by this rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of protocol
        """
        src_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source IP address (in IP or CIDR notation)
        """
        src_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source port
        """
        vlan: NotRequired[pulumi.Input[_builtins.str]]
        """
        ncoming traffic VLAN
        """
elif False:
    SwitchAccessControlListsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAccessControlListsRuleArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 dst_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 dst_port: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 src_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 src_port: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Description of the rule (optional)
        :param pulumi.Input[_builtins.str] dst_cidr: Destination IP address (in IP or CIDR notation)
        :param pulumi.Input[_builtins.str] dst_port: Destination port
        :param pulumi.Input[_builtins.str] ip_version: IP address version
        :param pulumi.Input[_builtins.str] policy: 'allow' or 'deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] protocol: The type of protocol
        :param pulumi.Input[_builtins.str] src_cidr: Source IP address (in IP or CIDR notation)
        :param pulumi.Input[_builtins.str] src_port: Source port
        :param pulumi.Input[_builtins.str] vlan: ncoming traffic VLAN
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dst_cidr is not None:
            pulumi.set(__self__, "dst_cidr", dst_cidr)
        if dst_port is not None:
            pulumi.set(__self__, "dst_port", dst_port)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="dstCidr")
    def dst_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination IP address (in IP or CIDR notation)
        """
        return pulumi.get(self, "dst_cidr")

    @dst_cidr.setter
    def dst_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dst_cidr", value)

    @_builtins.property
    @pulumi.getter(name="dstPort")
    def dst_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination port
        """
        return pulumi.get(self, "dst_port")

    @dst_port.setter
    def dst_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dst_port", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address version
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of protocol
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source IP address (in IP or CIDR notation)
        """
        return pulumi.get(self, "src_cidr")

    @src_cidr.setter
    def src_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_cidr", value)

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source port
        """
        return pulumi.get(self, "src_port")

    @src_port.setter
    def src_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_port", value)

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ncoming traffic VLAN
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vlan", value)


if not MYPY:
    class SwitchAccessControlListsRulesResponseArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the rule (optional)
        """
        dst_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination IP address (in IP or CIDR notation)
        """
        dst_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination port
        """
        ip_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address version
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'allow' or 'deny' traffic specified by this rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of protocol
        """
        src_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source IP address (in IP or CIDR notation)
        """
        src_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source port
        """
        vlan: NotRequired[pulumi.Input[_builtins.str]]
        """
        ncoming traffic VLAN
        """
elif False:
    SwitchAccessControlListsRulesResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAccessControlListsRulesResponseArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 dst_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 dst_port: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 src_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 src_port: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Description of the rule (optional)
        :param pulumi.Input[_builtins.str] dst_cidr: Destination IP address (in IP or CIDR notation)
        :param pulumi.Input[_builtins.str] dst_port: Destination port
        :param pulumi.Input[_builtins.str] ip_version: IP address version
        :param pulumi.Input[_builtins.str] policy: 'allow' or 'deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] protocol: The type of protocol
        :param pulumi.Input[_builtins.str] src_cidr: Source IP address (in IP or CIDR notation)
        :param pulumi.Input[_builtins.str] src_port: Source port
        :param pulumi.Input[_builtins.str] vlan: ncoming traffic VLAN
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dst_cidr is not None:
            pulumi.set(__self__, "dst_cidr", dst_cidr)
        if dst_port is not None:
            pulumi.set(__self__, "dst_port", dst_port)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_cidr is not None:
            pulumi.set(__self__, "src_cidr", src_cidr)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="dstCidr")
    def dst_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination IP address (in IP or CIDR notation)
        """
        return pulumi.get(self, "dst_cidr")

    @dst_cidr.setter
    def dst_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dst_cidr", value)

    @_builtins.property
    @pulumi.getter(name="dstPort")
    def dst_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination port
        """
        return pulumi.get(self, "dst_port")

    @dst_port.setter
    def dst_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dst_port", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address version
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of protocol
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="srcCidr")
    def src_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source IP address (in IP or CIDR notation)
        """
        return pulumi.get(self, "src_cidr")

    @src_cidr.setter
    def src_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_cidr", value)

    @_builtins.property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source port
        """
        return pulumi.get(self, "src_port")

    @src_port.setter
    def src_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_port", value)

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ncoming traffic VLAN
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vlan", value)


if not MYPY:
    class SwitchAccessPoliciesCountsArgsDict(TypedDict):
        ports: NotRequired[pulumi.Input['SwitchAccessPoliciesCountsPortsArgsDict']]
        """
        Counts associated with ports
        """
elif False:
    SwitchAccessPoliciesCountsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAccessPoliciesCountsArgs:
    def __init__(__self__, *,
                 ports: Optional[pulumi.Input['SwitchAccessPoliciesCountsPortsArgs']] = None):
        """
        :param pulumi.Input['SwitchAccessPoliciesCountsPortsArgs'] ports: Counts associated with ports
        """
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input['SwitchAccessPoliciesCountsPortsArgs']]:
        """
        Counts associated with ports
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input['SwitchAccessPoliciesCountsPortsArgs']]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class SwitchAccessPoliciesCountsPortsArgsDict(TypedDict):
        with_this_policy: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of ports in the network with this policy. For template networks, this is the number of template ports (not child ports) with this policy.
        """
elif False:
    SwitchAccessPoliciesCountsPortsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAccessPoliciesCountsPortsArgs:
    def __init__(__self__, *,
                 with_this_policy: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] with_this_policy: Number of ports in the network with this policy. For template networks, this is the number of template ports (not child ports) with this policy.
        """
        if with_this_policy is not None:
            pulumi.set(__self__, "with_this_policy", with_this_policy)

    @_builtins.property
    @pulumi.getter(name="withThisPolicy")
    def with_this_policy(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of ports in the network with this policy. For template networks, this is the number of template ports (not child ports) with this policy.
        """
        return pulumi.get(self, "with_this_policy")

    @with_this_policy.setter
    def with_this_policy(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "with_this_policy", value)


if not MYPY:
    class SwitchAccessPoliciesDot1xArgsDict(TypedDict):
        control_direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
        """
elif False:
    SwitchAccessPoliciesDot1xArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAccessPoliciesDot1xArgs:
    def __init__(__self__, *,
                 control_direction: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] control_direction: Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
        """
        if control_direction is not None:
            pulumi.set(__self__, "control_direction", control_direction)

    @_builtins.property
    @pulumi.getter(name="controlDirection")
    def control_direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
        """
        return pulumi.get(self, "control_direction")

    @control_direction.setter
    def control_direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "control_direction", value)


if not MYPY:
    class SwitchAccessPoliciesRadiusArgsDict(TypedDict):
        critical_auth: NotRequired[pulumi.Input['SwitchAccessPoliciesRadiusCriticalAuthArgsDict']]
        """
        Critical auth settings for when authentication is rejected by the RADIUS server
        """
        failed_auth_vlan_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        re_authentication_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
        """
elif False:
    SwitchAccessPoliciesRadiusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAccessPoliciesRadiusArgs:
    def __init__(__self__, *,
                 critical_auth: Optional[pulumi.Input['SwitchAccessPoliciesRadiusCriticalAuthArgs']] = None,
                 failed_auth_vlan_id: Optional[pulumi.Input[_builtins.int]] = None,
                 re_authentication_interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['SwitchAccessPoliciesRadiusCriticalAuthArgs'] critical_auth: Critical auth settings for when authentication is rejected by the RADIUS server
        :param pulumi.Input[_builtins.int] failed_auth_vlan_id: VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        :param pulumi.Input[_builtins.int] re_authentication_interval: Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
        """
        if critical_auth is not None:
            pulumi.set(__self__, "critical_auth", critical_auth)
        if failed_auth_vlan_id is not None:
            pulumi.set(__self__, "failed_auth_vlan_id", failed_auth_vlan_id)
        if re_authentication_interval is not None:
            pulumi.set(__self__, "re_authentication_interval", re_authentication_interval)

    @_builtins.property
    @pulumi.getter(name="criticalAuth")
    def critical_auth(self) -> Optional[pulumi.Input['SwitchAccessPoliciesRadiusCriticalAuthArgs']]:
        """
        Critical auth settings for when authentication is rejected by the RADIUS server
        """
        return pulumi.get(self, "critical_auth")

    @critical_auth.setter
    def critical_auth(self, value: Optional[pulumi.Input['SwitchAccessPoliciesRadiusCriticalAuthArgs']]):
        pulumi.set(self, "critical_auth", value)

    @_builtins.property
    @pulumi.getter(name="failedAuthVlanId")
    def failed_auth_vlan_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        return pulumi.get(self, "failed_auth_vlan_id")

    @failed_auth_vlan_id.setter
    def failed_auth_vlan_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failed_auth_vlan_id", value)

    @_builtins.property
    @pulumi.getter(name="reAuthenticationInterval")
    def re_authentication_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
        """
        return pulumi.get(self, "re_authentication_interval")

    @re_authentication_interval.setter
    def re_authentication_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "re_authentication_interval", value)


if not MYPY:
    class SwitchAccessPoliciesRadiusAccountingServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public IP address of the RADIUS accounting server
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        UDP port that the RADIUS Accounting server listens on for access requests
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        RADIUS client shared secret
        """
elif False:
    SwitchAccessPoliciesRadiusAccountingServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAccessPoliciesRadiusAccountingServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: Public IP address of the RADIUS accounting server
        :param pulumi.Input[_builtins.int] port: UDP port that the RADIUS Accounting server listens on for access requests
        :param pulumi.Input[_builtins.str] secret: RADIUS client shared secret
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public IP address of the RADIUS accounting server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        UDP port that the RADIUS Accounting server listens on for access requests
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RADIUS client shared secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class SwitchAccessPoliciesRadiusAccountingServersResponseArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public IP address of the RADIUS accounting server
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        UDP port that the RADIUS Accounting server listens on for access requests
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        RADIUS client shared secret
        """
elif False:
    SwitchAccessPoliciesRadiusAccountingServersResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAccessPoliciesRadiusAccountingServersResponseArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: Public IP address of the RADIUS accounting server
        :param pulumi.Input[_builtins.int] port: UDP port that the RADIUS Accounting server listens on for access requests
        :param pulumi.Input[_builtins.str] secret: RADIUS client shared secret
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public IP address of the RADIUS accounting server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        UDP port that the RADIUS Accounting server listens on for access requests
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RADIUS client shared secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class SwitchAccessPoliciesRadiusCriticalAuthArgsDict(TypedDict):
        data_vlan_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        suspend_port_bounce: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable to suspend port bounce when RADIUS servers are unreachable
        """
        voice_vlan_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
elif False:
    SwitchAccessPoliciesRadiusCriticalAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAccessPoliciesRadiusCriticalAuthArgs:
    def __init__(__self__, *,
                 data_vlan_id: Optional[pulumi.Input[_builtins.int]] = None,
                 suspend_port_bounce: Optional[pulumi.Input[_builtins.bool]] = None,
                 voice_vlan_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] data_vlan_id: VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        :param pulumi.Input[_builtins.bool] suspend_port_bounce: Enable to suspend port bounce when RADIUS servers are unreachable
        :param pulumi.Input[_builtins.int] voice_vlan_id: VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        if data_vlan_id is not None:
            pulumi.set(__self__, "data_vlan_id", data_vlan_id)
        if suspend_port_bounce is not None:
            pulumi.set(__self__, "suspend_port_bounce", suspend_port_bounce)
        if voice_vlan_id is not None:
            pulumi.set(__self__, "voice_vlan_id", voice_vlan_id)

    @_builtins.property
    @pulumi.getter(name="dataVlanId")
    def data_vlan_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        return pulumi.get(self, "data_vlan_id")

    @data_vlan_id.setter
    def data_vlan_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_vlan_id", value)

    @_builtins.property
    @pulumi.getter(name="suspendPortBounce")
    def suspend_port_bounce(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable to suspend port bounce when RADIUS servers are unreachable
        """
        return pulumi.get(self, "suspend_port_bounce")

    @suspend_port_bounce.setter
    def suspend_port_bounce(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "suspend_port_bounce", value)

    @_builtins.property
    @pulumi.getter(name="voiceVlanId")
    def voice_vlan_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
        """
        return pulumi.get(self, "voice_vlan_id")

    @voice_vlan_id.setter
    def voice_vlan_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "voice_vlan_id", value)


if not MYPY:
    class SwitchAccessPoliciesRadiusServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public IP address of the RADIUS server
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        UDP port that the RADIUS server listens on for access requests
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        RADIUS client shared secret
        """
elif False:
    SwitchAccessPoliciesRadiusServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAccessPoliciesRadiusServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: Public IP address of the RADIUS server
        :param pulumi.Input[_builtins.int] port: UDP port that the RADIUS server listens on for access requests
        :param pulumi.Input[_builtins.str] secret: RADIUS client shared secret
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public IP address of the RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        UDP port that the RADIUS server listens on for access requests
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RADIUS client shared secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class SwitchAccessPoliciesRadiusServersResponseArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public IP address of the RADIUS server
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        UDP port that the RADIUS server listens on for access requests
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        RADIUS client shared secret
        """
elif False:
    SwitchAccessPoliciesRadiusServersResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAccessPoliciesRadiusServersResponseArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: Public IP address of the RADIUS server
        :param pulumi.Input[_builtins.int] port: UDP port that the RADIUS server listens on for access requests
        :param pulumi.Input[_builtins.str] secret: RADIUS client shared secret
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public IP address of the RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        UDP port that the RADIUS server listens on for access requests
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RADIUS client shared secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class SwitchAlternateManagementInterfaceSwitchArgsDict(TypedDict):
        alternate_management_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Switch alternative management IP. To remove a prior IP setting, provide an empty string
        """
        gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        Switch gateway must be in IP format. Only and must be specified for Polaris switches
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Switch serial number
        """
        subnet_mask: NotRequired[pulumi.Input[_builtins.str]]
        """
        Switch subnet mask must be in IP format. Only and must be specified for Polaris switches
        """
elif False:
    SwitchAlternateManagementInterfaceSwitchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAlternateManagementInterfaceSwitchArgs:
    def __init__(__self__, *,
                 alternate_management_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_mask: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] alternate_management_ip: Switch alternative management IP. To remove a prior IP setting, provide an empty string
        :param pulumi.Input[_builtins.str] gateway: Switch gateway must be in IP format. Only and must be specified for Polaris switches
        :param pulumi.Input[_builtins.str] serial: Switch serial number
        :param pulumi.Input[_builtins.str] subnet_mask: Switch subnet mask must be in IP format. Only and must be specified for Polaris switches
        """
        if alternate_management_ip is not None:
            pulumi.set(__self__, "alternate_management_ip", alternate_management_ip)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)

    @_builtins.property
    @pulumi.getter(name="alternateManagementIp")
    def alternate_management_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Switch alternative management IP. To remove a prior IP setting, provide an empty string
        """
        return pulumi.get(self, "alternate_management_ip")

    @alternate_management_ip.setter
    def alternate_management_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alternate_management_ip", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Switch gateway must be in IP format. Only and must be specified for Polaris switches
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Switch serial number
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)

    @_builtins.property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Switch subnet mask must be in IP format. Only and must be specified for Polaris switches
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_mask", value)


if not MYPY:
    class SwitchDhcpServerPolicyAlertsArgsDict(TypedDict):
        email: NotRequired[pulumi.Input['SwitchDhcpServerPolicyAlertsEmailArgsDict']]
        """
        Alert settings for DHCP servers
        """
elif False:
    SwitchDhcpServerPolicyAlertsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchDhcpServerPolicyAlertsArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input['SwitchDhcpServerPolicyAlertsEmailArgs']] = None):
        """
        :param pulumi.Input['SwitchDhcpServerPolicyAlertsEmailArgs'] email: Alert settings for DHCP servers
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['SwitchDhcpServerPolicyAlertsEmailArgs']]:
        """
        Alert settings for DHCP servers
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['SwitchDhcpServerPolicyAlertsEmailArgs']]):
        pulumi.set(self, "email", value)


if not MYPY:
    class SwitchDhcpServerPolicyAlertsEmailArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When enabled, send an email if a new DHCP server is seen. Default value is false.
        """
elif False:
    SwitchDhcpServerPolicyAlertsEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchDhcpServerPolicyAlertsEmailArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: When enabled, send an email if a new DHCP server is seen. Default value is false.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When enabled, send an email if a new DHCP server is seen. Default value is false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SwitchDhcpServerPolicyArpInspectionArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable or disable Dynamic ARP Inspection on the network. Default value is false.
        """
        unsupported_models: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of switch models that does not support dynamic ARP inspection
        """
elif False:
    SwitchDhcpServerPolicyArpInspectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchDhcpServerPolicyArpInspectionArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 unsupported_models: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable or disable Dynamic ARP Inspection on the network. Default value is false.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] unsupported_models: List of switch models that does not support dynamic ARP inspection
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if unsupported_models is not None:
            pulumi.set(__self__, "unsupported_models", unsupported_models)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable or disable Dynamic ARP Inspection on the network. Default value is false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="unsupportedModels")
    def unsupported_models(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of switch models that does not support dynamic ARP inspection
        """
        return pulumi.get(self, "unsupported_models")

    @unsupported_models.setter
    def unsupported_models(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "unsupported_models", value)


if not MYPY:
    class SwitchDhcpServerPolicyArpInspectionTrustedServersIpv4ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv4 address of the trusted server.
        """
elif False:
    SwitchDhcpServerPolicyArpInspectionTrustedServersIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchDhcpServerPolicyArpInspectionTrustedServersIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: IPv4 address of the trusted server.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv4 address of the trusted server.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)


if not MYPY:
    class SwitchDscpToCosMappingsMappingArgsDict(TypedDict):
        cos: NotRequired[pulumi.Input[_builtins.int]]
        """
        The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
        """
        dscp: NotRequired[pulumi.Input[_builtins.int]]
        """
        The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Label for the mapping (optional).
        """
elif False:
    SwitchDscpToCosMappingsMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchDscpToCosMappingsMappingArgs:
    def __init__(__self__, *,
                 cos: Optional[pulumi.Input[_builtins.int]] = None,
                 dscp: Optional[pulumi.Input[_builtins.int]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] cos: The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
        :param pulumi.Input[_builtins.int] dscp: The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
        :param pulumi.Input[_builtins.str] title: Label for the mapping (optional).
        """
        if cos is not None:
            pulumi.set(__self__, "cos", cos)
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def cos(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
        """
        return pulumi.get(self, "cos")

    @cos.setter
    def cos(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cos", value)

    @_builtins.property
    @pulumi.getter
    def dscp(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
        """
        return pulumi.get(self, "dscp")

    @dscp.setter
    def dscp(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dscp", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Label for the mapping (optional).
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class SwitchLinkAggregationsSwitchPortArgsDict(TypedDict):
        port_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Serial number of the switch.
        """
elif False:
    SwitchLinkAggregationsSwitchPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchLinkAggregationsSwitchPortArgs:
    def __init__(__self__, *,
                 port_id: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] port_id: Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
        :param pulumi.Input[_builtins.str] serial: Serial number of the switch.
        """
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
        """
        return pulumi.get(self, "port_id")

    @port_id.setter
    def port_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_id", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Serial number of the switch.
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)


if not MYPY:
    class SwitchLinkAggregationsSwitchProfilePortArgsDict(TypedDict):
        port_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
        """
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile identifier.
        """
elif False:
    SwitchLinkAggregationsSwitchProfilePortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchLinkAggregationsSwitchProfilePortArgs:
    def __init__(__self__, *,
                 port_id: Optional[pulumi.Input[_builtins.str]] = None,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] port_id: Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
        :param pulumi.Input[_builtins.str] profile: Profile identifier.
        """
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
        """
        return pulumi.get(self, "port_id")

    @port_id.setter
    def port_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_id", value)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile identifier.
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class SwitchMtuOverrideArgsDict(TypedDict):
        mtu_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        MTU size for the switches or switch templates.
        """
        switch_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of switch template IDs. Applicable only for template network.
        """
        switches: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of switch serials. Applicable only for switch network.
        """
elif False:
    SwitchMtuOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchMtuOverrideArgs:
    def __init__(__self__, *,
                 mtu_size: Optional[pulumi.Input[_builtins.int]] = None,
                 switch_profiles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 switches: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] mtu_size: MTU size for the switches or switch templates.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] switch_profiles: List of switch template IDs. Applicable only for template network.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] switches: List of switch serials. Applicable only for switch network.
        """
        if mtu_size is not None:
            pulumi.set(__self__, "mtu_size", mtu_size)
        if switch_profiles is not None:
            pulumi.set(__self__, "switch_profiles", switch_profiles)
        if switches is not None:
            pulumi.set(__self__, "switches", switches)

    @_builtins.property
    @pulumi.getter(name="mtuSize")
    def mtu_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        MTU size for the switches or switch templates.
        """
        return pulumi.get(self, "mtu_size")

    @mtu_size.setter
    def mtu_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mtu_size", value)

    @_builtins.property
    @pulumi.getter(name="switchProfiles")
    def switch_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of switch template IDs. Applicable only for template network.
        """
        return pulumi.get(self, "switch_profiles")

    @switch_profiles.setter
    def switch_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "switch_profiles", value)

    @_builtins.property
    @pulumi.getter
    def switches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of switch serials. Applicable only for switch network.
        """
        return pulumi.get(self, "switches")

    @switches.setter
    def switches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "switches", value)


if not MYPY:
    class SwitchPortSchedulesPortScheduleArgsDict(TypedDict):
        friday: NotRequired[pulumi.Input['SwitchPortSchedulesPortScheduleFridayArgsDict']]
        """
        The schedule object for Friday.
        """
        monday: NotRequired[pulumi.Input['SwitchPortSchedulesPortScheduleMondayArgsDict']]
        """
        The schedule object for Monday.
        """
        saturday: NotRequired[pulumi.Input['SwitchPortSchedulesPortScheduleSaturdayArgsDict']]
        """
        The schedule object for Saturday.
        """
        sunday: NotRequired[pulumi.Input['SwitchPortSchedulesPortScheduleSundayArgsDict']]
        """
        The schedule object for Sunday.
        """
        thursday: NotRequired[pulumi.Input['SwitchPortSchedulesPortScheduleThursdayArgsDict']]
        """
        The schedule object for Thursday.
        """
        tuesday: NotRequired[pulumi.Input['SwitchPortSchedulesPortScheduleTuesdayArgsDict']]
        """
        The schedule object for Tuesday.
        """
        wednesday: NotRequired[pulumi.Input['SwitchPortSchedulesPortScheduleWednesdayArgsDict']]
        """
        The schedule object for Wednesday.
        """
elif False:
    SwitchPortSchedulesPortScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortSchedulesPortScheduleArgs:
    def __init__(__self__, *,
                 friday: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleFridayArgs']] = None,
                 monday: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleMondayArgs']] = None,
                 saturday: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleSaturdayArgs']] = None,
                 sunday: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleSundayArgs']] = None,
                 thursday: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleThursdayArgs']] = None,
                 tuesday: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleTuesdayArgs']] = None,
                 wednesday: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleWednesdayArgs']] = None):
        """
        :param pulumi.Input['SwitchPortSchedulesPortScheduleFridayArgs'] friday: The schedule object for Friday.
        :param pulumi.Input['SwitchPortSchedulesPortScheduleMondayArgs'] monday: The schedule object for Monday.
        :param pulumi.Input['SwitchPortSchedulesPortScheduleSaturdayArgs'] saturday: The schedule object for Saturday.
        :param pulumi.Input['SwitchPortSchedulesPortScheduleSundayArgs'] sunday: The schedule object for Sunday.
        :param pulumi.Input['SwitchPortSchedulesPortScheduleThursdayArgs'] thursday: The schedule object for Thursday.
        :param pulumi.Input['SwitchPortSchedulesPortScheduleTuesdayArgs'] tuesday: The schedule object for Tuesday.
        :param pulumi.Input['SwitchPortSchedulesPortScheduleWednesdayArgs'] wednesday: The schedule object for Wednesday.
        """
        if friday is not None:
            pulumi.set(__self__, "friday", friday)
        if monday is not None:
            pulumi.set(__self__, "monday", monday)
        if saturday is not None:
            pulumi.set(__self__, "saturday", saturday)
        if sunday is not None:
            pulumi.set(__self__, "sunday", sunday)
        if thursday is not None:
            pulumi.set(__self__, "thursday", thursday)
        if tuesday is not None:
            pulumi.set(__self__, "tuesday", tuesday)
        if wednesday is not None:
            pulumi.set(__self__, "wednesday", wednesday)

    @_builtins.property
    @pulumi.getter
    def friday(self) -> Optional[pulumi.Input['SwitchPortSchedulesPortScheduleFridayArgs']]:
        """
        The schedule object for Friday.
        """
        return pulumi.get(self, "friday")

    @friday.setter
    def friday(self, value: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleFridayArgs']]):
        pulumi.set(self, "friday", value)

    @_builtins.property
    @pulumi.getter
    def monday(self) -> Optional[pulumi.Input['SwitchPortSchedulesPortScheduleMondayArgs']]:
        """
        The schedule object for Monday.
        """
        return pulumi.get(self, "monday")

    @monday.setter
    def monday(self, value: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleMondayArgs']]):
        pulumi.set(self, "monday", value)

    @_builtins.property
    @pulumi.getter
    def saturday(self) -> Optional[pulumi.Input['SwitchPortSchedulesPortScheduleSaturdayArgs']]:
        """
        The schedule object for Saturday.
        """
        return pulumi.get(self, "saturday")

    @saturday.setter
    def saturday(self, value: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleSaturdayArgs']]):
        pulumi.set(self, "saturday", value)

    @_builtins.property
    @pulumi.getter
    def sunday(self) -> Optional[pulumi.Input['SwitchPortSchedulesPortScheduleSundayArgs']]:
        """
        The schedule object for Sunday.
        """
        return pulumi.get(self, "sunday")

    @sunday.setter
    def sunday(self, value: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleSundayArgs']]):
        pulumi.set(self, "sunday", value)

    @_builtins.property
    @pulumi.getter
    def thursday(self) -> Optional[pulumi.Input['SwitchPortSchedulesPortScheduleThursdayArgs']]:
        """
        The schedule object for Thursday.
        """
        return pulumi.get(self, "thursday")

    @thursday.setter
    def thursday(self, value: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleThursdayArgs']]):
        pulumi.set(self, "thursday", value)

    @_builtins.property
    @pulumi.getter
    def tuesday(self) -> Optional[pulumi.Input['SwitchPortSchedulesPortScheduleTuesdayArgs']]:
        """
        The schedule object for Tuesday.
        """
        return pulumi.get(self, "tuesday")

    @tuesday.setter
    def tuesday(self, value: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleTuesdayArgs']]):
        pulumi.set(self, "tuesday", value)

    @_builtins.property
    @pulumi.getter
    def wednesday(self) -> Optional[pulumi.Input['SwitchPortSchedulesPortScheduleWednesdayArgs']]:
        """
        The schedule object for Wednesday.
        """
        return pulumi.get(self, "wednesday")

    @wednesday.setter
    def wednesday(self, value: Optional[pulumi.Input['SwitchPortSchedulesPortScheduleWednesdayArgs']]):
        pulumi.set(self, "wednesday", value)


if not MYPY:
    class SwitchPortSchedulesPortScheduleFridayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    SwitchPortSchedulesPortScheduleFridayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortSchedulesPortScheduleFridayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class SwitchPortSchedulesPortScheduleMondayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    SwitchPortSchedulesPortScheduleMondayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortSchedulesPortScheduleMondayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class SwitchPortSchedulesPortScheduleSaturdayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    SwitchPortSchedulesPortScheduleSaturdayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortSchedulesPortScheduleSaturdayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class SwitchPortSchedulesPortScheduleSundayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    SwitchPortSchedulesPortScheduleSundayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortSchedulesPortScheduleSundayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class SwitchPortSchedulesPortScheduleThursdayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    SwitchPortSchedulesPortScheduleThursdayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortSchedulesPortScheduleThursdayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class SwitchPortSchedulesPortScheduleTuesdayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    SwitchPortSchedulesPortScheduleTuesdayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortSchedulesPortScheduleTuesdayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class SwitchPortSchedulesPortScheduleWednesdayArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
elif False:
    SwitchPortSchedulesPortScheduleWednesdayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortSchedulesPortScheduleWednesdayArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        :param pulumi.Input[_builtins.str] from_: The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        :param pulumi.Input[_builtins.str] to: The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class SwitchRoutingMulticastDefaultSettingsArgsDict(TypedDict):
        flood_unknown_multicast_traffic_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flood unknown multicast traffic enabled for the entire network
        """
        igmp_snooping_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        IGMP snooping enabled for the entire network
        """
elif False:
    SwitchRoutingMulticastDefaultSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRoutingMulticastDefaultSettingsArgs:
    def __init__(__self__, *,
                 flood_unknown_multicast_traffic_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 igmp_snooping_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] flood_unknown_multicast_traffic_enabled: Flood unknown multicast traffic enabled for the entire network
        :param pulumi.Input[_builtins.bool] igmp_snooping_enabled: IGMP snooping enabled for the entire network
        """
        if flood_unknown_multicast_traffic_enabled is not None:
            pulumi.set(__self__, "flood_unknown_multicast_traffic_enabled", flood_unknown_multicast_traffic_enabled)
        if igmp_snooping_enabled is not None:
            pulumi.set(__self__, "igmp_snooping_enabled", igmp_snooping_enabled)

    @_builtins.property
    @pulumi.getter(name="floodUnknownMulticastTrafficEnabled")
    def flood_unknown_multicast_traffic_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flood unknown multicast traffic enabled for the entire network
        """
        return pulumi.get(self, "flood_unknown_multicast_traffic_enabled")

    @flood_unknown_multicast_traffic_enabled.setter
    def flood_unknown_multicast_traffic_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "flood_unknown_multicast_traffic_enabled", value)

    @_builtins.property
    @pulumi.getter(name="igmpSnoopingEnabled")
    def igmp_snooping_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        IGMP snooping enabled for the entire network
        """
        return pulumi.get(self, "igmp_snooping_enabled")

    @igmp_snooping_enabled.setter
    def igmp_snooping_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "igmp_snooping_enabled", value)


if not MYPY:
    class SwitchRoutingMulticastOverrideArgsDict(TypedDict):
        flood_unknown_multicast_traffic_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flood unknown multicast traffic enabled for switches, switch stacks or switch templates
        """
        igmp_snooping_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        IGMP snooping enabled for switches, switch stacks or switch templates
        """
        stacks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (optional) List of switch stack ids for non-template network
        """
        switch_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (optional) List of switch templates ids for template network
        """
        switches: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (optional) List of switch serials for non-template network
        """
elif False:
    SwitchRoutingMulticastOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRoutingMulticastOverrideArgs:
    def __init__(__self__, *,
                 flood_unknown_multicast_traffic_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 igmp_snooping_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stacks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 switch_profiles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 switches: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] flood_unknown_multicast_traffic_enabled: Flood unknown multicast traffic enabled for switches, switch stacks or switch templates
        :param pulumi.Input[_builtins.bool] igmp_snooping_enabled: IGMP snooping enabled for switches, switch stacks or switch templates
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stacks: (optional) List of switch stack ids for non-template network
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] switch_profiles: (optional) List of switch templates ids for template network
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] switches: (optional) List of switch serials for non-template network
        """
        if flood_unknown_multicast_traffic_enabled is not None:
            pulumi.set(__self__, "flood_unknown_multicast_traffic_enabled", flood_unknown_multicast_traffic_enabled)
        if igmp_snooping_enabled is not None:
            pulumi.set(__self__, "igmp_snooping_enabled", igmp_snooping_enabled)
        if stacks is not None:
            pulumi.set(__self__, "stacks", stacks)
        if switch_profiles is not None:
            pulumi.set(__self__, "switch_profiles", switch_profiles)
        if switches is not None:
            pulumi.set(__self__, "switches", switches)

    @_builtins.property
    @pulumi.getter(name="floodUnknownMulticastTrafficEnabled")
    def flood_unknown_multicast_traffic_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flood unknown multicast traffic enabled for switches, switch stacks or switch templates
        """
        return pulumi.get(self, "flood_unknown_multicast_traffic_enabled")

    @flood_unknown_multicast_traffic_enabled.setter
    def flood_unknown_multicast_traffic_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "flood_unknown_multicast_traffic_enabled", value)

    @_builtins.property
    @pulumi.getter(name="igmpSnoopingEnabled")
    def igmp_snooping_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        IGMP snooping enabled for switches, switch stacks or switch templates
        """
        return pulumi.get(self, "igmp_snooping_enabled")

    @igmp_snooping_enabled.setter
    def igmp_snooping_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "igmp_snooping_enabled", value)

    @_builtins.property
    @pulumi.getter
    def stacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (optional) List of switch stack ids for non-template network
        """
        return pulumi.get(self, "stacks")

    @stacks.setter
    def stacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stacks", value)

    @_builtins.property
    @pulumi.getter(name="switchProfiles")
    def switch_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (optional) List of switch templates ids for template network
        """
        return pulumi.get(self, "switch_profiles")

    @switch_profiles.setter
    def switch_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "switch_profiles", value)

    @_builtins.property
    @pulumi.getter
    def switches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (optional) List of switch serials for non-template network
        """
        return pulumi.get(self, "switches")

    @switches.setter
    def switches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "switches", value)


if not MYPY:
    class SwitchRoutingOspfAreaArgsDict(TypedDict):
        area_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF area ID
        """
        area_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the OSPF area
        """
        area_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
        """
elif False:
    SwitchRoutingOspfAreaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRoutingOspfAreaArgs:
    def __init__(__self__, *,
                 area_id: Optional[pulumi.Input[_builtins.int]] = None,
                 area_name: Optional[pulumi.Input[_builtins.str]] = None,
                 area_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] area_id: OSPF area ID
        :param pulumi.Input[_builtins.str] area_name: Name of the OSPF area
        :param pulumi.Input[_builtins.str] area_type: Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
        """
        if area_id is not None:
            pulumi.set(__self__, "area_id", area_id)
        if area_name is not None:
            pulumi.set(__self__, "area_name", area_name)
        if area_type is not None:
            pulumi.set(__self__, "area_type", area_type)

    @_builtins.property
    @pulumi.getter(name="areaId")
    def area_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF area ID
        """
        return pulumi.get(self, "area_id")

    @area_id.setter
    def area_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "area_id", value)

    @_builtins.property
    @pulumi.getter(name="areaName")
    def area_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the OSPF area
        """
        return pulumi.get(self, "area_name")

    @area_name.setter
    def area_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "area_name", value)

    @_builtins.property
    @pulumi.getter(name="areaType")
    def area_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
        """
        return pulumi.get(self, "area_type")

    @area_type.setter
    def area_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "area_type", value)


if not MYPY:
    class SwitchRoutingOspfMd5AuthenticationKeyArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        MD5 authentication key index. Key index must be between 1 to 255
        """
        passphrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        MD5 authentication passphrase
        """
elif False:
    SwitchRoutingOspfMd5AuthenticationKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRoutingOspfMd5AuthenticationKeyArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 passphrase: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: MD5 authentication key index. Key index must be between 1 to 255
        :param pulumi.Input[_builtins.str] passphrase: MD5 authentication passphrase
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        MD5 authentication key index. Key index must be between 1 to 255
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        MD5 authentication passphrase
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "passphrase", value)


if not MYPY:
    class SwitchRoutingOspfV3ArgsDict(TypedDict):
        areas: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchRoutingOspfV3AreaArgsDict']]]]
        """
        OSPF v3 areas
        """
        dead_timer_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean value to enable or disable V3 OSPF routing. OSPF V3 routing is disabled by default.
        """
        hello_timer_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds.
        """
elif False:
    SwitchRoutingOspfV3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRoutingOspfV3Args:
    def __init__(__self__, *,
                 areas: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRoutingOspfV3AreaArgs']]]] = None,
                 dead_timer_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 hello_timer_in_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SwitchRoutingOspfV3AreaArgs']]] areas: OSPF v3 areas
        :param pulumi.Input[_builtins.int] dead_timer_in_seconds: Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535
        :param pulumi.Input[_builtins.bool] enabled: Boolean value to enable or disable V3 OSPF routing. OSPF V3 routing is disabled by default.
        :param pulumi.Input[_builtins.int] hello_timer_in_seconds: Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds.
        """
        if areas is not None:
            pulumi.set(__self__, "areas", areas)
        if dead_timer_in_seconds is not None:
            pulumi.set(__self__, "dead_timer_in_seconds", dead_timer_in_seconds)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hello_timer_in_seconds is not None:
            pulumi.set(__self__, "hello_timer_in_seconds", hello_timer_in_seconds)

    @_builtins.property
    @pulumi.getter
    def areas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRoutingOspfV3AreaArgs']]]]:
        """
        OSPF v3 areas
        """
        return pulumi.get(self, "areas")

    @areas.setter
    def areas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRoutingOspfV3AreaArgs']]]]):
        pulumi.set(self, "areas", value)

    @_builtins.property
    @pulumi.getter(name="deadTimerInSeconds")
    def dead_timer_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535
        """
        return pulumi.get(self, "dead_timer_in_seconds")

    @dead_timer_in_seconds.setter
    def dead_timer_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dead_timer_in_seconds", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean value to enable or disable V3 OSPF routing. OSPF V3 routing is disabled by default.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="helloTimerInSeconds")
    def hello_timer_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds.
        """
        return pulumi.get(self, "hello_timer_in_seconds")

    @hello_timer_in_seconds.setter
    def hello_timer_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hello_timer_in_seconds", value)


if not MYPY:
    class SwitchRoutingOspfV3AreaArgsDict(TypedDict):
        area_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF area ID
        """
        area_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the OSPF area
        """
        area_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
        """
elif False:
    SwitchRoutingOspfV3AreaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRoutingOspfV3AreaArgs:
    def __init__(__self__, *,
                 area_id: Optional[pulumi.Input[_builtins.int]] = None,
                 area_name: Optional[pulumi.Input[_builtins.str]] = None,
                 area_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] area_id: OSPF area ID
        :param pulumi.Input[_builtins.str] area_name: Name of the OSPF area
        :param pulumi.Input[_builtins.str] area_type: Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
        """
        if area_id is not None:
            pulumi.set(__self__, "area_id", area_id)
        if area_name is not None:
            pulumi.set(__self__, "area_name", area_name)
        if area_type is not None:
            pulumi.set(__self__, "area_type", area_type)

    @_builtins.property
    @pulumi.getter(name="areaId")
    def area_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF area ID
        """
        return pulumi.get(self, "area_id")

    @area_id.setter
    def area_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "area_id", value)

    @_builtins.property
    @pulumi.getter(name="areaName")
    def area_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the OSPF area
        """
        return pulumi.get(self, "area_name")

    @area_name.setter
    def area_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "area_name", value)

    @_builtins.property
    @pulumi.getter(name="areaType")
    def area_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
        """
        return pulumi.get(self, "area_type")

    @area_type.setter
    def area_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "area_type", value)


if not MYPY:
    class SwitchSettingsMacBlocklistArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable MAC blocklist for switches in the network
        """
elif False:
    SwitchSettingsMacBlocklistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSettingsMacBlocklistArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable MAC blocklist for switches in the network
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable MAC blocklist for switches in the network
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SwitchSettingsPowerExceptionArgsDict(TypedDict):
        power_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Per switch exception (combined, redundant, useNetworkSetting)
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Serial number of the switch
        """
elif False:
    SwitchSettingsPowerExceptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSettingsPowerExceptionArgs:
    def __init__(__self__, *,
                 power_type: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] power_type: Per switch exception (combined, redundant, useNetworkSetting)
        :param pulumi.Input[_builtins.str] serial: Serial number of the switch
        """
        if power_type is not None:
            pulumi.set(__self__, "power_type", power_type)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter(name="powerType")
    def power_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Per switch exception (combined, redundant, useNetworkSetting)
        """
        return pulumi.get(self, "power_type")

    @power_type.setter
    def power_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "power_type", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Serial number of the switch
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)


if not MYPY:
    class SwitchSettingsUplinkClientSamplingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable client sampling on uplink
        """
elif False:
    SwitchSettingsUplinkClientSamplingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSettingsUplinkClientSamplingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable client sampling on uplink
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable client sampling on uplink
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SwitchStacksAddItemArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the Switch stack
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Switch stack
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Serials of the switches in the switch stack
        """
elif False:
    SwitchStacksAddItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStacksAddItemArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the Switch stack
        :param pulumi.Input[_builtins.str] name: Name of the Switch stack
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: Serials of the switches in the switch stack
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the Switch stack
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Switch stack
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Serials of the switches in the switch stack
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)


if not MYPY:
    class SwitchStacksAddParametersArgsDict(TypedDict):
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        The serial of the switch to be added
        """
elif False:
    SwitchStacksAddParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStacksAddParametersArgs:
    def __init__(__self__, *,
                 serial: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] serial: The serial of the switch to be added
        """
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The serial of the switch to be added
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)


if not MYPY:
    class SwitchStacksRemoveItemArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the Switch stack
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Switch stack
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Serials of the switches in the switch stack
        """
elif False:
    SwitchStacksRemoveItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStacksRemoveItemArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the Switch stack
        :param pulumi.Input[_builtins.str] name: Name of the Switch stack
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: Serials of the switches in the switch stack
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the Switch stack
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Switch stack
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Serials of the switches in the switch stack
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)


if not MYPY:
    class SwitchStacksRemoveParametersArgsDict(TypedDict):
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        The serial of the switch to be removed
        """
elif False:
    SwitchStacksRemoveParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStacksRemoveParametersArgs:
    def __init__(__self__, *,
                 serial: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] serial: The serial of the switch to be removed
        """
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The serial of the switch to be removed
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)


if not MYPY:
    class SwitchStacksRoutingInterfacesDhcpDhcpOptionArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The code for DHCP option which should be from 2 to 254
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the DHCP option
        """
elif False:
    SwitchStacksRoutingInterfacesDhcpDhcpOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStacksRoutingInterfacesDhcpDhcpOptionArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] code: The code for DHCP option which should be from 2 to 254
        :param pulumi.Input[_builtins.str] type: The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
        :param pulumi.Input[_builtins.str] value: The value of the DHCP option
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The code for DHCP option which should be from 2 to 254
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the DHCP option
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SwitchStacksRoutingInterfacesDhcpFixedIpAssignmentArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the client which has fixed IP address assigned to it
        """
        mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MAC address of the client which has fixed IP address
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the client which has fixed IP address
        """
elif False:
    SwitchStacksRoutingInterfacesDhcpFixedIpAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStacksRoutingInterfacesDhcpFixedIpAssignmentArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 mac: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: The IP address of the client which has fixed IP address assigned to it
        :param pulumi.Input[_builtins.str] mac: The MAC address of the client which has fixed IP address
        :param pulumi.Input[_builtins.str] name: The name of the client which has fixed IP address
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the client which has fixed IP address assigned to it
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MAC address of the client which has fixed IP address
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the client which has fixed IP address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SwitchStacksRoutingInterfacesDhcpReservedIpRangeArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        The comment for the reserved IP range
        """
        end: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ending IP address of the reserved IP range
        """
        start: NotRequired[pulumi.Input[_builtins.str]]
        """
        The starting IP address of the reserved IP range
        """
elif False:
    SwitchStacksRoutingInterfacesDhcpReservedIpRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStacksRoutingInterfacesDhcpReservedIpRangeArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 end: Optional[pulumi.Input[_builtins.str]] = None,
                 start: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: The comment for the reserved IP range
        :param pulumi.Input[_builtins.str] end: The ending IP address of the reserved IP range
        :param pulumi.Input[_builtins.str] start: The starting IP address of the reserved IP range
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The comment for the reserved IP range
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ending IP address of the reserved IP range
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The starting IP address of the reserved IP range
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class SwitchStacksRoutingInterfacesIpv6ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv6 address
        """
        assignment_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Assignment mode
        """
        gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv6 gateway
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv6 subnet
        """
elif False:
    SwitchStacksRoutingInterfacesIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStacksRoutingInterfacesIpv6Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 assignment_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: IPv6 address
        :param pulumi.Input[_builtins.str] assignment_mode: Assignment mode
        :param pulumi.Input[_builtins.str] gateway: IPv6 gateway
        :param pulumi.Input[_builtins.str] prefix: IPv6 subnet
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if assignment_mode is not None:
            pulumi.set(__self__, "assignment_mode", assignment_mode)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv6 address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="assignmentMode")
    def assignment_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Assignment mode
        """
        return pulumi.get(self, "assignment_mode")

    @assignment_mode.setter
    def assignment_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "assignment_mode", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv6 gateway
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv6 subnet
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class SwitchStacksRoutingInterfacesOspfSettingsArgsDict(TypedDict):
        area: NotRequired[pulumi.Input[_builtins.str]]
        """
        Area id
        """
        cost: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF Cost
        """
        is_passive_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable sending Hello packets on this interface's IPv4 area
        """
elif False:
    SwitchStacksRoutingInterfacesOspfSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStacksRoutingInterfacesOspfSettingsArgs:
    def __init__(__self__, *,
                 area: Optional[pulumi.Input[_builtins.str]] = None,
                 cost: Optional[pulumi.Input[_builtins.int]] = None,
                 is_passive_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] area: Area id
        :param pulumi.Input[_builtins.int] cost: OSPF Cost
        :param pulumi.Input[_builtins.bool] is_passive_enabled: Disable sending Hello packets on this interface's IPv4 area
        """
        if area is not None:
            pulumi.set(__self__, "area", area)
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if is_passive_enabled is not None:
            pulumi.set(__self__, "is_passive_enabled", is_passive_enabled)

    @_builtins.property
    @pulumi.getter
    def area(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Area id
        """
        return pulumi.get(self, "area")

    @area.setter
    def area(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "area", value)

    @_builtins.property
    @pulumi.getter
    def cost(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF Cost
        """
        return pulumi.get(self, "cost")

    @cost.setter
    def cost(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cost", value)

    @_builtins.property
    @pulumi.getter(name="isPassiveEnabled")
    def is_passive_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable sending Hello packets on this interface's IPv4 area
        """
        return pulumi.get(self, "is_passive_enabled")

    @is_passive_enabled.setter
    def is_passive_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_passive_enabled", value)


if not MYPY:
    class SwitchStacksRoutingInterfacesOspfV3ArgsDict(TypedDict):
        area: NotRequired[pulumi.Input[_builtins.str]]
        """
        Area id
        """
        cost: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF Cost
        """
        is_passive_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable sending Hello packets on this interface's IPv6 area
        """
elif False:
    SwitchStacksRoutingInterfacesOspfV3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStacksRoutingInterfacesOspfV3Args:
    def __init__(__self__, *,
                 area: Optional[pulumi.Input[_builtins.str]] = None,
                 cost: Optional[pulumi.Input[_builtins.int]] = None,
                 is_passive_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] area: Area id
        :param pulumi.Input[_builtins.int] cost: OSPF Cost
        :param pulumi.Input[_builtins.bool] is_passive_enabled: Disable sending Hello packets on this interface's IPv6 area
        """
        if area is not None:
            pulumi.set(__self__, "area", area)
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if is_passive_enabled is not None:
            pulumi.set(__self__, "is_passive_enabled", is_passive_enabled)

    @_builtins.property
    @pulumi.getter
    def area(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Area id
        """
        return pulumi.get(self, "area")

    @area.setter
    def area(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "area", value)

    @_builtins.property
    @pulumi.getter
    def cost(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF Cost
        """
        return pulumi.get(self, "cost")

    @cost.setter
    def cost(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cost", value)

    @_builtins.property
    @pulumi.getter(name="isPassiveEnabled")
    def is_passive_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable sending Hello packets on this interface's IPv6 area
        """
        return pulumi.get(self, "is_passive_enabled")

    @is_passive_enabled.setter
    def is_passive_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_passive_enabled", value)


if not MYPY:
    class SwitchStpStpBridgePriorityArgsDict(TypedDict):
        stacks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of stack IDs
        """
        stp_priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        STP priority for switch, stacks, or switch profiles
        """
        switch_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of switch profile IDs
        """
        switches: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of switch serial numbers
        """
elif False:
    SwitchStpStpBridgePriorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStpStpBridgePriorityArgs:
    def __init__(__self__, *,
                 stacks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 stp_priority: Optional[pulumi.Input[_builtins.int]] = None,
                 switch_profiles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 switches: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stacks: List of stack IDs
        :param pulumi.Input[_builtins.int] stp_priority: STP priority for switch, stacks, or switch profiles
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] switch_profiles: List of switch profile IDs
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] switches: List of switch serial numbers
        """
        if stacks is not None:
            pulumi.set(__self__, "stacks", stacks)
        if stp_priority is not None:
            pulumi.set(__self__, "stp_priority", stp_priority)
        if switch_profiles is not None:
            pulumi.set(__self__, "switch_profiles", switch_profiles)
        if switches is not None:
            pulumi.set(__self__, "switches", switches)

    @_builtins.property
    @pulumi.getter
    def stacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of stack IDs
        """
        return pulumi.get(self, "stacks")

    @stacks.setter
    def stacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stacks", value)

    @_builtins.property
    @pulumi.getter(name="stpPriority")
    def stp_priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        STP priority for switch, stacks, or switch profiles
        """
        return pulumi.get(self, "stp_priority")

    @stp_priority.setter
    def stp_priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stp_priority", value)

    @_builtins.property
    @pulumi.getter(name="switchProfiles")
    def switch_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of switch profile IDs
        """
        return pulumi.get(self, "switch_profiles")

    @switch_profiles.setter
    def switch_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "switch_profiles", value)

    @_builtins.property
    @pulumi.getter
    def switches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of switch serial numbers
        """
        return pulumi.get(self, "switches")

    @switches.setter
    def switches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "switches", value)


if not MYPY:
    class SwitchStpStpBridgePriorityResponseArgsDict(TypedDict):
        stacks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of stack IDs
        """
        stp_priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        STP priority for switch, stacks, or switch templates
        """
        switch_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of switch template IDs
        """
        switches: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of switch serial numbers
        """
elif False:
    SwitchStpStpBridgePriorityResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStpStpBridgePriorityResponseArgs:
    def __init__(__self__, *,
                 stacks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 stp_priority: Optional[pulumi.Input[_builtins.int]] = None,
                 switch_profiles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 switches: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stacks: List of stack IDs
        :param pulumi.Input[_builtins.int] stp_priority: STP priority for switch, stacks, or switch templates
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] switch_profiles: List of switch template IDs
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] switches: List of switch serial numbers
        """
        if stacks is not None:
            pulumi.set(__self__, "stacks", stacks)
        if stp_priority is not None:
            pulumi.set(__self__, "stp_priority", stp_priority)
        if switch_profiles is not None:
            pulumi.set(__self__, "switch_profiles", switch_profiles)
        if switches is not None:
            pulumi.set(__self__, "switches", switches)

    @_builtins.property
    @pulumi.getter
    def stacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of stack IDs
        """
        return pulumi.get(self, "stacks")

    @stacks.setter
    def stacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stacks", value)

    @_builtins.property
    @pulumi.getter(name="stpPriority")
    def stp_priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        STP priority for switch, stacks, or switch templates
        """
        return pulumi.get(self, "stp_priority")

    @stp_priority.setter
    def stp_priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stp_priority", value)

    @_builtins.property
    @pulumi.getter(name="switchProfiles")
    def switch_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of switch template IDs
        """
        return pulumi.get(self, "switch_profiles")

    @switch_profiles.setter
    def switch_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "switch_profiles", value)

    @_builtins.property
    @pulumi.getter
    def switches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of switch serial numbers
        """
        return pulumi.get(self, "switches")

    @switches.setter
    def switches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "switches", value)


if not MYPY:
    class SyslogServersServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the syslog server
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port of the syslog server
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
        """
elif False:
    SyslogServersServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyslogServersServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The IP address of the syslog server
        :param pulumi.Input[_builtins.int] port: The port of the syslog server
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] roles: A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the syslog server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port of the syslog server
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class TrafficAnalysisCustomPieChartItemArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom pie chart item.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
        (see sample request/response for more details).
        """
elif False:
    TrafficAnalysisCustomPieChartItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficAnalysisCustomPieChartItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom pie chart item.
        :param pulumi.Input[_builtins.str] type: The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
        :param pulumi.Input[_builtins.str] value: The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
               (see sample request/response for more details).
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom pie chart item.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
        (see sample request/response for more details).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UnbindItemArgsDict(TypedDict):
        enrollment_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enrollment string for the network
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network ID
        """
        is_bound_to_config_template: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the network is bound to a config template
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network name
        """
        notes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notes for the network
        """
        organization_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization ID
        """
        product_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of the product types that the network supports
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Network tags
        """
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timezone of the network
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL to the network Dashboard UI
        """
elif False:
    UnbindItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnbindItemArgs:
    def __init__(__self__, *,
                 enrollment_string: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_bound_to_config_template: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 organization_id: Optional[pulumi.Input[_builtins.str]] = None,
                 product_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] enrollment_string: Enrollment string for the network
        :param pulumi.Input[_builtins.str] id: Network ID
        :param pulumi.Input[_builtins.bool] is_bound_to_config_template: If the network is bound to a config template
        :param pulumi.Input[_builtins.str] name: Network name
        :param pulumi.Input[_builtins.str] notes: Notes for the network
        :param pulumi.Input[_builtins.str] organization_id: Organization ID
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] product_types: List of the product types that the network supports
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: Network tags
        :param pulumi.Input[_builtins.str] time_zone: Timezone of the network
        :param pulumi.Input[_builtins.str] url: URL to the network Dashboard UI
        """
        if enrollment_string is not None:
            pulumi.set(__self__, "enrollment_string", enrollment_string)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_bound_to_config_template is not None:
            pulumi.set(__self__, "is_bound_to_config_template", is_bound_to_config_template)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)
        if product_types is not None:
            pulumi.set(__self__, "product_types", product_types)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="enrollmentString")
    def enrollment_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enrollment string for the network
        """
        return pulumi.get(self, "enrollment_string")

    @enrollment_string.setter
    def enrollment_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enrollment_string", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isBoundToConfigTemplate")
    def is_bound_to_config_template(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the network is bound to a config template
        """
        return pulumi.get(self, "is_bound_to_config_template")

    @is_bound_to_config_template.setter
    def is_bound_to_config_template(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_bound_to_config_template", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notes for the network
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization ID
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_id", value)

    @_builtins.property
    @pulumi.getter(name="productTypes")
    def product_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of the product types that the network supports
        """
        return pulumi.get(self, "product_types")

    @product_types.setter
    def product_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "product_types", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Network tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timezone of the network
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL to the network Dashboard UI
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class UnbindParametersArgsDict(TypedDict):
        retain_configs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Optional boolean to retain all the current configs given by the template.
        """
elif False:
    UnbindParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnbindParametersArgs:
    def __init__(__self__, *,
                 retain_configs: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] retain_configs: Optional boolean to retain all the current configs given by the template.
        """
        if retain_configs is not None:
            pulumi.set(__self__, "retain_configs", retain_configs)

    @_builtins.property
    @pulumi.getter(name="retainConfigs")
    def retain_configs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Optional boolean to retain all the current configs given by the template.
        """
        return pulumi.get(self, "retain_configs")

    @retain_configs.setter
    def retain_configs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "retain_configs", value)


if not MYPY:
    class VlanProfilesAssignmentsReassignItemArgsDict(TypedDict):
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of Device Serials
        """
        stack_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of Switch Stack IDs
        """
        vlan_profile: NotRequired[pulumi.Input['VlanProfilesAssignmentsReassignItemVlanProfileArgsDict']]
        """
        The VLAN Profile
        """
elif False:
    VlanProfilesAssignmentsReassignItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanProfilesAssignmentsReassignItemArgs:
    def __init__(__self__, *,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 stack_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vlan_profile: Optional[pulumi.Input['VlanProfilesAssignmentsReassignItemVlanProfileArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: Array of Device Serials
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stack_ids: Array of Switch Stack IDs
        :param pulumi.Input['VlanProfilesAssignmentsReassignItemVlanProfileArgs'] vlan_profile: The VLAN Profile
        """
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if stack_ids is not None:
            pulumi.set(__self__, "stack_ids", stack_ids)
        if vlan_profile is not None:
            pulumi.set(__self__, "vlan_profile", vlan_profile)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of Device Serials
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)

    @_builtins.property
    @pulumi.getter(name="stackIds")
    def stack_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of Switch Stack IDs
        """
        return pulumi.get(self, "stack_ids")

    @stack_ids.setter
    def stack_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stack_ids", value)

    @_builtins.property
    @pulumi.getter(name="vlanProfile")
    def vlan_profile(self) -> Optional[pulumi.Input['VlanProfilesAssignmentsReassignItemVlanProfileArgs']]:
        """
        The VLAN Profile
        """
        return pulumi.get(self, "vlan_profile")

    @vlan_profile.setter
    def vlan_profile(self, value: Optional[pulumi.Input['VlanProfilesAssignmentsReassignItemVlanProfileArgs']]):
        pulumi.set(self, "vlan_profile", value)


if not MYPY:
    class VlanProfilesAssignmentsReassignItemVlanProfileArgsDict(TypedDict):
        iname: NotRequired[pulumi.Input[_builtins.str]]
        """
        IName of the VLAN Profile
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the VLAN Profile
        """
elif False:
    VlanProfilesAssignmentsReassignItemVlanProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanProfilesAssignmentsReassignItemVlanProfileArgs:
    def __init__(__self__, *,
                 iname: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] iname: IName of the VLAN Profile
        :param pulumi.Input[_builtins.str] name: Name of the VLAN Profile
        """
        if iname is not None:
            pulumi.set(__self__, "iname", iname)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def iname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IName of the VLAN Profile
        """
        return pulumi.get(self, "iname")

    @iname.setter
    def iname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the VLAN Profile
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VlanProfilesAssignmentsReassignParametersArgsDict(TypedDict):
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of Device Serials
        """
        stack_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of Switch Stack IDs
        """
        vlan_profile: NotRequired[pulumi.Input['VlanProfilesAssignmentsReassignParametersVlanProfileArgsDict']]
        """
        The VLAN Profile
        """
elif False:
    VlanProfilesAssignmentsReassignParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanProfilesAssignmentsReassignParametersArgs:
    def __init__(__self__, *,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 stack_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vlan_profile: Optional[pulumi.Input['VlanProfilesAssignmentsReassignParametersVlanProfileArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: Array of Device Serials
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stack_ids: Array of Switch Stack IDs
        :param pulumi.Input['VlanProfilesAssignmentsReassignParametersVlanProfileArgs'] vlan_profile: The VLAN Profile
        """
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if stack_ids is not None:
            pulumi.set(__self__, "stack_ids", stack_ids)
        if vlan_profile is not None:
            pulumi.set(__self__, "vlan_profile", vlan_profile)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of Device Serials
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)

    @_builtins.property
    @pulumi.getter(name="stackIds")
    def stack_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of Switch Stack IDs
        """
        return pulumi.get(self, "stack_ids")

    @stack_ids.setter
    def stack_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stack_ids", value)

    @_builtins.property
    @pulumi.getter(name="vlanProfile")
    def vlan_profile(self) -> Optional[pulumi.Input['VlanProfilesAssignmentsReassignParametersVlanProfileArgs']]:
        """
        The VLAN Profile
        """
        return pulumi.get(self, "vlan_profile")

    @vlan_profile.setter
    def vlan_profile(self, value: Optional[pulumi.Input['VlanProfilesAssignmentsReassignParametersVlanProfileArgs']]):
        pulumi.set(self, "vlan_profile", value)


if not MYPY:
    class VlanProfilesAssignmentsReassignParametersVlanProfileArgsDict(TypedDict):
        iname: NotRequired[pulumi.Input[_builtins.str]]
        """
        IName of the VLAN Profile
        """
elif False:
    VlanProfilesAssignmentsReassignParametersVlanProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanProfilesAssignmentsReassignParametersVlanProfileArgs:
    def __init__(__self__, *,
                 iname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] iname: IName of the VLAN Profile
        """
        if iname is not None:
            pulumi.set(__self__, "iname", iname)

    @_builtins.property
    @pulumi.getter
    def iname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IName of the VLAN Profile
        """
        return pulumi.get(self, "iname")

    @iname.setter
    def iname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iname", value)


if not MYPY:
    class VlanProfilesVlanGroupArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the VLAN, string length must be from 1 to 32 characters
        """
        vlan_ids: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated VLAN IDs or ID ranges
        """
elif False:
    VlanProfilesVlanGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanProfilesVlanGroupArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan_ids: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the VLAN, string length must be from 1 to 32 characters
        :param pulumi.Input[_builtins.str] vlan_ids: Comma-separated VLAN IDs or ID ranges
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the VLAN, string length must be from 1 to 32 characters
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated VLAN IDs or ID ranges
        """
        return pulumi.get(self, "vlan_ids")

    @vlan_ids.setter
    def vlan_ids(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vlan_ids", value)


if not MYPY:
    class VlanProfilesVlanNameArgsDict(TypedDict):
        adaptive_policy_group: NotRequired[pulumi.Input['VlanProfilesVlanNameAdaptivePolicyGroupArgsDict']]
        """
        Adaptive Policy Group assigned to Vlan ID
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the VLAN, string length must be from 1 to 32 characters
        """
        vlan_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        VLAN ID
        """
elif False:
    VlanProfilesVlanNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanProfilesVlanNameArgs:
    def __init__(__self__, *,
                 adaptive_policy_group: Optional[pulumi.Input['VlanProfilesVlanNameAdaptivePolicyGroupArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['VlanProfilesVlanNameAdaptivePolicyGroupArgs'] adaptive_policy_group: Adaptive Policy Group assigned to Vlan ID
        :param pulumi.Input[_builtins.str] name: Name of the VLAN, string length must be from 1 to 32 characters
        :param pulumi.Input[_builtins.str] vlan_id: VLAN ID
        """
        if adaptive_policy_group is not None:
            pulumi.set(__self__, "adaptive_policy_group", adaptive_policy_group)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter(name="adaptivePolicyGroup")
    def adaptive_policy_group(self) -> Optional[pulumi.Input['VlanProfilesVlanNameAdaptivePolicyGroupArgs']]:
        """
        Adaptive Policy Group assigned to Vlan ID
        """
        return pulumi.get(self, "adaptive_policy_group")

    @adaptive_policy_group.setter
    def adaptive_policy_group(self, value: Optional[pulumi.Input['VlanProfilesVlanNameAdaptivePolicyGroupArgs']]):
        pulumi.set(self, "adaptive_policy_group", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the VLAN, string length must be from 1 to 32 characters
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VLAN ID
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class VlanProfilesVlanNameAdaptivePolicyGroupArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Adaptive Policy Group ID
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Adaptive Policy Group name
        """
elif False:
    VlanProfilesVlanNameAdaptivePolicyGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanProfilesVlanNameAdaptivePolicyGroupArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Adaptive Policy Group ID
        :param pulumi.Input[_builtins.str] name: Adaptive Policy Group name
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Adaptive Policy Group ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Adaptive Policy Group name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebhooksHttpServersPayloadTemplateArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload template.
        """
        payload_template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the payload template.
        """
elif False:
    WebhooksHttpServersPayloadTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhooksHttpServersPayloadTemplateArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 payload_template_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the payload template.
        :param pulumi.Input[_builtins.str] payload_template_id: The ID of the payload template.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if payload_template_id is not None:
            pulumi.set(__self__, "payload_template_id", payload_template_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="payloadTemplateId")
    def payload_template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the payload template.
        """
        return pulumi.get(self, "payload_template_id")

    @payload_template_id.setter
    def payload_template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload_template_id", value)


if not MYPY:
    class WebhooksPayloadTemplatesHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the header attribute
        """
        template: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value returned in the header attribute, in liquid template
        """
elif False:
    WebhooksPayloadTemplatesHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhooksPayloadTemplatesHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 template: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the header attribute
        :param pulumi.Input[_builtins.str] template: The value returned in the header attribute, in liquid template
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the header attribute
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value returned in the header attribute, in liquid template
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template", value)


if not MYPY:
    class WebhooksPayloadTemplatesSharingArgsDict(TypedDict):
        by_network: NotRequired[pulumi.Input['WebhooksPayloadTemplatesSharingByNetworkArgsDict']]
        """
        Information on network access to the template
        """
elif False:
    WebhooksPayloadTemplatesSharingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhooksPayloadTemplatesSharingArgs:
    def __init__(__self__, *,
                 by_network: Optional[pulumi.Input['WebhooksPayloadTemplatesSharingByNetworkArgs']] = None):
        """
        :param pulumi.Input['WebhooksPayloadTemplatesSharingByNetworkArgs'] by_network: Information on network access to the template
        """
        if by_network is not None:
            pulumi.set(__self__, "by_network", by_network)

    @_builtins.property
    @pulumi.getter(name="byNetwork")
    def by_network(self) -> Optional[pulumi.Input['WebhooksPayloadTemplatesSharingByNetworkArgs']]:
        """
        Information on network access to the template
        """
        return pulumi.get(self, "by_network")

    @by_network.setter
    def by_network(self, value: Optional[pulumi.Input['WebhooksPayloadTemplatesSharingByNetworkArgs']]):
        pulumi.set(self, "by_network", value)


if not MYPY:
    class WebhooksPayloadTemplatesSharingByNetworkArgsDict(TypedDict):
        admins_can_modify: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether network admins may modify this template
        """
elif False:
    WebhooksPayloadTemplatesSharingByNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhooksPayloadTemplatesSharingByNetworkArgs:
    def __init__(__self__, *,
                 admins_can_modify: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] admins_can_modify: Indicates whether network admins may modify this template
        """
        if admins_can_modify is not None:
            pulumi.set(__self__, "admins_can_modify", admins_can_modify)

    @_builtins.property
    @pulumi.getter(name="adminsCanModify")
    def admins_can_modify(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether network admins may modify this template
        """
        return pulumi.get(self, "admins_can_modify")

    @admins_can_modify.setter
    def admins_can_modify(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "admins_can_modify", value)


if not MYPY:
    class WirelessAlternateManagementInterfaceAccessPointArgsDict(TypedDict):
        alternate_management_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Wireless alternate management interface device IP. Provide an empty string to remove alternate management IP assignment
        """
        dns1: NotRequired[pulumi.Input[_builtins.str]]
        """
        Primary DNS must be in IP format
        """
        dns2: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional secondary DNS must be in IP format
        """
        gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        Gateway must be in IP format
        """
        serial: NotRequired[pulumi.Input[_builtins.str]]
        """
        Serial number of access point to be configured with alternate management IP
        """
        subnet_mask: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subnet mask must be in IP format
        """
elif False:
    WirelessAlternateManagementInterfaceAccessPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessAlternateManagementInterfaceAccessPointArgs:
    def __init__(__self__, *,
                 alternate_management_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 dns1: Optional[pulumi.Input[_builtins.str]] = None,
                 dns2: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 serial: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_mask: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] alternate_management_ip: Wireless alternate management interface device IP. Provide an empty string to remove alternate management IP assignment
        :param pulumi.Input[_builtins.str] dns1: Primary DNS must be in IP format
        :param pulumi.Input[_builtins.str] dns2: Optional secondary DNS must be in IP format
        :param pulumi.Input[_builtins.str] gateway: Gateway must be in IP format
        :param pulumi.Input[_builtins.str] serial: Serial number of access point to be configured with alternate management IP
        :param pulumi.Input[_builtins.str] subnet_mask: Subnet mask must be in IP format
        """
        if alternate_management_ip is not None:
            pulumi.set(__self__, "alternate_management_ip", alternate_management_ip)
        if dns1 is not None:
            pulumi.set(__self__, "dns1", dns1)
        if dns2 is not None:
            pulumi.set(__self__, "dns2", dns2)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)

    @_builtins.property
    @pulumi.getter(name="alternateManagementIp")
    def alternate_management_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Wireless alternate management interface device IP. Provide an empty string to remove alternate management IP assignment
        """
        return pulumi.get(self, "alternate_management_ip")

    @alternate_management_ip.setter
    def alternate_management_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alternate_management_ip", value)

    @_builtins.property
    @pulumi.getter
    def dns1(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Primary DNS must be in IP format
        """
        return pulumi.get(self, "dns1")

    @dns1.setter
    def dns1(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns1", value)

    @_builtins.property
    @pulumi.getter
    def dns2(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional secondary DNS must be in IP format
        """
        return pulumi.get(self, "dns2")

    @dns2.setter
    def dns2(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns2", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Gateway must be in IP format
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Serial number of access point to be configured with alternate management IP
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial", value)

    @_builtins.property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subnet mask must be in IP format
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_mask", value)


if not MYPY:
    class WirelessBillingPlanArgsDict(TypedDict):
        bandwidth_limits: NotRequired[pulumi.Input['WirelessBillingPlanBandwidthLimitsArgsDict']]
        """
        The uplink bandwidth settings for the pricing plan.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the pricing plan to update.
        """
        price: NotRequired[pulumi.Input[_builtins.float]]
        """
        The price of the billing plan.
        """
        time_limit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time limit of the pricing plan in minutes.
        """
elif False:
    WirelessBillingPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessBillingPlanArgs:
    def __init__(__self__, *,
                 bandwidth_limits: Optional[pulumi.Input['WirelessBillingPlanBandwidthLimitsArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 price: Optional[pulumi.Input[_builtins.float]] = None,
                 time_limit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['WirelessBillingPlanBandwidthLimitsArgs'] bandwidth_limits: The uplink bandwidth settings for the pricing plan.
        :param pulumi.Input[_builtins.str] id: The id of the pricing plan to update.
        :param pulumi.Input[_builtins.float] price: The price of the billing plan.
        :param pulumi.Input[_builtins.str] time_limit: The time limit of the pricing plan in minutes.
        """
        if bandwidth_limits is not None:
            pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if price is not None:
            pulumi.set(__self__, "price", price)
        if time_limit is not None:
            pulumi.set(__self__, "time_limit", time_limit)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> Optional[pulumi.Input['WirelessBillingPlanBandwidthLimitsArgs']]:
        """
        The uplink bandwidth settings for the pricing plan.
        """
        return pulumi.get(self, "bandwidth_limits")

    @bandwidth_limits.setter
    def bandwidth_limits(self, value: Optional[pulumi.Input['WirelessBillingPlanBandwidthLimitsArgs']]):
        pulumi.set(self, "bandwidth_limits", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the pricing plan to update.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def price(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The price of the billing plan.
        """
        return pulumi.get(self, "price")

    @price.setter
    def price(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "price", value)

    @_builtins.property
    @pulumi.getter(name="timeLimit")
    def time_limit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time limit of the pricing plan in minutes.
        """
        return pulumi.get(self, "time_limit")

    @time_limit.setter
    def time_limit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_limit", value)


if not MYPY:
    class WirelessBillingPlanBandwidthLimitsArgsDict(TypedDict):
        limit_down: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum download limit (integer, in Kbps).
        """
        limit_up: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum upload limit (integer, in Kbps).
        """
elif False:
    WirelessBillingPlanBandwidthLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessBillingPlanBandwidthLimitsArgs:
    def __init__(__self__, *,
                 limit_down: Optional[pulumi.Input[_builtins.int]] = None,
                 limit_up: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] limit_down: The maximum download limit (integer, in Kbps).
        :param pulumi.Input[_builtins.int] limit_up: The maximum upload limit (integer, in Kbps).
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum download limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_down")

    @limit_down.setter
    def limit_down(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_down", value)

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum upload limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_up")

    @limit_up.setter
    def limit_up(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_up", value)


if not MYPY:
    class WirelessEthernetPortsProfilesAssignItemArgsDict(TypedDict):
        profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        AP profile ID
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of updated AP serials
        """
elif False:
    WirelessEthernetPortsProfilesAssignItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessEthernetPortsProfilesAssignItemArgs:
    def __init__(__self__, *,
                 profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] profile_id: AP profile ID
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: List of updated AP serials
        """
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AP profile ID
        """
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_id", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of updated AP serials
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)


if not MYPY:
    class WirelessEthernetPortsProfilesAssignParametersArgsDict(TypedDict):
        profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        AP profile ID
        """
        serials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of AP serials
        """
elif False:
    WirelessEthernetPortsProfilesAssignParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessEthernetPortsProfilesAssignParametersArgs:
    def __init__(__self__, *,
                 profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 serials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] profile_id: AP profile ID
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] serials: List of AP serials
        """
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AP profile ID
        """
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_id", value)

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of AP serials
        """
        return pulumi.get(self, "serials")

    @serials.setter
    def serials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "serials", value)


if not MYPY:
    class WirelessEthernetPortsProfilesPortArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enabled
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number
        """
        psk_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        PSK Group number
        """
        ssid: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ssid number
        """
elif False:
    WirelessEthernetPortsProfilesPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessEthernetPortsProfilesPortArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 number: Optional[pulumi.Input[_builtins.int]] = None,
                 psk_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ssid: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enabled
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.int] number: Number
        :param pulumi.Input[_builtins.str] psk_group_id: PSK Group number
        :param pulumi.Input[_builtins.int] ssid: Ssid number
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if psk_group_id is not None:
            pulumi.set(__self__, "psk_group_id", psk_group_id)
        if ssid is not None:
            pulumi.set(__self__, "ssid", ssid)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter(name="pskGroupId")
    def psk_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        PSK Group number
        """
        return pulumi.get(self, "psk_group_id")

    @psk_group_id.setter
    def psk_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "psk_group_id", value)

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ssid number
        """
        return pulumi.get(self, "ssid")

    @ssid.setter
    def ssid(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ssid", value)


if not MYPY:
    class WirelessEthernetPortsProfilesSetDefaultItemArgsDict(TypedDict):
        profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        AP profile ID
        """
elif False:
    WirelessEthernetPortsProfilesSetDefaultItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessEthernetPortsProfilesSetDefaultItemArgs:
    def __init__(__self__, *,
                 profile_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile_id: AP profile ID
        """
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AP profile ID
        """
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_id", value)


if not MYPY:
    class WirelessEthernetPortsProfilesSetDefaultParametersArgsDict(TypedDict):
        profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        AP profile ID
        """
elif False:
    WirelessEthernetPortsProfilesSetDefaultParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessEthernetPortsProfilesSetDefaultParametersArgs:
    def __init__(__self__, *,
                 profile_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile_id: AP profile ID
        """
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AP profile ID
        """
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_id", value)


if not MYPY:
    class WirelessEthernetPortsProfilesUsbPortArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enabled
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        ssid: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ssid number
        """
elif False:
    WirelessEthernetPortsProfilesUsbPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessEthernetPortsProfilesUsbPortArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 ssid: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enabled
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.int] ssid: Ssid number
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ssid is not None:
            pulumi.set(__self__, "ssid", ssid)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ssid number
        """
        return pulumi.get(self, "ssid")

    @ssid.setter
    def ssid(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ssid", value)


if not MYPY:
    class WirelessRfProfilesApBandSettingsArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'. Defaults to dual.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band. Can be either true or false. Defaults to true.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesApBandSettingsBandsArgsDict']]
        """
        Settings related to all bands
        """
elif False:
    WirelessRfProfilesApBandSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesApBandSettingsArgs:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesApBandSettingsBandsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'. Defaults to dual.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band. Can be either true or false. Defaults to true.
        :param pulumi.Input['WirelessRfProfilesApBandSettingsBandsArgs'] bands: Settings related to all bands
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'. Defaults to dual.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band. Can be either true or false. Defaults to true.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesApBandSettingsBandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesApBandSettingsBandsArgs']]):
        pulumi.set(self, "bands", value)


if not MYPY:
    class WirelessRfProfilesApBandSettingsBandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesApBandSettingsBandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesApBandSettingsBandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesFiveGhzSettingsArgsDict(TypedDict):
        channel_width: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
        """
        max_power: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        """
        min_power: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
        """
        rxsop: NotRequired[pulumi.Input[_builtins.int]]
        """
        The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        """
        valid_auto_channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165].
        """
elif False:
    WirelessRfProfilesFiveGhzSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesFiveGhzSettingsArgs:
    def __init__(__self__, *,
                 channel_width: Optional[pulumi.Input[_builtins.str]] = None,
                 max_power: Optional[pulumi.Input[_builtins.int]] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 min_power: Optional[pulumi.Input[_builtins.int]] = None,
                 rxsop: Optional[pulumi.Input[_builtins.int]] = None,
                 valid_auto_channels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.str] channel_width: Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
        :param pulumi.Input[_builtins.int] max_power: Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        :param pulumi.Input[_builtins.int] min_power: Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
        :param pulumi.Input[_builtins.int] rxsop: The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] valid_auto_channels: Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165].
        """
        if channel_width is not None:
            pulumi.set(__self__, "channel_width", channel_width)
        if max_power is not None:
            pulumi.set(__self__, "max_power", max_power)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if min_power is not None:
            pulumi.set(__self__, "min_power", min_power)
        if rxsop is not None:
            pulumi.set(__self__, "rxsop", rxsop)
        if valid_auto_channels is not None:
            pulumi.set(__self__, "valid_auto_channels", valid_auto_channels)

    @_builtins.property
    @pulumi.getter(name="channelWidth")
    def channel_width(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
        """
        return pulumi.get(self, "channel_width")

    @channel_width.setter
    def channel_width(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_width", value)

    @_builtins.property
    @pulumi.getter(name="maxPower")
    def max_power(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
        """
        return pulumi.get(self, "max_power")

    @max_power.setter
    def max_power(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_power", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter(name="minPower")
    def min_power(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
        """
        return pulumi.get(self, "min_power")

    @min_power.setter
    def min_power(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_power", value)

    @_builtins.property
    @pulumi.getter
    def rxsop(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        """
        return pulumi.get(self, "rxsop")

    @rxsop.setter
    def rxsop(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rxsop", value)

    @_builtins.property
    @pulumi.getter(name="validAutoChannels")
    def valid_auto_channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165].
        """
        return pulumi.get(self, "valid_auto_channels")

    @valid_auto_channels.setter
    def valid_auto_channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "valid_auto_channels", value)


if not MYPY:
    class WirelessRfProfilesFlexRadiosArgsDict(TypedDict):
        by_models: NotRequired[pulumi.Input[Sequence[pulumi.Input['WirelessRfProfilesFlexRadiosByModelArgsDict']]]]
        """
        Flex radios by model.
        """
elif False:
    WirelessRfProfilesFlexRadiosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesFlexRadiosArgs:
    def __init__(__self__, *,
                 by_models: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessRfProfilesFlexRadiosByModelArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WirelessRfProfilesFlexRadiosByModelArgs']]] by_models: Flex radios by model.
        """
        if by_models is not None:
            pulumi.set(__self__, "by_models", by_models)

    @_builtins.property
    @pulumi.getter(name="byModels")
    def by_models(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WirelessRfProfilesFlexRadiosByModelArgs']]]]:
        """
        Flex radios by model.
        """
        return pulumi.get(self, "by_models")

    @by_models.setter
    def by_models(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessRfProfilesFlexRadiosByModelArgs']]]]):
        pulumi.set(self, "by_models", value)


if not MYPY:
    class WirelessRfProfilesFlexRadiosByModelArgsDict(TypedDict):
        bands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Band to use for each flex radio. For example, ['6'] will set the AP's first flex radio to 6 GHz
        """
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        Model of the AP
        """
elif False:
    WirelessRfProfilesFlexRadiosByModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesFlexRadiosByModelArgs:
    def __init__(__self__, *,
                 bands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] bands: Band to use for each flex radio. For example, ['6'] will set the AP's first flex radio to 6 GHz
        :param pulumi.Input[_builtins.str] model: Model of the AP
        """
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Band to use for each flex radio. For example, ['6'] will set the AP's first flex radio to 6 GHz
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Model of the AP
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsArgsDict(TypedDict):
        status0: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus0ArgsDict']]
        """
        Settings for SSID 0
        """
        status1: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus1ArgsDict']]
        """
        Settings for SSID 1
        """
        status10: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus10ArgsDict']]
        """
        Settings for SSID 10
        """
        status11: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus11ArgsDict']]
        """
        Settings for SSID 11
        """
        status12: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus12ArgsDict']]
        """
        Settings for SSID 12
        """
        status13: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus13ArgsDict']]
        """
        Settings for SSID 13
        """
        status14: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus14ArgsDict']]
        """
        Settings for SSID 14
        """
        status2: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus2ArgsDict']]
        """
        Settings for SSID 2
        """
        status3: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus3ArgsDict']]
        """
        Settings for SSID 3
        """
        status4: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus4ArgsDict']]
        """
        Settings for SSID 4
        """
        status5: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus5ArgsDict']]
        """
        Settings for SSID 5
        """
        status6: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus6ArgsDict']]
        """
        Settings for SSID 6
        """
        status7: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus7ArgsDict']]
        """
        Settings for SSID 7
        """
        status8: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus8ArgsDict']]
        """
        Settings for SSID 8
        """
        status9: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus9ArgsDict']]
        """
        Settings for SSID 9
        """
elif False:
    WirelessRfProfilesPerSsidSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsArgs:
    def __init__(__self__, *,
                 status0: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus0Args']] = None,
                 status1: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus1Args']] = None,
                 status10: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus10Args']] = None,
                 status11: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus11Args']] = None,
                 status12: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus12Args']] = None,
                 status13: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus13Args']] = None,
                 status14: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus14Args']] = None,
                 status2: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus2Args']] = None,
                 status3: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus3Args']] = None,
                 status4: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus4Args']] = None,
                 status5: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus5Args']] = None,
                 status6: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus6Args']] = None,
                 status7: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus7Args']] = None,
                 status8: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus8Args']] = None,
                 status9: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus9Args']] = None):
        """
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus0Args'] status0: Settings for SSID 0
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus1Args'] status1: Settings for SSID 1
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus10Args'] status10: Settings for SSID 10
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus11Args'] status11: Settings for SSID 11
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus12Args'] status12: Settings for SSID 12
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus13Args'] status13: Settings for SSID 13
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus14Args'] status14: Settings for SSID 14
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus2Args'] status2: Settings for SSID 2
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus3Args'] status3: Settings for SSID 3
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus4Args'] status4: Settings for SSID 4
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus5Args'] status5: Settings for SSID 5
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus6Args'] status6: Settings for SSID 6
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus7Args'] status7: Settings for SSID 7
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus8Args'] status8: Settings for SSID 8
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus9Args'] status9: Settings for SSID 9
        """
        if status0 is not None:
            pulumi.set(__self__, "status0", status0)
        if status1 is not None:
            pulumi.set(__self__, "status1", status1)
        if status10 is not None:
            pulumi.set(__self__, "status10", status10)
        if status11 is not None:
            pulumi.set(__self__, "status11", status11)
        if status12 is not None:
            pulumi.set(__self__, "status12", status12)
        if status13 is not None:
            pulumi.set(__self__, "status13", status13)
        if status14 is not None:
            pulumi.set(__self__, "status14", status14)
        if status2 is not None:
            pulumi.set(__self__, "status2", status2)
        if status3 is not None:
            pulumi.set(__self__, "status3", status3)
        if status4 is not None:
            pulumi.set(__self__, "status4", status4)
        if status5 is not None:
            pulumi.set(__self__, "status5", status5)
        if status6 is not None:
            pulumi.set(__self__, "status6", status6)
        if status7 is not None:
            pulumi.set(__self__, "status7", status7)
        if status8 is not None:
            pulumi.set(__self__, "status8", status8)
        if status9 is not None:
            pulumi.set(__self__, "status9", status9)

    @_builtins.property
    @pulumi.getter
    def status0(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus0Args']]:
        """
        Settings for SSID 0
        """
        return pulumi.get(self, "status0")

    @status0.setter
    def status0(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus0Args']]):
        pulumi.set(self, "status0", value)

    @_builtins.property
    @pulumi.getter
    def status1(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus1Args']]:
        """
        Settings for SSID 1
        """
        return pulumi.get(self, "status1")

    @status1.setter
    def status1(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus1Args']]):
        pulumi.set(self, "status1", value)

    @_builtins.property
    @pulumi.getter
    def status10(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus10Args']]:
        """
        Settings for SSID 10
        """
        return pulumi.get(self, "status10")

    @status10.setter
    def status10(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus10Args']]):
        pulumi.set(self, "status10", value)

    @_builtins.property
    @pulumi.getter
    def status11(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus11Args']]:
        """
        Settings for SSID 11
        """
        return pulumi.get(self, "status11")

    @status11.setter
    def status11(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus11Args']]):
        pulumi.set(self, "status11", value)

    @_builtins.property
    @pulumi.getter
    def status12(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus12Args']]:
        """
        Settings for SSID 12
        """
        return pulumi.get(self, "status12")

    @status12.setter
    def status12(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus12Args']]):
        pulumi.set(self, "status12", value)

    @_builtins.property
    @pulumi.getter
    def status13(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus13Args']]:
        """
        Settings for SSID 13
        """
        return pulumi.get(self, "status13")

    @status13.setter
    def status13(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus13Args']]):
        pulumi.set(self, "status13", value)

    @_builtins.property
    @pulumi.getter
    def status14(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus14Args']]:
        """
        Settings for SSID 14
        """
        return pulumi.get(self, "status14")

    @status14.setter
    def status14(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus14Args']]):
        pulumi.set(self, "status14", value)

    @_builtins.property
    @pulumi.getter
    def status2(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus2Args']]:
        """
        Settings for SSID 2
        """
        return pulumi.get(self, "status2")

    @status2.setter
    def status2(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus2Args']]):
        pulumi.set(self, "status2", value)

    @_builtins.property
    @pulumi.getter
    def status3(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus3Args']]:
        """
        Settings for SSID 3
        """
        return pulumi.get(self, "status3")

    @status3.setter
    def status3(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus3Args']]):
        pulumi.set(self, "status3", value)

    @_builtins.property
    @pulumi.getter
    def status4(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus4Args']]:
        """
        Settings for SSID 4
        """
        return pulumi.get(self, "status4")

    @status4.setter
    def status4(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus4Args']]):
        pulumi.set(self, "status4", value)

    @_builtins.property
    @pulumi.getter
    def status5(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus5Args']]:
        """
        Settings for SSID 5
        """
        return pulumi.get(self, "status5")

    @status5.setter
    def status5(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus5Args']]):
        pulumi.set(self, "status5", value)

    @_builtins.property
    @pulumi.getter
    def status6(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus6Args']]:
        """
        Settings for SSID 6
        """
        return pulumi.get(self, "status6")

    @status6.setter
    def status6(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus6Args']]):
        pulumi.set(self, "status6", value)

    @_builtins.property
    @pulumi.getter
    def status7(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus7Args']]:
        """
        Settings for SSID 7
        """
        return pulumi.get(self, "status7")

    @status7.setter
    def status7(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus7Args']]):
        pulumi.set(self, "status7", value)

    @_builtins.property
    @pulumi.getter
    def status8(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus8Args']]:
        """
        Settings for SSID 8
        """
        return pulumi.get(self, "status8")

    @status8.setter
    def status8(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus8Args']]):
        pulumi.set(self, "status8", value)

    @_builtins.property
    @pulumi.getter
    def status9(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus9Args']]:
        """
        Settings for SSID 9
        """
        return pulumi.get(self, "status9")

    @status9.setter
    def status9(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus9Args']]):
        pulumi.set(self, "status9", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus0ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus0BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus0ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus0Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus0BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus0BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus0BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus0BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus0BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus0BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus0BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus10ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus10BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus10ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus10Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus10BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus10BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus10BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus10BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus10BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus10BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus10BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus11ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus11BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus11ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus11Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus11BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus11BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus11BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus11BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus11BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus11BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus11BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus12ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus12BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus12ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus12Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus12BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus12BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus12BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus12BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus12BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus12BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus12BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus13ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus13BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus13ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus13Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus13BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus13BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus13BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus13BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus13BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus13BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus13BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus14ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus14BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus14ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus14Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus14BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus14BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus14BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus14BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus14BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus14BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus14BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus1ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus1BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus1Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus1BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus1BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus1BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus1BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus1BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus1BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus1BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus2ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus2BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus2Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus2BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus2BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus2BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus2BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus2BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus2BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus2BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus3ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus3BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus3Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus3BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus3BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus3BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus3BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus3BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus3BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus3BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus4ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus4BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus4Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus4BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus4BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus4BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus4BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus4BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus4BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus4BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus5ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus5BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus5Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus5BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus5BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus5BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus5BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus5BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus5BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus5BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus6ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus6BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus6Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus6BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus6BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus6BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus6BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus6BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus6BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus6BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus7ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus7BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus7ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus7Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus7BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus7BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus7BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus7BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus7BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus7BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus7BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus8ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus8BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus8ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus8Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus8BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus8BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus8BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus8BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus8BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus8BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus8BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus9ArgsDict(TypedDict):
        band_operation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        band_steering_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        bands: NotRequired[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus9BandsArgsDict']]
        """
        Settings related to all bands
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of SSID
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus9ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus9Args:
    def __init__(__self__, *,
                 band_operation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 band_steering_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bands: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus9BandsArgs']] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] band_operation_mode: Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        :param pulumi.Input[_builtins.bool] band_steering_enabled: Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        :param pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus9BandsArgs'] bands: Settings related to all bands
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        :param pulumi.Input[_builtins.str] name: Name of SSID
        """
        if band_operation_mode is not None:
            pulumi.set(__self__, "band_operation_mode", band_operation_mode)
        if band_steering_enabled is not None:
            pulumi.set(__self__, "band_steering_enabled", band_steering_enabled)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bandOperationMode")
    def band_operation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
        """
        return pulumi.get(self, "band_operation_mode")

    @band_operation_mode.setter
    def band_operation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "band_operation_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandSteeringEnabled")
    def band_steering_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
        """
        return pulumi.get(self, "band_steering_enabled")

    @band_steering_enabled.setter
    def band_steering_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "band_steering_enabled", value)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus9BandsArgs']]:
        """
        Settings related to all bands
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input['WirelessRfProfilesPerSsidSettingsStatus9BandsArgs']]):
        pulumi.set(self, "bands", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of SSID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessRfProfilesPerSsidSettingsStatus9BandsArgsDict(TypedDict):
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
elif False:
    WirelessRfProfilesPerSsidSettingsStatus9BandsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesPerSsidSettingsStatus9BandsArgs:
    def __init__(__self__, *,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of enabled bands. Can include ["2.4", "5", "6", "disabled"
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class WirelessRfProfilesSixGhzSettingsArgsDict(TypedDict):
        channel_width: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sets channel width (MHz) for 6Ghz band. Can be one of '0', '20', '40', '80' or '160'. Defaults to auto.
        """
        max_power: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets max power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 30.
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min bitrate (Mbps) of 6Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        """
        min_power: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 8.
        """
        rxsop: NotRequired[pulumi.Input[_builtins.int]]
        """
        The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        """
        valid_auto_channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Sets valid auto channels for 6Ghz band. Can be one of '1', '5', '9', '13', '17', '21', '25', '29', '33', '37', '41', '45', '49', '53', '57', '61', '65', '69', '73', '77', '81', '85', '89', '93', '97', '101', '105', '109', '113', '117', '121', '125', '129', '133', '137', '141', '145', '149', '153', '157', '161', '165', '169', '173', '177', '181', '185', '189', '193', '197', '201', '205', '209', '213', '217', '221', '225', '229' or '233'. Defaults to auto.
        """
elif False:
    WirelessRfProfilesSixGhzSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesSixGhzSettingsArgs:
    def __init__(__self__, *,
                 channel_width: Optional[pulumi.Input[_builtins.str]] = None,
                 max_power: Optional[pulumi.Input[_builtins.int]] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 min_power: Optional[pulumi.Input[_builtins.int]] = None,
                 rxsop: Optional[pulumi.Input[_builtins.int]] = None,
                 valid_auto_channels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.str] channel_width: Sets channel width (MHz) for 6Ghz band. Can be one of '0', '20', '40', '80' or '160'. Defaults to auto.
        :param pulumi.Input[_builtins.int] max_power: Sets max power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 30.
        :param pulumi.Input[_builtins.int] min_bitrate: Sets min bitrate (Mbps) of 6Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        :param pulumi.Input[_builtins.int] min_power: Sets min power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 8.
        :param pulumi.Input[_builtins.int] rxsop: The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] valid_auto_channels: Sets valid auto channels for 6Ghz band. Can be one of '1', '5', '9', '13', '17', '21', '25', '29', '33', '37', '41', '45', '49', '53', '57', '61', '65', '69', '73', '77', '81', '85', '89', '93', '97', '101', '105', '109', '113', '117', '121', '125', '129', '133', '137', '141', '145', '149', '153', '157', '161', '165', '169', '173', '177', '181', '185', '189', '193', '197', '201', '205', '209', '213', '217', '221', '225', '229' or '233'. Defaults to auto.
        """
        if channel_width is not None:
            pulumi.set(__self__, "channel_width", channel_width)
        if max_power is not None:
            pulumi.set(__self__, "max_power", max_power)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if min_power is not None:
            pulumi.set(__self__, "min_power", min_power)
        if rxsop is not None:
            pulumi.set(__self__, "rxsop", rxsop)
        if valid_auto_channels is not None:
            pulumi.set(__self__, "valid_auto_channels", valid_auto_channels)

    @_builtins.property
    @pulumi.getter(name="channelWidth")
    def channel_width(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sets channel width (MHz) for 6Ghz band. Can be one of '0', '20', '40', '80' or '160'. Defaults to auto.
        """
        return pulumi.get(self, "channel_width")

    @channel_width.setter
    def channel_width(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_width", value)

    @_builtins.property
    @pulumi.getter(name="maxPower")
    def max_power(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets max power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 30.
        """
        return pulumi.get(self, "max_power")

    @max_power.setter
    def max_power(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_power", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min bitrate (Mbps) of 6Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter(name="minPower")
    def min_power(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 8.
        """
        return pulumi.get(self, "min_power")

    @min_power.setter
    def min_power(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_power", value)

    @_builtins.property
    @pulumi.getter
    def rxsop(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        """
        return pulumi.get(self, "rxsop")

    @rxsop.setter
    def rxsop(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rxsop", value)

    @_builtins.property
    @pulumi.getter(name="validAutoChannels")
    def valid_auto_channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Sets valid auto channels for 6Ghz band. Can be one of '1', '5', '9', '13', '17', '21', '25', '29', '33', '37', '41', '45', '49', '53', '57', '61', '65', '69', '73', '77', '81', '85', '89', '93', '97', '101', '105', '109', '113', '117', '121', '125', '129', '133', '137', '141', '145', '149', '153', '157', '161', '165', '169', '173', '177', '181', '185', '189', '193', '197', '201', '205', '209', '213', '217', '221', '225', '229' or '233'. Defaults to auto.
        """
        return pulumi.get(self, "valid_auto_channels")

    @valid_auto_channels.setter
    def valid_auto_channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "valid_auto_channels", value)


if not MYPY:
    class WirelessRfProfilesTransmissionArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Toggle for radio transmission. When false, radios will not transmit at all.
        """
elif False:
    WirelessRfProfilesTransmissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesTransmissionArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Toggle for radio transmission. When false, radios will not transmit at all.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Toggle for radio transmission. When false, radios will not transmit at all.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WirelessRfProfilesTwoFourGhzSettingsArgsDict(TypedDict):
        ax_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
        """
        max_power: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
        """
        min_bitrate: NotRequired[pulumi.Input[_builtins.float]]
        """
        Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
        """
        min_power: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
        """
        rxsop: NotRequired[pulumi.Input[_builtins.int]]
        """
        The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        """
        valid_auto_channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
        """
elif False:
    WirelessRfProfilesTwoFourGhzSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessRfProfilesTwoFourGhzSettingsArgs:
    def __init__(__self__, *,
                 ax_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_power: Optional[pulumi.Input[_builtins.int]] = None,
                 min_bitrate: Optional[pulumi.Input[_builtins.float]] = None,
                 min_power: Optional[pulumi.Input[_builtins.int]] = None,
                 rxsop: Optional[pulumi.Input[_builtins.int]] = None,
                 valid_auto_channels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] ax_enabled: Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
        :param pulumi.Input[_builtins.int] max_power: Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
        :param pulumi.Input[_builtins.float] min_bitrate: Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
        :param pulumi.Input[_builtins.int] min_power: Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
        :param pulumi.Input[_builtins.int] rxsop: The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] valid_auto_channels: Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
        """
        if ax_enabled is not None:
            pulumi.set(__self__, "ax_enabled", ax_enabled)
        if max_power is not None:
            pulumi.set(__self__, "max_power", max_power)
        if min_bitrate is not None:
            pulumi.set(__self__, "min_bitrate", min_bitrate)
        if min_power is not None:
            pulumi.set(__self__, "min_power", min_power)
        if rxsop is not None:
            pulumi.set(__self__, "rxsop", rxsop)
        if valid_auto_channels is not None:
            pulumi.set(__self__, "valid_auto_channels", valid_auto_channels)

    @_builtins.property
    @pulumi.getter(name="axEnabled")
    def ax_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
        """
        return pulumi.get(self, "ax_enabled")

    @ax_enabled.setter
    def ax_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ax_enabled", value)

    @_builtins.property
    @pulumi.getter(name="maxPower")
    def max_power(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
        """
        return pulumi.get(self, "max_power")

    @max_power.setter
    def max_power(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_power", value)

    @_builtins.property
    @pulumi.getter(name="minBitrate")
    def min_bitrate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
        """
        return pulumi.get(self, "min_bitrate")

    @min_bitrate.setter
    def min_bitrate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min_bitrate", value)

    @_builtins.property
    @pulumi.getter(name="minPower")
    def min_power(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
        """
        return pulumi.get(self, "min_power")

    @min_power.setter
    def min_power(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_power", value)

    @_builtins.property
    @pulumi.getter
    def rxsop(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
        """
        return pulumi.get(self, "rxsop")

    @rxsop.setter
    def rxsop(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rxsop", value)

    @_builtins.property
    @pulumi.getter(name="validAutoChannels")
    def valid_auto_channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
        """
        return pulumi.get(self, "valid_auto_channels")

    @valid_auto_channels.setter
    def valid_auto_channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "valid_auto_channels", value)


if not MYPY:
    class WirelessSettingsNamedVlansArgsDict(TypedDict):
        pool_dhcp_monitoring: NotRequired[pulumi.Input['WirelessSettingsNamedVlansPoolDhcpMonitoringArgsDict']]
        """
        Named VLAN Pool DHCP Monitoring settings.
        """
elif False:
    WirelessSettingsNamedVlansArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSettingsNamedVlansArgs:
    def __init__(__self__, *,
                 pool_dhcp_monitoring: Optional[pulumi.Input['WirelessSettingsNamedVlansPoolDhcpMonitoringArgs']] = None):
        """
        :param pulumi.Input['WirelessSettingsNamedVlansPoolDhcpMonitoringArgs'] pool_dhcp_monitoring: Named VLAN Pool DHCP Monitoring settings.
        """
        if pool_dhcp_monitoring is not None:
            pulumi.set(__self__, "pool_dhcp_monitoring", pool_dhcp_monitoring)

    @_builtins.property
    @pulumi.getter(name="poolDhcpMonitoring")
    def pool_dhcp_monitoring(self) -> Optional[pulumi.Input['WirelessSettingsNamedVlansPoolDhcpMonitoringArgs']]:
        """
        Named VLAN Pool DHCP Monitoring settings.
        """
        return pulumi.get(self, "pool_dhcp_monitoring")

    @pool_dhcp_monitoring.setter
    def pool_dhcp_monitoring(self, value: Optional[pulumi.Input['WirelessSettingsNamedVlansPoolDhcpMonitoringArgs']]):
        pulumi.set(self, "pool_dhcp_monitoring", value)


if not MYPY:
    class WirelessSettingsNamedVlansPoolDhcpMonitoringArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP
        """
elif False:
    WirelessSettingsNamedVlansPoolDhcpMonitoringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSettingsNamedVlansPoolDhcpMonitoringArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WirelessSettingsRegulatoryDomainArgsDict(TypedDict):
        country_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The country code of the regulatory domain.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the regulatory domain for this network.
        """
        permits6e: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not the regulatory domain for this network permits Wifi 6E.
        """
elif False:
    WirelessSettingsRegulatoryDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSettingsRegulatoryDomainArgs:
    def __init__(__self__, *,
                 country_code: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 permits6e: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code of the regulatory domain.
        :param pulumi.Input[_builtins.str] name: The name of the regulatory domain for this network.
        :param pulumi.Input[_builtins.bool] permits6e: Whether or not the regulatory domain for this network permits Wifi 6E.
        """
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if permits6e is not None:
            pulumi.set(__self__, "permits6e", permits6e)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The country code of the regulatory domain.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the regulatory domain for this network.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permits6e(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the regulatory domain for this network permits Wifi 6E.
        """
        return pulumi.get(self, "permits6e")

    @permits6e.setter
    def permits6e(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "permits6e", value)


if not MYPY:
    class WirelessSsidsActiveDirectoryArgsDict(TypedDict):
        credentials: NotRequired[pulumi.Input['WirelessSsidsActiveDirectoryCredentialsArgsDict']]
        """
        (Optional) The credentials of the user account to be used by the AP to bind to your Active Directory server. The Active Directory account should have permissions on all your Active Directory servers. Only valid if the splashPage is 'Password-protected with Active Directory'.
        """
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsActiveDirectoryServerArgsDict']]]]
        """
        The Active Directory servers to be used for authentication.
        """
elif False:
    WirelessSsidsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsActiveDirectoryArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input['WirelessSsidsActiveDirectoryCredentialsArgs']] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsActiveDirectoryServerArgs']]]] = None):
        """
        :param pulumi.Input['WirelessSsidsActiveDirectoryCredentialsArgs'] credentials: (Optional) The credentials of the user account to be used by the AP to bind to your Active Directory server. The Active Directory account should have permissions on all your Active Directory servers. Only valid if the splashPage is 'Password-protected with Active Directory'.
        :param pulumi.Input[Sequence[pulumi.Input['WirelessSsidsActiveDirectoryServerArgs']]] servers: The Active Directory servers to be used for authentication.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['WirelessSsidsActiveDirectoryCredentialsArgs']]:
        """
        (Optional) The credentials of the user account to be used by the AP to bind to your Active Directory server. The Active Directory account should have permissions on all your Active Directory servers. Only valid if the splashPage is 'Password-protected with Active Directory'.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['WirelessSsidsActiveDirectoryCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsActiveDirectoryServerArgs']]]]:
        """
        The Active Directory servers to be used for authentication.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsActiveDirectoryServerArgs']]]]):
        pulumi.set(self, "servers", value)


if not MYPY:
    class WirelessSsidsActiveDirectoryCredentialsArgsDict(TypedDict):
        logon_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The logon name of the Active Directory account.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to the Active Directory user account.
        """
elif False:
    WirelessSsidsActiveDirectoryCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsActiveDirectoryCredentialsArgs:
    def __init__(__self__, *,
                 logon_name: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] logon_name: The logon name of the Active Directory account.
        :param pulumi.Input[_builtins.str] password: The password to the Active Directory user account.
        """
        if logon_name is not None:
            pulumi.set(__self__, "logon_name", logon_name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="logonName")
    def logon_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The logon name of the Active Directory account.
        """
        return pulumi.get(self, "logon_name")

    @logon_name.setter
    def logon_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logon_name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to the Active Directory user account.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class WirelessSsidsActiveDirectoryServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address (or FQDN) of your Active Directory server.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Optional) UDP port the Active Directory server listens on. By default, uses port 3268.
        """
elif False:
    WirelessSsidsActiveDirectoryServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsActiveDirectoryServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] host: IP address (or FQDN) of your Active Directory server.
        :param pulumi.Input[_builtins.int] port: (Optional) UDP port the Active Directory server listens on. By default, uses port 3268.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address (or FQDN) of your Active Directory server.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Optional) UDP port the Active Directory server listens on. By default, uses port 3268.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class WirelessSsidsApTagsAndVlanIdArgsDict(TypedDict):
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of AP tags
        """
        vlan_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Numerical identifier that is assigned to the VLAN
        """
elif False:
    WirelessSsidsApTagsAndVlanIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsApTagsAndVlanIdArgs:
    def __init__(__self__, *,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vlan_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: Array of AP tags
        :param pulumi.Input[_builtins.int] vlan_id: Numerical identifier that is assigned to the VLAN
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of AP tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Numerical identifier that is assigned to the VLAN
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class WirelessSsidsBonjourForwardingExceptionArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, Bonjour forwarding exception is enabled on this SSID. Exception is required to enable L2 isolation and Bonjour forwarding to work together.
        """
elif False:
    WirelessSsidsBonjourForwardingExceptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsBonjourForwardingExceptionArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If true, Bonjour forwarding exception is enabled on this SSID. Exception is required to enable L2 isolation and Bonjour forwarding to work together.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, Bonjour forwarding exception is enabled on this SSID. Exception is required to enable L2 isolation and Bonjour forwarding to work together.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WirelessSsidsBonjourForwardingRuleArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Desctiption of the bonjour forwarding rule
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        """
        vlan_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the service VLAN. Required
        """
elif False:
    WirelessSsidsBonjourForwardingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsBonjourForwardingRuleArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vlan_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Desctiption of the bonjour forwarding rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] services: A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        :param pulumi.Input[_builtins.str] vlan_id: The ID of the service VLAN. Required
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Desctiption of the bonjour forwarding rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "services", value)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the service VLAN. Required
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class WirelessSsidsDeviceTypeGroupPoliciesDeviceTypePolicyArgsDict(TypedDict):
        device_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device policy. Can be one of 'Allowed', 'Blocked' or 'Group policy'
        """
        device_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device type. Can be one of 'Android', 'BlackBerry', 'Chrome OS', 'iPad', 'iPhone', 'iPod', 'Mac OS X', 'Windows', 'Windows Phone', 'B&N Nook' or 'Other OS'
        """
        group_policy_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        ID of the group policy object.
        """
elif False:
    WirelessSsidsDeviceTypeGroupPoliciesDeviceTypePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsDeviceTypeGroupPoliciesDeviceTypePolicyArgs:
    def __init__(__self__, *,
                 device_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 device_type: Optional[pulumi.Input[_builtins.str]] = None,
                 group_policy_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] device_policy: The device policy. Can be one of 'Allowed', 'Blocked' or 'Group policy'
        :param pulumi.Input[_builtins.str] device_type: The device type. Can be one of 'Android', 'BlackBerry', 'Chrome OS', 'iPad', 'iPhone', 'iPod', 'Mac OS X', 'Windows', 'Windows Phone', 'B&N Nook' or 'Other OS'
        :param pulumi.Input[_builtins.int] group_policy_id: ID of the group policy object.
        """
        if device_policy is not None:
            pulumi.set(__self__, "device_policy", device_policy)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if group_policy_id is not None:
            pulumi.set(__self__, "group_policy_id", group_policy_id)

    @_builtins.property
    @pulumi.getter(name="devicePolicy")
    def device_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device policy. Can be one of 'Allowed', 'Blocked' or 'Group policy'
        """
        return pulumi.get(self, "device_policy")

    @device_policy.setter
    def device_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_policy", value)

    @_builtins.property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device type. Can be one of 'Android', 'BlackBerry', 'Chrome OS', 'iPad', 'iPhone', 'iPod', 'Mac OS X', 'Windows', 'Windows Phone', 'B&N Nook' or 'Other OS'
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_type", value)

    @_builtins.property
    @pulumi.getter(name="groupPolicyId")
    def group_policy_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        ID of the group policy object.
        """
        return pulumi.get(self, "group_policy_id")

    @group_policy_id.setter
    def group_policy_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_policy_id", value)


if not MYPY:
    class WirelessSsidsDnsRewriteArgsDict(TypedDict):
        dns_custom_nameservers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        User specified DNS servers (up to two servers)
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean indicating whether or not DNS server rewrite is enabled. If disabled, upstream DNS will be used
        """
elif False:
    WirelessSsidsDnsRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsDnsRewriteArgs:
    def __init__(__self__, *,
                 dns_custom_nameservers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dns_custom_nameservers: User specified DNS servers (up to two servers)
        :param pulumi.Input[_builtins.bool] enabled: Boolean indicating whether or not DNS server rewrite is enabled. If disabled, upstream DNS will be used
        """
        if dns_custom_nameservers is not None:
            pulumi.set(__self__, "dns_custom_nameservers", dns_custom_nameservers)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="dnsCustomNameservers")
    def dns_custom_nameservers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        User specified DNS servers (up to two servers)
        """
        return pulumi.get(self, "dns_custom_nameservers")

    @dns_custom_nameservers.setter
    def dns_custom_nameservers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dns_custom_nameservers", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean indicating whether or not DNS server rewrite is enabled. If disabled, upstream DNS will be used
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WirelessSsidsDot11rArgsDict(TypedDict):
        adaptive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Optional) Whether 802.11r is adaptive or not.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether 802.11r is enabled or not.
        """
elif False:
    WirelessSsidsDot11rArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsDot11rArgs:
    def __init__(__self__, *,
                 adaptive: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] adaptive: (Optional) Whether 802.11r is adaptive or not.
        :param pulumi.Input[_builtins.bool] enabled: Whether 802.11r is enabled or not.
        """
        if adaptive is not None:
            pulumi.set(__self__, "adaptive", adaptive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def adaptive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Optional) Whether 802.11r is adaptive or not.
        """
        return pulumi.get(self, "adaptive")

    @adaptive.setter
    def adaptive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "adaptive", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether 802.11r is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WirelessSsidsDot11wArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether 802.11w is enabled or not.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Optional) Whether 802.11w is required or not.
        """
elif False:
    WirelessSsidsDot11wArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsDot11wArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether 802.11w is enabled or not.
        :param pulumi.Input[_builtins.bool] required: (Optional) Whether 802.11w is required or not.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether 802.11w is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Optional) Whether 802.11w is required or not.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class WirelessSsidsEapOverrideEapolKeyArgsDict(TypedDict):
        retries: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of EAPOL key retries.
        """
        timeout_in_ms: NotRequired[pulumi.Input[_builtins.int]]
        """
        EAPOL Key timeout in milliseconds.
        """
elif False:
    WirelessSsidsEapOverrideEapolKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsEapOverrideEapolKeyArgs:
    def __init__(__self__, *,
                 retries: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_in_ms: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] retries: Maximum number of EAPOL key retries.
        :param pulumi.Input[_builtins.int] timeout_in_ms: EAPOL Key timeout in milliseconds.
        """
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if timeout_in_ms is not None:
            pulumi.set(__self__, "timeout_in_ms", timeout_in_ms)

    @_builtins.property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of EAPOL key retries.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retries", value)

    @_builtins.property
    @pulumi.getter(name="timeoutInMs")
    def timeout_in_ms(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        EAPOL Key timeout in milliseconds.
        """
        return pulumi.get(self, "timeout_in_ms")

    @timeout_in_ms.setter
    def timeout_in_ms(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_in_ms", value)


if not MYPY:
    class WirelessSsidsEapOverrideIdentityArgsDict(TypedDict):
        retries: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of EAP retries.
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        EAP timeout in seconds.
        """
elif False:
    WirelessSsidsEapOverrideIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsEapOverrideIdentityArgs:
    def __init__(__self__, *,
                 retries: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] retries: Maximum number of EAP retries.
        :param pulumi.Input[_builtins.int] timeout: EAP timeout in seconds.
        """
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of EAP retries.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retries", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        EAP timeout in seconds.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class WirelessSsidsFirewallL3FirewallRulesRuleArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the rule (optional)
        """
        dest_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        dest_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        ip_ver: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip Ver
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'allow' or 'deny' traffic specified by this rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
elif False:
    WirelessSsidsFirewallL3FirewallRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsFirewallL3FirewallRulesRuleArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_port: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_ver: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Description of the rule (optional)
        :param pulumi.Input[_builtins.str] dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param pulumi.Input[_builtins.str] dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.str] ip_ver: Ip Ver
        :param pulumi.Input[_builtins.str] policy: 'allow' or 'deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if ip_ver is not None:
            pulumi.set(__self__, "ip_ver", ip_ver)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @dest_cidr.setter
    def dest_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_cidr", value)

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @dest_port.setter
    def dest_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_port", value)

    @_builtins.property
    @pulumi.getter(name="ipVer")
    def ip_ver(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip Ver
        """
        return pulumi.get(self, "ip_ver")

    @ip_ver.setter
    def ip_ver(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_ver", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class WirelessSsidsFirewallL3FirewallRulesRulesResponseArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the rule (optional)
        """
        dest_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        dest_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        ip_ver: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip Version
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'allow' or 'deny' traffic specified by this rule
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
elif False:
    WirelessSsidsFirewallL3FirewallRulesRulesResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsFirewallL3FirewallRulesRulesResponseArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_port: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_ver: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Description of the rule (optional)
        :param pulumi.Input[_builtins.str] dest_cidr: Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        :param pulumi.Input[_builtins.str] dest_port: Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        :param pulumi.Input[_builtins.str] ip_ver: Ip Version
        :param pulumi.Input[_builtins.str] policy: 'allow' or 'deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] protocol: The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if ip_ver is not None:
            pulumi.set(__self__, "ip_ver", ip_ver)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the rule (optional)
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
        """
        return pulumi.get(self, "dest_cidr")

    @dest_cidr.setter
    def dest_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_cidr", value)

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
        """
        return pulumi.get(self, "dest_port")

    @dest_port.setter
    def dest_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_port", value)

    @_builtins.property
    @pulumi.getter(name="ipVer")
    def ip_ver(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip Version
        """
        return pulumi.get(self, "ip_ver")

    @ip_ver.setter
    def ip_ver(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_ver", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'allow' or 'deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class WirelessSsidsFirewallL7FirewallRulesRuleArgsDict(TypedDict):
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        'Deny' traffic specified by this rule
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected.
        """
        value_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The 'value_list' of what you want to block. Send a list in request
        """
        value_obj: NotRequired[pulumi.Input['WirelessSsidsFirewallL7FirewallRulesRuleValueObjArgsDict']]
        """
        The 'value_obj' of what you want to block. Send a dict in request
        """
elif False:
    WirelessSsidsFirewallL7FirewallRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsFirewallL7FirewallRulesRuleArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 value_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 value_obj: Optional[pulumi.Input['WirelessSsidsFirewallL7FirewallRulesRuleValueObjArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] policy: 'Deny' traffic specified by this rule
        :param pulumi.Input[_builtins.str] type: Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        :param pulumi.Input[_builtins.str] value: The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] value_lists: The 'value_list' of what you want to block. Send a list in request
        :param pulumi.Input['WirelessSsidsFirewallL7FirewallRulesRuleValueObjArgs'] value_obj: The 'value_obj' of what you want to block. Send a dict in request
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)
        if value_obj is not None:
            pulumi.set(__self__, "value_obj", value_obj)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        'Deny' traffic specified by this rule
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The 'value_list' of what you want to block. Send a list in request
        """
        return pulumi.get(self, "value_lists")

    @value_lists.setter
    def value_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value_lists", value)

    @_builtins.property
    @pulumi.getter(name="valueObj")
    def value_obj(self) -> Optional[pulumi.Input['WirelessSsidsFirewallL7FirewallRulesRuleValueObjArgs']]:
        """
        The 'value_obj' of what you want to block. Send a dict in request
        """
        return pulumi.get(self, "value_obj")

    @value_obj.setter
    def value_obj(self, value: Optional[pulumi.Input['WirelessSsidsFirewallL7FirewallRulesRuleValueObjArgs']]):
        pulumi.set(self, "value_obj", value)


if not MYPY:
    class WirelessSsidsFirewallL7FirewallRulesRuleValueObjArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WirelessSsidsFirewallL7FirewallRulesRuleValueObjArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsFirewallL7FirewallRulesRuleValueObjArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessSsidsGreArgsDict(TypedDict):
        concentrator: NotRequired[pulumi.Input['WirelessSsidsGreConcentratorArgsDict']]
        """
        The EoGRE concentrator's settings
        """
        key: NotRequired[pulumi.Input[_builtins.int]]
        """
        Optional numerical identifier that will add the GRE key field to the GRE header. Used to identify an individual traffic flow within a tunnel.
        """
elif False:
    WirelessSsidsGreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsGreArgs:
    def __init__(__self__, *,
                 concentrator: Optional[pulumi.Input['WirelessSsidsGreConcentratorArgs']] = None,
                 key: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['WirelessSsidsGreConcentratorArgs'] concentrator: The EoGRE concentrator's settings
        :param pulumi.Input[_builtins.int] key: Optional numerical identifier that will add the GRE key field to the GRE header. Used to identify an individual traffic flow within a tunnel.
        """
        if concentrator is not None:
            pulumi.set(__self__, "concentrator", concentrator)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def concentrator(self) -> Optional[pulumi.Input['WirelessSsidsGreConcentratorArgs']]:
        """
        The EoGRE concentrator's settings
        """
        return pulumi.get(self, "concentrator")

    @concentrator.setter
    def concentrator(self, value: Optional[pulumi.Input['WirelessSsidsGreConcentratorArgs']]):
        pulumi.set(self, "concentrator", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Optional numerical identifier that will add the GRE key field to the GRE header. Used to identify an individual traffic flow within a tunnel.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class WirelessSsidsGreConcentratorArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EoGRE concentrator's IP or FQDN. This param is required when ipAssignmentMode is 'Ethernet over GRE'.
        """
elif False:
    WirelessSsidsGreConcentratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsGreConcentratorArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The EoGRE concentrator's IP or FQDN. This param is required when ipAssignmentMode is 'Ethernet over GRE'.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EoGRE concentrator's IP or FQDN. This param is required when ipAssignmentMode is 'Ethernet over GRE'.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class WirelessSsidsHotspot20MccMncArgsDict(TypedDict):
        mcc: NotRequired[pulumi.Input[_builtins.str]]
        """
        MCC value
        """
        mnc: NotRequired[pulumi.Input[_builtins.str]]
        """
        MNC value
        """
elif False:
    WirelessSsidsHotspot20MccMncArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsHotspot20MccMncArgs:
    def __init__(__self__, *,
                 mcc: Optional[pulumi.Input[_builtins.str]] = None,
                 mnc: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mcc: MCC value
        :param pulumi.Input[_builtins.str] mnc: MNC value
        """
        if mcc is not None:
            pulumi.set(__self__, "mcc", mcc)
        if mnc is not None:
            pulumi.set(__self__, "mnc", mnc)

    @_builtins.property
    @pulumi.getter
    def mcc(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        MCC value
        """
        return pulumi.get(self, "mcc")

    @mcc.setter
    def mcc(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mcc", value)

    @_builtins.property
    @pulumi.getter
    def mnc(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        MNC value
        """
        return pulumi.get(self, "mnc")

    @mnc.setter
    def mnc(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mnc", value)


if not MYPY:
    class WirelessSsidsHotspot20NaiRealmArgsDict(TypedDict):
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The format for the realm ('1' or '0')
        """
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsHotspot20NaiRealmMethodArgsDict']]]]
        """
        An array of EAP methods for the realm.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        realm: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the realm
        """
elif False:
    WirelessSsidsHotspot20NaiRealmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsHotspot20NaiRealmArgs:
    def __init__(__self__, *,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsHotspot20NaiRealmMethodArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 realm: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] format: The format for the realm ('1' or '0')
        :param pulumi.Input[Sequence[pulumi.Input['WirelessSsidsHotspot20NaiRealmMethodArgs']]] methods: An array of EAP methods for the realm.
        :param pulumi.Input[_builtins.str] realm: The name of the realm
        """
        if format is not None:
            pulumi.set(__self__, "format", format)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The format for the realm ('1' or '0')
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsHotspot20NaiRealmMethodArgs']]]]:
        """
        An array of EAP methods for the realm.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsHotspot20NaiRealmMethodArgs']]]]):
        pulumi.set(self, "methods", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def realm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the realm
        """
        return pulumi.get(self, "realm")

    @realm.setter
    def realm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "realm", value)


if not MYPY:
    class WirelessSsidsHotspot20NaiRealmMethodArgsDict(TypedDict):
        authentication_types: NotRequired[pulumi.Input['WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypesArgsDict']]
        """
        The authentication types for the method. These should be formatted as an object with the EAP method category in camelcase as the key and the list of types as the value (nonEapInnerAuthentication: Reserved, PAP, CHAP, MSCHAP, MSCHAPV2; eapInnerAuthentication: EAP-TLS, EAP-SIM, EAP-AKA, EAP-TTLS with MSCHAPv2; credentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, none, Reserved, Vendor Specific; tunneledEapMethodCredentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, Reserved, Anonymous, Vendor Specific)
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of method
        """
elif False:
    WirelessSsidsHotspot20NaiRealmMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsHotspot20NaiRealmMethodArgs:
    def __init__(__self__, *,
                 authentication_types: Optional[pulumi.Input['WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypesArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypesArgs'] authentication_types: The authentication types for the method. These should be formatted as an object with the EAP method category in camelcase as the key and the list of types as the value (nonEapInnerAuthentication: Reserved, PAP, CHAP, MSCHAP, MSCHAPV2; eapInnerAuthentication: EAP-TLS, EAP-SIM, EAP-AKA, EAP-TTLS with MSCHAPv2; credentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, none, Reserved, Vendor Specific; tunneledEapMethodCredentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, Reserved, Anonymous, Vendor Specific)
        :param pulumi.Input[_builtins.str] id: ID of method
        """
        if authentication_types is not None:
            pulumi.set(__self__, "authentication_types", authentication_types)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="authenticationTypes")
    def authentication_types(self) -> Optional[pulumi.Input['WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypesArgs']]:
        """
        The authentication types for the method. These should be formatted as an object with the EAP method category in camelcase as the key and the list of types as the value (nonEapInnerAuthentication: Reserved, PAP, CHAP, MSCHAP, MSCHAPV2; eapInnerAuthentication: EAP-TLS, EAP-SIM, EAP-AKA, EAP-TTLS with MSCHAPv2; credentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, none, Reserved, Vendor Specific; tunneledEapMethodCredentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, Reserved, Anonymous, Vendor Specific)
        """
        return pulumi.get(self, "authentication_types")

    @authentication_types.setter
    def authentication_types(self, value: Optional[pulumi.Input['WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypesArgs']]):
        pulumi.set(self, "authentication_types", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of method
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypesArgsDict(TypedDict):
        credentials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        eapinner_authentications: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        non_eapinner_authentications: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        tunneled_eap_method_credentials: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypesArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 eapinner_authentications: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 non_eapinner_authentications: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tunneled_eap_method_credentials: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if eapinner_authentications is not None:
            pulumi.set(__self__, "eapinner_authentications", eapinner_authentications)
        if non_eapinner_authentications is not None:
            pulumi.set(__self__, "non_eapinner_authentications", non_eapinner_authentications)
        if tunneled_eap_method_credentials is not None:
            pulumi.set(__self__, "tunneled_eap_method_credentials", tunneled_eap_method_credentials)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="eapinnerAuthentications")
    def eapinner_authentications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "eapinner_authentications")

    @eapinner_authentications.setter
    def eapinner_authentications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "eapinner_authentications", value)

    @_builtins.property
    @pulumi.getter(name="nonEapinnerAuthentications")
    def non_eapinner_authentications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "non_eapinner_authentications")

    @non_eapinner_authentications.setter
    def non_eapinner_authentications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "non_eapinner_authentications", value)

    @_builtins.property
    @pulumi.getter(name="tunneledEapMethodCredentials")
    def tunneled_eap_method_credentials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "tunneled_eap_method_credentials")

    @tunneled_eap_method_credentials.setter
    def tunneled_eap_method_credentials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tunneled_eap_method_credentials", value)


if not MYPY:
    class WirelessSsidsHotspot20OperatorArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operator name
        """
elif False:
    WirelessSsidsHotspot20OperatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsHotspot20OperatorArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Operator name
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operator name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessSsidsHotspot20VenueArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Venue name
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Venue type ('Unspecified', 'Unspecified Assembly', 'Arena', 'Stadium', 'Passenger Terminal', 'Amphitheater', 'Amusement Park', 'Place of Worship', 'Convention Center', 'Library', 'Museum', 'Restaurant', 'Theater', 'Bar', 'Coffee Shop', 'Zoo or Aquarium', 'Emergency Coordination Center', 'Unspecified Business', 'Doctor or Dentist office', 'Bank', 'Fire Station', 'Police Station', 'Post Office', 'Professional Office', 'Research and Development Facility', 'Attorney Office', 'Unspecified Educational', 'School, Primary', 'School, Secondary', 'University or College', 'Unspecified Factory and Industrial', 'Factory', 'Unspecified Institutional', 'Hospital', 'Long-Term Care Facility', 'Alcohol and Drug Rehabilitation Center', 'Group Home', 'Prison or Jail', 'Unspecified Mercantile', 'Retail Store', 'Grocery Market', 'Automotive Service Station', 'Shopping Mall', 'Gas Station', 'Unspecified Residential', 'Private Residence', 'Hotel or Motel', 'Dormitory', 'Boarding House', 'Unspecified Storage', 'Unspecified Utility and Miscellaneous', 'Unspecified Vehicular', 'Automobile or Truck', 'Airplane', 'Bus', 'Ferry', 'Ship or Boat', 'Train', 'Motor Bike', 'Unspecified Outdoor', 'Muni-mesh Network', 'City Park', 'Rest Area', 'Traffic Control', 'Bus Stop', 'Kiosk')
        """
elif False:
    WirelessSsidsHotspot20VenueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsHotspot20VenueArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Venue name
        :param pulumi.Input[_builtins.str] type: Venue type ('Unspecified', 'Unspecified Assembly', 'Arena', 'Stadium', 'Passenger Terminal', 'Amphitheater', 'Amusement Park', 'Place of Worship', 'Convention Center', 'Library', 'Museum', 'Restaurant', 'Theater', 'Bar', 'Coffee Shop', 'Zoo or Aquarium', 'Emergency Coordination Center', 'Unspecified Business', 'Doctor or Dentist office', 'Bank', 'Fire Station', 'Police Station', 'Post Office', 'Professional Office', 'Research and Development Facility', 'Attorney Office', 'Unspecified Educational', 'School, Primary', 'School, Secondary', 'University or College', 'Unspecified Factory and Industrial', 'Factory', 'Unspecified Institutional', 'Hospital', 'Long-Term Care Facility', 'Alcohol and Drug Rehabilitation Center', 'Group Home', 'Prison or Jail', 'Unspecified Mercantile', 'Retail Store', 'Grocery Market', 'Automotive Service Station', 'Shopping Mall', 'Gas Station', 'Unspecified Residential', 'Private Residence', 'Hotel or Motel', 'Dormitory', 'Boarding House', 'Unspecified Storage', 'Unspecified Utility and Miscellaneous', 'Unspecified Vehicular', 'Automobile or Truck', 'Airplane', 'Bus', 'Ferry', 'Ship or Boat', 'Train', 'Motor Bike', 'Unspecified Outdoor', 'Muni-mesh Network', 'City Park', 'Rest Area', 'Traffic Control', 'Bus Stop', 'Kiosk')
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Venue name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Venue type ('Unspecified', 'Unspecified Assembly', 'Arena', 'Stadium', 'Passenger Terminal', 'Amphitheater', 'Amusement Park', 'Place of Worship', 'Convention Center', 'Library', 'Museum', 'Restaurant', 'Theater', 'Bar', 'Coffee Shop', 'Zoo or Aquarium', 'Emergency Coordination Center', 'Unspecified Business', 'Doctor or Dentist office', 'Bank', 'Fire Station', 'Police Station', 'Post Office', 'Professional Office', 'Research and Development Facility', 'Attorney Office', 'Unspecified Educational', 'School, Primary', 'School, Secondary', 'University or College', 'Unspecified Factory and Industrial', 'Factory', 'Unspecified Institutional', 'Hospital', 'Long-Term Care Facility', 'Alcohol and Drug Rehabilitation Center', 'Group Home', 'Prison or Jail', 'Unspecified Mercantile', 'Retail Store', 'Grocery Market', 'Automotive Service Station', 'Shopping Mall', 'Gas Station', 'Unspecified Residential', 'Private Residence', 'Hotel or Motel', 'Dormitory', 'Boarding House', 'Unspecified Storage', 'Unspecified Utility and Miscellaneous', 'Unspecified Vehicular', 'Automobile or Truck', 'Airplane', 'Bus', 'Ferry', 'Ship or Boat', 'Train', 'Motor Bike', 'Unspecified Outdoor', 'Muni-mesh Network', 'City Park', 'Rest Area', 'Traffic Control', 'Bus Stop', 'Kiosk')
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WirelessSsidsLdapArgsDict(TypedDict):
        base_distinguished_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base distinguished name of users on the LDAP server.
        """
        credentials: NotRequired[pulumi.Input['WirelessSsidsLdapCredentialsArgsDict']]
        """
        (Optional) The credentials of the user account to be used by the AP to bind to your LDAP server. The LDAP account should have permissions on all your LDAP servers.
        """
        server_ca_certificate: NotRequired[pulumi.Input['WirelessSsidsLdapServerCaCertificateArgsDict']]
        """
        The CA certificate used to sign the LDAP server's key.
        """
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsLdapServerArgsDict']]]]
        """
        The LDAP servers to be used for authentication.
        """
elif False:
    WirelessSsidsLdapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsLdapArgs:
    def __init__(__self__, *,
                 base_distinguished_name: Optional[pulumi.Input[_builtins.str]] = None,
                 credentials: Optional[pulumi.Input['WirelessSsidsLdapCredentialsArgs']] = None,
                 server_ca_certificate: Optional[pulumi.Input['WirelessSsidsLdapServerCaCertificateArgs']] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsLdapServerArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] base_distinguished_name: The base distinguished name of users on the LDAP server.
        :param pulumi.Input['WirelessSsidsLdapCredentialsArgs'] credentials: (Optional) The credentials of the user account to be used by the AP to bind to your LDAP server. The LDAP account should have permissions on all your LDAP servers.
        :param pulumi.Input['WirelessSsidsLdapServerCaCertificateArgs'] server_ca_certificate: The CA certificate used to sign the LDAP server's key.
        :param pulumi.Input[Sequence[pulumi.Input['WirelessSsidsLdapServerArgs']]] servers: The LDAP servers to be used for authentication.
        """
        if base_distinguished_name is not None:
            pulumi.set(__self__, "base_distinguished_name", base_distinguished_name)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if server_ca_certificate is not None:
            pulumi.set(__self__, "server_ca_certificate", server_ca_certificate)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @_builtins.property
    @pulumi.getter(name="baseDistinguishedName")
    def base_distinguished_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base distinguished name of users on the LDAP server.
        """
        return pulumi.get(self, "base_distinguished_name")

    @base_distinguished_name.setter
    def base_distinguished_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "base_distinguished_name", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['WirelessSsidsLdapCredentialsArgs']]:
        """
        (Optional) The credentials of the user account to be used by the AP to bind to your LDAP server. The LDAP account should have permissions on all your LDAP servers.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['WirelessSsidsLdapCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="serverCaCertificate")
    def server_ca_certificate(self) -> Optional[pulumi.Input['WirelessSsidsLdapServerCaCertificateArgs']]:
        """
        The CA certificate used to sign the LDAP server's key.
        """
        return pulumi.get(self, "server_ca_certificate")

    @server_ca_certificate.setter
    def server_ca_certificate(self, value: Optional[pulumi.Input['WirelessSsidsLdapServerCaCertificateArgs']]):
        pulumi.set(self, "server_ca_certificate", value)

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsLdapServerArgs']]]]:
        """
        The LDAP servers to be used for authentication.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsLdapServerArgs']]]]):
        pulumi.set(self, "servers", value)


if not MYPY:
    class WirelessSsidsLdapCredentialsArgsDict(TypedDict):
        distinguished_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The distinguished name of the LDAP user account (example: cn=user,dc=meraki,dc=com).
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password of the LDAP user account.
        """
elif False:
    WirelessSsidsLdapCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsLdapCredentialsArgs:
    def __init__(__self__, *,
                 distinguished_name: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] distinguished_name: The distinguished name of the LDAP user account (example: cn=user,dc=meraki,dc=com).
        :param pulumi.Input[_builtins.str] password: The password of the LDAP user account.
        """
        if distinguished_name is not None:
            pulumi.set(__self__, "distinguished_name", distinguished_name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="distinguishedName")
    def distinguished_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The distinguished name of the LDAP user account (example: cn=user,dc=meraki,dc=com).
        """
        return pulumi.get(self, "distinguished_name")

    @distinguished_name.setter
    def distinguished_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "distinguished_name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password of the LDAP user account.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class WirelessSsidsLdapServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address (or FQDN) of your LDAP server.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        UDP port the LDAP server listens on.
        """
elif False:
    WirelessSsidsLdapServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsLdapServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] host: IP address (or FQDN) of your LDAP server.
        :param pulumi.Input[_builtins.int] port: UDP port the LDAP server listens on.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address (or FQDN) of your LDAP server.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        UDP port the LDAP server listens on.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class WirelessSsidsLdapServerCaCertificateArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contents of the CA certificate. Must be in PEM or DER format.
        """
elif False:
    WirelessSsidsLdapServerCaCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsLdapServerCaCertificateArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contents: The contents of the CA certificate. Must be in PEM or DER format.
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contents of the CA certificate. Must be in PEM or DER format.
        """
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contents", value)


if not MYPY:
    class WirelessSsidsLocalRadiusArgsDict(TypedDict):
        cache_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration (in seconds) for which LDAP and OCSP lookups are cached.
        """
        certificate_authentication: NotRequired[pulumi.Input['WirelessSsidsLocalRadiusCertificateAuthenticationArgsDict']]
        """
        The current setting for certificate verification.
        """
        password_authentication: NotRequired[pulumi.Input['WirelessSsidsLocalRadiusPasswordAuthenticationArgsDict']]
        """
        The current setting for password-based authentication.
        """
elif False:
    WirelessSsidsLocalRadiusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsLocalRadiusArgs:
    def __init__(__self__, *,
                 cache_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 certificate_authentication: Optional[pulumi.Input['WirelessSsidsLocalRadiusCertificateAuthenticationArgs']] = None,
                 password_authentication: Optional[pulumi.Input['WirelessSsidsLocalRadiusPasswordAuthenticationArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] cache_timeout: The duration (in seconds) for which LDAP and OCSP lookups are cached.
        :param pulumi.Input['WirelessSsidsLocalRadiusCertificateAuthenticationArgs'] certificate_authentication: The current setting for certificate verification.
        :param pulumi.Input['WirelessSsidsLocalRadiusPasswordAuthenticationArgs'] password_authentication: The current setting for password-based authentication.
        """
        if cache_timeout is not None:
            pulumi.set(__self__, "cache_timeout", cache_timeout)
        if certificate_authentication is not None:
            pulumi.set(__self__, "certificate_authentication", certificate_authentication)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)

    @_builtins.property
    @pulumi.getter(name="cacheTimeout")
    def cache_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration (in seconds) for which LDAP and OCSP lookups are cached.
        """
        return pulumi.get(self, "cache_timeout")

    @cache_timeout.setter
    def cache_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cache_timeout", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthentication")
    def certificate_authentication(self) -> Optional[pulumi.Input['WirelessSsidsLocalRadiusCertificateAuthenticationArgs']]:
        """
        The current setting for certificate verification.
        """
        return pulumi.get(self, "certificate_authentication")

    @certificate_authentication.setter
    def certificate_authentication(self, value: Optional[pulumi.Input['WirelessSsidsLocalRadiusCertificateAuthenticationArgs']]):
        pulumi.set(self, "certificate_authentication", value)

    @_builtins.property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['WirelessSsidsLocalRadiusPasswordAuthenticationArgs']]:
        """
        The current setting for password-based authentication.
        """
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['WirelessSsidsLocalRadiusPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)


if not MYPY:
    class WirelessSsidsLocalRadiusCertificateAuthenticationArgsDict(TypedDict):
        client_root_ca_certificate: NotRequired[pulumi.Input['WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificateArgsDict']]
        """
        The Client CA Certificate used to sign the client certificate.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to use EAP-TLS certificate-based authentication to validate wireless clients.
        """
        ocsp_responder_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional) The URL of the OCSP responder to verify client certificate status.
        """
        use_ldap: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to verify the certificate with LDAP.
        """
        use_ocsp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to verify the certificate with OCSP.
        """
elif False:
    WirelessSsidsLocalRadiusCertificateAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsLocalRadiusCertificateAuthenticationArgs:
    def __init__(__self__, *,
                 client_root_ca_certificate: Optional[pulumi.Input['WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificateArgs']] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 ocsp_responder_url: Optional[pulumi.Input[_builtins.str]] = None,
                 use_ldap: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_ocsp: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificateArgs'] client_root_ca_certificate: The Client CA Certificate used to sign the client certificate.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not to use EAP-TLS certificate-based authentication to validate wireless clients.
        :param pulumi.Input[_builtins.str] ocsp_responder_url: (Optional) The URL of the OCSP responder to verify client certificate status.
        :param pulumi.Input[_builtins.bool] use_ldap: Whether or not to verify the certificate with LDAP.
        :param pulumi.Input[_builtins.bool] use_ocsp: Whether or not to verify the certificate with OCSP.
        """
        if client_root_ca_certificate is not None:
            pulumi.set(__self__, "client_root_ca_certificate", client_root_ca_certificate)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if ocsp_responder_url is not None:
            pulumi.set(__self__, "ocsp_responder_url", ocsp_responder_url)
        if use_ldap is not None:
            pulumi.set(__self__, "use_ldap", use_ldap)
        if use_ocsp is not None:
            pulumi.set(__self__, "use_ocsp", use_ocsp)

    @_builtins.property
    @pulumi.getter(name="clientRootCaCertificate")
    def client_root_ca_certificate(self) -> Optional[pulumi.Input['WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificateArgs']]:
        """
        The Client CA Certificate used to sign the client certificate.
        """
        return pulumi.get(self, "client_root_ca_certificate")

    @client_root_ca_certificate.setter
    def client_root_ca_certificate(self, value: Optional[pulumi.Input['WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificateArgs']]):
        pulumi.set(self, "client_root_ca_certificate", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to use EAP-TLS certificate-based authentication to validate wireless clients.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="ocspResponderUrl")
    def ocsp_responder_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional) The URL of the OCSP responder to verify client certificate status.
        """
        return pulumi.get(self, "ocsp_responder_url")

    @ocsp_responder_url.setter
    def ocsp_responder_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ocsp_responder_url", value)

    @_builtins.property
    @pulumi.getter(name="useLdap")
    def use_ldap(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to verify the certificate with LDAP.
        """
        return pulumi.get(self, "use_ldap")

    @use_ldap.setter
    def use_ldap(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_ldap", value)

    @_builtins.property
    @pulumi.getter(name="useOcsp")
    def use_ocsp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to verify the certificate with OCSP.
        """
        return pulumi.get(self, "use_ocsp")

    @use_ocsp.setter
    def use_ocsp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_ocsp", value)


if not MYPY:
    class WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificateArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contents of the Client CA Certificate. Must be in PEM or DER format.
        """
elif False:
    WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificateArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contents: The contents of the Client CA Certificate. Must be in PEM or DER format.
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contents of the Client CA Certificate. Must be in PEM or DER format.
        """
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contents", value)


if not MYPY:
    class WirelessSsidsLocalRadiusPasswordAuthenticationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to use EAP-TTLS/PAP or PEAP-GTC password-based authentication via LDAP lookup.
        """
elif False:
    WirelessSsidsLocalRadiusPasswordAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsLocalRadiusPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether or not to use EAP-TTLS/PAP or PEAP-GTC password-based authentication via LDAP lookup.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to use EAP-TTLS/PAP or PEAP-GTC password-based authentication via LDAP lookup.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WirelessSsidsNamedVlansArgsDict(TypedDict):
        radius: NotRequired[pulumi.Input['WirelessSsidsNamedVlansRadiusArgsDict']]
        """
        RADIUS settings. This param is only valid when authMode is 'open-with-radius' and ipAssignmentMode is not 'NAT mode'.
        """
        tagging: NotRequired[pulumi.Input['WirelessSsidsNamedVlansTaggingArgsDict']]
        """
        VLAN tagging settings. This param is only valid when ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'.
        """
elif False:
    WirelessSsidsNamedVlansArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsNamedVlansArgs:
    def __init__(__self__, *,
                 radius: Optional[pulumi.Input['WirelessSsidsNamedVlansRadiusArgs']] = None,
                 tagging: Optional[pulumi.Input['WirelessSsidsNamedVlansTaggingArgs']] = None):
        """
        :param pulumi.Input['WirelessSsidsNamedVlansRadiusArgs'] radius: RADIUS settings. This param is only valid when authMode is 'open-with-radius' and ipAssignmentMode is not 'NAT mode'.
        :param pulumi.Input['WirelessSsidsNamedVlansTaggingArgs'] tagging: VLAN tagging settings. This param is only valid when ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'.
        """
        if radius is not None:
            pulumi.set(__self__, "radius", radius)
        if tagging is not None:
            pulumi.set(__self__, "tagging", tagging)

    @_builtins.property
    @pulumi.getter
    def radius(self) -> Optional[pulumi.Input['WirelessSsidsNamedVlansRadiusArgs']]:
        """
        RADIUS settings. This param is only valid when authMode is 'open-with-radius' and ipAssignmentMode is not 'NAT mode'.
        """
        return pulumi.get(self, "radius")

    @radius.setter
    def radius(self, value: Optional[pulumi.Input['WirelessSsidsNamedVlansRadiusArgs']]):
        pulumi.set(self, "radius", value)

    @_builtins.property
    @pulumi.getter
    def tagging(self) -> Optional[pulumi.Input['WirelessSsidsNamedVlansTaggingArgs']]:
        """
        VLAN tagging settings. This param is only valid when ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'.
        """
        return pulumi.get(self, "tagging")

    @tagging.setter
    def tagging(self, value: Optional[pulumi.Input['WirelessSsidsNamedVlansTaggingArgs']]):
        pulumi.set(self, "tagging", value)


if not MYPY:
    class WirelessSsidsNamedVlansRadiusArgsDict(TypedDict):
        guest_vlan: NotRequired[pulumi.Input['WirelessSsidsNamedVlansRadiusGuestVlanArgsDict']]
        """
        Guest VLAN settings. Used to direct traffic to a guest VLAN when none of the RADIUS servers are reachable or a client receives access-reject from the RADIUS server.
        """
elif False:
    WirelessSsidsNamedVlansRadiusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsNamedVlansRadiusArgs:
    def __init__(__self__, *,
                 guest_vlan: Optional[pulumi.Input['WirelessSsidsNamedVlansRadiusGuestVlanArgs']] = None):
        """
        :param pulumi.Input['WirelessSsidsNamedVlansRadiusGuestVlanArgs'] guest_vlan: Guest VLAN settings. Used to direct traffic to a guest VLAN when none of the RADIUS servers are reachable or a client receives access-reject from the RADIUS server.
        """
        if guest_vlan is not None:
            pulumi.set(__self__, "guest_vlan", guest_vlan)

    @_builtins.property
    @pulumi.getter(name="guestVlan")
    def guest_vlan(self) -> Optional[pulumi.Input['WirelessSsidsNamedVlansRadiusGuestVlanArgs']]:
        """
        Guest VLAN settings. Used to direct traffic to a guest VLAN when none of the RADIUS servers are reachable or a client receives access-reject from the RADIUS server.
        """
        return pulumi.get(self, "guest_vlan")

    @guest_vlan.setter
    def guest_vlan(self, value: Optional[pulumi.Input['WirelessSsidsNamedVlansRadiusGuestVlanArgs']]):
        pulumi.set(self, "guest_vlan", value)


if not MYPY:
    class WirelessSsidsNamedVlansRadiusGuestVlanArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not RADIUS guest named VLAN is enabled.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        RADIUS guest VLAN name.
        """
elif False:
    WirelessSsidsNamedVlansRadiusGuestVlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsNamedVlansRadiusGuestVlanArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether or not RADIUS guest named VLAN is enabled.
        :param pulumi.Input[_builtins.str] name: RADIUS guest VLAN name.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not RADIUS guest named VLAN is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RADIUS guest VLAN name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WirelessSsidsNamedVlansTaggingArgsDict(TypedDict):
        by_ap_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsNamedVlansTaggingByApTagArgsDict']]]]
        """
        The list of AP tags and VLAN names used for named VLAN tagging. If an AP has a tag matching one in the list, then traffic on this SSID will be directed to use the VLAN name associated to the tag.
        """
        default_vlan_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default VLAN name used to tag traffic in the absence of a matching AP tag.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not traffic should be directed to use specific VLAN names.
        """
elif False:
    WirelessSsidsNamedVlansTaggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsNamedVlansTaggingArgs:
    def __init__(__self__, *,
                 by_ap_tags: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsNamedVlansTaggingByApTagArgs']]]] = None,
                 default_vlan_name: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WirelessSsidsNamedVlansTaggingByApTagArgs']]] by_ap_tags: The list of AP tags and VLAN names used for named VLAN tagging. If an AP has a tag matching one in the list, then traffic on this SSID will be directed to use the VLAN name associated to the tag.
        :param pulumi.Input[_builtins.str] default_vlan_name: The default VLAN name used to tag traffic in the absence of a matching AP tag.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not traffic should be directed to use specific VLAN names.
        """
        if by_ap_tags is not None:
            pulumi.set(__self__, "by_ap_tags", by_ap_tags)
        if default_vlan_name is not None:
            pulumi.set(__self__, "default_vlan_name", default_vlan_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="byApTags")
    def by_ap_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsNamedVlansTaggingByApTagArgs']]]]:
        """
        The list of AP tags and VLAN names used for named VLAN tagging. If an AP has a tag matching one in the list, then traffic on this SSID will be directed to use the VLAN name associated to the tag.
        """
        return pulumi.get(self, "by_ap_tags")

    @by_ap_tags.setter
    def by_ap_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsNamedVlansTaggingByApTagArgs']]]]):
        pulumi.set(self, "by_ap_tags", value)

    @_builtins.property
    @pulumi.getter(name="defaultVlanName")
    def default_vlan_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default VLAN name used to tag traffic in the absence of a matching AP tag.
        """
        return pulumi.get(self, "default_vlan_name")

    @default_vlan_name.setter
    def default_vlan_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_vlan_name", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not traffic should be directed to use specific VLAN names.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WirelessSsidsNamedVlansTaggingByApTagArgsDict(TypedDict):
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of AP tags.
        """
        vlan_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        VLAN name that will be used to tag traffic.
        """
elif False:
    WirelessSsidsNamedVlansTaggingByApTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsNamedVlansTaggingByApTagArgs:
    def __init__(__self__, *,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vlan_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: List of AP tags.
        :param pulumi.Input[_builtins.str] vlan_name: VLAN name that will be used to tag traffic.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of AP tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VLAN name that will be used to tag traffic.
        """
        return pulumi.get(self, "vlan_name")

    @vlan_name.setter
    def vlan_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vlan_name", value)


if not MYPY:
    class WirelessSsidsOauthArgsDict(TypedDict):
        allowed_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Optional) The list of domains allowed access to the network.
        """
elif False:
    WirelessSsidsOauthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsOauthArgs:
    def __init__(__self__, *,
                 allowed_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_domains: (Optional) The list of domains allowed access to the network.
        """
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)

    @_builtins.property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Optional) The list of domains allowed access to the network.
        """
        return pulumi.get(self, "allowed_domains")

    @allowed_domains.setter
    def allowed_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_domains", value)


if not MYPY:
    class WirelessSsidsRadiusAccountingServerArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate used for authorization for the RADSEC Server
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address (or FQDN) to which the APs will send RADIUS accounting messages
        """
        open_roaming_certificate_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the Openroaming Certificate attached to radius server
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port on the RADIUS server that is listening for accounting messages
        """
        radsec_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Shared key used to authenticate messages between the APs and RADIUS server
        """
elif False:
    WirelessSsidsRadiusAccountingServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsRadiusAccountingServerArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 open_roaming_certificate_id: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 radsec_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ca_certificate: Certificate used for authorization for the RADSEC Server
        :param pulumi.Input[_builtins.str] host: IP address (or FQDN) to which the APs will send RADIUS accounting messages
        :param pulumi.Input[_builtins.int] open_roaming_certificate_id: The ID of the Openroaming Certificate attached to radius server
        :param pulumi.Input[_builtins.int] port: Port on the RADIUS server that is listening for accounting messages
        :param pulumi.Input[_builtins.bool] radsec_enabled: Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
        :param pulumi.Input[_builtins.str] secret: Shared key used to authenticate messages between the APs and RADIUS server
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if open_roaming_certificate_id is not None:
            pulumi.set(__self__, "open_roaming_certificate_id", open_roaming_certificate_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if radsec_enabled is not None:
            pulumi.set(__self__, "radsec_enabled", radsec_enabled)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate used for authorization for the RADSEC Server
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_certificate", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address (or FQDN) to which the APs will send RADIUS accounting messages
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="openRoamingCertificateId")
    def open_roaming_certificate_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the Openroaming Certificate attached to radius server
        """
        return pulumi.get(self, "open_roaming_certificate_id")

    @open_roaming_certificate_id.setter
    def open_roaming_certificate_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "open_roaming_certificate_id", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port on the RADIUS server that is listening for accounting messages
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="radsecEnabled")
    def radsec_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
        """
        return pulumi.get(self, "radsec_enabled")

    @radsec_enabled.setter
    def radsec_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "radsec_enabled", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Shared key used to authenticate messages between the APs and RADIUS server
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class WirelessSsidsRadiusAccountingServersResponseArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate used for authorization for the RADSEC Server
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address (or FQDN) to which the APs will send RADIUS accounting messages
        """
        open_roaming_certificate_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the Openroaming Certificate attached to radius server
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port on the RADIUS server that is listening for accounting messages
        """
        radsec_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Shared key used to authenticate messages between the APs and RADIUS server
        """
elif False:
    WirelessSsidsRadiusAccountingServersResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsRadiusAccountingServersResponseArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 open_roaming_certificate_id: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 radsec_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ca_certificate: Certificate used for authorization for the RADSEC Server
        :param pulumi.Input[_builtins.str] host: IP address (or FQDN) to which the APs will send RADIUS accounting messages
        :param pulumi.Input[_builtins.int] open_roaming_certificate_id: The ID of the Openroaming Certificate attached to radius server
        :param pulumi.Input[_builtins.int] port: Port on the RADIUS server that is listening for accounting messages
        :param pulumi.Input[_builtins.bool] radsec_enabled: Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
        :param pulumi.Input[_builtins.str] secret: Shared key used to authenticate messages between the APs and RADIUS server
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if open_roaming_certificate_id is not None:
            pulumi.set(__self__, "open_roaming_certificate_id", open_roaming_certificate_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if radsec_enabled is not None:
            pulumi.set(__self__, "radsec_enabled", radsec_enabled)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate used for authorization for the RADSEC Server
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_certificate", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address (or FQDN) to which the APs will send RADIUS accounting messages
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="openRoamingCertificateId")
    def open_roaming_certificate_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the Openroaming Certificate attached to radius server
        """
        return pulumi.get(self, "open_roaming_certificate_id")

    @open_roaming_certificate_id.setter
    def open_roaming_certificate_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "open_roaming_certificate_id", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port on the RADIUS server that is listening for accounting messages
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="radsecEnabled")
    def radsec_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
        """
        return pulumi.get(self, "radsec_enabled")

    @radsec_enabled.setter
    def radsec_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "radsec_enabled", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Shared key used to authenticate messages between the APs and RADIUS server
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class WirelessSsidsRadiusServerArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate used for authorization for the RADSEC Server
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address of your RADIUS server
        """
        open_roaming_certificate_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the Openroaming Certificate attached to radius server.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        UDP port the RADIUS server listens on for Access-requests
        """
        radsec_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        RADIUS client shared secret
        """
elif False:
    WirelessSsidsRadiusServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsRadiusServerArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 open_roaming_certificate_id: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 radsec_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ca_certificate: Certificate used for authorization for the RADSEC Server
        :param pulumi.Input[_builtins.str] host: IP address of your RADIUS server
        :param pulumi.Input[_builtins.int] open_roaming_certificate_id: The ID of the Openroaming Certificate attached to radius server.
        :param pulumi.Input[_builtins.int] port: UDP port the RADIUS server listens on for Access-requests
        :param pulumi.Input[_builtins.bool] radsec_enabled: Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
        :param pulumi.Input[_builtins.str] secret: RADIUS client shared secret
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if open_roaming_certificate_id is not None:
            pulumi.set(__self__, "open_roaming_certificate_id", open_roaming_certificate_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if radsec_enabled is not None:
            pulumi.set(__self__, "radsec_enabled", radsec_enabled)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate used for authorization for the RADSEC Server
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_certificate", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address of your RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="openRoamingCertificateId")
    def open_roaming_certificate_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the Openroaming Certificate attached to radius server.
        """
        return pulumi.get(self, "open_roaming_certificate_id")

    @open_roaming_certificate_id.setter
    def open_roaming_certificate_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "open_roaming_certificate_id", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        UDP port the RADIUS server listens on for Access-requests
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="radsecEnabled")
    def radsec_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
        """
        return pulumi.get(self, "radsec_enabled")

    @radsec_enabled.setter
    def radsec_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "radsec_enabled", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RADIUS client shared secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class WirelessSsidsRadiusServersResponseArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate used for authorization for the RADSEC Server
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address of your RADIUS server
        """
        open_roaming_certificate_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the Openroaming Certificate attached to radius server.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        UDP port the RADIUS server listens on for Access-requests
        """
        radsec_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        RADIUS client shared secret
        """
elif False:
    WirelessSsidsRadiusServersResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsRadiusServersResponseArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 open_roaming_certificate_id: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 radsec_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ca_certificate: Certificate used for authorization for the RADSEC Server
        :param pulumi.Input[_builtins.str] host: IP address of your RADIUS server
        :param pulumi.Input[_builtins.int] open_roaming_certificate_id: The ID of the Openroaming Certificate attached to radius server.
        :param pulumi.Input[_builtins.int] port: UDP port the RADIUS server listens on for Access-requests
        :param pulumi.Input[_builtins.bool] radsec_enabled: Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
        :param pulumi.Input[_builtins.str] secret: RADIUS client shared secret
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if open_roaming_certificate_id is not None:
            pulumi.set(__self__, "open_roaming_certificate_id", open_roaming_certificate_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if radsec_enabled is not None:
            pulumi.set(__self__, "radsec_enabled", radsec_enabled)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate used for authorization for the RADSEC Server
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_certificate", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address of your RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="openRoamingCertificateId")
    def open_roaming_certificate_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the Openroaming Certificate attached to radius server.
        """
        return pulumi.get(self, "open_roaming_certificate_id")

    @open_roaming_certificate_id.setter
    def open_roaming_certificate_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "open_roaming_certificate_id", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        UDP port the RADIUS server listens on for Access-requests
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="radsecEnabled")
    def radsec_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
        """
        return pulumi.get(self, "radsec_enabled")

    @radsec_enabled.setter
    def radsec_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "radsec_enabled", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RADIUS client shared secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class WirelessSsidsSchedulesRangeArgsDict(TypedDict):
        end_day: NotRequired[pulumi.Input[_builtins.str]]
        """
        Day of when the outage ends. Can be either full day name, or three letter abbreviation
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        24 hour time when the outage ends.
        """
        start_day: NotRequired[pulumi.Input[_builtins.str]]
        """
        Day of when the outage starts. Can be either full day name, or three letter abbreviation.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        24 hour time when the outage starts.
        """
elif False:
    WirelessSsidsSchedulesRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSchedulesRangeArgs:
    def __init__(__self__, *,
                 end_day: Optional[pulumi.Input[_builtins.str]] = None,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 start_day: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] end_day: Day of when the outage ends. Can be either full day name, or three letter abbreviation
        :param pulumi.Input[_builtins.str] end_time: 24 hour time when the outage ends.
        :param pulumi.Input[_builtins.str] start_day: Day of when the outage starts. Can be either full day name, or three letter abbreviation.
        :param pulumi.Input[_builtins.str] start_time: 24 hour time when the outage starts.
        """
        if end_day is not None:
            pulumi.set(__self__, "end_day", end_day)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_day is not None:
            pulumi.set(__self__, "start_day", start_day)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endDay")
    def end_day(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Day of when the outage ends. Can be either full day name, or three letter abbreviation
        """
        return pulumi.get(self, "end_day")

    @end_day.setter
    def end_day(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_day", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        24 hour time when the outage ends.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startDay")
    def start_day(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Day of when the outage starts. Can be either full day name, or three letter abbreviation.
        """
        return pulumi.get(self, "start_day")

    @start_day.setter
    def start_day(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_day", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        24 hour time when the outage starts.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class WirelessSsidsSchedulesRangesInSecondArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[_builtins.int]]
        """
        Seconds since Sunday at midnight when that outage range ends.
        """
        start: NotRequired[pulumi.Input[_builtins.int]]
        """
        Seconds since Sunday at midnight when the outage range starts.
        """
elif False:
    WirelessSsidsSchedulesRangesInSecondArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSchedulesRangesInSecondArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[_builtins.int]] = None,
                 start: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] end: Seconds since Sunday at midnight when that outage range ends.
        :param pulumi.Input[_builtins.int] start: Seconds since Sunday at midnight when the outage range starts.
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Seconds since Sunday at midnight when that outage range ends.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Seconds since Sunday at midnight when the outage range starts.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class WirelessSsidsSpeedBurstArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean indicating whether or not to allow users to temporarily exceed the bandwidth limit for short periods while still keeping them under the bandwidth limit over time.
        """
elif False:
    WirelessSsidsSpeedBurstArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSpeedBurstArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Boolean indicating whether or not to allow users to temporarily exceed the bandwidth limit for short periods while still keeping them under the bandwidth limit over time.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean indicating whether or not to allow users to temporarily exceed the bandwidth limit for short periods while still keeping them under the bandwidth limit over time.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WirelessSsidsSplashSettingsBillingArgsDict(TypedDict):
        free_access: NotRequired[pulumi.Input['WirelessSsidsSplashSettingsBillingFreeAccessArgsDict']]
        """
        Details associated with a free access plan with limits
        """
        prepaid_access_fast_login_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not billing uses the fast login prepaid access option.
        """
        reply_to_email_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The email address that reeceives replies from clients
        """
elif False:
    WirelessSsidsSplashSettingsBillingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSplashSettingsBillingArgs:
    def __init__(__self__, *,
                 free_access: Optional[pulumi.Input['WirelessSsidsSplashSettingsBillingFreeAccessArgs']] = None,
                 prepaid_access_fast_login_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 reply_to_email_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['WirelessSsidsSplashSettingsBillingFreeAccessArgs'] free_access: Details associated with a free access plan with limits
        :param pulumi.Input[_builtins.bool] prepaid_access_fast_login_enabled: Whether or not billing uses the fast login prepaid access option.
        :param pulumi.Input[_builtins.str] reply_to_email_address: The email address that reeceives replies from clients
        """
        if free_access is not None:
            pulumi.set(__self__, "free_access", free_access)
        if prepaid_access_fast_login_enabled is not None:
            pulumi.set(__self__, "prepaid_access_fast_login_enabled", prepaid_access_fast_login_enabled)
        if reply_to_email_address is not None:
            pulumi.set(__self__, "reply_to_email_address", reply_to_email_address)

    @_builtins.property
    @pulumi.getter(name="freeAccess")
    def free_access(self) -> Optional[pulumi.Input['WirelessSsidsSplashSettingsBillingFreeAccessArgs']]:
        """
        Details associated with a free access plan with limits
        """
        return pulumi.get(self, "free_access")

    @free_access.setter
    def free_access(self, value: Optional[pulumi.Input['WirelessSsidsSplashSettingsBillingFreeAccessArgs']]):
        pulumi.set(self, "free_access", value)

    @_builtins.property
    @pulumi.getter(name="prepaidAccessFastLoginEnabled")
    def prepaid_access_fast_login_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not billing uses the fast login prepaid access option.
        """
        return pulumi.get(self, "prepaid_access_fast_login_enabled")

    @prepaid_access_fast_login_enabled.setter
    def prepaid_access_fast_login_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "prepaid_access_fast_login_enabled", value)

    @_builtins.property
    @pulumi.getter(name="replyToEmailAddress")
    def reply_to_email_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The email address that reeceives replies from clients
        """
        return pulumi.get(self, "reply_to_email_address")

    @reply_to_email_address.setter
    def reply_to_email_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reply_to_email_address", value)


if not MYPY:
    class WirelessSsidsSplashSettingsBillingFreeAccessArgsDict(TypedDict):
        duration_in_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        How long a device can use a network for free.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not free access is enabled.
        """
elif False:
    WirelessSsidsSplashSettingsBillingFreeAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSplashSettingsBillingFreeAccessArgs:
    def __init__(__self__, *,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] duration_in_minutes: How long a device can use a network for free.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not free access is enabled.
        """
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How long a device can use a network for free.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_minutes", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not free access is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WirelessSsidsSplashSettingsGuestSponsorshipArgsDict(TypedDict):
        duration_in_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration in minutes of sponsored guest authorization.
        """
        guest_can_request_timeframe: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not guests can specify how much time they are requesting.
        """
elif False:
    WirelessSsidsSplashSettingsGuestSponsorshipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSplashSettingsGuestSponsorshipArgs:
    def __init__(__self__, *,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 guest_can_request_timeframe: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] duration_in_minutes: Duration in minutes of sponsored guest authorization.
        :param pulumi.Input[_builtins.bool] guest_can_request_timeframe: Whether or not guests can specify how much time they are requesting.
        """
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if guest_can_request_timeframe is not None:
            pulumi.set(__self__, "guest_can_request_timeframe", guest_can_request_timeframe)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration in minutes of sponsored guest authorization.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_minutes", value)

    @_builtins.property
    @pulumi.getter(name="guestCanRequestTimeframe")
    def guest_can_request_timeframe(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not guests can specify how much time they are requesting.
        """
        return pulumi.get(self, "guest_can_request_timeframe")

    @guest_can_request_timeframe.setter
    def guest_can_request_timeframe(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "guest_can_request_timeframe", value)


if not MYPY:
    class WirelessSsidsSplashSettingsSelfRegistrationArgsDict(TypedDict):
        authorization_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How created user accounts should be authorized.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to allow users to create their own account on the network.
        """
elif False:
    WirelessSsidsSplashSettingsSelfRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSplashSettingsSelfRegistrationArgs:
    def __init__(__self__, *,
                 authorization_type: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] authorization_type: How created user accounts should be authorized.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not to allow users to create their own account on the network.
        """
        if authorization_type is not None:
            pulumi.set(__self__, "authorization_type", authorization_type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="authorizationType")
    def authorization_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How created user accounts should be authorized.
        """
        return pulumi.get(self, "authorization_type")

    @authorization_type.setter
    def authorization_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_type", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to allow users to create their own account on the network.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WirelessSsidsSplashSettingsSentryEnrollmentArgsDict(TypedDict):
        enforced_systems: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The system types that the Sentry enforces.
        """
        strength: NotRequired[pulumi.Input[_builtins.str]]
        """
        The strength of the enforcement of selected system types.
        """
        systems_manager_network: NotRequired[pulumi.Input['WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetworkArgsDict']]
        """
        Systems Manager network targeted for sentry enrollment.
        """
elif False:
    WirelessSsidsSplashSettingsSentryEnrollmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSplashSettingsSentryEnrollmentArgs:
    def __init__(__self__, *,
                 enforced_systems: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 strength: Optional[pulumi.Input[_builtins.str]] = None,
                 systems_manager_network: Optional[pulumi.Input['WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetworkArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enforced_systems: The system types that the Sentry enforces.
        :param pulumi.Input[_builtins.str] strength: The strength of the enforcement of selected system types.
        :param pulumi.Input['WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetworkArgs'] systems_manager_network: Systems Manager network targeted for sentry enrollment.
        """
        if enforced_systems is not None:
            pulumi.set(__self__, "enforced_systems", enforced_systems)
        if strength is not None:
            pulumi.set(__self__, "strength", strength)
        if systems_manager_network is not None:
            pulumi.set(__self__, "systems_manager_network", systems_manager_network)

    @_builtins.property
    @pulumi.getter(name="enforcedSystems")
    def enforced_systems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The system types that the Sentry enforces.
        """
        return pulumi.get(self, "enforced_systems")

    @enforced_systems.setter
    def enforced_systems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enforced_systems", value)

    @_builtins.property
    @pulumi.getter
    def strength(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The strength of the enforcement of selected system types.
        """
        return pulumi.get(self, "strength")

    @strength.setter
    def strength(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "strength", value)

    @_builtins.property
    @pulumi.getter(name="systemsManagerNetwork")
    def systems_manager_network(self) -> Optional[pulumi.Input['WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetworkArgs']]:
        """
        Systems Manager network targeted for sentry enrollment.
        """
        return pulumi.get(self, "systems_manager_network")

    @systems_manager_network.setter
    def systems_manager_network(self, value: Optional[pulumi.Input['WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetworkArgs']]):
        pulumi.set(self, "systems_manager_network", value)


if not MYPY:
    class WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetworkArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The network ID of the Systems Manager network.
        """
elif False:
    WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetworkArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The network ID of the Systems Manager network.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The network ID of the Systems Manager network.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class WirelessSsidsSplashSettingsSplashImageArgsDict(TypedDict):
        extension: NotRequired[pulumi.Input[_builtins.str]]
        """
        The extension of the image file.
        """
        image: NotRequired[pulumi.Input['WirelessSsidsSplashSettingsSplashImageImageArgsDict']]
        """
        Properties for setting a new image.
        """
        md5: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MD5 value of the image file.
        """
elif False:
    WirelessSsidsSplashSettingsSplashImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSplashSettingsSplashImageArgs:
    def __init__(__self__, *,
                 extension: Optional[pulumi.Input[_builtins.str]] = None,
                 image: Optional[pulumi.Input['WirelessSsidsSplashSettingsSplashImageImageArgs']] = None,
                 md5: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] extension: The extension of the image file.
        :param pulumi.Input['WirelessSsidsSplashSettingsSplashImageImageArgs'] image: Properties for setting a new image.
        :param pulumi.Input[_builtins.str] md5: The MD5 value of the image file.
        """
        if extension is not None:
            pulumi.set(__self__, "extension", extension)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)

    @_builtins.property
    @pulumi.getter
    def extension(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The extension of the image file.
        """
        return pulumi.get(self, "extension")

    @extension.setter
    def extension(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extension", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['WirelessSsidsSplashSettingsSplashImageImageArgs']]:
        """
        Properties for setting a new image.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['WirelessSsidsSplashSettingsSplashImageImageArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MD5 value of the image file.
        """
        return pulumi.get(self, "md5")

    @md5.setter
    def md5(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "md5", value)


if not MYPY:
    class WirelessSsidsSplashSettingsSplashImageImageArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[_builtins.str]]
        """
        The file contents (a base 64 encoded string) of your new image.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
elif False:
    WirelessSsidsSplashSettingsSplashImageImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSplashSettingsSplashImageImageArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contents: The file contents (a base 64 encoded string) of your new image.
        :param pulumi.Input[_builtins.str] format: The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The file contents (a base 64 encoded string) of your new image.
        """
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contents", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)


if not MYPY:
    class WirelessSsidsSplashSettingsSplashLogoArgsDict(TypedDict):
        extension: NotRequired[pulumi.Input[_builtins.str]]
        """
        The extension of the logo file.
        """
        image: NotRequired[pulumi.Input['WirelessSsidsSplashSettingsSplashLogoImageArgsDict']]
        """
        Properties for setting a new image.
        """
        md5: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MD5 value of the logo file.
        """
elif False:
    WirelessSsidsSplashSettingsSplashLogoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSplashSettingsSplashLogoArgs:
    def __init__(__self__, *,
                 extension: Optional[pulumi.Input[_builtins.str]] = None,
                 image: Optional[pulumi.Input['WirelessSsidsSplashSettingsSplashLogoImageArgs']] = None,
                 md5: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] extension: The extension of the logo file.
        :param pulumi.Input['WirelessSsidsSplashSettingsSplashLogoImageArgs'] image: Properties for setting a new image.
        :param pulumi.Input[_builtins.str] md5: The MD5 value of the logo file.
        """
        if extension is not None:
            pulumi.set(__self__, "extension", extension)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)

    @_builtins.property
    @pulumi.getter
    def extension(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The extension of the logo file.
        """
        return pulumi.get(self, "extension")

    @extension.setter
    def extension(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extension", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['WirelessSsidsSplashSettingsSplashLogoImageArgs']]:
        """
        Properties for setting a new image.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['WirelessSsidsSplashSettingsSplashLogoImageArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MD5 value of the logo file.
        """
        return pulumi.get(self, "md5")

    @md5.setter
    def md5(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "md5", value)


if not MYPY:
    class WirelessSsidsSplashSettingsSplashLogoImageArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[_builtins.str]]
        """
        The file contents (a base 64 encoded string) of your new logo.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
elif False:
    WirelessSsidsSplashSettingsSplashLogoImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSplashSettingsSplashLogoImageArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contents: The file contents (a base 64 encoded string) of your new logo.
        :param pulumi.Input[_builtins.str] format: The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The file contents (a base 64 encoded string) of your new logo.
        """
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contents", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)


if not MYPY:
    class WirelessSsidsSplashSettingsSplashPrepaidFrontArgsDict(TypedDict):
        extension: NotRequired[pulumi.Input[_builtins.str]]
        """
        The extension of the prepaid front image file.
        """
        image: NotRequired[pulumi.Input['WirelessSsidsSplashSettingsSplashPrepaidFrontImageArgsDict']]
        """
        Properties for setting a new image.
        """
        md5: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MD5 value of the prepaid front image file.
        """
elif False:
    WirelessSsidsSplashSettingsSplashPrepaidFrontArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSplashSettingsSplashPrepaidFrontArgs:
    def __init__(__self__, *,
                 extension: Optional[pulumi.Input[_builtins.str]] = None,
                 image: Optional[pulumi.Input['WirelessSsidsSplashSettingsSplashPrepaidFrontImageArgs']] = None,
                 md5: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] extension: The extension of the prepaid front image file.
        :param pulumi.Input['WirelessSsidsSplashSettingsSplashPrepaidFrontImageArgs'] image: Properties for setting a new image.
        :param pulumi.Input[_builtins.str] md5: The MD5 value of the prepaid front image file.
        """
        if extension is not None:
            pulumi.set(__self__, "extension", extension)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)

    @_builtins.property
    @pulumi.getter
    def extension(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The extension of the prepaid front image file.
        """
        return pulumi.get(self, "extension")

    @extension.setter
    def extension(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extension", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['WirelessSsidsSplashSettingsSplashPrepaidFrontImageArgs']]:
        """
        Properties for setting a new image.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['WirelessSsidsSplashSettingsSplashPrepaidFrontImageArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MD5 value of the prepaid front image file.
        """
        return pulumi.get(self, "md5")

    @md5.setter
    def md5(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "md5", value)


if not MYPY:
    class WirelessSsidsSplashSettingsSplashPrepaidFrontImageArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[_builtins.str]]
        """
        The file contents (a base 64 encoded string) of your new prepaid front.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
elif False:
    WirelessSsidsSplashSettingsSplashPrepaidFrontImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsSplashSettingsSplashPrepaidFrontImageArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contents: The file contents (a base 64 encoded string) of your new prepaid front.
        :param pulumi.Input[_builtins.str] format: The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The file contents (a base 64 encoded string) of your new prepaid front.
        """
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contents", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)


if not MYPY:
    class WirelessSsidsTrafficShapingRulesRuleArgsDict(TypedDict):
        definitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsTrafficShapingRulesRuleDefinitionArgsDict']]]]
        """
        A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        """
        dscp_tag_value: NotRequired[pulumi.Input[_builtins.int]]
        """
        The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        """
        pcp_tag_value: NotRequired[pulumi.Input[_builtins.int]]
        """
        The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
        null means 'Do not set PCP tag'.
        """
        per_client_bandwidth_limits: NotRequired[pulumi.Input['WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsArgsDict']]
        """
        An object describing the bandwidth settings for your rule.
        """
elif False:
    WirelessSsidsTrafficShapingRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsTrafficShapingRulesRuleArgs:
    def __init__(__self__, *,
                 definitions: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsTrafficShapingRulesRuleDefinitionArgs']]]] = None,
                 dscp_tag_value: Optional[pulumi.Input[_builtins.int]] = None,
                 pcp_tag_value: Optional[pulumi.Input[_builtins.int]] = None,
                 per_client_bandwidth_limits: Optional[pulumi.Input['WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WirelessSsidsTrafficShapingRulesRuleDefinitionArgs']]] definitions: A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        :param pulumi.Input[_builtins.int] dscp_tag_value: The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
               For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        :param pulumi.Input[_builtins.int] pcp_tag_value: The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
               null means 'Do not set PCP tag'.
        :param pulumi.Input['WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsArgs'] per_client_bandwidth_limits: An object describing the bandwidth settings for your rule.
        """
        if definitions is not None:
            pulumi.set(__self__, "definitions", definitions)
        if dscp_tag_value is not None:
            pulumi.set(__self__, "dscp_tag_value", dscp_tag_value)
        if pcp_tag_value is not None:
            pulumi.set(__self__, "pcp_tag_value", pcp_tag_value)
        if per_client_bandwidth_limits is not None:
            pulumi.set(__self__, "per_client_bandwidth_limits", per_client_bandwidth_limits)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsTrafficShapingRulesRuleDefinitionArgs']]]]:
        """
        A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
        """
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsTrafficShapingRulesRuleDefinitionArgs']]]]):
        pulumi.set(self, "definitions", value)

    @_builtins.property
    @pulumi.getter(name="dscpTagValue")
    def dscp_tag_value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
        """
        return pulumi.get(self, "dscp_tag_value")

    @dscp_tag_value.setter
    def dscp_tag_value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dscp_tag_value", value)

    @_builtins.property
    @pulumi.getter(name="pcpTagValue")
    def pcp_tag_value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
        null means 'Do not set PCP tag'.
        """
        return pulumi.get(self, "pcp_tag_value")

    @pcp_tag_value.setter
    def pcp_tag_value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "pcp_tag_value", value)

    @_builtins.property
    @pulumi.getter(name="perClientBandwidthLimits")
    def per_client_bandwidth_limits(self) -> Optional[pulumi.Input['WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsArgs']]:
        """
        An object describing the bandwidth settings for your rule.
        """
        return pulumi.get(self, "per_client_bandwidth_limits")

    @per_client_bandwidth_limits.setter
    def per_client_bandwidth_limits(self, value: Optional[pulumi.Input['WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsArgs']]):
        pulumi.set(self, "per_client_bandwidth_limits", value)


if not MYPY:
    class WirelessSsidsTrafficShapingRulesRuleDefinitionArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
        a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
        "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
        custom ports.
         If "type" is 'application' or 'applicationCategory', then "value" must be an object
        with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
        application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
        endpoint).
        """
elif False:
    WirelessSsidsTrafficShapingRulesRuleDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsTrafficShapingRulesRuleDefinitionArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        :param pulumi.Input[_builtins.str] value: If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
               a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
               "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
               custom ports.
                If "type" is 'application' or 'applicationCategory', then "value" must be an object
               with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
               application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
               endpoint).
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
        a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
        "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
        custom ports.
         If "type" is 'application' or 'applicationCategory', then "value" must be an object
        with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
        application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
        endpoint).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsArgsDict(TypedDict):
        bandwidth_limits: NotRequired[pulumi.Input['WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgsDict']]
        """
        The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        """
        settings: NotRequired[pulumi.Input[_builtins.str]]
        """
        How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
elif False:
    WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsArgs:
    def __init__(__self__, *,
                 bandwidth_limits: Optional[pulumi.Input['WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs']] = None,
                 settings: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs'] bandwidth_limits: The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        :param pulumi.Input[_builtins.str] settings: How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        if bandwidth_limits is not None:
            pulumi.set(__self__, "bandwidth_limits", bandwidth_limits)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimits")
    def bandwidth_limits(self) -> Optional[pulumi.Input['WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs']]:
        """
        The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
        """
        return pulumi.get(self, "bandwidth_limits")

    @bandwidth_limits.setter
    def bandwidth_limits(self, value: Optional[pulumi.Input['WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs']]):
        pulumi.set(self, "bandwidth_limits", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgsDict(TypedDict):
        limit_down: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum download limit (integer, in Kbps).
        """
        limit_up: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum upload limit (integer, in Kbps).
        """
elif False:
    WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimitsArgs:
    def __init__(__self__, *,
                 limit_down: Optional[pulumi.Input[_builtins.int]] = None,
                 limit_up: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] limit_down: The maximum download limit (integer, in Kbps).
        :param pulumi.Input[_builtins.int] limit_up: The maximum upload limit (integer, in Kbps).
        """
        if limit_down is not None:
            pulumi.set(__self__, "limit_down", limit_down)
        if limit_up is not None:
            pulumi.set(__self__, "limit_up", limit_up)

    @_builtins.property
    @pulumi.getter(name="limitDown")
    def limit_down(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum download limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_down")

    @limit_down.setter
    def limit_down(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_down", value)

    @_builtins.property
    @pulumi.getter(name="limitUp")
    def limit_up(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum upload limit (integer, in Kbps).
        """
        return pulumi.get(self, "limit_up")

    @limit_up.setter
    def limit_up(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limit_up", value)


if not MYPY:
    class WirelessSsidsVpnConcentratorArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The NAT ID of the concentrator that should be set.
        """
        vlan_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The VLAN that should be tagged for the concentrator.
        """
elif False:
    WirelessSsidsVpnConcentratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsVpnConcentratorArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] network_id: The NAT ID of the concentrator that should be set.
        :param pulumi.Input[_builtins.int] vlan_id: The VLAN that should be tagged for the concentrator.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The NAT ID of the concentrator that should be set.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The VLAN that should be tagged for the concentrator.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class WirelessSsidsVpnFailoverArgsDict(TypedDict):
        heartbeat_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Idle timer interval in seconds.
        """
        idle_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Idle timer timeout in seconds.
        """
        request_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP addressed reserved on DHCP server where SSID will terminate.
        """
elif False:
    WirelessSsidsVpnFailoverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsVpnFailoverArgs:
    def __init__(__self__, *,
                 heartbeat_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 idle_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 request_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] heartbeat_interval: Idle timer interval in seconds.
        :param pulumi.Input[_builtins.int] idle_timeout: Idle timer timeout in seconds.
        :param pulumi.Input[_builtins.str] request_ip: IP addressed reserved on DHCP server where SSID will terminate.
        """
        if heartbeat_interval is not None:
            pulumi.set(__self__, "heartbeat_interval", heartbeat_interval)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if request_ip is not None:
            pulumi.set(__self__, "request_ip", request_ip)

    @_builtins.property
    @pulumi.getter(name="heartbeatInterval")
    def heartbeat_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Idle timer interval in seconds.
        """
        return pulumi.get(self, "heartbeat_interval")

    @heartbeat_interval.setter
    def heartbeat_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "heartbeat_interval", value)

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Idle timer timeout in seconds.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "idle_timeout", value)

    @_builtins.property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP addressed reserved on DHCP server where SSID will terminate.
        """
        return pulumi.get(self, "request_ip")

    @request_ip.setter
    def request_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_ip", value)


if not MYPY:
    class WirelessSsidsVpnSplitTunnelArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, VPN split tunnel is enabled.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsVpnSplitTunnelRuleArgsDict']]]]
        """
        List of VPN split tunnel rules.
        """
elif False:
    WirelessSsidsVpnSplitTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsVpnSplitTunnelArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsVpnSplitTunnelRuleArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If true, VPN split tunnel is enabled.
        :param pulumi.Input[Sequence[pulumi.Input['WirelessSsidsVpnSplitTunnelRuleArgs']]] rules: List of VPN split tunnel rules.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, VPN split tunnel is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsVpnSplitTunnelRuleArgs']]]]:
        """
        List of VPN split tunnel rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WirelessSsidsVpnSplitTunnelRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class WirelessSsidsVpnSplitTunnelRuleArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description for this split tunnel rule (optional).
        """
        dest_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination for this split tunnel rule. IP address, fully-qualified domain names (FQDN) or 'any'.
        """
        dest_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination port for this split tunnel rule, (integer in the range 1-65535), or 'any'.
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Traffic policy specified for this split tunnel rule, 'allow' or 'deny'.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol for this split tunnel rule.
        """
elif False:
    WirelessSsidsVpnSplitTunnelRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WirelessSsidsVpnSplitTunnelRuleArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_port: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comment: Description for this split tunnel rule (optional).
        :param pulumi.Input[_builtins.str] dest_cidr: Destination for this split tunnel rule. IP address, fully-qualified domain names (FQDN) or 'any'.
        :param pulumi.Input[_builtins.str] dest_port: Destination port for this split tunnel rule, (integer in the range 1-65535), or 'any'.
        :param pulumi.Input[_builtins.str] policy: Traffic policy specified for this split tunnel rule, 'allow' or 'deny'.
        :param pulumi.Input[_builtins.str] protocol: Protocol for this split tunnel rule.
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dest_cidr is not None:
            pulumi.set(__self__, "dest_cidr", dest_cidr)
        if dest_port is not None:
            pulumi.set(__self__, "dest_port", dest_port)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description for this split tunnel rule (optional).
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="destCidr")
    def dest_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination for this split tunnel rule. IP address, fully-qualified domain names (FQDN) or 'any'.
        """
        return pulumi.get(self, "dest_cidr")

    @dest_cidr.setter
    def dest_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_cidr", value)

    @_builtins.property
    @pulumi.getter(name="destPort")
    def dest_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination port for this split tunnel rule, (integer in the range 1-65535), or 'any'.
        """
        return pulumi.get(self, "dest_port")

    @dest_port.setter
    def dest_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_port", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Traffic policy specified for this split tunnel rule, 'allow' or 'deny'.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol for this split tunnel rule.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


