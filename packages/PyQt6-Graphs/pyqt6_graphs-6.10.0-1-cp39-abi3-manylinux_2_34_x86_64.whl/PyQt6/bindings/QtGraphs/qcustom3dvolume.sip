// qcustom3dvolume.sip generated by MetaSIP
//
// This file is part of the QtGraphs Python extension module.
//
// Copyright (c) 2025 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt6-Graphs.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


// Mapped types needed by QCustom3DVolume
%MappedType QList<QImage *>
        /TypeHintIn="Iterable[QImage]", TypeHintOut="List[QImage]",
        TypeHintValue="[]"/
{
%TypeHeaderCode
#include <qimage.h>
#include <qlist.h>
%End

%ConvertFromTypeCode
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QImage *t = sipCpp->at(i);

        PyObject *tobj = sipConvertFromType(t, sipType_QImage, sipTransferObj);

        if (!tobj)
        {
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
%End

%ConvertToTypeCode
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        Py_XDECREF(iter);

        return (iter && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QImage *> *ql = new QList<QImage *>;

    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        QImage *t = reinterpret_cast<QImage *>(
                sipForceConvertToType(itm, sipType_QImage, sipTransferObj, 0,
                        0, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QImage' is expected",
                    i, sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(t);

        Py_DECREF(itm);
    }

    Py_DECREF(iter);

    *sipCppPtr = ql;

    return sipGetState(sipTransferObj);
%End
};


%MappedType QList<unsigned char> /TypeHint="sip.array"/
{
%TypeHeaderCode
#include <qlist.h>
%End

%ConvertFromTypeCode
    return sipConvertToArray(reinterpret_cast<void *>(sipCpp->data()), "B", sipCpp->size(), 0);
%End

%ConvertToTypeCode
    if (!sipIsErr)
        return sipGetBufferInfo(sipPy, NULL);

    const void *buffer;
    Py_ssize_t buffer_len;

    sipBufferInfoDef bi;

    if (sipGetBufferInfo(sipPy, &bi) < 0)
    {
        *sipIsErr = 1;
        return 0;
    }

    buffer = bi.bi_buf;
    buffer_len = bi.bi_len;

    QList<unsigned char> *qv = new QList<unsigned char>(buffer_len);

    for (Py_ssize_t i = 0; i < buffer_len; ++i)
        (*qv)[i] = reinterpret_cast<const uchar *>(buffer)[i];

    *sipCppPtr = qv;

    sipReleaseBufferInfo(&bi);
    
    return sipGetState(sipTransferObj);
%End
};

class QCustom3DVolume : public QCustom3DItem
{
%TypeHeaderCode
#include <qcustom3dvolume.h>
%End

public:
    explicit QCustom3DVolume(QObject *parent /TransferThis/ = 0);
    QCustom3DVolume(QVector3D position, QVector3D scaling, const QQuaternion &rotation, int textureWidth, int textureHeight, int textureDepth, QList<unsigned char> *textureData /Transfer/, QImage::Format textureFormat, const QList<unsigned int> &colorTable, QObject *parent /TransferThis/ = 0);
    virtual ~QCustom3DVolume();
    void setTextureWidth(int value);
    int textureWidth() const;
    void setTextureHeight(int value);
    int textureHeight() const;
    void setTextureDepth(int value);
    int textureDepth() const;
    void setTextureDimensions(int width, int height, int depth);
    int textureDataWidth() const;
    void setSliceIndexX(int value);
    int sliceIndexX() const;
    void setSliceIndexY(int value);
    int sliceIndexY() const;
    void setSliceIndexZ(int value);
    int sliceIndexZ() const;
    void setSliceIndices(int x, int y, int z);
    void setColorTable(const QList<unsigned int> &colors);
    QList<unsigned int> colorTable() const;
    void setTextureData(QList<unsigned char> *data /Transfer/);
    QList<unsigned char> *createTextureData(const QList<QImage *> &images);
    QList<unsigned char> *textureData() const;
    void setSubTextureData(Qt::Axis axis, int index, const void *data);
%MethodCode
        sipCpp->setSubTextureData(a0, a1, reinterpret_cast<const uchar *>(a2));
%End

    void setSubTextureData(Qt::Axis axis, int index, const QImage &image);
    void setTextureFormat(QImage::Format format);
    QImage::Format textureFormat() const;
    void setAlphaMultiplier(float mult);
    float alphaMultiplier() const;
    void setPreserveOpacity(bool enable);
    bool preserveOpacity() const;
    void setUseHighDefShader(bool enable);
    bool useHighDefShader() const;
    void setDrawSlices(bool enable);
    bool drawSlices() const;
    void setDrawSliceFrames(bool enable);
    bool drawSliceFrames() const;
    void setSliceFrameColor(QColor color);
    QColor sliceFrameColor() const;
    void setSliceFrameWidths(QVector3D values);
    QVector3D sliceFrameWidths() const;
    void setSliceFrameGaps(QVector3D values);
    QVector3D sliceFrameGaps() const;
    void setSliceFrameThicknesses(QVector3D values);
    QVector3D sliceFrameThicknesses() const;
    QImage renderSlice(Qt::Axis axis, int index);

signals:
    void textureWidthChanged(int value);
    void textureHeightChanged(int value);
    void textureDepthChanged(int value);
    void sliceIndexXChanged(int value);
    void sliceIndexYChanged(int value);
    void sliceIndexZChanged(int value);
    void colorTableChanged();
    void textureDataChanged(QList<unsigned char> *data);
    void textureFormatChanged(QImage::Format format);
    void alphaMultiplierChanged(float mult);
    void preserveOpacityChanged(bool enabled);
    void useHighDefShaderChanged(bool enabled);
    void drawSlicesChanged(bool enabled);
    void drawSliceFramesChanged(bool enabled);
    void sliceFrameColorChanged(QColor color);
    void sliceFrameWidthsChanged(QVector3D values);
    void sliceFrameGapsChanged(QVector3D values);
    void sliceFrameThicknessesChanged(QVector3D values);
};
