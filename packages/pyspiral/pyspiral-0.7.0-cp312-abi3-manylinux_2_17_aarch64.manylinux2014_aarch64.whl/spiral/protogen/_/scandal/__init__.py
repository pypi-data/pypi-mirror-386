# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: scandal/scandal.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Connectivity",
    "Fetch",
    "FetchRequest",
    "FetchResponse",
    "Metadata",
    "MetadataParquet",
    "Put",
    "PutRequest",
    "PutResponse",
    "ScandalServiceStub",
    "Sink",
    "Source",
)

from dataclasses import dataclass

import betterproto2
import grpc

from ..message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False)
class Connectivity(betterproto2.Message):
    """
    Information about the client's perceived connectivity to a FileSystem.
    """

    unreachable: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)

    round_trip_time_us: "int | None" = betterproto2.field(2, betterproto2.TYPE_INT32, optional=True)


default_message_pool.register_message("scandal", "Connectivity", Connectivity)


@dataclass(eq=False, repr=False)
class Fetch(betterproto2.Message):
    """
    Let's make "fetch" happen.
    """

    pass


default_message_pool.register_message("scandal", "Fetch", Fetch)


@dataclass(eq=False, repr=False)
class FetchRequest(betterproto2.Message):
    """
    TODO(ngates): include projection expression.
    """

    uri: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    A signed request to read an
    spfs://&lt;fsid&gt;/path?token=&lt;jwt&gt URI.
    """

    connectivity: "Connectivity | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    """
    Declares whether the client has connectivity to the FileSystem.
    """

    accepts: "list[str]" = betterproto2.field(3, betterproto2.TYPE_STRING, repeated=True)
    """
    Declares the MIME types the client can read directly.
    """


default_message_pool.register_message("scandal", "Fetch.Request", FetchRequest)


@dataclass(eq=False, repr=False)
class FetchResponse(betterproto2.Message):
    sources: "list[Source]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    The sources the client should use to attempt to read the file.
    The client should try each source in order until it finds one that works.
    """


default_message_pool.register_message("scandal", "Fetch.Response", FetchResponse)


@dataclass(eq=False, repr=False)
class Metadata(betterproto2.Message):
    pass


default_message_pool.register_message("scandal", "Metadata", Metadata)


@dataclass(eq=False, repr=False)
class MetadataParquet(betterproto2.Message):
    """
    A bunch of optional metadata that the client can use
    to accelerate reading the file.
    """

    pass


default_message_pool.register_message("scandal", "Metadata.Parquet", MetadataParquet)


@dataclass(eq=False, repr=False)
class Put(betterproto2.Message):
    pass


default_message_pool.register_message("scandal", "Put", Put)


@dataclass(eq=False, repr=False)
class PutRequest(betterproto2.Message):
    uri: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    connectivity: "Connectivity | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("scandal", "Put.Request", PutRequest)


@dataclass(eq=False, repr=False)
class PutResponse(betterproto2.Message):
    sinks: "list[Sink]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("scandal", "Put.Response", PutResponse)


@dataclass(eq=False, repr=False)
class Sink(betterproto2.Message):
    url: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)


default_message_pool.register_message("scandal", "Sink", Sink)


@dataclass(eq=False, repr=False)
class Source(betterproto2.Message):
    """
    NOTE(marko): Scandal does not yet exist and this file is unused.

    Oneofs:
        - metadata:
    """

    url: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    content_type: "str | None" = betterproto2.field(2, betterproto2.TYPE_STRING, optional=True)

    size: "int | None" = betterproto2.field(3, betterproto2.TYPE_INT64, optional=True)

    parquet: "MetadataParquet | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="metadata"
    )


default_message_pool.register_message("scandal", "Source", Source)


class ScandalServiceStub:
    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def fetch(self, message: "FetchRequest") -> "FetchResponse":
        return self._channel.unary_unary(
            "/scandal.ScandalService/Fetch",
            FetchRequest.SerializeToString,
            FetchResponse.FromString,
        )(message)

    def put(self, message: "PutRequest") -> "PutResponse":
        return self._channel.unary_unary(
            "/scandal.ScandalService/Put",
            PutRequest.SerializeToString,
            PutResponse.FromString,
        )(message)
