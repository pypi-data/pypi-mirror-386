# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: substrait/algebra.proto, substrait/capabilities.proto, substrait/extended_expression.proto, substrait/function.proto, substrait/parameterized_types.proto, substrait/plan.proto, substrait/type.proto, substrait/type_expressions.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AggregateFunction",
    "AggregateFunctionAggregationInvocation",
    "AggregateRel",
    "AggregateRelGrouping",
    "AggregateRelMeasure",
    "AggregationPhase",
    "Capabilities",
    "CapabilitiesSimpleExtension",
    "ComparisonJoinKey",
    "ComparisonJoinKeyComparisonType",
    "ComparisonJoinKeySimpleComparisonType",
    "ConsistentPartitionWindowRel",
    "ConsistentPartitionWindowRelWindowRelFunction",
    "CrossRel",
    "DdlRel",
    "DdlRelDdlObject",
    "DdlRelDdlOp",
    "DerivationExpression",
    "DerivationExpressionBinaryOp",
    "DerivationExpressionBinaryOpBinaryOpType",
    "DerivationExpressionExpressionDecimal",
    "DerivationExpressionExpressionFixedBinary",
    "DerivationExpressionExpressionFixedChar",
    "DerivationExpressionExpressionIntervalCompound",
    "DerivationExpressionExpressionIntervalDay",
    "DerivationExpressionExpressionList",
    "DerivationExpressionExpressionMap",
    "DerivationExpressionExpressionNamedStruct",
    "DerivationExpressionExpressionPrecisionTimestamp",
    "DerivationExpressionExpressionPrecisionTimestampTz",
    "DerivationExpressionExpressionStruct",
    "DerivationExpressionExpressionUserDefined",
    "DerivationExpressionExpressionVarChar",
    "DerivationExpressionIfElse",
    "DerivationExpressionReturnProgram",
    "DerivationExpressionReturnProgramAssignment",
    "DerivationExpressionUnaryOp",
    "DerivationExpressionUnaryOpUnaryOpType",
    "ExchangeRel",
    "ExchangeRelBroadcast",
    "ExchangeRelExchangeTarget",
    "ExchangeRelMultiBucketExpression",
    "ExchangeRelRoundRobin",
    "ExchangeRelScatterFields",
    "ExchangeRelSingleBucketExpression",
    "ExpandRel",
    "ExpandRelExpandField",
    "ExpandRelSwitchingField",
    "Expression",
    "ExpressionCast",
    "ExpressionCastFailureBehavior",
    "ExpressionEmbeddedFunction",
    "ExpressionEmbeddedFunctionPythonPickleFunction",
    "ExpressionEmbeddedFunctionWebAssemblyFunction",
    "ExpressionEnum",
    "ExpressionEnumEmpty",
    "ExpressionFieldReference",
    "ExpressionFieldReferenceOuterReference",
    "ExpressionFieldReferenceRootReference",
    "ExpressionIfThen",
    "ExpressionIfThenIfClause",
    "ExpressionLiteral",
    "ExpressionLiteralDecimal",
    "ExpressionLiteralIntervalCompound",
    "ExpressionLiteralIntervalDayToSecond",
    "ExpressionLiteralIntervalYearToMonth",
    "ExpressionLiteralList",
    "ExpressionLiteralMap",
    "ExpressionLiteralMapKeyValue",
    "ExpressionLiteralPrecisionTimestamp",
    "ExpressionLiteralStruct",
    "ExpressionLiteralUserDefined",
    "ExpressionLiteralVarChar",
    "ExpressionMaskExpression",
    "ExpressionMaskExpressionListSelect",
    "ExpressionMaskExpressionListSelectListSelectItem",
    "ExpressionMaskExpressionListSelectListSelectItemListElement",
    "ExpressionMaskExpressionListSelectListSelectItemListSlice",
    "ExpressionMaskExpressionMapSelect",
    "ExpressionMaskExpressionMapSelectMapKey",
    "ExpressionMaskExpressionMapSelectMapKeyExpression",
    "ExpressionMaskExpressionSelect",
    "ExpressionMaskExpressionStructItem",
    "ExpressionMaskExpressionStructSelect",
    "ExpressionMultiOrList",
    "ExpressionMultiOrListRecord",
    "ExpressionNested",
    "ExpressionNestedList",
    "ExpressionNestedMap",
    "ExpressionNestedMapKeyValue",
    "ExpressionNestedStruct",
    "ExpressionReference",
    "ExpressionReferenceSegment",
    "ExpressionReferenceSegmentListElement",
    "ExpressionReferenceSegmentMapKey",
    "ExpressionReferenceSegmentStructField",
    "ExpressionScalarFunction",
    "ExpressionSingularOrList",
    "ExpressionSubquery",
    "ExpressionSubqueryInPredicate",
    "ExpressionSubqueryScalar",
    "ExpressionSubquerySetComparison",
    "ExpressionSubquerySetComparisonComparisonOp",
    "ExpressionSubquerySetComparisonReductionOp",
    "ExpressionSubquerySetPredicate",
    "ExpressionSubquerySetPredicatePredicateOp",
    "ExpressionSwitchExpression",
    "ExpressionSwitchExpressionIfValue",
    "ExpressionWindowFunction",
    "ExpressionWindowFunctionBound",
    "ExpressionWindowFunctionBoundCurrentRow",
    "ExpressionWindowFunctionBoundFollowing",
    "ExpressionWindowFunctionBoundPreceding",
    "ExpressionWindowFunctionBoundUnbounded",
    "ExpressionWindowFunctionBoundsType",
    "ExtendedExpression",
    "ExtensionLeafRel",
    "ExtensionMultiRel",
    "ExtensionObject",
    "ExtensionSingleRel",
    "FetchRel",
    "FilterRel",
    "FunctionArgument",
    "FunctionOption",
    "FunctionSignature",
    "FunctionSignatureAggregate",
    "FunctionSignatureArgument",
    "FunctionSignatureArgumentEnumArgument",
    "FunctionSignatureArgumentTypeArgument",
    "FunctionSignatureArgumentValueArgument",
    "FunctionSignatureDescription",
    "FunctionSignatureFinalArgNormal",
    "FunctionSignatureFinalArgVariadic",
    "FunctionSignatureFinalArgVariadicParameterConsistency",
    "FunctionSignatureImplementation",
    "FunctionSignatureImplementationType",
    "FunctionSignatureScalar",
    "FunctionSignatureWindow",
    "FunctionSignatureWindowWindowType",
    "HashJoinRel",
    "HashJoinRelJoinType",
    "JoinRel",
    "JoinRelJoinType",
    "MergeJoinRel",
    "MergeJoinRelJoinType",
    "NamedObjectWrite",
    "NamedStruct",
    "NestedLoopJoinRel",
    "NestedLoopJoinRelJoinType",
    "ParameterizedType",
    "ParameterizedTypeIntegerOption",
    "ParameterizedTypeIntegerParameter",
    "ParameterizedTypeNullableInteger",
    "ParameterizedTypeParameterizedDecimal",
    "ParameterizedTypeParameterizedFixedBinary",
    "ParameterizedTypeParameterizedFixedChar",
    "ParameterizedTypeParameterizedIntervalCompound",
    "ParameterizedTypeParameterizedIntervalDay",
    "ParameterizedTypeParameterizedList",
    "ParameterizedTypeParameterizedMap",
    "ParameterizedTypeParameterizedNamedStruct",
    "ParameterizedTypeParameterizedPrecisionTimestamp",
    "ParameterizedTypeParameterizedPrecisionTimestampTz",
    "ParameterizedTypeParameterizedStruct",
    "ParameterizedTypeParameterizedUserDefined",
    "ParameterizedTypeParameterizedVarChar",
    "ParameterizedTypeTypeParameter",
    "Plan",
    "PlanRel",
    "PlanVersion",
    "ProjectRel",
    "ReadRel",
    "ReadRelExtensionTable",
    "ReadRelLocalFiles",
    "ReadRelLocalFilesFileOrFiles",
    "ReadRelLocalFilesFileOrFilesArrowReadOptions",
    "ReadRelLocalFilesFileOrFilesDelimiterSeparatedTextReadOptions",
    "ReadRelLocalFilesFileOrFilesDwrfReadOptions",
    "ReadRelLocalFilesFileOrFilesOrcReadOptions",
    "ReadRelLocalFilesFileOrFilesParquetReadOptions",
    "ReadRelNamedTable",
    "ReadRelVirtualTable",
    "ReferenceRel",
    "Rel",
    "RelCommon",
    "RelCommonDirect",
    "RelCommonEmit",
    "RelCommonHint",
    "RelCommonHintComputationType",
    "RelCommonHintLoadedComputation",
    "RelCommonHintRuntimeConstraint",
    "RelCommonHintSavedComputation",
    "RelCommonHintStats",
    "RelRoot",
    "SetRel",
    "SetRelSetOp",
    "SortField",
    "SortFieldSortDirection",
    "SortRel",
    "Type",
    "TypeBinary",
    "TypeBoolean",
    "TypeDate",
    "TypeDecimal",
    "TypeFixedBinary",
    "TypeFixedChar",
    "TypeFp32",
    "TypeFp64",
    "TypeI8",
    "TypeI16",
    "TypeI32",
    "TypeI64",
    "TypeIntervalCompound",
    "TypeIntervalDay",
    "TypeIntervalYear",
    "TypeList",
    "TypeMap",
    "TypeNullability",
    "TypeParameter",
    "TypePrecisionTimestamp",
    "TypePrecisionTimestampTz",
    "TypeString",
    "TypeStruct",
    "TypeTime",
    "TypeTimestamp",
    "TypeTimestampTz",
    "TypeUserDefined",
    "TypeUuid",
    "TypeVarChar",
    "Version",
    "WriteRel",
    "WriteRelOutputMode",
    "WriteRelWriteOp",
)

import warnings
from dataclasses import dataclass

import betterproto2

from ..message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class AggregateFunctionAggregationInvocation(betterproto2.Enum):
    """
    Method in which equivalent records are merged before being aggregated.
    """

    UNSPECIFIED = 0
    """
    This default value implies AGGREGATION_INVOCATION_ALL.
    """

    ALL = 1
    """
    Use all values in the aggregation calculation.
    """

    DISTINCT = 2
    """
    Use only distinct values in the aggregation calculation.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "AGGREGATION_INVOCATION_UNSPECIFIED",
            1: "AGGREGATION_INVOCATION_ALL",
            2: "AGGREGATION_INVOCATION_DISTINCT",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "AGGREGATION_INVOCATION_UNSPECIFIED": 0,
            "AGGREGATION_INVOCATION_ALL": 1,
            "AGGREGATION_INVOCATION_DISTINCT": 2,
        }


class AggregationPhase(betterproto2.Enum):
    """
    Describes which part of an aggregation or window function to perform within
    the context of distributed algorithms.
    """

    UNSPECIFIED = 0
    """
    Implies `INTERMEDIATE_TO_RESULT`.
    """

    INITIAL_TO_INTERMEDIATE = 1
    """
    Specifies that the function should be run only up to the point of
    generating an intermediate value, to be further aggregated later using
    INTERMEDIATE_TO_INTERMEDIATE or INTERMEDIATE_TO_RESULT.
    """

    INTERMEDIATE_TO_INTERMEDIATE = 2
    """
    Specifies that the inputs of the aggregate or window function are the
    intermediate values of the function, and that the output should also be
    an intermediate value, to be further aggregated later using
    INTERMEDIATE_TO_INTERMEDIATE or INTERMEDIATE_TO_RESULT.
    """

    INITIAL_TO_RESULT = 3
    """
    A complete invocation: the function should aggregate the given set of
    inputs to yield a single return value. This style must be used for
    aggregate or window functions that are not decomposable.
    """

    INTERMEDIATE_TO_RESULT = 4
    """
    Specifies that the inputs of the aggregate or window function are the
    intermediate values of the function, generated previously using
    INITIAL_TO_INTERMEDIATE and possibly INTERMEDIATE_TO_INTERMEDIATE calls.
    This call should combine the intermediate values to yield the final
    return value.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "AGGREGATION_PHASE_UNSPECIFIED",
            1: "AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE",
            2: "AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE",
            3: "AGGREGATION_PHASE_INITIAL_TO_RESULT",
            4: "AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "AGGREGATION_PHASE_UNSPECIFIED": 0,
            "AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE": 1,
            "AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE": 2,
            "AGGREGATION_PHASE_INITIAL_TO_RESULT": 3,
            "AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT": 4,
        }


class ComparisonJoinKeySimpleComparisonType(betterproto2.Enum):
    """
    Most joins will use one of the following behaviors.  To avoid the complexity
    of a function lookup we define the common behaviors here
    """

    UNSPECIFIED = 0

    EQ = 1
    """
    Returns true only if both values are equal and not null
    """

    IS_NOT_DISTINCT_FROM = 2
    """
    Returns true if both values are equal and not null
    Returns true if both values are null
    Returns false if one value is null and the other value is not null

    This can be expressed as a = b OR (isnull(a) AND isnull(b))
    """

    MIGHT_EQUAL = 3
    """
    Returns true if both values are equal and not null
    Returns true if either value is null

    This can be expressed as a = b OR isnull(a = b)
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "SIMPLE_COMPARISON_TYPE_UNSPECIFIED",
            1: "SIMPLE_COMPARISON_TYPE_EQ",
            2: "SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM",
            3: "SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "SIMPLE_COMPARISON_TYPE_UNSPECIFIED": 0,
            "SIMPLE_COMPARISON_TYPE_EQ": 1,
            "SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM": 2,
            "SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL": 3,
        }


class DdlRelDdlObject(betterproto2.Enum):
    UNSPECIFIED = 0

    TABLE = 1
    """
    A Table object in the system
    """

    VIEW = 2
    """
    A View object in the system
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "DDL_OBJECT_UNSPECIFIED",
            1: "DDL_OBJECT_TABLE",
            2: "DDL_OBJECT_VIEW",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "DDL_OBJECT_UNSPECIFIED": 0,
            "DDL_OBJECT_TABLE": 1,
            "DDL_OBJECT_VIEW": 2,
        }


class DdlRelDdlOp(betterproto2.Enum):
    UNSPECIFIED = 0

    CREATE = 1
    """
    A create operation (for any object)
    """

    CREATE_OR_REPLACE = 2
    """
    A create operation if the object does not exist, or replaces it (equivalent to a DROP + CREATE) if the object already exists
    """

    ALTER = 3
    """
    An operation that modifies the schema (e.g., column names, types, default values) for the target object
    """

    DROP = 4
    """
    An operation that removes an object from the system
    """

    DROP_IF_EXIST = 5
    """
    An operation that removes an object from the system (without throwing an exception if the object did not exist)
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "DDL_OP_UNSPECIFIED",
            1: "DDL_OP_CREATE",
            2: "DDL_OP_CREATE_OR_REPLACE",
            3: "DDL_OP_ALTER",
            4: "DDL_OP_DROP",
            5: "DDL_OP_DROP_IF_EXIST",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "DDL_OP_UNSPECIFIED": 0,
            "DDL_OP_CREATE": 1,
            "DDL_OP_CREATE_OR_REPLACE": 2,
            "DDL_OP_ALTER": 3,
            "DDL_OP_DROP": 4,
            "DDL_OP_DROP_IF_EXIST": 5,
        }


class DerivationExpressionBinaryOpBinaryOpType(betterproto2.Enum):
    UNSPECIFIED = 0

    PLUS = 1

    MINUS = 2

    MULTIPLY = 3

    DIVIDE = 4

    MIN = 5

    MAX = 6

    GREATER_THAN = 7

    LESS_THAN = 8

    AND = 9

    OR = 10

    EQUALS = 11

    COVERS = 12

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "BINARY_OP_TYPE_UNSPECIFIED",
            1: "BINARY_OP_TYPE_PLUS",
            2: "BINARY_OP_TYPE_MINUS",
            3: "BINARY_OP_TYPE_MULTIPLY",
            4: "BINARY_OP_TYPE_DIVIDE",
            5: "BINARY_OP_TYPE_MIN",
            6: "BINARY_OP_TYPE_MAX",
            7: "BINARY_OP_TYPE_GREATER_THAN",
            8: "BINARY_OP_TYPE_LESS_THAN",
            9: "BINARY_OP_TYPE_AND",
            10: "BINARY_OP_TYPE_OR",
            11: "BINARY_OP_TYPE_EQUALS",
            12: "BINARY_OP_TYPE_COVERS",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "BINARY_OP_TYPE_UNSPECIFIED": 0,
            "BINARY_OP_TYPE_PLUS": 1,
            "BINARY_OP_TYPE_MINUS": 2,
            "BINARY_OP_TYPE_MULTIPLY": 3,
            "BINARY_OP_TYPE_DIVIDE": 4,
            "BINARY_OP_TYPE_MIN": 5,
            "BINARY_OP_TYPE_MAX": 6,
            "BINARY_OP_TYPE_GREATER_THAN": 7,
            "BINARY_OP_TYPE_LESS_THAN": 8,
            "BINARY_OP_TYPE_AND": 9,
            "BINARY_OP_TYPE_OR": 10,
            "BINARY_OP_TYPE_EQUALS": 11,
            "BINARY_OP_TYPE_COVERS": 12,
        }


class DerivationExpressionUnaryOpUnaryOpType(betterproto2.Enum):
    UNSPECIFIED = 0

    BOOLEAN_NOT = 1

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "UNARY_OP_TYPE_UNSPECIFIED",
            1: "UNARY_OP_TYPE_BOOLEAN_NOT",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "UNARY_OP_TYPE_UNSPECIFIED": 0,
            "UNARY_OP_TYPE_BOOLEAN_NOT": 1,
        }


class ExpressionCastFailureBehavior(betterproto2.Enum):
    UNSPECIFIED = 0

    RETURN_NULL = 1

    THROW_EXCEPTION = 2

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "FAILURE_BEHAVIOR_UNSPECIFIED",
            1: "FAILURE_BEHAVIOR_RETURN_NULL",
            2: "FAILURE_BEHAVIOR_THROW_EXCEPTION",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "FAILURE_BEHAVIOR_UNSPECIFIED": 0,
            "FAILURE_BEHAVIOR_RETURN_NULL": 1,
            "FAILURE_BEHAVIOR_THROW_EXCEPTION": 2,
        }


class ExpressionSubquerySetComparisonComparisonOp(betterproto2.Enum):
    UNSPECIFIED = 0

    EQ = 1

    NE = 2

    LT = 3

    GT = 4

    LE = 5

    GE = 6

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "COMPARISON_OP_UNSPECIFIED",
            1: "COMPARISON_OP_EQ",
            2: "COMPARISON_OP_NE",
            3: "COMPARISON_OP_LT",
            4: "COMPARISON_OP_GT",
            5: "COMPARISON_OP_LE",
            6: "COMPARISON_OP_GE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "COMPARISON_OP_UNSPECIFIED": 0,
            "COMPARISON_OP_EQ": 1,
            "COMPARISON_OP_NE": 2,
            "COMPARISON_OP_LT": 3,
            "COMPARISON_OP_GT": 4,
            "COMPARISON_OP_LE": 5,
            "COMPARISON_OP_GE": 6,
        }


class ExpressionSubquerySetComparisonReductionOp(betterproto2.Enum):
    UNSPECIFIED = 0

    ANY = 1

    ALL = 2

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "REDUCTION_OP_UNSPECIFIED",
            1: "REDUCTION_OP_ANY",
            2: "REDUCTION_OP_ALL",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "REDUCTION_OP_UNSPECIFIED": 0,
            "REDUCTION_OP_ANY": 1,
            "REDUCTION_OP_ALL": 2,
        }


class ExpressionSubquerySetPredicatePredicateOp(betterproto2.Enum):
    UNSPECIFIED = 0

    EXISTS = 1

    UNIQUE = 2

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "PREDICATE_OP_UNSPECIFIED",
            1: "PREDICATE_OP_EXISTS",
            2: "PREDICATE_OP_UNIQUE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "PREDICATE_OP_UNSPECIFIED": 0,
            "PREDICATE_OP_EXISTS": 1,
            "PREDICATE_OP_UNIQUE": 2,
        }


class ExpressionWindowFunctionBoundsType(betterproto2.Enum):
    UNSPECIFIED = 0

    ROWS = 1
    """
    The lower and upper bound specify how many rows before and after the current row
    the window should extend.
    """

    RANGE = 2
    """
    The lower and upper bound describe a range of values.  The window should include all rows
    where the value of the ordering column is greater than or equal to (current_value - lower bound)
    and less than or equal to (current_value + upper bound).  This bounds type is only valid if there
    is a single ordering column.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "BOUNDS_TYPE_UNSPECIFIED",
            1: "BOUNDS_TYPE_ROWS",
            2: "BOUNDS_TYPE_RANGE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "BOUNDS_TYPE_UNSPECIFIED": 0,
            "BOUNDS_TYPE_ROWS": 1,
            "BOUNDS_TYPE_RANGE": 2,
        }


class FunctionSignatureFinalArgVariadicParameterConsistency(betterproto2.Enum):
    UNSPECIFIED = 0

    CONSISTENT = 1
    """
    All argument must be the same concrete type.
    """

    INCONSISTENT = 2
    """
    Each argument can be any possible concrete type afforded by the bounds
    of any parameter defined in the arguments specification.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "PARAMETER_CONSISTENCY_UNSPECIFIED",
            1: "PARAMETER_CONSISTENCY_CONSISTENT",
            2: "PARAMETER_CONSISTENCY_INCONSISTENT",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "PARAMETER_CONSISTENCY_UNSPECIFIED": 0,
            "PARAMETER_CONSISTENCY_CONSISTENT": 1,
            "PARAMETER_CONSISTENCY_INCONSISTENT": 2,
        }


class FunctionSignatureImplementationType(betterproto2.Enum):
    UNSPECIFIED = 0

    WEB_ASSEMBLY = 1

    TRINO_JAR = 2

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_UNSPECIFIED",
            1: "TYPE_WEB_ASSEMBLY",
            2: "TYPE_TRINO_JAR",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_UNSPECIFIED": 0,
            "TYPE_WEB_ASSEMBLY": 1,
            "TYPE_TRINO_JAR": 2,
        }


class FunctionSignatureWindowWindowType(betterproto2.Enum):
    UNSPECIFIED = 0

    STREAMING = 1

    PARTITION = 2

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "WINDOW_TYPE_UNSPECIFIED",
            1: "WINDOW_TYPE_STREAMING",
            2: "WINDOW_TYPE_PARTITION",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "WINDOW_TYPE_UNSPECIFIED": 0,
            "WINDOW_TYPE_STREAMING": 1,
            "WINDOW_TYPE_PARTITION": 2,
        }


class HashJoinRelJoinType(betterproto2.Enum):
    UNSPECIFIED = 0

    INNER = 1

    OUTER = 2

    LEFT = 3

    RIGHT = 4

    LEFT_SEMI = 5

    RIGHT_SEMI = 6

    LEFT_ANTI = 7

    RIGHT_ANTI = 8

    LEFT_SINGLE = 9

    RIGHT_SINGLE = 10

    LEFT_MARK = 11

    RIGHT_MARK = 12

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "JOIN_TYPE_UNSPECIFIED",
            1: "JOIN_TYPE_INNER",
            2: "JOIN_TYPE_OUTER",
            3: "JOIN_TYPE_LEFT",
            4: "JOIN_TYPE_RIGHT",
            5: "JOIN_TYPE_LEFT_SEMI",
            6: "JOIN_TYPE_RIGHT_SEMI",
            7: "JOIN_TYPE_LEFT_ANTI",
            8: "JOIN_TYPE_RIGHT_ANTI",
            9: "JOIN_TYPE_LEFT_SINGLE",
            10: "JOIN_TYPE_RIGHT_SINGLE",
            11: "JOIN_TYPE_LEFT_MARK",
            12: "JOIN_TYPE_RIGHT_MARK",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "JOIN_TYPE_UNSPECIFIED": 0,
            "JOIN_TYPE_INNER": 1,
            "JOIN_TYPE_OUTER": 2,
            "JOIN_TYPE_LEFT": 3,
            "JOIN_TYPE_RIGHT": 4,
            "JOIN_TYPE_LEFT_SEMI": 5,
            "JOIN_TYPE_RIGHT_SEMI": 6,
            "JOIN_TYPE_LEFT_ANTI": 7,
            "JOIN_TYPE_RIGHT_ANTI": 8,
            "JOIN_TYPE_LEFT_SINGLE": 9,
            "JOIN_TYPE_RIGHT_SINGLE": 10,
            "JOIN_TYPE_LEFT_MARK": 11,
            "JOIN_TYPE_RIGHT_MARK": 12,
        }


class JoinRelJoinType(betterproto2.Enum):
    UNSPECIFIED = 0

    INNER = 1

    OUTER = 2

    LEFT = 3

    RIGHT = 4

    LEFT_SEMI = 5

    LEFT_ANTI = 6

    LEFT_SINGLE = 7

    RIGHT_SEMI = 8

    RIGHT_ANTI = 9

    RIGHT_SINGLE = 10

    LEFT_MARK = 11

    RIGHT_MARK = 12

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "JOIN_TYPE_UNSPECIFIED",
            1: "JOIN_TYPE_INNER",
            2: "JOIN_TYPE_OUTER",
            3: "JOIN_TYPE_LEFT",
            4: "JOIN_TYPE_RIGHT",
            5: "JOIN_TYPE_LEFT_SEMI",
            6: "JOIN_TYPE_LEFT_ANTI",
            7: "JOIN_TYPE_LEFT_SINGLE",
            8: "JOIN_TYPE_RIGHT_SEMI",
            9: "JOIN_TYPE_RIGHT_ANTI",
            10: "JOIN_TYPE_RIGHT_SINGLE",
            11: "JOIN_TYPE_LEFT_MARK",
            12: "JOIN_TYPE_RIGHT_MARK",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "JOIN_TYPE_UNSPECIFIED": 0,
            "JOIN_TYPE_INNER": 1,
            "JOIN_TYPE_OUTER": 2,
            "JOIN_TYPE_LEFT": 3,
            "JOIN_TYPE_RIGHT": 4,
            "JOIN_TYPE_LEFT_SEMI": 5,
            "JOIN_TYPE_LEFT_ANTI": 6,
            "JOIN_TYPE_LEFT_SINGLE": 7,
            "JOIN_TYPE_RIGHT_SEMI": 8,
            "JOIN_TYPE_RIGHT_ANTI": 9,
            "JOIN_TYPE_RIGHT_SINGLE": 10,
            "JOIN_TYPE_LEFT_MARK": 11,
            "JOIN_TYPE_RIGHT_MARK": 12,
        }


class MergeJoinRelJoinType(betterproto2.Enum):
    UNSPECIFIED = 0

    INNER = 1

    OUTER = 2

    LEFT = 3

    RIGHT = 4

    LEFT_SEMI = 5

    RIGHT_SEMI = 6

    LEFT_ANTI = 7

    RIGHT_ANTI = 8

    LEFT_SINGLE = 9

    RIGHT_SINGLE = 10

    LEFT_MARK = 11

    RIGHT_MARK = 12

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "JOIN_TYPE_UNSPECIFIED",
            1: "JOIN_TYPE_INNER",
            2: "JOIN_TYPE_OUTER",
            3: "JOIN_TYPE_LEFT",
            4: "JOIN_TYPE_RIGHT",
            5: "JOIN_TYPE_LEFT_SEMI",
            6: "JOIN_TYPE_RIGHT_SEMI",
            7: "JOIN_TYPE_LEFT_ANTI",
            8: "JOIN_TYPE_RIGHT_ANTI",
            9: "JOIN_TYPE_LEFT_SINGLE",
            10: "JOIN_TYPE_RIGHT_SINGLE",
            11: "JOIN_TYPE_LEFT_MARK",
            12: "JOIN_TYPE_RIGHT_MARK",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "JOIN_TYPE_UNSPECIFIED": 0,
            "JOIN_TYPE_INNER": 1,
            "JOIN_TYPE_OUTER": 2,
            "JOIN_TYPE_LEFT": 3,
            "JOIN_TYPE_RIGHT": 4,
            "JOIN_TYPE_LEFT_SEMI": 5,
            "JOIN_TYPE_RIGHT_SEMI": 6,
            "JOIN_TYPE_LEFT_ANTI": 7,
            "JOIN_TYPE_RIGHT_ANTI": 8,
            "JOIN_TYPE_LEFT_SINGLE": 9,
            "JOIN_TYPE_RIGHT_SINGLE": 10,
            "JOIN_TYPE_LEFT_MARK": 11,
            "JOIN_TYPE_RIGHT_MARK": 12,
        }


class NestedLoopJoinRelJoinType(betterproto2.Enum):
    UNSPECIFIED = 0

    INNER = 1

    OUTER = 2

    LEFT = 3

    RIGHT = 4

    LEFT_SEMI = 5

    RIGHT_SEMI = 6

    LEFT_ANTI = 7

    RIGHT_ANTI = 8

    LEFT_SINGLE = 9

    RIGHT_SINGLE = 10

    LEFT_MARK = 11

    RIGHT_MARK = 12

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "JOIN_TYPE_UNSPECIFIED",
            1: "JOIN_TYPE_INNER",
            2: "JOIN_TYPE_OUTER",
            3: "JOIN_TYPE_LEFT",
            4: "JOIN_TYPE_RIGHT",
            5: "JOIN_TYPE_LEFT_SEMI",
            6: "JOIN_TYPE_RIGHT_SEMI",
            7: "JOIN_TYPE_LEFT_ANTI",
            8: "JOIN_TYPE_RIGHT_ANTI",
            9: "JOIN_TYPE_LEFT_SINGLE",
            10: "JOIN_TYPE_RIGHT_SINGLE",
            11: "JOIN_TYPE_LEFT_MARK",
            12: "JOIN_TYPE_RIGHT_MARK",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "JOIN_TYPE_UNSPECIFIED": 0,
            "JOIN_TYPE_INNER": 1,
            "JOIN_TYPE_OUTER": 2,
            "JOIN_TYPE_LEFT": 3,
            "JOIN_TYPE_RIGHT": 4,
            "JOIN_TYPE_LEFT_SEMI": 5,
            "JOIN_TYPE_RIGHT_SEMI": 6,
            "JOIN_TYPE_LEFT_ANTI": 7,
            "JOIN_TYPE_RIGHT_ANTI": 8,
            "JOIN_TYPE_LEFT_SINGLE": 9,
            "JOIN_TYPE_RIGHT_SINGLE": 10,
            "JOIN_TYPE_LEFT_MARK": 11,
            "JOIN_TYPE_RIGHT_MARK": 12,
        }


class RelCommonHintComputationType(betterproto2.Enum):
    UNSPECIFIED = 0

    HASHTABLE = 1

    BLOOM_FILTER = 2

    UNKNOWN = 9999

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "COMPUTATION_TYPE_UNSPECIFIED",
            1: "COMPUTATION_TYPE_HASHTABLE",
            2: "COMPUTATION_TYPE_BLOOM_FILTER",
            9999: "COMPUTATION_TYPE_UNKNOWN",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "COMPUTATION_TYPE_UNSPECIFIED": 0,
            "COMPUTATION_TYPE_HASHTABLE": 1,
            "COMPUTATION_TYPE_BLOOM_FILTER": 2,
            "COMPUTATION_TYPE_UNKNOWN": 9999,
        }


class SetRelSetOp(betterproto2.Enum):
    UNSPECIFIED = 0

    MINUS_PRIMARY = 1

    MINUS_PRIMARY_ALL = 7

    MINUS_MULTISET = 2

    INTERSECTION_PRIMARY = 3

    INTERSECTION_MULTISET = 4

    INTERSECTION_MULTISET_ALL = 8

    UNION_DISTINCT = 5

    UNION_ALL = 6

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "SET_OP_UNSPECIFIED",
            1: "SET_OP_MINUS_PRIMARY",
            7: "SET_OP_MINUS_PRIMARY_ALL",
            2: "SET_OP_MINUS_MULTISET",
            3: "SET_OP_INTERSECTION_PRIMARY",
            4: "SET_OP_INTERSECTION_MULTISET",
            8: "SET_OP_INTERSECTION_MULTISET_ALL",
            5: "SET_OP_UNION_DISTINCT",
            6: "SET_OP_UNION_ALL",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "SET_OP_UNSPECIFIED": 0,
            "SET_OP_MINUS_PRIMARY": 1,
            "SET_OP_MINUS_PRIMARY_ALL": 7,
            "SET_OP_MINUS_MULTISET": 2,
            "SET_OP_INTERSECTION_PRIMARY": 3,
            "SET_OP_INTERSECTION_MULTISET": 4,
            "SET_OP_INTERSECTION_MULTISET_ALL": 8,
            "SET_OP_UNION_DISTINCT": 5,
            "SET_OP_UNION_ALL": 6,
        }


class SortFieldSortDirection(betterproto2.Enum):
    UNSPECIFIED = 0

    ASC_NULLS_FIRST = 1

    ASC_NULLS_LAST = 2

    DESC_NULLS_FIRST = 3

    DESC_NULLS_LAST = 4

    CLUSTERED = 5

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "SORT_DIRECTION_UNSPECIFIED",
            1: "SORT_DIRECTION_ASC_NULLS_FIRST",
            2: "SORT_DIRECTION_ASC_NULLS_LAST",
            3: "SORT_DIRECTION_DESC_NULLS_FIRST",
            4: "SORT_DIRECTION_DESC_NULLS_LAST",
            5: "SORT_DIRECTION_CLUSTERED",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "SORT_DIRECTION_UNSPECIFIED": 0,
            "SORT_DIRECTION_ASC_NULLS_FIRST": 1,
            "SORT_DIRECTION_ASC_NULLS_LAST": 2,
            "SORT_DIRECTION_DESC_NULLS_FIRST": 3,
            "SORT_DIRECTION_DESC_NULLS_LAST": 4,
            "SORT_DIRECTION_CLUSTERED": 5,
        }


class TypeNullability(betterproto2.Enum):
    UNSPECIFIED = 0

    NULLABLE = 1

    REQUIRED = 2

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "NULLABILITY_UNSPECIFIED",
            1: "NULLABILITY_NULLABLE",
            2: "NULLABILITY_REQUIRED",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "NULLABILITY_UNSPECIFIED": 0,
            "NULLABILITY_NULLABLE": 1,
            "NULLABILITY_REQUIRED": 2,
        }


class WriteRelOutputMode(betterproto2.Enum):
    UNSPECIFIED = 0

    NO_OUTPUT = 1
    """
    return no records at all
    """

    MODIFIED_RECORDS = 2
    """
    this mode makes the operator return all the record INSERTED/DELETED/UPDATED by the operator.
    The operator returns the AFTER-image of any change. This can be further manipulated by operators upstreams
    (e.g., retunring the typical "count of modified records").
    For scenarios in which the BEFORE image is required, the user must implement a spool (via references to
    subplans in the body of the Rel input) and return those with anounter PlanRel.relations.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "OUTPUT_MODE_UNSPECIFIED",
            1: "OUTPUT_MODE_NO_OUTPUT",
            2: "OUTPUT_MODE_MODIFIED_RECORDS",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "OUTPUT_MODE_UNSPECIFIED": 0,
            "OUTPUT_MODE_NO_OUTPUT": 1,
            "OUTPUT_MODE_MODIFIED_RECORDS": 2,
        }


class WriteRelWriteOp(betterproto2.Enum):
    UNSPECIFIED = 0

    INSERT = 1
    """
    The insert of new records in a table
    """

    DELETE = 2
    """
    The removal of records from a table
    """

    UPDATE = 3
    """
    The modification of existing records within a table
    """

    CTAS = 4
    """
    The Creation of a new table, and the insert of new records in the table
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "WRITE_OP_UNSPECIFIED",
            1: "WRITE_OP_INSERT",
            2: "WRITE_OP_DELETE",
            3: "WRITE_OP_UPDATE",
            4: "WRITE_OP_CTAS",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "WRITE_OP_UNSPECIFIED": 0,
            "WRITE_OP_INSERT": 1,
            "WRITE_OP_DELETE": 2,
            "WRITE_OP_UPDATE": 3,
            "WRITE_OP_CTAS": 4,
        }


@dataclass(eq=False, repr=False)
class AggregateFunction(betterproto2.Message):
    """
    An aggregate function.
    """

    function_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)
    """
    Points to a function_anchor defined in this plan, which must refer
    to an aggregate function in the associated YAML file. Required; 0 is
    considered to be a valid anchor/reference.
    """

    arguments: "list[FunctionArgument]" = betterproto2.field(7, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    The arguments to be bound to the function. This must have exactly the
    number of arguments specified in the function definition, and the
    argument types must also match exactly:

     - Value arguments must be bound using FunctionArgument.value, and
       the expression in that must yield a value of a type that a function
       overload is defined for.
     - Type arguments must be bound using FunctionArgument.type, and a
       function overload must be defined for that type.
     - Enum arguments must be bound using FunctionArgument.enum
       followed by Enum.specified, with a string that case-insensitively
       matches one of the allowed options.
     - Optional enum arguments must be bound using FunctionArgument.enum
       followed by either Enum.specified or Enum.unspecified. If specified,
       the string must case-insensitively match one of the allowed options.
    """

    options: "list[FunctionOption]" = betterproto2.field(8, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    Options to specify behavior for corner cases, or leave behavior
    unspecified if the consumer does not need specific behavior in these
    cases.
    """

    output_type: "Type | None" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True)
    """
    Must be set to the return type of the function, exactly as derived
    using the declaration in the extension.
    """

    phase: "AggregationPhase" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: AggregationPhase(0)
    )
    """
    Describes which part of the aggregation to perform within the context of
    distributed algorithms. Required. Must be set to INITIAL_TO_RESULT for
    aggregate functions that are not decomposable.
    """

    sorts: "list[SortField]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    If specified, the aggregated records are ordered according to this list
    before they are aggregated. The first sort field has the highest
    priority; only if a sort field determines two records to be equivalent is
    the next field queried. This field is optional.
    """

    invocation: "AggregateFunctionAggregationInvocation" = betterproto2.field(
        6, betterproto2.TYPE_ENUM, default_factory=lambda: AggregateFunctionAggregationInvocation(0)
    )
    """
    Specifies whether equivalent records are merged before being aggregated.
    Optional, defaults to AGGREGATION_INVOCATION_ALL.
    """

    args: "list[Expression]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    deprecated; use arguments instead
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("args"):
            warnings.warn("AggregateFunction.args is deprecated", DeprecationWarning)


default_message_pool.register_message("substrait", "AggregateFunction", AggregateFunction)


@dataclass(eq=False, repr=False)
class AggregateRel(betterproto2.Message):
    """
    The relational operator representing a GROUP BY Aggregate
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    input: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    """
    Input of the aggregation
    """

    groupings: "list[AggregateRelGrouping]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    A list of zero or more grouping sets that the aggregation measures should
    be calculated for. There must be at least one grouping set if there are no
    measures (but it can be the empty grouping set).
    """

    measures: "list[AggregateRelMeasure]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    A list of one or more aggregate expressions along with an optional filter.
    Required if there are no groupings.
    """

    grouping_expressions: "list[Expression]" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    A list of zero or more grouping expressions that grouping sets (i.e.,
    `Grouping` messages in the `groupings` field) can reference. Each
    expression in this list must be referred to by at least one
    `Grouping.expression_references`.
    """

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "AggregateRel", AggregateRel)


@dataclass(eq=False, repr=False)
class AggregateRelGrouping(betterproto2.Message):
    grouping_expressions: "list[Expression]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    Deprecated in favor of `expression_references` below.
    """

    expression_references: "list[int]" = betterproto2.field(2, betterproto2.TYPE_UINT32, repeated=True)
    """
    A list of zero or more references to grouping expressions, i.e., indices
    into the `grouping_expression` list.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("grouping_expressions"):
            warnings.warn("AggregateRelGrouping.grouping_expressions is deprecated", DeprecationWarning)


default_message_pool.register_message("substrait", "AggregateRel.Grouping", AggregateRelGrouping)


@dataclass(eq=False, repr=False)
class AggregateRelMeasure(betterproto2.Message):
    measure: "AggregateFunction | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    filter: "Expression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    """
    An optional boolean expression that acts to filter which records are
    included in the measure. True means include this record for calculation
    within the measure.
    Helps to support SUM(<c>) FILTER(WHERE...) syntax without masking opportunities for optimization
    """


default_message_pool.register_message("substrait", "AggregateRel.Measure", AggregateRelMeasure)


@dataclass(eq=False, repr=False)
class Capabilities(betterproto2.Message):
    """
    Defines a set of Capabilities that a system (producer or consumer) supports.
    """

    substrait_versions: "list[str]" = betterproto2.field(1, betterproto2.TYPE_STRING, repeated=True)
    """
    List of Substrait versions this system supports
    """

    advanced_extension_type_urls: "list[str]" = betterproto2.field(2, betterproto2.TYPE_STRING, repeated=True)
    """
    list of com.google.Any message types this system supports for advanced
    extensions.
    """

    simple_extensions: "list[CapabilitiesSimpleExtension]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    list of simple extensions this system supports.
    """


default_message_pool.register_message("substrait", "Capabilities", Capabilities)


@dataclass(eq=False, repr=False)
class CapabilitiesSimpleExtension(betterproto2.Message):
    uri: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    function_keys: "list[str]" = betterproto2.field(2, betterproto2.TYPE_STRING, repeated=True)

    type_keys: "list[str]" = betterproto2.field(3, betterproto2.TYPE_STRING, repeated=True)

    type_variation_keys: "list[str]" = betterproto2.field(4, betterproto2.TYPE_STRING, repeated=True)


default_message_pool.register_message("substrait", "Capabilities.SimpleExtension", CapabilitiesSimpleExtension)


@dataclass(eq=False, repr=False)
class ComparisonJoinKey(betterproto2.Message):
    """
    Hash joins and merge joins are a specialization of the general join where the join
    expression is an series of comparisons between fields that are ANDed together.  The
    behavior of this comparison is flexible
    """

    left: "ExpressionFieldReference | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    """
    The key to compare from the left table
    """

    right: "ExpressionFieldReference | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    """
    The key to compare from the right table
    """

    comparison: "ComparisonJoinKeyComparisonType | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Describes how to compare the two keys
    """


default_message_pool.register_message("substrait", "ComparisonJoinKey", ComparisonJoinKey)


@dataclass(eq=False, repr=False)
class ComparisonJoinKeyComparisonType(betterproto2.Message):
    """
    Describes how the relation should consider if two rows are a match

    Oneofs:
        - inner_type:
    """

    simple: "ComparisonJoinKeySimpleComparisonType | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True, group="inner_type"
    )
    """
    One of the simple comparison behaviors is used
    """

    custom_function_reference: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True, group="inner_type"
    )
    """
    A custom comparison behavior is used.  This can happen, for example, when using
    collations, where we might want to do something like a case-insensitive comparison.

    This must be a binary function with a boolean return type
    """


default_message_pool.register_message("substrait", "ComparisonJoinKey.ComparisonType", ComparisonJoinKeyComparisonType)


@dataclass(eq=False, repr=False)
class ConsistentPartitionWindowRel(betterproto2.Message):
    """
    ConsistentPartitionWindowRel provides the ability to perform calculations across sets of rows
    that are related to the current query row. It can be used to execute window functions where
    all the windows share the same partitioning and ordering.
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    input: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    window_functions: "list[ConsistentPartitionWindowRelWindowRelFunction]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )

    partition_expressions: "list[Expression]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)

    sorts: "list[SortField]" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, repeated=True)

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "ConsistentPartitionWindowRel", ConsistentPartitionWindowRel)


@dataclass(eq=False, repr=False)
class ConsistentPartitionWindowRelWindowRelFunction(betterproto2.Message):
    """
    This message mirrors the `WindowFunction` message but removes the fields defining the partition,
    sorts, and bounds, since those must be consistent across the various functions in this rel.  Refer
    to the `WindowFunction` message for a description of these fields.
    """

    function_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    arguments: "list[FunctionArgument]" = betterproto2.field(9, betterproto2.TYPE_MESSAGE, repeated=True)

    options: "list[FunctionOption]" = betterproto2.field(11, betterproto2.TYPE_MESSAGE, repeated=True)

    output_type: "Type | None" = betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True)

    phase: "AggregationPhase" = betterproto2.field(
        6, betterproto2.TYPE_ENUM, default_factory=lambda: AggregationPhase(0)
    )

    invocation: "AggregateFunctionAggregationInvocation" = betterproto2.field(
        10, betterproto2.TYPE_ENUM, default_factory=lambda: AggregateFunctionAggregationInvocation(0)
    )

    lower_bound: "ExpressionWindowFunctionBound | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )

    upper_bound: "ExpressionWindowFunctionBound | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )

    bounds_type: "ExpressionWindowFunctionBoundsType" = betterproto2.field(
        12, betterproto2.TYPE_ENUM, default_factory=lambda: ExpressionWindowFunctionBoundsType(0)
    )


default_message_pool.register_message(
    "substrait", "ConsistentPartitionWindowRel.WindowRelFunction", ConsistentPartitionWindowRelWindowRelFunction
)


@dataclass(eq=False, repr=False)
class CrossRel(betterproto2.Message):
    """
    Cartesian product relational operator of two tables (left and right)
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    left: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    right: "Rel | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "CrossRel", CrossRel)


@dataclass(eq=False, repr=False)
class DdlRel(betterproto2.Message):
    """


    Oneofs:
        - write_type: Definition of which type of object we are operating on
    """

    named_object: "NamedObjectWrite | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="write_type"
    )

    extension_object: "ExtensionObject | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="write_type"
    )

    table_schema: "NamedStruct | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)
    """
    The columns that will be modified (representing after-image of a schema change)
    """

    table_defaults: "ExpressionLiteralStruct | None" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True)
    """
    The default values for the columns (representing after-image of a schema change)
    E.g., in case of an ALTER TABLE that changes some of the column default values, we expect
    the table_defaults Struct to report a full list of default values reflecting the result of applying
    the ALTER TABLE operator successfully
    """

    object: "DdlRelDdlObject" = betterproto2.field(
        5, betterproto2.TYPE_ENUM, default_factory=lambda: DdlRelDdlObject(0)
    )
    """
    Which type of object we operate on
    """

    op: "DdlRelDdlOp" = betterproto2.field(6, betterproto2.TYPE_ENUM, default_factory=lambda: DdlRelDdlOp(0))
    """
    The type of operation to perform
    """

    view_definition: "Rel | None" = betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True)
    """
    The body of the CREATE VIEW
    """

    common: "RelCommon | None" = betterproto2.field(8, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "DdlRel", DdlRel)


@dataclass(eq=False, repr=False)
class DerivationExpression(betterproto2.Message):
    """


    Oneofs:
        - kind:
    """

    bool: "TypeBoolean | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    i8: "TypeI8 | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    i16: "TypeI16 | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    i32: "TypeI32 | None" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    i64: "TypeI64 | None" = betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    fp32: "TypeFp32 | None" = betterproto2.field(10, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    fp64: "TypeFp64 | None" = betterproto2.field(11, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    string: "TypeString | None" = betterproto2.field(12, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    binary: "TypeBinary | None" = betterproto2.field(13, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    timestamp: "TypeTimestamp | None" = betterproto2.field(14, betterproto2.TYPE_MESSAGE, optional=True, group="kind")
    """
    Deprecated in favor of `ExpressionPrecisionTimestamp precision_timestamp`
    """

    date: "TypeDate | None" = betterproto2.field(16, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    time: "TypeTime | None" = betterproto2.field(17, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    interval_year: "TypeIntervalYear | None" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    timestamp_tz: "TypeTimestampTz | None" = betterproto2.field(
        29, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    Deprecated in favor of `ExpressionPrecisionTimestampTZ precision_timestamp_tz`
    """

    uuid: "TypeUuid | None" = betterproto2.field(32, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    interval_day: "DerivationExpressionExpressionIntervalDay | None" = betterproto2.field(
        20, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    interval_compound: "DerivationExpressionExpressionIntervalCompound | None" = betterproto2.field(
        42, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    fixed_char: "DerivationExpressionExpressionFixedChar | None" = betterproto2.field(
        21, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    varchar: "DerivationExpressionExpressionVarChar | None" = betterproto2.field(
        22, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    fixed_binary: "DerivationExpressionExpressionFixedBinary | None" = betterproto2.field(
        23, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    decimal: "DerivationExpressionExpressionDecimal | None" = betterproto2.field(
        24, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    precision_timestamp: "DerivationExpressionExpressionPrecisionTimestamp | None" = betterproto2.field(
        40, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    precision_timestamp_tz: "DerivationExpressionExpressionPrecisionTimestampTz | None" = betterproto2.field(
        41, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    struct: "DerivationExpressionExpressionStruct | None" = betterproto2.field(
        25, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    list: "DerivationExpressionExpressionList | None" = betterproto2.field(
        27, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    map: "DerivationExpressionExpressionMap | None" = betterproto2.field(
        28, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    user_defined: "DerivationExpressionExpressionUserDefined | None" = betterproto2.field(
        30, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    user_defined_pointer: "int | None" = betterproto2.field(31, betterproto2.TYPE_UINT32, optional=True, group="kind")
    """
    Deprecated in favor of user_defined, which allows nullability and
    variations to be specified. If user_defined_pointer is encountered,
    treat it as being non-nullable and having the default variation.
    """

    type_parameter_name: "str | None" = betterproto2.field(33, betterproto2.TYPE_STRING, optional=True, group="kind")

    integer_parameter_name: "str | None" = betterproto2.field(34, betterproto2.TYPE_STRING, optional=True, group="kind")

    integer_literal: "int | None" = betterproto2.field(35, betterproto2.TYPE_INT32, optional=True, group="kind")

    unary_op: "DerivationExpressionUnaryOp | None" = betterproto2.field(
        36, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    binary_op: "DerivationExpressionBinaryOp | None" = betterproto2.field(
        37, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    if_else: "DerivationExpressionIfElse | None" = betterproto2.field(
        38, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    return_program: "DerivationExpressionReturnProgram | None" = betterproto2.field(
        39, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("timestamp"):
            warnings.warn("DerivationExpression.timestamp is deprecated", DeprecationWarning)
        if self.is_set("timestamp_tz"):
            warnings.warn("DerivationExpression.timestamp_tz is deprecated", DeprecationWarning)
        if self.is_set("user_defined_pointer"):
            warnings.warn("DerivationExpression.user_defined_pointer is deprecated", DeprecationWarning)


default_message_pool.register_message("substrait", "DerivationExpression", DerivationExpression)


@dataclass(eq=False, repr=False)
class DerivationExpressionBinaryOp(betterproto2.Message):
    op_type: "DerivationExpressionBinaryOpBinaryOpType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: DerivationExpressionBinaryOpBinaryOpType(0)
    )

    arg1: "DerivationExpression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    arg2: "DerivationExpression | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "DerivationExpression.BinaryOp", DerivationExpressionBinaryOp)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionDecimal(betterproto2.Message):
    scale: "DerivationExpression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    precision: "DerivationExpression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(3, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "DerivationExpression.ExpressionDecimal", DerivationExpressionExpressionDecimal
)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionFixedBinary(betterproto2.Message):
    length: "DerivationExpression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "DerivationExpression.ExpressionFixedBinary", DerivationExpressionExpressionFixedBinary
)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionFixedChar(betterproto2.Message):
    length: "DerivationExpression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "DerivationExpression.ExpressionFixedChar", DerivationExpressionExpressionFixedChar
)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionIntervalCompound(betterproto2.Message):
    precision: "DerivationExpression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "DerivationExpression.ExpressionIntervalCompound", DerivationExpressionExpressionIntervalCompound
)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionIntervalDay(betterproto2.Message):
    precision: "DerivationExpression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "DerivationExpression.ExpressionIntervalDay", DerivationExpressionExpressionIntervalDay
)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionList(betterproto2.Message):
    type: "DerivationExpression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "DerivationExpression.ExpressionList", DerivationExpressionExpressionList
)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionMap(betterproto2.Message):
    key: "DerivationExpression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    value: "DerivationExpression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(3, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "DerivationExpression.ExpressionMap", DerivationExpressionExpressionMap
)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionNamedStruct(betterproto2.Message):
    names: "list[str]" = betterproto2.field(1, betterproto2.TYPE_STRING, repeated=True)

    struct: "DerivationExpressionExpressionStruct | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "substrait", "DerivationExpression.ExpressionNamedStruct", DerivationExpressionExpressionNamedStruct
)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionPrecisionTimestamp(betterproto2.Message):
    precision: "DerivationExpression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "DerivationExpression.ExpressionPrecisionTimestamp", DerivationExpressionExpressionPrecisionTimestamp
)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionPrecisionTimestampTz(betterproto2.Message):
    precision: "DerivationExpression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait",
    "DerivationExpression.ExpressionPrecisionTimestampTZ",
    DerivationExpressionExpressionPrecisionTimestampTz,
)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionStruct(betterproto2.Message):
    types: "list[DerivationExpression]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "DerivationExpression.ExpressionStruct", DerivationExpressionExpressionStruct
)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionUserDefined(betterproto2.Message):
    type_pointer: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "DerivationExpression.ExpressionUserDefined", DerivationExpressionExpressionUserDefined
)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionVarChar(betterproto2.Message):
    length: "DerivationExpression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "DerivationExpression.ExpressionVarChar", DerivationExpressionExpressionVarChar
)


@dataclass(eq=False, repr=False)
class DerivationExpressionIfElse(betterproto2.Message):
    if_condition: "DerivationExpression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    if_return: "DerivationExpression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    else_return: "DerivationExpression | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "DerivationExpression.IfElse", DerivationExpressionIfElse)


@dataclass(eq=False, repr=False)
class DerivationExpressionReturnProgram(betterproto2.Message):
    assignments: "list[DerivationExpressionReturnProgramAssignment]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )

    final_expression: "DerivationExpression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message(
    "substrait", "DerivationExpression.ReturnProgram", DerivationExpressionReturnProgram
)


@dataclass(eq=False, repr=False)
class DerivationExpressionReturnProgramAssignment(betterproto2.Message):
    name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    expression: "DerivationExpression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message(
    "substrait", "DerivationExpression.ReturnProgram.Assignment", DerivationExpressionReturnProgramAssignment
)


@dataclass(eq=False, repr=False)
class DerivationExpressionUnaryOp(betterproto2.Message):
    op_type: "DerivationExpressionUnaryOpUnaryOpType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: DerivationExpressionUnaryOpUnaryOpType(0)
    )

    arg: "DerivationExpression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "DerivationExpression.UnaryOp", DerivationExpressionUnaryOp)


@dataclass(eq=False, repr=False)
class ExchangeRel(betterproto2.Message):
    """
    A redistribution operation

    Oneofs:
        - exchange_kind: the type of exchange used
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    input: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    partition_count: "int" = betterproto2.field(3, betterproto2.TYPE_INT32)

    targets: "list[ExchangeRelExchangeTarget]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)

    scatter_by_fields: "ExchangeRelScatterFields | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="exchange_kind"
    )

    single_target: "ExchangeRelSingleBucketExpression | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="exchange_kind"
    )

    multi_target: "ExchangeRelMultiBucketExpression | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="exchange_kind"
    )

    round_robin: "ExchangeRelRoundRobin | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="exchange_kind"
    )

    broadcast: "ExchangeRelBroadcast | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="exchange_kind"
    )

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "ExchangeRel", ExchangeRel)


@dataclass(eq=False, repr=False)
class ExchangeRelBroadcast(betterproto2.Message):
    """
    Send all data to every target.
    """

    pass


default_message_pool.register_message("substrait", "ExchangeRel.Broadcast", ExchangeRelBroadcast)


@dataclass(eq=False, repr=False)
class ExchangeRelExchangeTarget(betterproto2.Message):
    """
    The message to describe partition targets of an exchange

    Oneofs:
        - target_type:
    """

    partition_id: "list[int]" = betterproto2.field(1, betterproto2.TYPE_INT32, repeated=True)
    """
    Describes the partition id(s) to send. If this is empty, all data is sent
    to this target.
    """

    uri: "str | None" = betterproto2.field(2, betterproto2.TYPE_STRING, optional=True, group="target_type")

    extended: "_google__protobuf__.Any | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="target_type"
    )


default_message_pool.register_message("substrait", "ExchangeRel.ExchangeTarget", ExchangeRelExchangeTarget)


@dataclass(eq=False, repr=False)
class ExchangeRelMultiBucketExpression(betterproto2.Message):
    """
    Returns zero or more bucket numbers per record
    """

    expression: "Expression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    constrained_to_count: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)


default_message_pool.register_message(
    "substrait", "ExchangeRel.MultiBucketExpression", ExchangeRelMultiBucketExpression
)


@dataclass(eq=False, repr=False)
class ExchangeRelRoundRobin(betterproto2.Message):
    """
    Route approximately
    """

    exact: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    whether the round robin behavior is required to exact (per record) or
    approximate. Defaults to approximate.
    """


default_message_pool.register_message("substrait", "ExchangeRel.RoundRobin", ExchangeRelRoundRobin)


@dataclass(eq=False, repr=False)
class ExchangeRelScatterFields(betterproto2.Message):
    fields: "list[ExpressionFieldReference]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("substrait", "ExchangeRel.ScatterFields", ExchangeRelScatterFields)


@dataclass(eq=False, repr=False)
class ExchangeRelSingleBucketExpression(betterproto2.Message):
    """
    Returns a single bucket number per record.
    """

    expression: "Expression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message(
    "substrait", "ExchangeRel.SingleBucketExpression", ExchangeRelSingleBucketExpression
)


@dataclass(eq=False, repr=False)
class ExpandRel(betterproto2.Message):
    """
    Duplicates records by emitting one or more rows per input row.  The number of rows emitted per
    input row is the same for all input rows.

    In addition to a field being emitted per input field an extra int64 field is emitted which
    contains a zero-indexed ordinal corresponding to the duplicate definition.
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    input: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    fields: "list[ExpandRelExpandField]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    There should be one definition here for each input field.  Any fields beyond the provided
    definitions will be emitted as is (as if a consistent_field record with an identity
    expression was provided).
    """


default_message_pool.register_message("substrait", "ExpandRel", ExpandRel)


@dataclass(eq=False, repr=False)
class ExpandRelExpandField(betterproto2.Message):
    """


    Oneofs:
        - field_type:
    """

    switching_field: "ExpandRelSwitchingField | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="field_type"
    )
    """
    Field that switches output based on which duplicate is being output.  Every
    switching_field should contain the same number of duplicates (so that the output rows
    are of consistent size and type).  If there are not enough switching field definitions
    to match the other field definitions NULL will be returned to fill the extras.
    """

    consistent_field: "Expression | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="field_type"
    )
    """
    Field that outputs the same value no matter which duplicate is being output.  Equivalent
    to a switching_field that lists the same expression multiple times.
    """


default_message_pool.register_message("substrait", "ExpandRel.ExpandField", ExpandRelExpandField)


@dataclass(eq=False, repr=False)
class ExpandRelSwitchingField(betterproto2.Message):
    duplicates: "list[Expression]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    All duplicates must return the same type class but may differ in nullability.  The effective
    type of the output field will be nullable if any of the duplicate expressions are nullable.
    """


default_message_pool.register_message("substrait", "ExpandRel.SwitchingField", ExpandRelSwitchingField)


@dataclass(eq=False, repr=False)
class Expression(betterproto2.Message):
    """


    Oneofs:
        - rex_type:
    """

    literal: "ExpressionLiteral | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="rex_type"
    )

    selection: "ExpressionFieldReference | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="rex_type"
    )

    scalar_function: "ExpressionScalarFunction | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="rex_type"
    )

    window_function: "ExpressionWindowFunction | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="rex_type"
    )

    if_then: "ExpressionIfThen | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="rex_type"
    )

    switch_expression: "ExpressionSwitchExpression | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="rex_type"
    )

    singular_or_list: "ExpressionSingularOrList | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="rex_type"
    )

    multi_or_list: "ExpressionMultiOrList | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="rex_type"
    )

    cast: "ExpressionCast | None" = betterproto2.field(11, betterproto2.TYPE_MESSAGE, optional=True, group="rex_type")

    subquery: "ExpressionSubquery | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True, group="rex_type"
    )

    nested: "ExpressionNested | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True, group="rex_type"
    )

    enum: "ExpressionEnum | None" = betterproto2.field(10, betterproto2.TYPE_MESSAGE, optional=True, group="rex_type")
    """
    deprecated: enum literals are only sensible in the context of
    function arguments, for which FunctionArgument should now be
    used
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("enum"):
            warnings.warn("Expression.enum is deprecated", DeprecationWarning)


default_message_pool.register_message("substrait", "Expression", Expression)


@dataclass(eq=False, repr=False)
class ExpressionCast(betterproto2.Message):
    type: "Type | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    input: "Expression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    failure_behavior: "ExpressionCastFailureBehavior" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: ExpressionCastFailureBehavior(0)
    )


default_message_pool.register_message("substrait", "Expression.Cast", ExpressionCast)


@dataclass(eq=False, repr=False)
class ExpressionEmbeddedFunction(betterproto2.Message):
    """


    Oneofs:
        - kind:
    """

    arguments: "list[Expression]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    output_type: "Type | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    python_pickle_function: "ExpressionEmbeddedFunctionPythonPickleFunction | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    web_assembly_function: "ExpressionEmbeddedFunctionWebAssemblyFunction | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )


default_message_pool.register_message("substrait", "Expression.EmbeddedFunction", ExpressionEmbeddedFunction)


@dataclass(eq=False, repr=False)
class ExpressionEmbeddedFunctionPythonPickleFunction(betterproto2.Message):
    function: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    prerequisite: "list[str]" = betterproto2.field(2, betterproto2.TYPE_STRING, repeated=True)


default_message_pool.register_message(
    "substrait", "Expression.EmbeddedFunction.PythonPickleFunction", ExpressionEmbeddedFunctionPythonPickleFunction
)


@dataclass(eq=False, repr=False)
class ExpressionEmbeddedFunctionWebAssemblyFunction(betterproto2.Message):
    script: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    prerequisite: "list[str]" = betterproto2.field(2, betterproto2.TYPE_STRING, repeated=True)


default_message_pool.register_message(
    "substrait", "Expression.EmbeddedFunction.WebAssemblyFunction", ExpressionEmbeddedFunctionWebAssemblyFunction
)


@dataclass(eq=False, repr=False)
class ExpressionEnum(betterproto2.Message):
    """


    Oneofs:
        - enum_kind:
    """

    specified: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True, group="enum_kind")

    unspecified: "ExpressionEnumEmpty | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="enum_kind"
    )

    def __post_init__(self) -> None:
        warnings.warn("ExpressionEnum is deprecated", DeprecationWarning)
        super().__post_init__()


default_message_pool.register_message("substrait", "Expression.Enum", ExpressionEnum)


@dataclass(eq=False, repr=False)
class ExpressionEnumEmpty(betterproto2.Message):
    pass

    def __post_init__(self) -> None:
        warnings.warn("ExpressionEnumEmpty is deprecated", DeprecationWarning)
        super().__post_init__()


default_message_pool.register_message("substrait", "Expression.Enum.Empty", ExpressionEnumEmpty)


@dataclass(eq=False, repr=False)
class ExpressionFieldReference(betterproto2.Message):
    """
    A reference to an inner part of a complex object. Can reference reference a
    single element or a masked version of elements

    Oneofs:
        - reference_type: Whether this is composed of a single element reference or a masked
            element subtree
        - root_type: Whether this reference has an origin of a root struct or is based on the
            ouput of an expression. When this is a RootReference and direct_reference
            above is used, the direct_reference must be of a type StructField.
    """

    direct_reference: "ExpressionReferenceSegment | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="reference_type"
    )

    masked_reference: "ExpressionMaskExpression | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="reference_type"
    )

    expression: "Expression | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True, group="root_type")

    root_reference: "ExpressionFieldReferenceRootReference | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="root_type"
    )

    outer_reference: "ExpressionFieldReferenceOuterReference | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="root_type"
    )


default_message_pool.register_message("substrait", "Expression.FieldReference", ExpressionFieldReference)


@dataclass(eq=False, repr=False)
class ExpressionFieldReferenceOuterReference(betterproto2.Message):
    """
    A root reference for the outer relation's subquery
    """

    steps_out: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)
    """
    number of subquery boundaries to traverse up for this field's reference

    This value must be >= 1
    """


default_message_pool.register_message(
    "substrait", "Expression.FieldReference.OuterReference", ExpressionFieldReferenceOuterReference
)


@dataclass(eq=False, repr=False)
class ExpressionFieldReferenceRootReference(betterproto2.Message):
    """
    Singleton that expresses this FieldReference is rooted off the root
    incoming record type
    """

    pass


default_message_pool.register_message(
    "substrait", "Expression.FieldReference.RootReference", ExpressionFieldReferenceRootReference
)


@dataclass(eq=False, repr=False)
class ExpressionIfThen(betterproto2.Message):
    ifs: "list[ExpressionIfThenIfClause]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    A list of one or more IfClauses
    """

    else_: "Expression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    """
    The returned Expression if no IfClauses are satisified
    """


default_message_pool.register_message("substrait", "Expression.IfThen", ExpressionIfThen)


@dataclass(eq=False, repr=False)
class ExpressionIfThenIfClause(betterproto2.Message):
    if_: "Expression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    then: "Expression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "Expression.IfThen.IfClause", ExpressionIfThenIfClause)


@dataclass(eq=False, repr=False)
class ExpressionLiteral(betterproto2.Message):
    """


    Oneofs:
        - literal_type:
    """

    boolean: "bool | None" = betterproto2.field(1, betterproto2.TYPE_BOOL, optional=True, group="literal_type")

    i8: "int | None" = betterproto2.field(2, betterproto2.TYPE_INT32, optional=True, group="literal_type")

    i16: "int | None" = betterproto2.field(3, betterproto2.TYPE_INT32, optional=True, group="literal_type")

    i32: "int | None" = betterproto2.field(5, betterproto2.TYPE_INT32, optional=True, group="literal_type")

    i64: "int | None" = betterproto2.field(7, betterproto2.TYPE_INT64, optional=True, group="literal_type")

    fp32: "float | None" = betterproto2.field(10, betterproto2.TYPE_FLOAT, optional=True, group="literal_type")

    fp64: "float | None" = betterproto2.field(11, betterproto2.TYPE_DOUBLE, optional=True, group="literal_type")

    string: "str | None" = betterproto2.field(12, betterproto2.TYPE_STRING, optional=True, group="literal_type")

    binary: "bytes | None" = betterproto2.field(13, betterproto2.TYPE_BYTES, optional=True, group="literal_type")

    timestamp: "int | None" = betterproto2.field(14, betterproto2.TYPE_INT64, optional=True, group="literal_type")
    """
    Timestamp in units of microseconds since the UNIX epoch.
    Deprecated in favor of `precision_timestamp`
    """

    date: "int | None" = betterproto2.field(16, betterproto2.TYPE_INT32, optional=True, group="literal_type")
    """
    Date in units of days since the UNIX epoch.
    """

    time: "int | None" = betterproto2.field(17, betterproto2.TYPE_INT64, optional=True, group="literal_type")
    """
    Time in units of microseconds past midnight
    """

    interval_year_to_month: "ExpressionLiteralIntervalYearToMonth | None" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type"
    )

    interval_day_to_second: "ExpressionLiteralIntervalDayToSecond | None" = betterproto2.field(
        20, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type"
    )

    interval_compound: "ExpressionLiteralIntervalCompound | None" = betterproto2.field(
        36, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type"
    )

    fixed_char: "str | None" = betterproto2.field(21, betterproto2.TYPE_STRING, optional=True, group="literal_type")

    var_char: "ExpressionLiteralVarChar | None" = betterproto2.field(
        22, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type"
    )

    fixed_binary: "bytes | None" = betterproto2.field(23, betterproto2.TYPE_BYTES, optional=True, group="literal_type")

    decimal: "ExpressionLiteralDecimal | None" = betterproto2.field(
        24, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type"
    )

    precision_timestamp: "ExpressionLiteralPrecisionTimestamp | None" = betterproto2.field(
        34, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type"
    )

    precision_timestamp_tz: "ExpressionLiteralPrecisionTimestamp | None" = betterproto2.field(
        35, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type"
    )

    struct: "ExpressionLiteralStruct | None" = betterproto2.field(
        25, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type"
    )

    map: "ExpressionLiteralMap | None" = betterproto2.field(
        26, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type"
    )

    timestamp_tz: "int | None" = betterproto2.field(27, betterproto2.TYPE_INT64, optional=True, group="literal_type")
    """
    Timestamp in units of microseconds since the UNIX epoch.
    Deprecated in favor of `precision_timestamp_tz`
    """

    uuid: "bytes | None" = betterproto2.field(28, betterproto2.TYPE_BYTES, optional=True, group="literal_type")

    null: "Type | None" = betterproto2.field(29, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type")
    """
    a typed null literal
    """

    list: "ExpressionLiteralList | None" = betterproto2.field(
        30, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type"
    )

    empty_list: "TypeList | None" = betterproto2.field(
        31, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type"
    )

    empty_map: "TypeMap | None" = betterproto2.field(32, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type")

    user_defined: "ExpressionLiteralUserDefined | None" = betterproto2.field(
        33, betterproto2.TYPE_MESSAGE, optional=True, group="literal_type"
    )

    nullable: "bool" = betterproto2.field(50, betterproto2.TYPE_BOOL)
    """
    Whether the literal_type above should be treated as a nullable type.
    Applies to all members of the literal_type oneof EXCEPT:
     * Type null             (must be nullable by definition)
     * Type.List empty_list  (use Type.List::nullability)
     * Type.Map empty_map    (use Type.Map::nullability)
    """

    type_variation_reference: "int" = betterproto2.field(51, betterproto2.TYPE_UINT32)
    """
    optionally points to a type_variation_anchor defined in this plan.
    Applies to all members of union other than the Typed null (which should
    directly declare the type variation).
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("timestamp"):
            warnings.warn("ExpressionLiteral.timestamp is deprecated", DeprecationWarning)
        if self.is_set("timestamp_tz"):
            warnings.warn("ExpressionLiteral.timestamp_tz is deprecated", DeprecationWarning)


default_message_pool.register_message("substrait", "Expression.Literal", ExpressionLiteral)


@dataclass(eq=False, repr=False)
class ExpressionLiteralDecimal(betterproto2.Message):
    value: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    little-endian twos-complement integer representation of complete value
    (ignoring precision) Always 16 bytes in length
    """

    precision: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)
    """
    The maximum number of digits allowed in the value.
    the maximum precision is 38.
    """

    scale: "int" = betterproto2.field(3, betterproto2.TYPE_INT32)
    """
    declared scale of decimal literal
    """


default_message_pool.register_message("substrait", "Expression.Literal.Decimal", ExpressionLiteralDecimal)


@dataclass(eq=False, repr=False)
class ExpressionLiteralIntervalCompound(betterproto2.Message):
    interval_year_to_month: "ExpressionLiteralIntervalYearToMonth | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    interval_day_to_second: "ExpressionLiteralIntervalDayToSecond | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "substrait", "Expression.Literal.IntervalCompound", ExpressionLiteralIntervalCompound
)


@dataclass(eq=False, repr=False)
class ExpressionLiteralIntervalDayToSecond(betterproto2.Message):
    """


    Oneofs:
        - precision_mode: Consumers should expect either (miroseconds) to be set or (precision and subseconds) to be set
    """

    days: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)

    seconds: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)

    microseconds: "int | None" = betterproto2.field(3, betterproto2.TYPE_INT32, optional=True, group="precision_mode")
    """
    use precision and subseconds below, they cover and replace microseconds.
    """

    precision: "int | None" = betterproto2.field(4, betterproto2.TYPE_INT32, optional=True, group="precision_mode")
    """
    Sub-second precision, 0 means the value given is in seconds, 3 is milliseconds, 6 microseconds, 9 is nanoseconds. Should be used with subseconds below.
    """

    subseconds: "int" = betterproto2.field(5, betterproto2.TYPE_INT64)
    """
    the number of fractional seconds using 1e(-precision) units. Should only be used with precision field, not microseconds.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("microseconds"):
            warnings.warn("ExpressionLiteralIntervalDayToSecond.microseconds is deprecated", DeprecationWarning)


default_message_pool.register_message(
    "substrait", "Expression.Literal.IntervalDayToSecond", ExpressionLiteralIntervalDayToSecond
)


@dataclass(eq=False, repr=False)
class ExpressionLiteralIntervalYearToMonth(betterproto2.Message):
    years: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)

    months: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)


default_message_pool.register_message(
    "substrait", "Expression.Literal.IntervalYearToMonth", ExpressionLiteralIntervalYearToMonth
)


@dataclass(eq=False, repr=False)
class ExpressionLiteralList(betterproto2.Message):
    values: "list[ExpressionLiteral]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    A homogeneously typed list of literals
    """


default_message_pool.register_message("substrait", "Expression.Literal.List", ExpressionLiteralList)


@dataclass(eq=False, repr=False)
class ExpressionLiteralMap(betterproto2.Message):
    key_values: "list[ExpressionLiteralMapKeyValue]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("substrait", "Expression.Literal.Map", ExpressionLiteralMap)


@dataclass(eq=False, repr=False)
class ExpressionLiteralMapKeyValue(betterproto2.Message):
    key: "ExpressionLiteral | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    value: "ExpressionLiteral | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "Expression.Literal.Map.KeyValue", ExpressionLiteralMapKeyValue)


@dataclass(eq=False, repr=False)
class ExpressionLiteralPrecisionTimestamp(betterproto2.Message):
    precision: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)
    """
    Sub-second precision, 0 means the value given is in seconds, 3 is milliseconds, 6 microseconds, 9 is nanoseconds
    """

    value: "int" = betterproto2.field(2, betterproto2.TYPE_INT64)
    """
    Time passed since 1970-01-01 00:00:00.000000 in UTC for PrecisionTimestampTZ and unspecified timezone for PrecisionTimestamp
    """


default_message_pool.register_message(
    "substrait", "Expression.Literal.PrecisionTimestamp", ExpressionLiteralPrecisionTimestamp
)


@dataclass(eq=False, repr=False)
class ExpressionLiteralStruct(betterproto2.Message):
    fields: "list[ExpressionLiteral]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    A possibly heterogeneously typed list of literals
    """


default_message_pool.register_message("substrait", "Expression.Literal.Struct", ExpressionLiteralStruct)


@dataclass(eq=False, repr=False)
class ExpressionLiteralUserDefined(betterproto2.Message):
    """


    Oneofs:
        - val: a user-defined literal can be encoded in one of two ways
    """

    type_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)
    """
    points to a type_anchor defined in this plan
    """

    type_parameters: "list[TypeParameter]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    The parameters to be bound to the type class, if the type class is
    parameterizable.
    """

    value: "_google__protobuf__.Any | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="val"
    )
    """
    the value of the literal, serialized using some type-specific protobuf message
    """

    struct: "ExpressionLiteralStruct | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="val"
    )
    """
    the value of the literal, serialized using the structure definition in its declaration
    """


default_message_pool.register_message("substrait", "Expression.Literal.UserDefined", ExpressionLiteralUserDefined)


@dataclass(eq=False, repr=False)
class ExpressionLiteralVarChar(betterproto2.Message):
    value: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    length: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)


default_message_pool.register_message("substrait", "Expression.Literal.VarChar", ExpressionLiteralVarChar)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpression(betterproto2.Message):
    """
    A reference that takes an existing subtype and selectively removes fields
    from it. For example, one might initially have an inner struct with 100
    fields but a particular operation only needs to interact with only 2 of
    those 100 fields. In this situation, one would use a mask expression to
    eliminate the 98 fields that are not relevant to the rest of the operation
    pipeline.

    Note that this does not fundamentally alter the structure of data beyond
    the elimination of unnecessary elements.
    """

    select: "ExpressionMaskExpressionStructSelect | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    maintain_singular_struct: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)


default_message_pool.register_message("substrait", "Expression.MaskExpression", ExpressionMaskExpression)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionListSelect(betterproto2.Message):
    selection: "list[ExpressionMaskExpressionListSelectListSelectItem]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )

    child: "ExpressionMaskExpressionSelect | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message(
    "substrait", "Expression.MaskExpression.ListSelect", ExpressionMaskExpressionListSelect
)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionListSelectListSelectItem(betterproto2.Message):
    """


    Oneofs:
        - type:
    """

    item: "ExpressionMaskExpressionListSelectListSelectItemListElement | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="type"
    )

    slice: "ExpressionMaskExpressionListSelectListSelectItemListSlice | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="type"
    )


default_message_pool.register_message(
    "substrait", "Expression.MaskExpression.ListSelect.ListSelectItem", ExpressionMaskExpressionListSelectListSelectItem
)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionListSelectListSelectItemListElement(betterproto2.Message):
    field: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)


default_message_pool.register_message(
    "substrait",
    "Expression.MaskExpression.ListSelect.ListSelectItem.ListElement",
    ExpressionMaskExpressionListSelectListSelectItemListElement,
)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionListSelectListSelectItemListSlice(betterproto2.Message):
    start: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)

    end: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)


default_message_pool.register_message(
    "substrait",
    "Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice",
    ExpressionMaskExpressionListSelectListSelectItemListSlice,
)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionMapSelect(betterproto2.Message):
    """


    Oneofs:
        - select:
    """

    key: "ExpressionMaskExpressionMapSelectMapKey | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="select"
    )

    expression: "ExpressionMaskExpressionMapSelectMapKeyExpression | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="select"
    )

    child: "ExpressionMaskExpressionSelect | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message(
    "substrait", "Expression.MaskExpression.MapSelect", ExpressionMaskExpressionMapSelect
)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionMapSelectMapKey(betterproto2.Message):
    map_key: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "substrait", "Expression.MaskExpression.MapSelect.MapKey", ExpressionMaskExpressionMapSelectMapKey
)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionMapSelectMapKeyExpression(betterproto2.Message):
    map_key_expression: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "substrait",
    "Expression.MaskExpression.MapSelect.MapKeyExpression",
    ExpressionMaskExpressionMapSelectMapKeyExpression,
)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionSelect(betterproto2.Message):
    """


    Oneofs:
        - type:
    """

    struct: "ExpressionMaskExpressionStructSelect | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="type"
    )

    list: "ExpressionMaskExpressionListSelect | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="type"
    )

    map: "ExpressionMaskExpressionMapSelect | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="type"
    )


default_message_pool.register_message("substrait", "Expression.MaskExpression.Select", ExpressionMaskExpressionSelect)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionStructItem(betterproto2.Message):
    field: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)

    child: "ExpressionMaskExpressionSelect | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message(
    "substrait", "Expression.MaskExpression.StructItem", ExpressionMaskExpressionStructItem
)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionStructSelect(betterproto2.Message):
    struct_items: "list[ExpressionMaskExpressionStructItem]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "substrait", "Expression.MaskExpression.StructSelect", ExpressionMaskExpressionStructSelect
)


@dataclass(eq=False, repr=False)
class ExpressionMultiOrList(betterproto2.Message):
    value: "list[Expression]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    options: "list[ExpressionMultiOrListRecord]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("substrait", "Expression.MultiOrList", ExpressionMultiOrList)


@dataclass(eq=False, repr=False)
class ExpressionMultiOrListRecord(betterproto2.Message):
    fields: "list[Expression]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("substrait", "Expression.MultiOrList.Record", ExpressionMultiOrListRecord)


@dataclass(eq=False, repr=False)
class ExpressionNested(betterproto2.Message):
    """
    Expression to dynamically construct nested types.

    Oneofs:
        - nested_type:
    """

    nullable: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    Whether the returned nested type is nullable.
    """

    type_variation_reference: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)
    """
    Optionally points to a type_variation_anchor defined in this plan for
    the returned nested type.
    """

    struct: "ExpressionNestedStruct | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="nested_type"
    )

    list: "ExpressionNestedList | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="nested_type"
    )

    map: "ExpressionNestedMap | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="nested_type"
    )


default_message_pool.register_message("substrait", "Expression.Nested", ExpressionNested)


@dataclass(eq=False, repr=False)
class ExpressionNestedList(betterproto2.Message):
    values: "list[Expression]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    A homogeneously-typed list of one or more expressions that form the
    list entries. To specify an empty list, use Literal.empty_list
    (otherwise type information would be missing).
    """


default_message_pool.register_message("substrait", "Expression.Nested.List", ExpressionNestedList)


@dataclass(eq=False, repr=False)
class ExpressionNestedMap(betterproto2.Message):
    key_values: "list[ExpressionNestedMapKeyValue]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    One or more key-value pairs. To specify an empty map, use
    Literal.empty_map (otherwise type information would be missing).
    """


default_message_pool.register_message("substrait", "Expression.Nested.Map", ExpressionNestedMap)


@dataclass(eq=False, repr=False)
class ExpressionNestedMapKeyValue(betterproto2.Message):
    key: "Expression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    """
    Mandatory key/value expressions.
    """

    value: "Expression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "Expression.Nested.Map.KeyValue", ExpressionNestedMapKeyValue)


@dataclass(eq=False, repr=False)
class ExpressionNestedStruct(betterproto2.Message):
    fields: "list[Expression]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    Zero or more possibly heterogeneously-typed list of expressions that
    form the struct fields.
    """


default_message_pool.register_message("substrait", "Expression.Nested.Struct", ExpressionNestedStruct)


@dataclass(eq=False, repr=False)
class ExpressionReferenceSegment(betterproto2.Message):
    """
    A way to reference the inner property of a complex record. Can reference
    either a map key by literal, a struct field by the ordinal position of
    the desired field or a particular element in an array. Supports
    expressions that would roughly translate to something similar to:
    a.b[2].c['my_map_key'].x where a,b,c and x are struct field references
    (ordinalized in the internal representation here), [2] is a list offset
    and ['my_map_key'] is a reference into a map field.

    Oneofs:
        - reference_type:
    """

    map_key: "ExpressionReferenceSegmentMapKey | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="reference_type"
    )

    struct_field: "ExpressionReferenceSegmentStructField | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="reference_type"
    )

    list_element: "ExpressionReferenceSegmentListElement | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="reference_type"
    )


default_message_pool.register_message("substrait", "Expression.ReferenceSegment", ExpressionReferenceSegment)


@dataclass(eq=False, repr=False)
class ExpressionReferenceSegmentListElement(betterproto2.Message):
    offset: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)
    """
    zero-indexed ordinal position of element in list
    """

    child: "ExpressionReferenceSegment | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    """
    Optional child segment
    """


default_message_pool.register_message(
    "substrait", "Expression.ReferenceSegment.ListElement", ExpressionReferenceSegmentListElement
)


@dataclass(eq=False, repr=False)
class ExpressionReferenceSegmentMapKey(betterproto2.Message):
    map_key: "ExpressionLiteral | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    """
    literal based reference to specific possible value in map.
    """

    child: "ExpressionReferenceSegment | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    """
    Optional child segment
    """


default_message_pool.register_message(
    "substrait", "Expression.ReferenceSegment.MapKey", ExpressionReferenceSegmentMapKey
)


@dataclass(eq=False, repr=False)
class ExpressionReferenceSegmentStructField(betterproto2.Message):
    field: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)
    """
    zero-indexed ordinal position of field in struct
    """

    child: "ExpressionReferenceSegment | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    """
    Optional child segment
    """


default_message_pool.register_message(
    "substrait", "Expression.ReferenceSegment.StructField", ExpressionReferenceSegmentStructField
)


@dataclass(eq=False, repr=False)
class ExpressionScalarFunction(betterproto2.Message):
    """
    A scalar function call.
    """

    function_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)
    """
    Points to a function_anchor defined in this plan, which must refer
    to a scalar function in the associated YAML file. Required; avoid
    using anchor/reference zero.
    """

    arguments: "list[FunctionArgument]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    The arguments to be bound to the function. This must have exactly the
    number of arguments specified in the function definition, and the
    argument types must also match exactly:

     - Value arguments must be bound using FunctionArgument.value, and
       the expression in that must yield a value of a type that a function
       overload is defined for.
     - Type arguments must be bound using FunctionArgument.type.
     - Enum arguments must be bound using FunctionArgument.enum
       followed by Enum.specified, with a string that case-insensitively
       matches one of the allowed options.
    """

    options: "list[FunctionOption]" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    Options to specify behavior for corner cases, or leave behavior
    unspecified if the consumer does not need specific behavior in these
    cases.
    """

    output_type: "Type | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)
    """
    Must be set to the return type of the function, exactly as derived
    using the declaration in the extension.
    """

    args: "list[Expression]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    Deprecated; use arguments instead.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("args"):
            warnings.warn("ExpressionScalarFunction.args is deprecated", DeprecationWarning)


default_message_pool.register_message("substrait", "Expression.ScalarFunction", ExpressionScalarFunction)


@dataclass(eq=False, repr=False)
class ExpressionSingularOrList(betterproto2.Message):
    value: "Expression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    options: "list[Expression]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("substrait", "Expression.SingularOrList", ExpressionSingularOrList)


@dataclass(eq=False, repr=False)
class ExpressionSubquery(betterproto2.Message):
    """
    Subquery relation expression

    Oneofs:
        - subquery_type:
    """

    scalar: "ExpressionSubqueryScalar | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="subquery_type"
    )
    """
    Scalar subquery
    """

    in_predicate: "ExpressionSubqueryInPredicate | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="subquery_type"
    )
    """
    x IN y predicate
    """

    set_predicate: "ExpressionSubquerySetPredicate | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="subquery_type"
    )
    """
    EXISTS/UNIQUE predicate
    """

    set_comparison: "ExpressionSubquerySetComparison | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="subquery_type"
    )
    """
    ANY/ALL predicate
    """


default_message_pool.register_message("substrait", "Expression.Subquery", ExpressionSubquery)


@dataclass(eq=False, repr=False)
class ExpressionSubqueryInPredicate(betterproto2.Message):
    """
    Predicate checking that the left expression is contained in the right
    subquery

    Examples:

    x IN (SELECT * FROM t)
    (x, y) IN (SELECT a, b FROM t)
    """

    needles: "list[Expression]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    haystack: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "Expression.Subquery.InPredicate", ExpressionSubqueryInPredicate)


@dataclass(eq=False, repr=False)
class ExpressionSubqueryScalar(betterproto2.Message):
    """
    A subquery with one row and one column. This is often an aggregate
    though not required to be.
    """

    input: "Rel | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "Expression.Subquery.Scalar", ExpressionSubqueryScalar)


@dataclass(eq=False, repr=False)
class ExpressionSubquerySetComparison(betterproto2.Message):
    """
    A subquery comparison using ANY or ALL.
    Examples:

    SELECT *
    FROM t1
    WHERE x < ANY(SELECT y from t2)
    """

    reduction_op: "ExpressionSubquerySetComparisonReductionOp" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: ExpressionSubquerySetComparisonReductionOp(0)
    )
    """
    ANY or ALL
    """

    comparison_op: "ExpressionSubquerySetComparisonComparisonOp" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: ExpressionSubquerySetComparisonComparisonOp(0)
    )
    """
    A comparison operator
    """

    left: "Expression | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)
    """
    left side of the expression
    """

    right: "Rel | None" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True)
    """
    right side of the expression
    """


default_message_pool.register_message("substrait", "Expression.Subquery.SetComparison", ExpressionSubquerySetComparison)


@dataclass(eq=False, repr=False)
class ExpressionSubquerySetPredicate(betterproto2.Message):
    """
    A predicate over a set of rows in the form of a subquery
    EXISTS and UNIQUE are common SQL forms of this operation.
    """

    predicate_op: "ExpressionSubquerySetPredicatePredicateOp" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: ExpressionSubquerySetPredicatePredicateOp(0)
    )
    """
    TODO: should allow expressions
    """

    tuples: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "Expression.Subquery.SetPredicate", ExpressionSubquerySetPredicate)


@dataclass(eq=False, repr=False)
class ExpressionSwitchExpression(betterproto2.Message):
    match: "Expression | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)

    ifs: "list[ExpressionSwitchExpressionIfValue]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    else_: "Expression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "Expression.SwitchExpression", ExpressionSwitchExpression)


@dataclass(eq=False, repr=False)
class ExpressionSwitchExpressionIfValue(betterproto2.Message):
    if_: "ExpressionLiteral | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    then: "Expression | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message(
    "substrait", "Expression.SwitchExpression.IfValue", ExpressionSwitchExpressionIfValue
)


@dataclass(eq=False, repr=False)
class ExpressionWindowFunction(betterproto2.Message):
    """
    A window function call.
    """

    function_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)
    """
    Points to a function_anchor defined in this plan. The function must be:
     - a window function
     - an aggregate function

    An aggregate function referenced here should be treated as a window
    function with Window Type STREAMING

    Required; 0 is considered to be a valid anchor/reference.
    """

    arguments: "list[FunctionArgument]" = betterproto2.field(9, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    The arguments to be bound to the function. This must have exactly the
    number of arguments specified in the function definition, and the
    argument types must also match exactly:

     - Value arguments must be bound using FunctionArgument.value, and
       the expression in that must yield a value of a type that a function
       overload is defined for.
     - Type arguments must be bound using FunctionArgument.type, and a
       function overload must be defined for that type.
     - Enum arguments must be bound using FunctionArgument.enum
       followed by Enum.specified, with a string that case-insensitively
       matches one of the allowed options.
    """

    options: "list[FunctionOption]" = betterproto2.field(11, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    Options to specify behavior for corner cases, or leave behavior
    unspecified if the consumer does not need specific behavior in these
    cases.
    """

    output_type: "Type | None" = betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True)
    """
    Must be set to the return type of the function, exactly as derived
    using the declaration in the extension.
    """

    phase: "AggregationPhase" = betterproto2.field(
        6, betterproto2.TYPE_ENUM, default_factory=lambda: AggregationPhase(0)
    )
    """
    Describes which part of the window function to perform within the
    context of distributed algorithms. Required. Must be set to
    INITIAL_TO_RESULT for window functions that are not decomposable.
    """

    sorts: "list[SortField]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    If specified, the records that are part of the window defined by
    upper_bound and lower_bound are ordered according to this list
    before they are aggregated. The first sort field has the highest
    priority; only if a sort field determines two records to be equivalent
    is the next field queried. This field is optional, and is only allowed
    if the window function is defined to support sorting.
    """

    invocation: "AggregateFunctionAggregationInvocation" = betterproto2.field(
        10, betterproto2.TYPE_ENUM, default_factory=lambda: AggregateFunctionAggregationInvocation(0)
    )
    """
    Specifies whether equivalent records are merged before being aggregated.
    Optional, defaults to AGGREGATION_INVOCATION_ALL.
    """

    partitions: "list[Expression]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    When one or more partition expressions are specified, two records are
    considered to be in the same partition if and only if these expressions
    yield an equal record of values for both. When computing the window
    function, only the subset of records within the bounds that are also in
    the same partition as the current record are aggregated.
    """

    bounds_type: "ExpressionWindowFunctionBoundsType" = betterproto2.field(
        12, betterproto2.TYPE_ENUM, default_factory=lambda: ExpressionWindowFunctionBoundsType(0)
    )
    """
    Defines the bounds type: ROWS, RANGE
    """

    lower_bound: "ExpressionWindowFunctionBound | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Defines the record relative to the current record from which the window
    extends. The bound is inclusive. If the lower bound indexes a record
    greater than the upper bound, TODO (null range/no records passed?
    wrapping around as if lower/upper were swapped? error? null?).
    Optional; defaults to the start of the partition.
    """

    upper_bound: "ExpressionWindowFunctionBound | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Defines the record relative to the current record up to which the window
    extends. The bound is inclusive. If the upper bound indexes a record
    less than the lower bound, TODO (null range/no records passed?
    wrapping around as if lower/upper were swapped? error? null?).
    Optional; defaults to the end of the partition.
    """

    args: "list[Expression]" = betterproto2.field(8, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    Deprecated; use arguments instead.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("args"):
            warnings.warn("ExpressionWindowFunction.args is deprecated", DeprecationWarning)


default_message_pool.register_message("substrait", "Expression.WindowFunction", ExpressionWindowFunction)


@dataclass(eq=False, repr=False)
class ExpressionWindowFunctionBound(betterproto2.Message):
    """
    Defines one of the two boundaries for the window of a window function.

    Oneofs:
        - kind:
    """

    preceding: "ExpressionWindowFunctionBoundPreceding | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    The bound extends some number of records behind the current record.
    """

    following: "ExpressionWindowFunctionBoundFollowing | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    The bound extends some number of records ahead of the current
    record.
    """

    current_row: "ExpressionWindowFunctionBoundCurrentRow | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    The bound extends to the current record.
    """

    unbounded: "ExpressionWindowFunctionBoundUnbounded | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    The bound extends to the start of the partition or the end of the
    partition, depending on whether this represents the upper or lower
    bound.
    """


default_message_pool.register_message("substrait", "Expression.WindowFunction.Bound", ExpressionWindowFunctionBound)


@dataclass(eq=False, repr=False)
class ExpressionWindowFunctionBoundCurrentRow(betterproto2.Message):
    """
    Defines that the bound extends to or from the current record.
    """

    pass


default_message_pool.register_message(
    "substrait", "Expression.WindowFunction.Bound.CurrentRow", ExpressionWindowFunctionBoundCurrentRow
)


@dataclass(eq=False, repr=False)
class ExpressionWindowFunctionBoundFollowing(betterproto2.Message):
    """
    Defines that the bound extends this far ahead of the current record.
    """

    offset: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    A strictly positive integer specifying the number of records that
    the window extends ahead of the current record. Required. Use
    CurrentRow for offset zero and Preceding for negative offsets.
    """


default_message_pool.register_message(
    "substrait", "Expression.WindowFunction.Bound.Following", ExpressionWindowFunctionBoundFollowing
)


@dataclass(eq=False, repr=False)
class ExpressionWindowFunctionBoundPreceding(betterproto2.Message):
    """
    Defines that the bound extends this far back from the current record.
    """

    offset: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    A strictly positive integer specifying the number of records that
    the window extends back from the current record. Required. Use
    CurrentRow for offset zero and Following for negative offsets.
    """


default_message_pool.register_message(
    "substrait", "Expression.WindowFunction.Bound.Preceding", ExpressionWindowFunctionBoundPreceding
)


@dataclass(eq=False, repr=False)
class ExpressionWindowFunctionBoundUnbounded(betterproto2.Message):
    """
    Defines an "unbounded bound": for lower bounds this means the start
    of the partition, and for upper bounds this means the end of the
    partition.
    """

    pass


default_message_pool.register_message(
    "substrait", "Expression.WindowFunction.Bound.Unbounded", ExpressionWindowFunctionBoundUnbounded
)


@dataclass(eq=False, repr=False)
class ExpressionReference(betterproto2.Message):
    """


    Oneofs:
        - expr_type:
    """

    expression: "Expression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True, group="expr_type")

    measure: "AggregateFunction | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="expr_type"
    )

    output_names: "list[str]" = betterproto2.field(3, betterproto2.TYPE_STRING, repeated=True)
    """
    Field names in depth-first order
    """


default_message_pool.register_message("substrait", "ExpressionReference", ExpressionReference)


@dataclass(eq=False, repr=False)
class ExtendedExpression(betterproto2.Message):
    """
    Describe a set of operations to complete.
    For compactness sake, identifiers are normalized at the plan level.
    """

    version: "Version | None" = betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True)
    """
    Substrait version of the expression. Optional up to 0.17.0, required for later
    versions.
    """

    extension_uris: "list[extensions.SimpleExtensionUri]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    a list of yaml specifications this expression may depend on
    """

    extensions: "list[extensions.SimpleExtensionDeclaration]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    a list of extensions this expression may depend on
    """

    referred_expr: "list[ExpressionReference]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    one or more expression trees with same order in plan rel
    """

    base_schema: "NamedStruct | None" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True)

    advanced_extensions: "extensions.AdvancedExtension | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    additional extensions associated with this expression.
    """

    expected_type_urls: "list[str]" = betterproto2.field(6, betterproto2.TYPE_STRING, repeated=True)
    """
    A list of com.google.Any entities that this plan may use. Can be used to
    warn if some embedded message types are unknown. Note that this list may
    include message types that are ignorable (optimizations) or that are
    unused. In many cases, a consumer may be able to work with a plan even if
    one or more message types defined here are unknown.
    """


default_message_pool.register_message("substrait", "ExtendedExpression", ExtendedExpression)


@dataclass(eq=False, repr=False)
class ExtensionLeafRel(betterproto2.Message):
    """
    Stub to support extension with a zero inputs
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    detail: "_google__protobuf__.Any | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "ExtensionLeafRel", ExtensionLeafRel)


@dataclass(eq=False, repr=False)
class ExtensionMultiRel(betterproto2.Message):
    """
    Stub to support extension with multiple inputs
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    inputs: "list[Rel]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    detail: "_google__protobuf__.Any | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "ExtensionMultiRel", ExtensionMultiRel)


@dataclass(eq=False, repr=False)
class ExtensionObject(betterproto2.Message):
    """
    A stub type that can be used to extend/introduce new table types outside
    the specification.
    """

    detail: "_google__protobuf__.Any | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "ExtensionObject", ExtensionObject)


@dataclass(eq=False, repr=False)
class ExtensionSingleRel(betterproto2.Message):
    """
    Stub to support extension with a single input
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    input: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    detail: "_google__protobuf__.Any | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "ExtensionSingleRel", ExtensionSingleRel)


@dataclass(eq=False, repr=False)
class FetchRel(betterproto2.Message):
    """
    The relational operator representing LIMIT/OFFSET or TOP type semantics.
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    input: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    offset: "int" = betterproto2.field(3, betterproto2.TYPE_INT64)
    """
    the offset expressed in number of records
    """

    count: "int" = betterproto2.field(4, betterproto2.TYPE_INT64)
    """
    the amount of records to return
    use -1 to signal that ALL records should be returned
    """

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "FetchRel", FetchRel)


@dataclass(eq=False, repr=False)
class FilterRel(betterproto2.Message):
    """
    The relational operator capturing simple FILTERs (as in the WHERE clause of SQL)
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    input: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    condition: "Expression | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "FilterRel", FilterRel)


@dataclass(eq=False, repr=False)
class FunctionArgument(betterproto2.Message):
    """
    The argument of a function

    Oneofs:
        - arg_type:
    """

    enum: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True, group="arg_type")

    type: "Type | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True, group="arg_type")

    value: "Expression | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True, group="arg_type")


default_message_pool.register_message("substrait", "FunctionArgument", FunctionArgument)


@dataclass(eq=False, repr=False)
class FunctionOption(betterproto2.Message):
    """
    An optional function argument.  Typically used for specifying behavior in
    invalid or corner cases.
    """

    name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Name of the option to set. If the consumer does not recognize the
    option, it must reject the plan. The name is matched case-insensitively
    with option names defined for the function.
    """

    preference: "list[str]" = betterproto2.field(2, betterproto2.TYPE_STRING, repeated=True)
    """
    List of behavior options allowed by the producer. At least one must be
    specified; to leave an option unspecified, simply don't add an entry to
    `options`. The consumer must use the first option from the list that it
    supports. If the consumer supports none of the specified options, it
    must reject the plan. The name is matched case-insensitively and must
    match one of the option values defined for the option.
    """


default_message_pool.register_message("substrait", "FunctionOption", FunctionOption)


@dataclass(eq=False, repr=False)
class FunctionSignature(betterproto2.Message):
    """
    List of function signatures available.
    """

    pass


default_message_pool.register_message("substrait", "FunctionSignature", FunctionSignature)


@dataclass(eq=False, repr=False)
class FunctionSignatureAggregate(betterproto2.Message):
    """


    Oneofs:
        - final_variable_behavior:
    """

    arguments: "list[FunctionSignatureArgument]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    name: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)

    description: "FunctionSignatureDescription | None" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True)

    deterministic: "bool" = betterproto2.field(7, betterproto2.TYPE_BOOL)

    session_dependent: "bool" = betterproto2.field(8, betterproto2.TYPE_BOOL)

    output_type: "DerivationExpression | None" = betterproto2.field(9, betterproto2.TYPE_MESSAGE, optional=True)

    variadic: "FunctionSignatureFinalArgVariadic | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="final_variable_behavior"
    )

    normal: "FunctionSignatureFinalArgNormal | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="final_variable_behavior"
    )

    ordered: "bool" = betterproto2.field(14, betterproto2.TYPE_BOOL)

    max_set: "int" = betterproto2.field(12, betterproto2.TYPE_UINT64)

    intermediate_type: "Type | None" = betterproto2.field(13, betterproto2.TYPE_MESSAGE, optional=True)

    implementations: "list[FunctionSignatureImplementation]" = betterproto2.field(
        15, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("substrait", "FunctionSignature.Aggregate", FunctionSignatureAggregate)


@dataclass(eq=False, repr=False)
class FunctionSignatureArgument(betterproto2.Message):
    """


    Oneofs:
        - argument_kind:
    """

    name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    value: "FunctionSignatureArgumentValueArgument | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="argument_kind"
    )

    type: "FunctionSignatureArgumentTypeArgument | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="argument_kind"
    )

    enum: "FunctionSignatureArgumentEnumArgument | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="argument_kind"
    )


default_message_pool.register_message("substrait", "FunctionSignature.Argument", FunctionSignatureArgument)


@dataclass(eq=False, repr=False)
class FunctionSignatureArgumentEnumArgument(betterproto2.Message):
    options: "list[str]" = betterproto2.field(1, betterproto2.TYPE_STRING, repeated=True)

    optional: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)


default_message_pool.register_message(
    "substrait", "FunctionSignature.Argument.EnumArgument", FunctionSignatureArgumentEnumArgument
)


@dataclass(eq=False, repr=False)
class FunctionSignatureArgumentTypeArgument(betterproto2.Message):
    type: "ParameterizedType | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message(
    "substrait", "FunctionSignature.Argument.TypeArgument", FunctionSignatureArgumentTypeArgument
)


@dataclass(eq=False, repr=False)
class FunctionSignatureArgumentValueArgument(betterproto2.Message):
    type: "ParameterizedType | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    constant: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)


default_message_pool.register_message(
    "substrait", "FunctionSignature.Argument.ValueArgument", FunctionSignatureArgumentValueArgument
)


@dataclass(eq=False, repr=False)
class FunctionSignatureDescription(betterproto2.Message):
    language: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    body: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message("substrait", "FunctionSignature.Description", FunctionSignatureDescription)


@dataclass(eq=False, repr=False)
class FunctionSignatureFinalArgNormal(betterproto2.Message):
    pass


default_message_pool.register_message("substrait", "FunctionSignature.FinalArgNormal", FunctionSignatureFinalArgNormal)


@dataclass(eq=False, repr=False)
class FunctionSignatureFinalArgVariadic(betterproto2.Message):
    min_args: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    the minimum number of arguments allowed for the list of final arguments
    (inclusive).
    """

    max_args: "int" = betterproto2.field(2, betterproto2.TYPE_INT64)
    """
    the maximum number of arguments allowed for the list of final arguments
    (exclusive)
    """

    consistency: "FunctionSignatureFinalArgVariadicParameterConsistency" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: FunctionSignatureFinalArgVariadicParameterConsistency(0)
    )
    """
    the type of parameterized type consistency
    """


default_message_pool.register_message(
    "substrait", "FunctionSignature.FinalArgVariadic", FunctionSignatureFinalArgVariadic
)


@dataclass(eq=False, repr=False)
class FunctionSignatureImplementation(betterproto2.Message):
    type: "FunctionSignatureImplementationType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: FunctionSignatureImplementationType(0)
    )

    uri: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message("substrait", "FunctionSignature.Implementation", FunctionSignatureImplementation)


@dataclass(eq=False, repr=False)
class FunctionSignatureScalar(betterproto2.Message):
    """


    Oneofs:
        - final_variable_behavior:
    """

    arguments: "list[FunctionSignatureArgument]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    name: "list[str]" = betterproto2.field(3, betterproto2.TYPE_STRING, repeated=True)

    description: "FunctionSignatureDescription | None" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True)

    deterministic: "bool" = betterproto2.field(7, betterproto2.TYPE_BOOL)

    session_dependent: "bool" = betterproto2.field(8, betterproto2.TYPE_BOOL)

    output_type: "DerivationExpression | None" = betterproto2.field(9, betterproto2.TYPE_MESSAGE, optional=True)

    variadic: "FunctionSignatureFinalArgVariadic | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="final_variable_behavior"
    )

    normal: "FunctionSignatureFinalArgNormal | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="final_variable_behavior"
    )

    implementations: "list[FunctionSignatureImplementation]" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("substrait", "FunctionSignature.Scalar", FunctionSignatureScalar)


@dataclass(eq=False, repr=False)
class FunctionSignatureWindow(betterproto2.Message):
    """


    Oneofs:
        - final_variable_behavior:
    """

    arguments: "list[FunctionSignatureArgument]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    name: "list[str]" = betterproto2.field(3, betterproto2.TYPE_STRING, repeated=True)

    description: "FunctionSignatureDescription | None" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True)

    deterministic: "bool" = betterproto2.field(7, betterproto2.TYPE_BOOL)

    session_dependent: "bool" = betterproto2.field(8, betterproto2.TYPE_BOOL)

    intermediate_type: "DerivationExpression | None" = betterproto2.field(9, betterproto2.TYPE_MESSAGE, optional=True)

    output_type: "DerivationExpression | None" = betterproto2.field(10, betterproto2.TYPE_MESSAGE, optional=True)

    variadic: "FunctionSignatureFinalArgVariadic | None" = betterproto2.field(
        16, betterproto2.TYPE_MESSAGE, optional=True, group="final_variable_behavior"
    )

    normal: "FunctionSignatureFinalArgNormal | None" = betterproto2.field(
        17, betterproto2.TYPE_MESSAGE, optional=True, group="final_variable_behavior"
    )

    ordered: "bool" = betterproto2.field(11, betterproto2.TYPE_BOOL)

    max_set: "int" = betterproto2.field(12, betterproto2.TYPE_UINT64)

    window_type: "FunctionSignatureWindowWindowType" = betterproto2.field(
        14, betterproto2.TYPE_ENUM, default_factory=lambda: FunctionSignatureWindowWindowType(0)
    )

    implementations: "list[FunctionSignatureImplementation]" = betterproto2.field(
        15, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("substrait", "FunctionSignature.Window", FunctionSignatureWindow)


@dataclass(eq=False, repr=False)
class HashJoinRel(betterproto2.Message):
    """
    The hash equijoin join operator will build a hash table out of the right input based on a set of join keys.
    It will then probe that hash table for incoming inputs, finding matches.

    Two rows are a match if the comparison function returns true for all keys
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    left: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    right: "Rel | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)

    left_keys: "list[ExpressionFieldReference]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    These fields are deprecated in favor of `keys`.  If they are set then
    the two lists (left_keys and right_keys) must have the same length and
    the comparion function is considered to be SimpleEqualityType::EQ
    """

    right_keys: "list[ExpressionFieldReference]" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, repeated=True)

    keys: "list[ComparisonJoinKey]" = betterproto2.field(8, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    One or more keys to join on.  The relation is invalid if this is empty
    (unless the deprecated left_keys/right_keys fields are being used).

    If a custom comparison function is used then it must be consistent with
    the hash function used for the keys.

    In other words, the hash function must return the same hash code when the
    comparison returns true.  For example, if the comparison function is
    "equals ignoring case" then the hash function must return the same hash
    code for strings that differ only by case.  Note: the hash function is not
    specified here.  It is the responsibility of the consumer to find an appropriate
    hash function for a given comparsion function or to reject the plan if it cannot
    do so.
    """

    post_join_filter: "Expression | None" = betterproto2.field(6, betterproto2.TYPE_MESSAGE, optional=True)

    type: "HashJoinRelJoinType" = betterproto2.field(
        7, betterproto2.TYPE_ENUM, default_factory=lambda: HashJoinRelJoinType(0)
    )

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("left_keys"):
            warnings.warn("HashJoinRel.left_keys is deprecated", DeprecationWarning)
        if self.is_set("right_keys"):
            warnings.warn("HashJoinRel.right_keys is deprecated", DeprecationWarning)


default_message_pool.register_message("substrait", "HashJoinRel", HashJoinRel)


@dataclass(eq=False, repr=False)
class JoinRel(betterproto2.Message):
    """
    The binary JOIN relational operator left-join-right, including various join types, a join condition and post_join_filter expression
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    left: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    right: "Rel | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)

    expression: "Expression | None" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True)

    post_join_filter: "Expression | None" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True)

    type: "JoinRelJoinType" = betterproto2.field(6, betterproto2.TYPE_ENUM, default_factory=lambda: JoinRelJoinType(0))

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "JoinRel", JoinRel)


@dataclass(eq=False, repr=False)
class MergeJoinRel(betterproto2.Message):
    """
    The merge equijoin does a join by taking advantage of two sets that are sorted on the join keys.
    This allows the join operation to be done in a streaming fashion.
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    left: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    right: "Rel | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)

    left_keys: "list[ExpressionFieldReference]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    These fields are deprecated in favor of `keys`.  If they are set then
    the two lists (left_keys and right_keys) must have the same length and
    the comparion function is considered to be SimpleEqualityType::EQ
    """

    right_keys: "list[ExpressionFieldReference]" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, repeated=True)

    keys: "list[ComparisonJoinKey]" = betterproto2.field(8, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    One or more keys to join on.  The relation is invalid if this is empty
    (unless the deprecated left_keys/right_keys fields are being used).

    If a custom comparison function is used then it must be consistent with
    the ordering of the input data.  For example, if the comparison function
    is "<" then we generally expect the data to be sorted in ascending order.

    If the comparison function is something like "less than ignoring case" then
    the data should be sorted appropriately (e.g. both "A" and "a" should come
    before "b")

    The sort order is not specified here.  It is typically the responsibility of
    the producer to ensure the plan sorts the data if needed (although the consumer
    is free to do so as well).  If possible, the consumer should verify the sort
    order and reject invalid plans.
    """

    post_join_filter: "Expression | None" = betterproto2.field(6, betterproto2.TYPE_MESSAGE, optional=True)

    type: "MergeJoinRelJoinType" = betterproto2.field(
        7, betterproto2.TYPE_ENUM, default_factory=lambda: MergeJoinRelJoinType(0)
    )

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("left_keys"):
            warnings.warn("MergeJoinRel.left_keys is deprecated", DeprecationWarning)
        if self.is_set("right_keys"):
            warnings.warn("MergeJoinRel.right_keys is deprecated", DeprecationWarning)


default_message_pool.register_message("substrait", "MergeJoinRel", MergeJoinRel)


@dataclass(eq=False, repr=False)
class NamedObjectWrite(betterproto2.Message):
    """
    A base object for writing (e.g., a table or a view).
    """

    names: "list[str]" = betterproto2.field(1, betterproto2.TYPE_STRING, repeated=True)
    """
    The list of string is used to represent namespacing (e.g., mydb.mytable).
    This assumes shared catalog between systems exchanging a message.
    """

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "NamedObjectWrite", NamedObjectWrite)


@dataclass(eq=False, repr=False)
class NamedStruct(betterproto2.Message):
    """
    A message for modeling name/type pairs.

    Useful for representing relation schemas.

    Notes:

    * The names field is in depth-first order.

    For example a schema such as:

    a: int64
    b: struct<c: float32, d: string>

    would have a `names` field that looks like:

    ["a", "b", "c", "d"]

    * Only struct fields are contained in this field's elements,
    * Map keys should be traversed first, then values when producing/consuming
    """

    names: "list[str]" = betterproto2.field(1, betterproto2.TYPE_STRING, repeated=True)
    """
    list of names in dfs order
    """

    struct: "TypeStruct | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "NamedStruct", NamedStruct)


@dataclass(eq=False, repr=False)
class NestedLoopJoinRel(betterproto2.Message):
    """
    The nested loop join (NLJ) operator will hold the entire right input and iterate over it using the
    left input, evaluating the join expression on the Cartesian product of all rows.
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    left: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    right: "Rel | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)

    expression: "Expression | None" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True)
    """
    optional, defaults to true (a cartesian join)
    """

    type: "NestedLoopJoinRelJoinType" = betterproto2.field(
        5, betterproto2.TYPE_ENUM, default_factory=lambda: NestedLoopJoinRelJoinType(0)
    )

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "NestedLoopJoinRel", NestedLoopJoinRel)


@dataclass(eq=False, repr=False)
class ParameterizedType(betterproto2.Message):
    """


    Oneofs:
        - kind:
    """

    bool: "TypeBoolean | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    i8: "TypeI8 | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    i16: "TypeI16 | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    i32: "TypeI32 | None" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    i64: "TypeI64 | None" = betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    fp32: "TypeFp32 | None" = betterproto2.field(10, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    fp64: "TypeFp64 | None" = betterproto2.field(11, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    string: "TypeString | None" = betterproto2.field(12, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    binary: "TypeBinary | None" = betterproto2.field(13, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    timestamp: "TypeTimestamp | None" = betterproto2.field(14, betterproto2.TYPE_MESSAGE, optional=True, group="kind")
    """
    Deprecated in favor of `ParameterizedPrecisionTimestamp precision_timestamp`
    """

    date: "TypeDate | None" = betterproto2.field(16, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    time: "TypeTime | None" = betterproto2.field(17, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    interval_year: "TypeIntervalYear | None" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    interval_day: "ParameterizedTypeParameterizedIntervalDay | None" = betterproto2.field(
        20, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    interval_compound: "ParameterizedTypeParameterizedIntervalCompound | None" = betterproto2.field(
        36, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    timestamp_tz: "TypeTimestampTz | None" = betterproto2.field(
        29, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    Deprecated in favor of `ParameterizedPrecisionTimestampTZ precision_timestamp_tz`
    """

    uuid: "TypeUuid | None" = betterproto2.field(32, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    fixed_char: "ParameterizedTypeParameterizedFixedChar | None" = betterproto2.field(
        21, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    varchar: "ParameterizedTypeParameterizedVarChar | None" = betterproto2.field(
        22, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    fixed_binary: "ParameterizedTypeParameterizedFixedBinary | None" = betterproto2.field(
        23, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    decimal: "ParameterizedTypeParameterizedDecimal | None" = betterproto2.field(
        24, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    precision_timestamp: "ParameterizedTypeParameterizedPrecisionTimestamp | None" = betterproto2.field(
        34, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    precision_timestamp_tz: "ParameterizedTypeParameterizedPrecisionTimestampTz | None" = betterproto2.field(
        35, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    struct: "ParameterizedTypeParameterizedStruct | None" = betterproto2.field(
        25, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    list: "ParameterizedTypeParameterizedList | None" = betterproto2.field(
        27, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    map: "ParameterizedTypeParameterizedMap | None" = betterproto2.field(
        28, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    user_defined: "ParameterizedTypeParameterizedUserDefined | None" = betterproto2.field(
        30, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    user_defined_pointer: "int | None" = betterproto2.field(31, betterproto2.TYPE_UINT32, optional=True, group="kind")
    """
    Deprecated in favor of user_defined, which allows nullability and
    variations to be specified. If user_defined_pointer is encountered,
    treat it as being non-nullable and having the default variation.
    """

    type_parameter: "ParameterizedTypeTypeParameter | None" = betterproto2.field(
        33, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("timestamp"):
            warnings.warn("ParameterizedType.timestamp is deprecated", DeprecationWarning)
        if self.is_set("timestamp_tz"):
            warnings.warn("ParameterizedType.timestamp_tz is deprecated", DeprecationWarning)
        if self.is_set("user_defined_pointer"):
            warnings.warn("ParameterizedType.user_defined_pointer is deprecated", DeprecationWarning)


default_message_pool.register_message("substrait", "ParameterizedType", ParameterizedType)


@dataclass(eq=False, repr=False)
class ParameterizedTypeIntegerOption(betterproto2.Message):
    """


    Oneofs:
        - integer_type:
    """

    literal: "int | None" = betterproto2.field(1, betterproto2.TYPE_INT32, optional=True, group="integer_type")

    parameter: "ParameterizedTypeIntegerParameter | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="integer_type"
    )


default_message_pool.register_message("substrait", "ParameterizedType.IntegerOption", ParameterizedTypeIntegerOption)


@dataclass(eq=False, repr=False)
class ParameterizedTypeIntegerParameter(betterproto2.Message):
    name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    range_start_inclusive: "ParameterizedTypeNullableInteger | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    range_end_exclusive: "ParameterizedTypeNullableInteger | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.IntegerParameter", ParameterizedTypeIntegerParameter
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeNullableInteger(betterproto2.Message):
    value: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)


default_message_pool.register_message(
    "substrait", "ParameterizedType.NullableInteger", ParameterizedTypeNullableInteger
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedDecimal(betterproto2.Message):
    scale: "ParameterizedTypeIntegerOption | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    precision: "ParameterizedTypeIntegerOption | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(3, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.ParameterizedDecimal", ParameterizedTypeParameterizedDecimal
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedFixedBinary(betterproto2.Message):
    length: "ParameterizedTypeIntegerOption | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.ParameterizedFixedBinary", ParameterizedTypeParameterizedFixedBinary
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedFixedChar(betterproto2.Message):
    length: "ParameterizedTypeIntegerOption | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.ParameterizedFixedChar", ParameterizedTypeParameterizedFixedChar
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedIntervalCompound(betterproto2.Message):
    precision: "ParameterizedTypeIntegerOption | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.ParameterizedIntervalCompound", ParameterizedTypeParameterizedIntervalCompound
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedIntervalDay(betterproto2.Message):
    precision: "ParameterizedTypeIntegerOption | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.ParameterizedIntervalDay", ParameterizedTypeParameterizedIntervalDay
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedList(betterproto2.Message):
    type: "ParameterizedType | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.ParameterizedList", ParameterizedTypeParameterizedList
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedMap(betterproto2.Message):
    key: "ParameterizedType | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    value: "ParameterizedType | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(3, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.ParameterizedMap", ParameterizedTypeParameterizedMap
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedNamedStruct(betterproto2.Message):
    names: "list[str]" = betterproto2.field(1, betterproto2.TYPE_STRING, repeated=True)
    """
    list of names in dfs order
    """

    struct: "ParameterizedTypeParameterizedStruct | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.ParameterizedNamedStruct", ParameterizedTypeParameterizedNamedStruct
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedPrecisionTimestamp(betterproto2.Message):
    precision: "ParameterizedTypeIntegerOption | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.ParameterizedPrecisionTimestamp", ParameterizedTypeParameterizedPrecisionTimestamp
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedPrecisionTimestampTz(betterproto2.Message):
    precision: "ParameterizedTypeIntegerOption | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait",
    "ParameterizedType.ParameterizedPrecisionTimestampTZ",
    ParameterizedTypeParameterizedPrecisionTimestampTz,
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedStruct(betterproto2.Message):
    types: "list[ParameterizedType]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.ParameterizedStruct", ParameterizedTypeParameterizedStruct
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedUserDefined(betterproto2.Message):
    type_pointer: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.ParameterizedUserDefined", ParameterizedTypeParameterizedUserDefined
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedVarChar(betterproto2.Message):
    length: "ParameterizedTypeIntegerOption | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    variation_pointer: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message(
    "substrait", "ParameterizedType.ParameterizedVarChar", ParameterizedTypeParameterizedVarChar
)


@dataclass(eq=False, repr=False)
class ParameterizedTypeTypeParameter(betterproto2.Message):
    name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    bounds: "list[ParameterizedType]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("substrait", "ParameterizedType.TypeParameter", ParameterizedTypeTypeParameter)


@dataclass(eq=False, repr=False)
class Plan(betterproto2.Message):
    """
    Describe a set of operations to complete.
    For compactness sake, identifiers are normalized at the plan level.
    """

    version: "Version | None" = betterproto2.field(6, betterproto2.TYPE_MESSAGE, optional=True)
    """
    Substrait version of the plan. Optional up to 0.17.0, required for later
    versions.
    """

    extension_uris: "list[extensions.SimpleExtensionUri]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    a list of yaml specifications this plan may depend on
    """

    extensions: "list[extensions.SimpleExtensionDeclaration]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    a list of extensions this plan may depend on
    """

    relations: "list[PlanRel]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    one or more relation trees that are associated with this plan.
    """

    advanced_extensions: "extensions.AdvancedExtension | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    additional extensions associated with this plan.
    """

    expected_type_urls: "list[str]" = betterproto2.field(5, betterproto2.TYPE_STRING, repeated=True)
    """
    A list of com.google.Any entities that this plan may use. Can be used to
    warn if some embedded message types are unknown. Note that this list may
    include message types that are ignorable (optimizations) or that are
    unused. In many cases, a consumer may be able to work with a plan even if
    one or more message types defined here are unknown.
    """


default_message_pool.register_message("substrait", "Plan", Plan)


@dataclass(eq=False, repr=False)
class PlanRel(betterproto2.Message):
    """
    Either a relation or root relation

    Oneofs:
        - rel_type:
    """

    rel: "Rel | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")
    """
    Any relation (used for references and CTEs)
    """

    root: "RelRoot | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")
    """
    The root of a relation tree
    """


default_message_pool.register_message("substrait", "PlanRel", PlanRel)


@dataclass(eq=False, repr=False)
class PlanVersion(betterproto2.Message):
    """
    This message type can be used to deserialize only the version of a Substrait
    Plan message. This prevents deserialization errors when there were breaking
    changes between the Substrait version of the tool that produced the plan and
    the Substrait version used to deserialize it, such that a consumer can emit
    a more helpful error message in this case.
    """

    version: "Version | None" = betterproto2.field(6, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "PlanVersion", PlanVersion)


@dataclass(eq=False, repr=False)
class ProjectRel(betterproto2.Message):
    """
    This operator allows to represent calculated expressions of fields (e.g., a+b). Direct/Emit are used to represent classical relational projections
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    input: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    expressions: "list[Expression]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "ProjectRel", ProjectRel)


@dataclass(eq=False, repr=False)
class ReadRel(betterproto2.Message):
    """
    The scan operator of base data (physical or virtual), including filtering and projection.

    Oneofs:
        - read_type: Definition of which type of scan operation is to be performed
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    base_schema: "NamedStruct | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    filter: "Expression | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)

    best_effort_filter: "Expression | None" = betterproto2.field(11, betterproto2.TYPE_MESSAGE, optional=True)

    projection: "ExpressionMaskExpression | None" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True)

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )

    virtual_table: "ReadRelVirtualTable | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="read_type"
    )

    local_files: "ReadRelLocalFiles | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="read_type"
    )

    named_table: "ReadRelNamedTable | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="read_type"
    )

    extension_table: "ReadRelExtensionTable | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="read_type"
    )


default_message_pool.register_message("substrait", "ReadRel", ReadRel)


@dataclass(eq=False, repr=False)
class ReadRelExtensionTable(betterproto2.Message):
    """
    A stub type that can be used to extend/introduce new table types outside
    the specification.
    """

    detail: "_google__protobuf__.Any | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "ReadRel.ExtensionTable", ReadRelExtensionTable)


@dataclass(eq=False, repr=False)
class ReadRelLocalFiles(betterproto2.Message):
    """
    Represents a list of files in input of a scan operation
    """

    items: "list[ReadRelLocalFilesFileOrFiles]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "ReadRel.LocalFiles", ReadRelLocalFiles)


@dataclass(eq=False, repr=False)
class ReadRelLocalFilesFileOrFiles(betterproto2.Message):
    """
    Many files consist of indivisible chunks (e.g. parquet row groups
    or CSV rows).  If a slice partially selects an indivisible chunk
    then the consumer should employ some rule to decide which slice to
    include the chunk in (e.g. include it in the slice that contains
    the midpoint of the chunk)

    Oneofs:
        - path_type:
        - file_format: The format of the files along with options for reading those files.
    """

    uri_path: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True, group="path_type")
    """
    A URI that can refer to either a single folder or a single file
    """

    uri_path_glob: "str | None" = betterproto2.field(2, betterproto2.TYPE_STRING, optional=True, group="path_type")
    """
    A URI where the path portion is a glob expression that can
    identify zero or more paths.
    Consumers should support the POSIX syntax.  The recursive
    globstar (**) may not be supported.
    """

    uri_file: "str | None" = betterproto2.field(3, betterproto2.TYPE_STRING, optional=True, group="path_type")
    """
    A URI that refers to a single file
    """

    uri_folder: "str | None" = betterproto2.field(4, betterproto2.TYPE_STRING, optional=True, group="path_type")
    """
    A URI that refers to a single folder
    """

    partition_index: "int" = betterproto2.field(6, betterproto2.TYPE_UINT64)
    """
    The index of the partition this item belongs to
    """

    start: "int" = betterproto2.field(7, betterproto2.TYPE_UINT64)
    """
    The start position in byte to read from this item
    """

    length: "int" = betterproto2.field(8, betterproto2.TYPE_UINT64)
    """
    The length in byte to read from this item
    """

    parquet: "ReadRelLocalFilesFileOrFilesParquetReadOptions | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="file_format"
    )

    arrow: "ReadRelLocalFilesFileOrFilesArrowReadOptions | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="file_format"
    )

    orc: "ReadRelLocalFilesFileOrFilesOrcReadOptions | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="file_format"
    )

    extension: "_google__protobuf__.Any | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True, group="file_format"
    )

    dwrf: "ReadRelLocalFilesFileOrFilesDwrfReadOptions | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True, group="file_format"
    )

    text: "ReadRelLocalFilesFileOrFilesDelimiterSeparatedTextReadOptions | None" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, optional=True, group="file_format"
    )


default_message_pool.register_message("substrait", "ReadRel.LocalFiles.FileOrFiles", ReadRelLocalFilesFileOrFiles)


@dataclass(eq=False, repr=False)
class ReadRelLocalFilesFileOrFilesArrowReadOptions(betterproto2.Message):
    pass


default_message_pool.register_message(
    "substrait", "ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions", ReadRelLocalFilesFileOrFilesArrowReadOptions
)


@dataclass(eq=False, repr=False)
class ReadRelLocalFilesFileOrFilesDelimiterSeparatedTextReadOptions(betterproto2.Message):
    """
    Delimiter separated files may be compressed.  The reader should
    autodetect this and decompress as needed.
    """

    field_delimiter: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    The character(s) used to separate fields.  Common values are comma,
    tab, and pipe.  Multiple characters are allowed.
    """

    max_line_size: "int" = betterproto2.field(2, betterproto2.TYPE_UINT64)
    """
    The maximum number of bytes to read from a single line.  If a line
    exceeds this limit the resulting behavior is undefined.
    """

    quote: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    The character(s) used to quote strings.  Common values are single
    and double quotation marks.
    """

    header_lines_to_skip: "int" = betterproto2.field(4, betterproto2.TYPE_UINT64)
    """
    The number of lines to skip at the beginning of the file.
    """

    escape: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)
    """
    The character used to escape characters in strings.  Backslash is
    a common value.  Note that a double quote mark can also be used as an
    escape character but the external quotes should be removed first.
    """

    value_treated_as_null: "str | None" = betterproto2.field(6, betterproto2.TYPE_STRING, optional=True)
    """
    If this value is encountered (including empty string), the resulting
    value is null instead.  Leave unset to disable.  If this value is
    provided, the effective schema of this file is comprised entirely of
    nullable strings.  If not provided, the effective schema is instead
    made up of non-nullable strings.
    """


default_message_pool.register_message(
    "substrait",
    "ReadRel.LocalFiles.FileOrFiles.DelimiterSeparatedTextReadOptions",
    ReadRelLocalFilesFileOrFilesDelimiterSeparatedTextReadOptions,
)


@dataclass(eq=False, repr=False)
class ReadRelLocalFilesFileOrFilesDwrfReadOptions(betterproto2.Message):
    pass


default_message_pool.register_message(
    "substrait", "ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions", ReadRelLocalFilesFileOrFilesDwrfReadOptions
)


@dataclass(eq=False, repr=False)
class ReadRelLocalFilesFileOrFilesOrcReadOptions(betterproto2.Message):
    pass


default_message_pool.register_message(
    "substrait", "ReadRel.LocalFiles.FileOrFiles.OrcReadOptions", ReadRelLocalFilesFileOrFilesOrcReadOptions
)


@dataclass(eq=False, repr=False)
class ReadRelLocalFilesFileOrFilesParquetReadOptions(betterproto2.Message):
    pass


default_message_pool.register_message(
    "substrait", "ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions", ReadRelLocalFilesFileOrFilesParquetReadOptions
)


@dataclass(eq=False, repr=False)
class ReadRelNamedTable(betterproto2.Message):
    """
    A base table. The list of string is used to represent namespacing (e.g., mydb.mytable).
    This assumes shared catalog between systems exchanging a message.
    """

    names: "list[str]" = betterproto2.field(1, betterproto2.TYPE_STRING, repeated=True)

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "ReadRel.NamedTable", ReadRelNamedTable)


@dataclass(eq=False, repr=False)
class ReadRelVirtualTable(betterproto2.Message):
    """
    A table composed of expressions.
    """

    values: "list[ExpressionLiteralStruct]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    expressions: "list[Expression]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("values"):
            warnings.warn("ReadRelVirtualTable.values is deprecated", DeprecationWarning)


default_message_pool.register_message("substrait", "ReadRel.VirtualTable", ReadRelVirtualTable)


@dataclass(eq=False, repr=False)
class ReferenceRel(betterproto2.Message):
    """
    This rel is used  to create references,
    in case we refer to a RelRoot field names will be ignored
    """

    subtree_ordinal: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)


default_message_pool.register_message("substrait", "ReferenceRel", ReferenceRel)


@dataclass(eq=False, repr=False)
class Rel(betterproto2.Message):
    """
    A relation (used internally in a plan)

    Oneofs:
        - rel_type:
    """

    read: "ReadRel | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")

    filter: "FilterRel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")

    fetch: "FetchRel | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")

    aggregate: "AggregateRel | None" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")

    sort: "SortRel | None" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")

    join: "JoinRel | None" = betterproto2.field(6, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")

    project: "ProjectRel | None" = betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")

    set: "SetRel | None" = betterproto2.field(8, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")

    extension_single: "ExtensionSingleRel | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type"
    )

    extension_multi: "ExtensionMultiRel | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type"
    )

    extension_leaf: "ExtensionLeafRel | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type"
    )

    cross: "CrossRel | None" = betterproto2.field(12, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")

    reference: "ReferenceRel | None" = betterproto2.field(
        21, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type"
    )

    write: "WriteRel | None" = betterproto2.field(19, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")

    ddl: "DdlRel | None" = betterproto2.field(20, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")

    hash_join: "HashJoinRel | None" = betterproto2.field(13, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")
    """
    Physical relations
    """

    merge_join: "MergeJoinRel | None" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type"
    )

    nested_loop_join: "NestedLoopJoinRel | None" = betterproto2.field(
        18, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type"
    )

    window: "ConsistentPartitionWindowRel | None" = betterproto2.field(
        17, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type"
    )

    exchange: "ExchangeRel | None" = betterproto2.field(15, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")

    expand: "ExpandRel | None" = betterproto2.field(16, betterproto2.TYPE_MESSAGE, optional=True, group="rel_type")


default_message_pool.register_message("substrait", "Rel", Rel)


@dataclass(eq=False, repr=False)
class RelCommon(betterproto2.Message):
    """
    Common fields for all relational operators

    Oneofs:
        - emit_kind:
    """

    direct: "RelCommonDirect | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="emit_kind"
    )
    """
    The underlying relation is output as is (no reordering or projection of columns)
    """

    emit: "RelCommonEmit | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True, group="emit_kind")
    """
    Allows to control for order and inclusion of fields
    """

    hint: "RelCommonHint | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "RelCommon", RelCommon)


@dataclass(eq=False, repr=False)
class RelCommonDirect(betterproto2.Message):
    """
    Direct indicates no change on presence and ordering of fields in the output
    """

    pass


default_message_pool.register_message("substrait", "RelCommon.Direct", RelCommonDirect)


@dataclass(eq=False, repr=False)
class RelCommonEmit(betterproto2.Message):
    """
    Remap which fields are output and in which order
    """

    output_mapping: "list[int]" = betterproto2.field(1, betterproto2.TYPE_INT32, repeated=True)


default_message_pool.register_message("substrait", "RelCommon.Emit", RelCommonEmit)


@dataclass(eq=False, repr=False)
class RelCommonHint(betterproto2.Message):
    """
    Changes to the operation that can influence efficiency/performance but
    should not impact correctness.
    """

    stats: "RelCommonHintStats | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    constraint: "RelCommonHintRuntimeConstraint | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    alias: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    Name (alias) for this relation. Can be used for e.g. qualifying the relation (see e.g.
    Spark's SubqueryAlias), or debugging.
    """

    output_names: "list[str]" = betterproto2.field(4, betterproto2.TYPE_STRING, repeated=True)
    """
    Assigns alternative output field names for any relation.  Equivalent to the names field
    in RelRoot but applies to the output of the relation this RelCommon is attached to.
    """

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )

    saved_computations: "list[RelCommonHintSavedComputation]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Save or load a system-specific computation for use in optimizing a remote operation.
    The anchor refers to the source/destination of the computation.  The computation type
    and number refer to the current relation.
    """

    loaded_computations: "list[RelCommonHintLoadedComputation]" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("substrait", "RelCommon.Hint", RelCommonHint)


@dataclass(eq=False, repr=False)
class RelCommonHintLoadedComputation(betterproto2.Message):
    computation_id_reference: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)
    """
    The value corresponds to a plan unique number for that datastructure.  Any particular
    computation may be saved only once but it may be loaded multiple times.
    """

    type: "RelCommonHintComputationType" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: RelCommonHintComputationType(0)
    )
    """
    The type of this computation.  While a plan may use COMPUTATION_TYPE_UNKNOWN for all
    of its types it is recommended to use a more specific type so that the optimization
    is more portable.  The consumer should be able to decide if an unknown type here
    matches the same unknown type at a different plan and ignore the optimization if they
    are mismatched.
    """


default_message_pool.register_message("substrait", "RelCommon.Hint.LoadedComputation", RelCommonHintLoadedComputation)


@dataclass(eq=False, repr=False)
class RelCommonHintRuntimeConstraint(betterproto2.Message):
    """
    TODO: nodes, cpu threads/%, memory, iops, etc.
    """

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "RelCommon.Hint.RuntimeConstraint", RelCommonHintRuntimeConstraint)


@dataclass(eq=False, repr=False)
class RelCommonHintSavedComputation(betterproto2.Message):
    computation_id: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)
    """
    The value corresponds to a plan unique number for that datastructure.  Any particular
    computation may be saved only once but it may be loaded multiple times.
    """

    type: "RelCommonHintComputationType" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: RelCommonHintComputationType(0)
    )
    """
    The type of this computation.  While a plan may use COMPUTATION_TYPE_UNKNOWN for all
    of its types it is recommended to use a more specific type so that the optimization
    is more portable.  The consumer should be able to decide if an unknown type here
    matches the same unknown type at a different plan and ignore the optimization if they
    are mismatched.
    """


default_message_pool.register_message("substrait", "RelCommon.Hint.SavedComputation", RelCommonHintSavedComputation)


@dataclass(eq=False, repr=False)
class RelCommonHintStats(betterproto2.Message):
    """
    The statistics related to a hint (physical properties of records)
    """

    row_count: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)

    record_size: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "RelCommon.Hint.Stats", RelCommonHintStats)


@dataclass(eq=False, repr=False)
class RelRoot(betterproto2.Message):
    """
    A relation with output field names.

    This is for use at the root of a `Rel` tree.
    """

    input: "Rel | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    """
    A relation
    """

    names: "list[str]" = betterproto2.field(2, betterproto2.TYPE_STRING, repeated=True)
    """
    Field names in depth-first order
    """


default_message_pool.register_message("substrait", "RelRoot", RelRoot)


@dataclass(eq=False, repr=False)
class SetRel(betterproto2.Message):
    """
    The relational set operators (intersection/union/etc..)
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    inputs: "list[Rel]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    The first input is the primary input, the remaining are secondary
    inputs.  There must be at least two inputs.
    """

    op: "SetRelSetOp" = betterproto2.field(3, betterproto2.TYPE_ENUM, default_factory=lambda: SetRelSetOp(0))

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "SetRel", SetRel)


@dataclass(eq=False, repr=False)
class SortField(betterproto2.Message):
    """
    The description of a field to sort on (including the direction of sorting and null semantics)

    Oneofs:
        - sort_kind:
    """

    expr: "Expression | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    direction: "SortFieldSortDirection | None" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, optional=True, group="sort_kind"
    )

    comparison_function_reference: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT32, optional=True, group="sort_kind"
    )


default_message_pool.register_message("substrait", "SortField", SortField)


@dataclass(eq=False, repr=False)
class SortRel(betterproto2.Message):
    """
    The ORDERY BY (or sorting) relational operator. Beside describing a base relation, it includes a list of fields to sort on
    """

    common: "RelCommon | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    input: "Rel | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    sorts: "list[SortField]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)

    advanced_extension: "extensions.AdvancedExtension | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("substrait", "SortRel", SortRel)


@dataclass(eq=False, repr=False)
class Type(betterproto2.Message):
    """


    Oneofs:
        - kind:
    """

    bool: "TypeBoolean | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    i8: "TypeI8 | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    i16: "TypeI16 | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    i32: "TypeI32 | None" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    i64: "TypeI64 | None" = betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    fp32: "TypeFp32 | None" = betterproto2.field(10, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    fp64: "TypeFp64 | None" = betterproto2.field(11, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    string: "TypeString | None" = betterproto2.field(12, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    binary: "TypeBinary | None" = betterproto2.field(13, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    timestamp: "TypeTimestamp | None" = betterproto2.field(14, betterproto2.TYPE_MESSAGE, optional=True, group="kind")
    """
    Deprecated in favor of `PrecisionTimestamp precision_timestamp`
    """

    date: "TypeDate | None" = betterproto2.field(16, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    time: "TypeTime | None" = betterproto2.field(17, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    interval_year: "TypeIntervalYear | None" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    interval_day: "TypeIntervalDay | None" = betterproto2.field(
        20, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    interval_compound: "TypeIntervalCompound | None" = betterproto2.field(
        35, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    timestamp_tz: "TypeTimestampTz | None" = betterproto2.field(
        29, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    Deprecated in favor of `PrecisionTimestampTZ precision_timestamp_tz`
    """

    uuid: "TypeUuid | None" = betterproto2.field(32, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    fixed_char: "TypeFixedChar | None" = betterproto2.field(21, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    varchar: "TypeVarChar | None" = betterproto2.field(22, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    fixed_binary: "TypeFixedBinary | None" = betterproto2.field(
        23, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    decimal: "TypeDecimal | None" = betterproto2.field(24, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    precision_timestamp: "TypePrecisionTimestamp | None" = betterproto2.field(
        33, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    precision_timestamp_tz: "TypePrecisionTimestampTz | None" = betterproto2.field(
        34, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    value is since UNIX epoch in UTC
    """

    struct: "TypeStruct | None" = betterproto2.field(25, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    list: "TypeList | None" = betterproto2.field(27, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    map: "TypeMap | None" = betterproto2.field(28, betterproto2.TYPE_MESSAGE, optional=True, group="kind")

    user_defined: "TypeUserDefined | None" = betterproto2.field(
        30, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )

    user_defined_type_reference: "int | None" = betterproto2.field(
        31, betterproto2.TYPE_UINT32, optional=True, group="kind"
    )
    """
    Deprecated in favor of user_defined, which allows nullability and
    variations to be specified. If user_defined_type_reference is
    encountered, treat it as being non-nullable and having the default
    variation.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("timestamp"):
            warnings.warn("Type.timestamp is deprecated", DeprecationWarning)
        if self.is_set("timestamp_tz"):
            warnings.warn("Type.timestamp_tz is deprecated", DeprecationWarning)
        if self.is_set("user_defined_type_reference"):
            warnings.warn("Type.user_defined_type_reference is deprecated", DeprecationWarning)


default_message_pool.register_message("substrait", "Type", Type)


@dataclass(eq=False, repr=False)
class TypeBinary(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.Binary", TypeBinary)


@dataclass(eq=False, repr=False)
class TypeBoolean(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.Boolean", TypeBoolean)


@dataclass(eq=False, repr=False)
class TypeDate(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.Date", TypeDate)


@dataclass(eq=False, repr=False)
class TypeDecimal(betterproto2.Message):
    scale: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)

    precision: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)

    type_variation_reference: "int" = betterproto2.field(3, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.Decimal", TypeDecimal)


@dataclass(eq=False, repr=False)
class TypeFixedBinary(betterproto2.Message):
    length: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)

    type_variation_reference: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.FixedBinary", TypeFixedBinary)


@dataclass(eq=False, repr=False)
class TypeFixedChar(betterproto2.Message):
    """
    Start compound types.
    """

    length: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)

    type_variation_reference: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.FixedChar", TypeFixedChar)


@dataclass(eq=False, repr=False)
class TypeFp32(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.FP32", TypeFp32)


@dataclass(eq=False, repr=False)
class TypeFp64(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.FP64", TypeFp64)


@dataclass(eq=False, repr=False)
class TypeI16(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.I16", TypeI16)


@dataclass(eq=False, repr=False)
class TypeI32(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.I32", TypeI32)


@dataclass(eq=False, repr=False)
class TypeI64(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.I64", TypeI64)


@dataclass(eq=False, repr=False)
class TypeI8(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.I8", TypeI8)


@dataclass(eq=False, repr=False)
class TypeIntervalCompound(betterproto2.Message):
    """
    An interval consisting of the components of both IntervalMonth and IntervalDay
    """

    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )

    precision: "int" = betterproto2.field(3, betterproto2.TYPE_INT32)
    """
    Sub-second precision, 0 means the value given is in seconds, 3 is milliseconds, 6 microseconds, 9 is nanoseconds, etc.
    """


default_message_pool.register_message("substrait", "Type.IntervalCompound", TypeIntervalCompound)


@dataclass(eq=False, repr=False)
class TypeIntervalDay(betterproto2.Message):
    """
    An interval consisting of days, seconds, and microseconds
    """

    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )

    precision: "int | None" = betterproto2.field(3, betterproto2.TYPE_INT32, optional=True)
    """
    Sub-second precision, 0 means the value given is in seconds, 3 is milliseconds, 6 microseconds, 9 is nanoseconds, etc.
    if unset, treat as 6.
    """


default_message_pool.register_message("substrait", "Type.IntervalDay", TypeIntervalDay)


@dataclass(eq=False, repr=False)
class TypeIntervalYear(betterproto2.Message):
    """
    An interval consisting of years and months
    """

    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.IntervalYear", TypeIntervalYear)


@dataclass(eq=False, repr=False)
class TypeList(betterproto2.Message):
    type: "Type | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    type_variation_reference: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.List", TypeList)


@dataclass(eq=False, repr=False)
class TypeMap(betterproto2.Message):
    key: "Type | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    value: "Type | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    type_variation_reference: "int" = betterproto2.field(3, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.Map", TypeMap)


@dataclass(eq=False, repr=False)
class TypeParameter(betterproto2.Message):
    """


    Oneofs:
        - parameter:
    """

    null: "_google__protobuf__.Empty | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="parameter"
    )
    """
    Explicitly null/unspecified parameter, to select the default value (if
    any).
    """

    data_type: "Type | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True, group="parameter")
    """
    Data type parameters, like the i32 in LIST<i32>.
    """

    boolean: "bool | None" = betterproto2.field(3, betterproto2.TYPE_BOOL, optional=True, group="parameter")
    """
    Value parameters, like the 10 in VARCHAR<10>.
    """

    integer: "int | None" = betterproto2.field(4, betterproto2.TYPE_INT64, optional=True, group="parameter")

    enum: "str | None" = betterproto2.field(5, betterproto2.TYPE_STRING, optional=True, group="parameter")

    string: "str | None" = betterproto2.field(6, betterproto2.TYPE_STRING, optional=True, group="parameter")


default_message_pool.register_message("substrait", "Type.Parameter", TypeParameter)


@dataclass(eq=False, repr=False)
class TypePrecisionTimestamp(betterproto2.Message):
    precision: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)
    """
    Sub-second precision, 0 means the value given is in seconds, 3 is milliseconds, 6 microseconds, 9 is nanoseconds
    """

    type_variation_reference: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.PrecisionTimestamp", TypePrecisionTimestamp)


@dataclass(eq=False, repr=False)
class TypePrecisionTimestampTz(betterproto2.Message):
    precision: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)
    """
    Sub-second precision, 0 means the value given is in seconds, 3 is milliseconds, 6 microseconds, 9 is nanoseconds
    """

    type_variation_reference: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.PrecisionTimestampTZ", TypePrecisionTimestampTz)


@dataclass(eq=False, repr=False)
class TypeString(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.String", TypeString)


@dataclass(eq=False, repr=False)
class TypeStruct(betterproto2.Message):
    types: "list[Type]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    type_variation_reference: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.Struct", TypeStruct)


@dataclass(eq=False, repr=False)
class TypeTime(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.Time", TypeTime)


@dataclass(eq=False, repr=False)
class TypeTimestamp(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.Timestamp", TypeTimestamp)


@dataclass(eq=False, repr=False)
class TypeTimestampTz(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.TimestampTZ", TypeTimestampTz)


@dataclass(eq=False, repr=False)
class TypeUserDefined(betterproto2.Message):
    type_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    type_variation_reference: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )

    type_parameters: "list[TypeParameter]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("substrait", "Type.UserDefined", TypeUserDefined)


@dataclass(eq=False, repr=False)
class TypeUuid(betterproto2.Message):
    type_variation_reference: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.UUID", TypeUuid)


@dataclass(eq=False, repr=False)
class TypeVarChar(betterproto2.Message):
    length: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)

    type_variation_reference: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    nullability: "TypeNullability" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TypeNullability(0)
    )


default_message_pool.register_message("substrait", "Type.VarChar", TypeVarChar)


@dataclass(eq=False, repr=False)
class Version(betterproto2.Message):
    major_number: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)
    """
    Substrait version number.
    """

    minor_number: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    patch_number: "int" = betterproto2.field(3, betterproto2.TYPE_UINT32)

    git_hash: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)
    """
    If a particular version of Substrait is used that does not correspond to
    a version number exactly (for example when using an unofficial fork or
    using a version that is not yet released or is between versions), set this
    to the full git hash of the utilized commit of
    https://github.com/substrait-io/substrait (or fork thereof), represented
    using a lowercase hex ASCII string 40 characters in length. The version
    number above should be set to the most recent version tag in the history
    of that commit.
    """

    producer: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)
    """
    Identifying information for the producer that created this plan. Under
    ideal circumstances, consumers should not need this information. However,
    it is foreseen that consumers may need to work around bugs in particular
    producers in practice, and therefore may need to know which producer
    created the plan.
    """


default_message_pool.register_message("substrait", "Version", Version)


@dataclass(eq=False, repr=False)
class WriteRel(betterproto2.Message):
    """
    The operator that modifies the content of a database (operates on 1 table at a time, but record-selection/source can be
    based on joining of multiple tables).

    Oneofs:
        - write_type: Definition of which TABLE we are operating on
    """

    named_table: "NamedObjectWrite | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="write_type"
    )

    extension_table: "ExtensionObject | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="write_type"
    )

    table_schema: "NamedStruct | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)
    """
    The schema of the table (must align with Rel input (e.g., number of leaf fields must match))
    """

    op: "WriteRelWriteOp" = betterproto2.field(4, betterproto2.TYPE_ENUM, default_factory=lambda: WriteRelWriteOp(0))
    """
    The type of operation to perform
    """

    input: "Rel | None" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True)
    """
    The relation that determines the records to add/remove/modify
    the schema must match with table_schema. Default values must be explicitly stated
    in a ProjectRel at the top of the input. The match must also
    occur in case of DELETE to ensure multi-engine plans are unequivocal.
    """

    output: "WriteRelOutputMode" = betterproto2.field(
        6, betterproto2.TYPE_ENUM, default_factory=lambda: WriteRelOutputMode(0)
    )
    """
    Output mode determines what is the output of executing this rel
    """

    common: "RelCommon | None" = betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("substrait", "WriteRel", WriteRel)


from ..google import protobuf as _google__protobuf__
from . import extensions
