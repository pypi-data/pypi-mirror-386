from typing import Any

import pyarrow as pa
from spiral.core.client import Shard, ShuffleConfig

from .manifests import FragmentManifest
from .metastore import PyMetastore
from .spec import ColumnGroup, Key, Operation, Schema, WriteAheadLog

class KeyRange:
    """A right-exclusive range of keys."""

    def __init__(self, *, begin: Key, end: Key): ...

    begin: Key
    end: Key

    def union(self, other: KeyRange) -> KeyRange: ...
    def __or__(self, other: KeyRange) -> KeyRange: ...
    def intersection(self, key_extent: KeyRange) -> KeyRange | None: ...
    def __and__(self, other: KeyRange) -> KeyRange | None: ...
    def contains(self, item: Key) -> bool: ...
    def __contains__(self, item: Key) -> bool: ...
    def is_disjoint(self, key_range: KeyRange) -> bool:
        return self.end <= key_range.begin or self.begin >= key_range.end

    @staticmethod
    def beginning_with(begin: Key) -> KeyRange: ...
    @staticmethod
    def ending_with(end: Key) -> KeyRange: ...
    @staticmethod
    def full() -> KeyRange: ...
    def __reduce__(self) -> tuple[type[KeyRange], tuple[Key, Key]]: ...

class Table:
    def __init__(self, metastore: PyMetastore): ...

    id: str
    root_uri: str
    mount_id: str | None
    key_schema: Schema
    metastore: PyMetastore

    def get_wal(self, *, asof: int | None) -> WriteAheadLog: ...
    def get_schema(self, *, asof: int | None) -> Schema: ...
    def get_snapshot(self, *, asof: int | None) -> Snapshot: ...

class Snapshot:
    """A snapshot of a table at a specific point in time."""

    asof: int
    table: Table
    wal: WriteAheadLog

class ScanState:
    def to_json(self) -> str: ...
    @staticmethod
    def from_json(json: str) -> ScanState: ...

class Scan:
    def key_schema(self) -> Schema: ...
    def schema(self) -> Schema: ...
    def is_empty(self) -> bool: ...
    def splits(self) -> list[KeyRange]: ...
    def shards(self) -> list[Shard]: ...
    def table_ids(self) -> list[str]: ...
    def column_groups(self) -> list[ColumnGroup]: ...
    def column_group_state(self, column_group: ColumnGroup) -> ColumnGroupState: ...
    def key_space_state(self, table_id: str) -> KeySpaceState: ...
    def scan_state(self) -> ScanState: ...
    def to_record_batches(
        self,
        key_range: KeyRange | None = None,
        key_table: pa.Table | pa.RecordBatch | None = None,
        batch_readahead: int | None = None,
        progress: bool = True,
    ) -> pa.RecordBatchReader: ...
    def to_shuffled_record_batches(
        self,
        shards: list[Shard] | None = None,
        shuffle: ShuffleConfig | None = None,
        max_batch_size: int | None = None,
        batch_readahead: int | None = None,
        infinite: bool = False,
    ) -> pa.RecordBatchReader:
        # If `infinite` is True, shards are shuffled after exhausted but not before the first pass.
        # Otherwise, shards are not shuffle and shuffle config is only used for shuffle buffer.
        ...
    def metrics(self) -> dict[str, Any]: ...

class KeySpaceState:
    manifest: FragmentManifest

    def key_schema(self) -> Schema: ...

class ColumnGroupState:
    manifest: FragmentManifest
    column_group: ColumnGroup

    def schema(self) -> Schema: ...

class Transaction:
    status: str

    def write(self, table: pa.RecordBatchReader, *, partition_size_bytes: int | None = None): ...
    def writeback(
        self,
        scan: Scan,
        *,
        key_range: KeyRange | None = None,
        partition_size_bytes: int | None = None,
        batch_readahead: int | None = None,
    ): ...
    def drop_columns(self, column_paths: list[str]): ...
    def ops(self) -> list[Operation]: ...
    def take(self) -> list[Operation]: ...
    def include(self, ops: list[Operation]): ...
    def commit(self): ...
    def abort(self): ...
    def is_empty(self) -> bool: ...
    def metrics(self) -> dict[str, Any]: ...
