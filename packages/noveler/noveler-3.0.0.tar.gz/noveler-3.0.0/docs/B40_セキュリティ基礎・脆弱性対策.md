# B40_ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åŸºç¤ãƒ»è„†å¼±æ€§å¯¾ç­–

## ğŸ¯ æ¦‚è¦

æƒ…å ±ã‚·ã‚¹ãƒ†ãƒ é–‹ç™ºã«ãŠã‘ã‚‹ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®åŸºç¤æ¦‚å¿µã€ä¸€èˆ¬çš„ãªè„†å¼±æ€§ã¨ãã®å¯¾ç­–ã€ã‚»ã‚­ãƒ¥ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®å®Ÿè·µæ–¹æ³•ã‚’è§£èª¬ã—ã¾ã™ã€‚
OWASP Top 10ã‚’åŸºæº–ã¨ã—ãŸåŒ…æ‹¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã‚’ç›®æŒ‡ã—ã¾ã™ã€‚

---

## ğŸ“‹ ç›®æ¬¡

1. [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åŸºç¤æ¦‚å¿µ](#ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åŸºç¤æ¦‚å¿µ)
2. [OWASP Top 10ãƒ»ä¸»è¦è„†å¼±æ€§](#owasp-top-10ä¸»è¦è„†å¼±æ€§)
3. [èªè¨¼ãƒ»èªå¯ãƒ»ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†](#èªè¨¼èªå¯ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†)
4. [å…¥åŠ›å€¤æ¤œè¨¼ãƒ»ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–](#å…¥åŠ›å€¤æ¤œè¨¼ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–)
5. [æš—å·åŒ–ãƒ»HTTPSãƒ»ãƒãƒƒã‚·ãƒ¥åŒ–](#æš—å·åŒ–httpsãƒãƒƒã‚·ãƒ¥åŒ–)
6. [ã‚»ã‚­ãƒ¥ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å®Ÿè·µ](#ã‚»ã‚­ãƒ¥ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å®Ÿè·µ)

---

## ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åŸºç¤æ¦‚å¿µ

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®3è¦ç´ ï¼ˆCIAï¼‰

#### **æ©Ÿå¯†æ€§ï¼ˆConfidentialityï¼‰**
- **å®šç¾©**: è¨±å¯ã•ã‚ŒãŸè€…ã®ã¿ãŒæƒ…å ±ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã“ã¨
- **è„…å¨**: æƒ…å ±æ¼æ´©ã€ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹ã€ç›—è´
- **å¯¾ç­–**: æš—å·åŒ–ã€ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ã€èªè¨¼

#### **å®Œå…¨æ€§ï¼ˆIntegrityï¼‰**
- **å®šç¾©**: æƒ…å ±ãŒæ”¹ã–ã‚“ã•ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã“ã¨
- **è„…å¨**: ãƒ‡ãƒ¼ã‚¿æ”¹ã–ã‚“ã€ä¸æ­£ãªå¤‰æ›´ã€ç ´æ
- **å¯¾ç­–**: ãƒ‡ã‚¸ã‚¿ãƒ«ç½²åã€ãƒãƒƒã‚·ãƒ¥å€¤ã€ãƒã‚§ãƒƒã‚¯ã‚µãƒ 

#### **å¯ç”¨æ€§ï¼ˆAvailabilityï¼‰**
- **å®šç¾©**: å¿…è¦ãªæ™‚ã«æƒ…å ±ã‚·ã‚¹ãƒ†ãƒ ãŒåˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã“ã¨
- **è„…å¨**: DoSæ”»æ’ƒã€ã‚·ã‚¹ãƒ†ãƒ éšœå®³ã€ã‚µãƒ¼ãƒ“ã‚¹åœæ­¢
- **å¯¾ç­–**: å†—é•·åŒ–ã€è² è·åˆ†æ•£ã€ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®åŸºæœ¬åŸå‰‡

#### 1. å¤šå±¤é˜²å¾¡ï¼ˆDefense in Depthï¼‰
```
   å¤–éƒ¨ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«
          â†“
      DMZï¼ˆéæ­¦è£…åœ°å¸¯ï¼‰
          â†“
    å†…éƒ¨ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«
          â†“
    ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èªè¨¼
          â†“
     ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡
```

#### 2. æœ€å°æ¨©é™ã®åŸå‰‡ï¼ˆPrinciple of Least Privilegeï¼‰
```python
# âœ… è‰¯ã„ä¾‹ï¼šå¿…è¦æœ€å°é™ã®æ¨©é™
class EpisodeEditor:
    def __init__(self):
        self.permissions = [
            "read_own_episodes",
            "write_own_episodes",
            "read_episode_templates"
        ]

# âŒ æ‚ªã„ä¾‹ï¼šéå‰°ãªæ¨©é™
class AdminUser:
    def __init__(self):
        self.permissions = [
            "read_all", "write_all", "delete_all",
            "admin_all", "system_config"
        ]
```

#### 3. æ˜ç¤ºçš„æ‹’å¦ï¼ˆDeny by Defaultï¼‰
```python
class AccessController:
    def __init__(self):
        self._allowed_actions = set()  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç©ºï¼å…¨ã¦æ‹’å¦

    def is_allowed(self, user: User, action: str) -> bool:
        # æ˜ç¤ºçš„ã«è¨±å¯ã•ã‚ŒãŸã‚‚ã®ã®ã¿True
        return f"{user.role}:{action}" in self._allowed_actions

    def grant_permission(self, role: str, action: str):
        self._allowed_actions.add(f"{role}:{action}")
```

#### 4. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»ãƒã‚¤ãƒ»ãƒ‡ã‚¶ã‚¤ãƒ³
- è¨­è¨ˆæ®µéšã‹ã‚‰ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’è€ƒæ…®
- å¾Œä»˜ã‘ã§ã¯ãªãã€åŸºç›¤ã¨ã—ã¦çµ„ã¿è¾¼ã‚€
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶ã®æ˜ç¢ºåŒ–

---

## ğŸš¨ OWASP Top 10ãƒ»ä¸»è¦è„†å¼±æ€§

### 1. A01: ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ã®ä¸å‚™

#### è„†å¼±æ€§ã®ä¾‹
```python
# âœ… å®‰å…¨ãªå®Ÿè£…
@app.route('/episode/<int:episode_id>')
@require_login
def get_episode(episode_id):
    episode = Episode.get_by_id(episode_id)

    # æ‰€æœ‰è€…ãƒã‚§ãƒƒã‚¯
    if episode.author_id != current_user.id:
        abort(403, "Access denied")

    return jsonify(episode.to_dict())

# âŒ è„†å¼±ãªå®Ÿè£…
@app.route('/episode/<int:episode_id>')
def get_episode(episode_id):
    episode = Episode.get_by_id(episode_id)
    return jsonify(episode.to_dict())  # æ‰€æœ‰è€…ãƒã‚§ãƒƒã‚¯ãªã—
```

#### å¯¾ç­–å®Ÿè£…
```python
class EpisodeAccessController:
    def __init__(self, episode_repository: EpisodeRepository):
        self._repository = episode_repository

    def can_read(self, user: User, episode_id: str) -> bool:
        episode = self._repository.get_by_id(episode_id)
        if not episode:
            return False

        # æ‰€æœ‰è€…ã¾ãŸã¯å…¬é–‹æ¸ˆã¿
        return (episode.author_id == user.id or
                episode.status == EpisodeStatus.PUBLISHED)

    def can_write(self, user: User, episode_id: str) -> bool:
        episode = self._repository.get_by_id(episode_id)
        if not episode:
            return False

        # æ‰€æœ‰è€…ã®ã¿
        return episode.author_id == user.id

    def can_delete(self, user: User, episode_id: str) -> bool:
        return (self.can_write(user, episode_id) and
                user.has_permission("delete_episodes"))
```

### 2. A02: æš—å·åŒ–ã®ä¸å‚™

#### è„†å¼±æ€§ã®ä¾‹
```python
# âŒ è„†å¼±ãªå®Ÿè£…
import hashlib

def hash_password(password: str) -> str:
    return hashlib.md5(password.encode()).hexdigest()  # MD5ã¯è„†å¼±

# âŒ å¹³æ–‡ä¿å­˜
def save_user_password(user_id: str, password: str):
    database.save({
        "user_id": user_id,
        "password": password  # å¹³æ–‡ä¿å­˜
    })
```

#### å®‰å…¨ãªå®Ÿè£…
```python
import bcrypt
import secrets
from cryptography.fernet import Fernet

class SecurePasswordManager:
    def __init__(self):
        self._salt_rounds = 12

    def hash_password(self, password: str) -> str:
        """bcryptã‚’ä½¿ç”¨ã—ãŸå®‰å…¨ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–"""
        salt = bcrypt.gensalt(rounds=self._salt_rounds)
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')

    def verify_password(self, password: str, hashed: str) -> bool:
        """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ¤œè¨¼"""
        return bcrypt.checkpw(
            password.encode('utf-8'),
            hashed.encode('utf-8')
        )

    def generate_secure_token(self, length: int = 32) -> str:
        """æš—å·å­¦çš„ã«å®‰å…¨ãªãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ"""
        return secrets.token_urlsafe(length)

class DataEncryption:
    def __init__(self, encryption_key: bytes):
        self._fernet = Fernet(encryption_key)

    def encrypt_sensitive_data(self, data: str) -> str:
        """æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ã®æš—å·åŒ–"""
        encrypted = self._fernet.encrypt(data.encode('utf-8'))
        return encrypted.decode('utf-8')

    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ã®å¾©å·"""
        decrypted = self._fernet.decrypt(encrypted_data.encode('utf-8'))
        return decrypted.decode('utf-8')
```

### 3. A03: ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ”»æ’ƒ

#### SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–
```python
# âœ… å®‰å…¨ãªå®Ÿè£…ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚¯ã‚¨ãƒªï¼‰
def get_user_episodes(user_id: str):
    query = "SELECT * FROM episodes WHERE author_id = %s"
    return database.execute(query, (user_id,))

# âœ… ORMã‚’ä½¿ç”¨ã—ãŸå®‰å…¨ãªå®Ÿè£…
class EpisodeRepository:
    def get_by_author(self, author_id: str) -> List[Episode]:
        return (session.query(Episode)
                .filter(Episode.author_id == author_id)
                .all())

# âŒ è„†å¼±ãªå®Ÿè£…
def get_user_episodes(user_id: str):
    query = f"SELECT * FROM episodes WHERE author_id = '{user_id}'"
    return database.execute(query)  # SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è„†å¼±æ€§

```

#### ã‚³ãƒãƒ³ãƒ‰ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–
```python
import subprocess
import shlex

# âœ… å®‰å…¨ãªå®Ÿè£…
def process_file(filename: str):
    # å…¥åŠ›å€¤æ¤œè¨¼
    if not filename.replace('_', '').replace('-', '').replace('.', '').isalnum():
        raise ValueError("Invalid filename")

    # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã§å®Ÿè¡Œ
    subprocess.run([
        "python", "process.py", filename
    ], check=True)

# âœ… ã‚ˆã‚Šå®‰å…¨ãªå®Ÿè£…ï¼ˆãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆæ–¹å¼ï¼‰
class SecureFileProcessor:
    ALLOWED_EXTENSIONS = {'.txt', '.md', '.yaml'}
    MAX_FILENAME_LENGTH = 100

    def process_file(self, filename: str):
        self._validate_filename(filename)

        # å®‰å…¨ãªãƒ‘ã‚¹ã«åˆ¶é™
        safe_path = self._get_safe_path(filename)

        subprocess.run([
            "python", "scripts/tools/process_file.py", safe_path
        ], check=True, timeout=30)

    def _validate_filename(self, filename: str):
        if len(filename) > self.MAX_FILENAME_LENGTH:
            raise ValueError("Filename too long")

        path = Path(filename)
        if path.suffix not in self.ALLOWED_EXTENSIONS:
            raise ValueError("File extension not allowed")

        # ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«å¯¾ç­–
        if '..' in filename or filename.startswith('/'):
            raise ValueError("Invalid path")

    def _get_safe_path(self, filename: str) -> str:
        # å®‰å…¨ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«åˆ¶é™
        safe_dir = Path("./temp/processing")
        safe_dir.mkdir(exist_ok=True)
        return str(safe_dir / Path(filename).name)

# âŒ è„†å¼±ãªå®Ÿè£…
def process_file(filename: str):
    command = f"python process.py {filename}"
    subprocess.run(command, shell=True)  # ã‚³ãƒãƒ³ãƒ‰ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è„†å¼±æ€§
```

### 4. A04: ä¸å®‰å…¨ãªè¨­è¨ˆ

#### ã‚»ã‚­ãƒ¥ã‚¢ãªè¨­è¨ˆåŸå‰‡
```python
class SecureEpisodeService:
    def __init__(self,
                 repository: EpisodeRepository,
                 access_controller: AccessController,
                 audit_logger: AuditLogger):
        self._repository = repository
        self._access_controller = access_controller
        self._audit_logger = audit_logger

    def create_episode(self, user: User, episode_data: dict) -> Episode:
        # 1. å…¥åŠ›å€¤æ¤œè¨¼
        validated_data = self._validate_episode_data(episode_data)

        # 2. æ¨©é™ãƒã‚§ãƒƒã‚¯
        if not self._access_controller.can_create_episode(user):
            self._audit_logger.log_unauthorized_attempt(
                user.id, "create_episode", episode_data
            )
            raise UnauthorizedError("Cannot create episode")

        # 3. ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯
        if self._exceeds_episode_limit(user):
            raise BusinessRuleViolationError("Episode limit exceeded")

        # 4. å®‰å…¨ãªä½œæˆå‡¦ç†
        episode = Episode.create(validated_data)
        saved_episode = self._repository.save(episode)

        # 5. ç›£æŸ»ãƒ­ã‚°
        self._audit_logger.log_episode_created(user.id, saved_episode.id)

        return saved_episode

    def _validate_episode_data(self, data: dict) -> dict:
        """å…¥åŠ›å€¤æ¤œè¨¼ã¨ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³"""
        validator = EpisodeDataValidator()
        return validator.validate_and_sanitize(data)

    def _exceeds_episode_limit(self, user: User) -> bool:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰æ•°åˆ¶é™ãƒã‚§ãƒƒã‚¯"""
        current_count = self._repository.count_by_author(user.id)
        return current_count >= user.max_episodes
```

### 5. A05: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šãƒŸã‚¹

#### å®‰å…¨ãªè¨­å®šç®¡ç†
```python
import os
from dataclasses import dataclass
from typing import Optional

@dataclass
class SecurityConfig:
    secret_key: str
    database_url: str
    encryption_key: str
    session_timeout: int = 3600
    max_login_attempts: int = 5
    password_min_length: int = 8

    @classmethod
    def from_environment(cls) -> 'SecurityConfig':
        # å¿…é ˆç’°å¢ƒå¤‰æ•°ã®ãƒã‚§ãƒƒã‚¯
        required_vars = ['SECRET_KEY', 'DATABASE_URL', 'ENCRYPTION_KEY']
        missing_vars = [var for var in required_vars if not os.getenv(var)]

        if missing_vars:
            raise ValueError(f"Missing required environment variables: {missing_vars}")

        return cls(
            secret_key=os.getenv('SECRET_KEY'),
            database_url=os.getenv('DATABASE_URL'),
            encryption_key=os.getenv('ENCRYPTION_KEY'),
            session_timeout=int(os.getenv('SESSION_TIMEOUT', '3600')),
            max_login_attempts=int(os.getenv('MAX_LOGIN_ATTEMPTS', '5')),
            password_min_length=int(os.getenv('PASSWORD_MIN_LENGTH', '8'))
        )

    def validate(self):
        """è¨­å®šå€¤ã®å¦¥å½“æ€§æ¤œè¨¼"""
        if len(self.secret_key) < 32:
            raise ValueError("SECRET_KEY must be at least 32 characters")

        if self.session_timeout < 300:  # 5åˆ†æœªæº€ã¯å±é™º
            raise ValueError("SESSION_TIMEOUT too short")

        if self.password_min_length < 8:
            raise ValueError("PASSWORD_MIN_LENGTH too short")

# è¨­å®šã®èª­ã¿è¾¼ã¿ã¨æ¤œè¨¼
config = SecurityConfig.from_environment()
config.validate()
```

#### ã‚»ã‚­ãƒ¥ã‚¢ãƒ˜ãƒƒãƒ€ãƒ¼ã®è¨­å®š
```python
# CLIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¾‹
from typer import Typer
from pathlib import Path
import os

app = Typer()

# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ã®è¨­å®š
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://trusted-domain.com"],
    allow_credentials=True,
    allow_methods=["GET", "POST"],
    allow_headers=["*"],
)
```

---

## ğŸ”‘ èªè¨¼ãƒ»èªå¯ãƒ»ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†

### èªè¨¼ï¼ˆAuthenticationï¼‰ã®å®Ÿè£…

#### å¤šè¦ç´ èªè¨¼ï¼ˆMFAï¼‰
```python
import pyotp
import qrcode
from io import BytesIO

class MultiFactorAuth:
    def __init__(self, user_repository: UserRepository):
        self._user_repo = user_repository

    def setup_totp(self, user: User) -> tuple[str, bytes]:
        """TOTPï¼ˆæ™‚é–“ãƒ™ãƒ¼ã‚¹ãƒ¯ãƒ³ã‚¿ã‚¤ãƒ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼‰è¨­å®š"""
        secret = pyotp.random_base32()

        # QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
        totp_uri = pyotp.totp.TOTP(secret).provisioning_uri(
            name=user.email,
            issuer_name="Novel Writing System"
        )

        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(totp_uri)
        qr.make(fit=True)

        qr_image = qr.make_image(fill_color="black", back_color="white")
        buffer = BytesIO()
        qr_image.save(buffer, format='PNG')

        # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«TOTPç§˜å¯†éµã‚’ä¿å­˜
        user.totp_secret = secret
        self._user_repo.save(user)

        return secret, buffer.getvalue()

    def verify_totp(self, user: User, token: str) -> bool:
        """TOTPãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼"""
        if not user.totp_secret:
            return False

        totp = pyotp.TOTP(user.totp_secret)
        return totp.verify(token, valid_window=1)  # 30ç§’ã®èª¤å·®è¨±å®¹

    def require_mfa(self, user: User, password: str, totp_token: str) -> bool:
        """å¤šè¦ç´ èªè¨¼ã®å®Ÿè£…"""
        # 1. ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰èªè¨¼
        if not self._verify_password(user, password):
            return False

        # 2. TOTPèªè¨¼
        if not self.verify_totp(user, totp_token):
            return False

        return True
```

#### ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†
```python
import secrets
import time
from datetime import datetime, timedelta

class SecureSessionManager:
    def __init__(self, redis_client, session_timeout: int = 3600):
        self._redis = redis_client
        self._timeout = session_timeout

    def create_session(self, user: User) -> str:
        """ã‚»ã‚­ãƒ¥ã‚¢ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ"""
        # æš—å·å­¦çš„ã«å®‰å…¨ãªã‚»ãƒƒã‚·ãƒ§ãƒ³IDç”Ÿæˆ
        session_id = secrets.token_urlsafe(32)

        session_data = {
            'user_id': user.id,
            'user_role': user.role,
            'created_at': datetime.now().isoformat(),
            'last_activity': datetime.now().isoformat(),
            'ip_address': self._get_client_ip(),
            'user_agent': self._get_user_agent()
        }

        # Redisã«ä¿å­˜ï¼ˆTTLä»˜ãï¼‰
        self._redis.setex(
            f"session:{session_id}",
            self._timeout,
            json.dumps(session_data)
        )

        return session_id

    def validate_session(self, session_id: str) -> Optional[dict]:
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³æ¤œè¨¼"""
        if not session_id:
            return None

        session_data = self._redis.get(f"session:{session_id}")
        if not session_data:
            return None

        data = json.loads(session_data)

        # ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒã‚¤ã‚¸ãƒ£ãƒƒã‚¯å¯¾ç­–ï¼šIPãƒ»User-Agentãƒã‚§ãƒƒã‚¯
        if (data.get('ip_address') != self._get_client_ip() or
            data.get('user_agent') != self._get_user_agent()):
            self.invalidate_session(session_id)
            return None

        # æœ€çµ‚æ´»å‹•æ™‚é–“æ›´æ–°
        data['last_activity'] = datetime.now().isoformat()
        self._redis.setex(
            f"session:{session_id}",
            self._timeout,
            json.dumps(data)
        )

        return data

    def invalidate_session(self, session_id: str):
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³ç„¡åŠ¹åŒ–"""
        self._redis.delete(f"session:{session_id}")

    def cleanup_expired_sessions(self):
        """æœŸé™åˆ‡ã‚Œã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        # Redisã®æœŸé™åˆ‡ã‚Œè‡ªå‹•å‰Šé™¤ã‚’åˆ©ç”¨
        pass
```

### èªå¯ï¼ˆAuthorizationï¼‰ã®å®Ÿè£…

#### ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ï¼ˆRBACï¼‰
```python
from enum import Enum
from dataclasses import dataclass
from typing import Set

class Permission(Enum):
    READ_EPISODE = "read_episode"
    WRITE_EPISODE = "write_episode"
    DELETE_EPISODE = "delete_episode"
    PUBLISH_EPISODE = "publish_episode"
    ADMIN_USERS = "admin_users"
    SYSTEM_CONFIG = "system_config"

class Role(Enum):
    READER = "reader"
    AUTHOR = "author"
    EDITOR = "editor"
    ADMIN = "admin"

@dataclass
class RolePermissions:
    ROLE_PERMISSIONS = {
        Role.READER: {
            Permission.READ_EPISODE
        },
        Role.AUTHOR: {
            Permission.READ_EPISODE,
            Permission.WRITE_EPISODE,
            Permission.DELETE_EPISODE,
            Permission.PUBLISH_EPISODE
        },
        Role.EDITOR: {
            Permission.READ_EPISODE,
            Permission.WRITE_EPISODE,
            Permission.DELETE_EPISODE,
            Permission.PUBLISH_EPISODE
        },
        Role.ADMIN: {
            Permission.READ_EPISODE,
            Permission.WRITE_EPISODE,
            Permission.DELETE_EPISODE,
            Permission.PUBLISH_EPISODE,
            Permission.ADMIN_USERS,
            Permission.SYSTEM_CONFIG
        }
    }

class AuthorizationService:
    def __init__(self):
        self._role_permissions = RolePermissions.ROLE_PERMISSIONS

    def has_permission(self, user: User, permission: Permission) -> bool:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç‰¹å®šã®æ¨©é™ã‚’æŒã¤ã‹ãƒã‚§ãƒƒã‚¯"""
        user_permissions = self._role_permissions.get(user.role, set())
        return permission in user_permissions

    def can_access_episode(self, user: User, episode: Episode) -> bool:
        """ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½æ€§ãƒã‚§ãƒƒã‚¯"""
        # è‡ªåˆ†ã®ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ãªã‚‰å¸¸ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
        if episode.author_id == user.id:
            return True

        # å…¬é–‹æ¸ˆã¿ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã¯èª­ã¿å–ã‚Šæ¨©é™ãŒã‚ã‚Œã°å¯èƒ½
        if (episode.status == EpisodeStatus.PUBLISHED and
            self.has_permission(user, Permission.READ_EPISODE)):
            return True

        # ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãƒ»ç®¡ç†è€…ã¯å…¨ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
        return user.role in [Role.EDITOR, Role.ADMIN]

    def require_permission(self, permission: Permission):
        """ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ï¼šæ¨©é™ãƒã‚§ãƒƒã‚¯"""
        def decorator(func):
            def wrapper(*args, **kwargs):
                current_user = get_current_user()
                if not self.has_permission(current_user, permission):
                    raise UnauthorizedError(f"Permission {permission.value} required")
                return func(*args, **kwargs)
            return wrapper
        return decorator

# ä½¿ç”¨ä¾‹
auth_service = AuthorizationService()

@auth_service.require_permission(Permission.WRITE_EPISODE)
def create_episode(episode_data: dict) -> Episode:
    # ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ä½œæˆå‡¦ç†
    pass
```

---

## ğŸ›¡ï¸ å…¥åŠ›å€¤æ¤œè¨¼ãƒ»ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–

### åŒ…æ‹¬çš„å…¥åŠ›å€¤æ¤œè¨¼

#### ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
```python
from pydantic import BaseModel, validator, Field
from typing import Optional
import re
import html

class EpisodeCreateRequest(BaseModel):
    title: str = Field(..., min_length=1, max_length=100)
    content: str = Field(..., min_length=1, max_length=50000)
    episode_number: int = Field(..., ge=1, le=9999)
    tags: Optional[List[str]] = Field(default=[], max_items=10)

    @validator('title')
    def validate_title(cls, v):
        # HTMLã‚¿ã‚°é™¤å»
        clean_title = html.escape(v.strip())

        # ä¸æ­£æ–‡å­—ãƒã‚§ãƒƒã‚¯
        if re.search(r'[<>\"\'&]', clean_title):
            raise ValueError('Title contains invalid characters')

        return clean_title

    @validator('content')
    def validate_content(cls, v):
        # åŸºæœ¬çš„ãªHTMLã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
        clean_content = html.escape(v)

        # éåº¦ã«é•·ã„è¡Œã®ãƒã‚§ãƒƒã‚¯
        lines = clean_content.split('\n')
        for line in lines:
            if len(line) > 1000:
                raise ValueError('Content line too long')

        return clean_content

    @validator('tags')
    def validate_tags(cls, v):
        if not v:
            return []

        clean_tags = []
        for tag in v:
            # ã‚¿ã‚°ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
            clean_tag = html.escape(tag.strip().lower())

            # ã‚¿ã‚°å½¢å¼ãƒã‚§ãƒƒã‚¯
            if not re.match(r'^[a-zA-Z0-9_-]+$', clean_tag):
                raise ValueError(f'Invalid tag format: {tag}')

            if len(clean_tag) > 20:
                raise ValueError(f'Tag too long: {tag}')

            clean_tags.append(clean_tag)

        return clean_tags

class SecureInputValidator:
    def __init__(self):
        self._max_string_length = 10000
        self._allowed_file_extensions = {'.md', '.txt', '.yaml'}
        self._dangerous_patterns = [
            r'<script.*?>.*?</script>',
            r'javascript:',
            r'vbscript:',
            r'onload=',
            r'onerror=',
            r'eval\(',
            r'exec\('
        ]

    def validate_string(self, value: str, field_name: str) -> str:
        """æ–‡å­—åˆ—ã®å®‰å…¨æ€§æ¤œè¨¼"""
        if not isinstance(value, str):
            raise ValueError(f"{field_name} must be a string")

        if len(value) > self._max_string_length:
            raise ValueError(f"{field_name} too long")

        # å±é™ºãªãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯
        for pattern in self._dangerous_patterns:
            if re.search(pattern, value, re.IGNORECASE):
                raise ValueError(f"{field_name} contains dangerous content")

        return html.escape(value.strip())

    def validate_filename(self, filename: str) -> str:
        """ãƒ•ã‚¡ã‚¤ãƒ«åã®å®‰å…¨æ€§æ¤œè¨¼"""
        if not filename:
            raise ValueError("Filename cannot be empty")

        # ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«å¯¾ç­–
        if '..' in filename or filename.startswith('/'):
            raise ValueError("Invalid filename path")

        # æ‹¡å¼µå­ãƒã‚§ãƒƒã‚¯
        file_path = Path(filename)
        if file_path.suffix not in self._allowed_file_extensions:
            raise ValueError("File extension not allowed")

        # ãƒ•ã‚¡ã‚¤ãƒ«åæ–‡å­—ãƒã‚§ãƒƒã‚¯
        if not re.match(r'^[a-zA-Z0-9._-]+$', file_path.name):
            raise ValueError("Filename contains invalid characters")

        return filename

    def validate_episode_number(self, number: int) -> int:
        """ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ç•ªå·ã®æ¤œè¨¼"""
        if not isinstance(number, int):
            raise ValueError("Episode number must be an integer")

        if number < 1 or number > 9999:
            raise ValueError("Episode number out of range")

        return number
```

### XSSå¯¾ç­–

#### å‡ºåŠ›ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
```python
import html
from markupsafe import Markup, escape
from jinja2 import Environment, select_autoescape

class XSSProtection:
    def __init__(self):
        # Jinja2ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚¨ãƒ³ã‚¸ãƒ³ã®å®‰å…¨ãªè¨­å®š
        self._jinja_env = Environment(
            autoescape=select_autoescape(['html', 'xml'])
        )

    def escape_html(self, text: str) -> str:
        """HTMLç‰¹æ®Šæ–‡å­—ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—"""
        return html.escape(text, quote=True)

    def escape_javascript(self, text: str) -> str:
        """JavaScriptç”¨ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—"""
        # JavaScriptå†…ã§ä½¿ç”¨ã™ã‚‹éš›ã®ç‰¹æ®Šæ–‡å­—ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
        replacements = {
            '\\': '\\\\',
            '"': '\\"',
            "'": "\\'",
            '\n': '\\n',
            '\r': '\\r',
            '\t': '\\t',
            '<': '\\x3C',
            '>': '\\x3E',
            '&': '\\x26'
        }

        escaped = text
        for char, replacement in replacements.items():
            escaped = escaped.replace(char, replacement)

        return escaped

    def sanitize_markdown(self, markdown_text: str) -> str:
        """Markdownå®‰å…¨åŒ–"""
        import bleach

        # è¨±å¯ã™ã‚‹HTMLã‚¿ã‚°ã¨ã‚¢ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆ
        allowed_tags = [
            'p', 'br', 'strong', 'em', 'u', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
            'ul', 'ol', 'li', 'blockquote', 'code', 'pre'
        ]

        allowed_attributes = {
            '*': ['class'],
            'a': ['href', 'title'],
            'img': ['src', 'alt', 'title']
        }

        return bleach.clean(
            markdown_text,
            tags=allowed_tags,
            attributes=allowed_attributes,
            strip=True
        )

# ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½¿ç”¨ä¾‹
class EpisodeRenderer:
    def __init__(self):
        self._xss_protection = XSSProtection()

    def render_episode(self, episode: Episode) -> str:
        """ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã®å®‰å…¨ãªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°"""
        template = """
        <div class="episode">
            <h1>{{ title|e }}</h1>
            <div class="content">{{ content|safe }}</div>
            <div class="tags">
                {% for tag in tags %}
                    <span class="tag">{{ tag|e }}</span>
                {% endfor %}
            </div>
        </div>
        """

        # Markdownã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
        safe_content = self._xss_protection.sanitize_markdown(episode.content)

        return self._xss_protection._jinja_env.from_string(template).render(
            title=episode.title,
            content=Markup(safe_content),  # æ—¢ã«ã‚µãƒ‹ã‚¿ã‚¤ã‚ºæ¸ˆã¿ãªã®ã§safe
            tags=episode.tags
        )
```

---

## ğŸ” æš—å·åŒ–ãƒ»HTTPSãƒ»ãƒãƒƒã‚·ãƒ¥åŒ–

### ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–

#### å¯¾ç§°æš—å·åŒ–ï¼ˆAESï¼‰
```python
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os

class DataEncryption:
    def __init__(self, password: str):
        # ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰æš—å·åŒ–ã‚­ãƒ¼ã‚’å°å‡º
        salt = os.urandom(16)
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        self._cipher = Fernet(key)
        self._salt = salt

    def encrypt(self, data: str) -> str:
        """ãƒ‡ãƒ¼ã‚¿ã®æš—å·åŒ–"""
        encrypted = self._cipher.encrypt(data.encode('utf-8'))
        # salt + encrypted data
        return base64.urlsafe_b64encode(self._salt + encrypted).decode('utf-8')

    def decrypt(self, encrypted_data: str) -> str:
        """ãƒ‡ãƒ¼ã‚¿ã®å¾©å·"""
        data = base64.urlsafe_b64decode(encrypted_data.encode('utf-8'))
        salt = data[:16]
        encrypted = data[16:]

        # åŒã˜saltã§éµã‚’å†ç”Ÿæˆ
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        cipher = Fernet(key)

        decrypted = cipher.decrypt(encrypted)
        return decrypted.decode('utf-8')

class EpisodeDraftEncryption:
    """ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ä¸‹æ›¸ãã®æš—å·åŒ–ä¿å­˜"""

    def __init__(self, encryption_service: DataEncryption):
        self._encryption = encryption_service

    def save_draft(self, episode_id: str, content: str, author_key: str):
        """ä¸‹æ›¸ãã®æš—å·åŒ–ä¿å­˜"""
        # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æš—å·åŒ–
        encrypted_content = self._encryption.encrypt(content)

        # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼ˆæš—å·åŒ–ã—ãªã„ï¼‰
        metadata = {
            'episode_id': episode_id,
            'created_at': datetime.now().isoformat(),
            'encrypted': True
        }

        # ä¿å­˜
        draft_data = {
            'metadata': metadata,
            'encrypted_content': encrypted_content
        }

        with open(f"drafts/{episode_id}.json", 'w') as f:
            json.dump(draft_data, f)

    def load_draft(self, episode_id: str, author_key: str) -> str:
        """ä¸‹æ›¸ãã®å¾©å·èª­ã¿è¾¼ã¿"""
        with open(f"drafts/{episode_id}.json", 'r') as f:
            draft_data = json.load(f)

        encrypted_content = draft_data['encrypted_content']
        return self._encryption.decrypt(encrypted_content)
```

#### éå¯¾ç§°æš—å·åŒ–ï¼ˆRSAï¼‰
```python
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization

class AsymmetricEncryption:
    def __init__(self):
        self._private_key = None
        self._public_key = None

    def generate_key_pair(self) -> tuple[bytes, bytes]:
        """RSAã‚­ãƒ¼ãƒšã‚¢ç”Ÿæˆ"""
        self._private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
        )
        self._public_key = self._private_key.public_key()

        # PEMå½¢å¼ã§ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
        private_pem = self._private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )

        public_pem = self._public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )

        return private_pem, public_pem

    def encrypt_with_public_key(self, data: str, public_key_pem: bytes) -> bytes:
        """å…¬é–‹éµã«ã‚ˆã‚‹æš—å·åŒ–"""
        public_key = serialization.load_pem_public_key(public_key_pem)

        encrypted = public_key.encrypt(
            data.encode('utf-8'),
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return encrypted

    def decrypt_with_private_key(self, encrypted_data: bytes, private_key_pem: bytes) -> str:
        """ç§˜å¯†éµã«ã‚ˆã‚‹å¾©å·"""
        private_key = serialization.load_pem_private_key(
            private_key_pem,
            password=None,
        )

        decrypted = private_key.decrypt(
            encrypted_data,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return decrypted.decode('utf-8')
```

### HTTPSå®Ÿè£…

#### CLIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š
```python
# æœ¬ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯CLIãƒ„ãƒ¼ãƒ«ã®ãŸã‚ã€Webã‚µãƒ¼ãƒãƒ¼ã¯ä½¿ç”¨ã—ã¦ã„ã¾ã›ã‚“
# ä»£ã‚ã‚Šã«ã€CLIãƒ„ãƒ¼ãƒ«ï¼ˆTyperï¼‰ã§ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®Ÿè£…ä¾‹ã‚’ç¤ºã—ã¾ã™
from typer import Typer
from pathlib import Path
import os

app = Typer()

# CLIãƒ„ãƒ¼ãƒ«ã§ã®ã‚»ã‚­ãƒ¥ã‚¢é€šä¿¡
# APIã‚¢ã‚¯ã‚»ã‚¹æ™‚ã®HTTPSåˆ©ç”¨ä¾‹
import requests

def secure_api_call(endpoint: str, data: dict):
    """å¤–éƒ¨APIã¸ã®ã‚»ã‚­ãƒ¥ã‚¢ãªé€šä¿¡"""
    response = requests.post(
        endpoint,
        json=data,
        verify=True,  # SSLè¨¼æ˜æ›¸æ¤œè¨¼ã‚’æœ‰åŠ¹åŒ–
        timeout=30
    )
    return response

# CLIã‚³ãƒãƒ³ãƒ‰ã§ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®Ÿè£…
@app.command()
def process_secure(
    file_path: Path = typer.Argument(..., help="å‡¦ç†å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«"),
    confirm: bool = typer.Option(False, "--confirm", help="å®Ÿè¡Œç¢ºèª")
):
    """ã‚»ã‚­ãƒ¥ã‚¢ãªãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚³ãƒãƒ³ãƒ‰"""
    # ãƒ‘ã‚¹æ¤œè¨¼
    if not file_path.exists():
        typer.echo(f"Error: ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“: {file_path}")
        raise typer.Exit(1)

    # ç¢ºèªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
    if not confirm:
        typer.echo("--confirm ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§å®Ÿè¡Œã‚’ç¢ºèªã—ã¦ãã ã•ã„")
        raise typer.Exit(1)

    # ã‚»ã‚­ãƒ¥ã‚¢ãªå‡¦ç†å®Ÿè¡Œ
    typer.echo(f"å‡¦ç†ä¸­: {file_path}")
```

#### è¨¼æ˜æ›¸ç®¡ç†
```python
import ssl
import socket
from datetime import datetime
from cryptography import x509
from cryptography.x509.oid import NameOID

class CertificateManager:
    def check_certificate_expiry(self, hostname: str, port: int = 443) -> dict:
        """SSLè¨¼æ˜æ›¸ã®æœ‰åŠ¹æœŸé™ãƒã‚§ãƒƒã‚¯"""
        try:
            # SSLè¨¼æ˜æ›¸å–å¾—
            context = ssl.create_default_context()
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert_der = ssock.getpeercert(binary_form=True)

            # è¨¼æ˜æ›¸è§£æ
            cert = x509.load_der_x509_certificate(cert_der)

            # æœ‰åŠ¹æœŸé™æƒ…å ±
            not_after = cert.not_valid_after
            days_until_expiry = (not_after - datetime.now()).days

            # ã‚µãƒ–ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±
            subject = cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME)[0].value

            return {
                'hostname': hostname,
                'subject': subject,
                'not_after': not_after.isoformat(),
                'days_until_expiry': days_until_expiry,
                'is_valid': days_until_expiry > 0,
                'needs_renewal': days_until_expiry < 30  # 30æ—¥ä»¥å†…ã«æ›´æ–°
            }

        except Exception as e:
            return {
                'hostname': hostname,
                'error': str(e),
                'is_valid': False
            }

    def validate_certificate_chain(self, cert_file: str) -> bool:
        """è¨¼æ˜æ›¸ãƒã‚§ãƒ¼ãƒ³ã®æ¤œè¨¼"""
        try:
            with open(cert_file, 'rb') as f:
                cert_data = f.read()

            cert = x509.load_pem_x509_certificate(cert_data)

            # åŸºæœ¬çš„ãªæ¤œè¨¼
            now = datetime.now()
            if cert.not_valid_after < now:
                return False

            if cert.not_valid_before > now:
                return False

            return True

        except Exception:
            return False
```

---

## ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å®Ÿè·µ

### ã‚»ã‚­ãƒ¥ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

#### 1. å…¥åŠ›å€¤ã¯ä¿¡é ¼ã—ãªã„
```python
# âœ… å®‰å…¨ãªä¾‹
def process_user_input(user_input: str):
    # å…¥åŠ›å€¤æ¤œè¨¼
    validator = InputValidator()
    safe_input = validator.validate_and_sanitize(user_input)

    # å®‰å…¨ãªå‡¦ç†
    return process_safe_data(safe_input)

# âŒ å±é™ºãªä¾‹
def process_user_input(user_input: str):
    # å…¥åŠ›å€¤ã‚’ãã®ã¾ã¾ä½¿ç”¨
    eval(user_input)  # æ¥µã‚ã¦å±é™º
    exec(f"result = {user_input}")  # å±é™º
```

#### 2. æœ€å°æ¨©é™ã®åŸå‰‡
```python
class EpisodeFileManager:
    def __init__(self, base_path: str):
        self._base_path = Path(base_path)
        self._allowed_extensions = {'.md', '.txt', '.yaml'}

    def read_episode_file(self, filename: str, user: User) -> str:
        # ãƒ•ã‚¡ã‚¤ãƒ«åæ¤œè¨¼
        safe_path = self._validate_file_path(filename)

        # æ¨©é™ãƒã‚§ãƒƒã‚¯
        if not self._can_read_file(safe_path, user):
            raise PermissionError("Access denied")

        # å®‰å…¨ãªèª­ã¿è¾¼ã¿
        return self._read_file_safely(safe_path)

    def _validate_file_path(self, filename: str) -> Path:
        """ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®å®‰å…¨æ€§æ¤œè¨¼"""
        # ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«å¯¾ç­–
        if '..' in filename or filename.startswith('/'):
            raise ValueError("Invalid file path")

        # ãƒ™ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã«åˆ¶é™
        full_path = self._base_path / filename
        if not str(full_path).startswith(str(self._base_path)):
            raise ValueError("Path outside allowed directory")

        # æ‹¡å¼µå­ãƒã‚§ãƒƒã‚¯
        if full_path.suffix not in self._allowed_extensions:
            raise ValueError("File type not allowed")

        return full_path

    def _can_read_file(self, file_path: Path, user: User) -> bool:
        """ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿å–ã‚Šæ¨©é™ãƒã‚§ãƒƒã‚¯"""
        # ãƒ•ã‚¡ã‚¤ãƒ«æ‰€æœ‰è€…ãƒã‚§ãƒƒã‚¯
        file_metadata = self._get_file_metadata(file_path)
        if file_metadata.get('owner_id') == user.id:
            return True

        # å…¬é–‹ãƒ•ã‚¡ã‚¤ãƒ«ãƒã‚§ãƒƒã‚¯
        if file_metadata.get('is_public', False):
            return True

        # ç®¡ç†è€…æ¨©é™ãƒã‚§ãƒƒã‚¯
        return user.role == Role.ADMIN
```

#### 3. ã‚¨ãƒ©ãƒ¼æƒ…å ±ã®é©åˆ‡ãªå‡¦ç†
```python
from typing import Optional
from noveler.infrastructure.logging.unified_logger import (
    get_logger, configure_logging, LogLevel
)

class SecureErrorHandler:
    def __init__(self):
        # çµ±ä¸€ãƒ­ã‚¬ãƒ¼ã‚’ä½¿ç”¨ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›/ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯ unified è¨­å®šå´ã§åˆ¶å¾¡ï¼‰
        configure_logging(file_level=LogLevel.WARNING)
        self._logger = get_logger(__name__)

    def handle_error(self, err: Exception, user_id: Optional[str] = None) -> None:
        masked_user = user_id[:4] + '***' if user_id else 'anonymous'
        self._logger.warning("security: error detected", extra={
            "extra_data": {"user": masked_user, "error": str(err)[:200]}
        })
```

#### 4. ã‚»ã‚­ãƒ¥ã‚¢ãªè¨­å®šç®¡ç†
```python
from cryptography.fernet import Fernet
import json
import os

class SecureConfigManager:
    def __init__(self, config_file: str, encryption_key: str):
        self._config_file = config_file
        self._cipher = Fernet(encryption_key.encode())
        self._config = {}
        self._load_config()

    def _load_config(self):
        """è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®å®‰å…¨ãªèª­ã¿è¾¼ã¿"""
        try:
            if os.path.exists(self._config_file):
                with open(self._config_file, 'rb') as f:
                    encrypted_data = f.read()

                decrypted_data = self._cipher.decrypt(encrypted_data)
                self._config = json.loads(decrypted_data.decode('utf-8'))
            else:
                self._config = self._get_default_config()
                self._save_config()

        except Exception as e:
            # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ç ´ææ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’ä½¿ç”¨
            self._config = self._get_default_config()

    def _save_config(self):
        """è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®æš—å·åŒ–ä¿å­˜"""
        config_json = json.dumps(self._config, indent=2)
        encrypted_data = self._cipher.encrypt(config_json.encode('utf-8'))

        # åŸå­çš„æ›¸ãè¾¼ã¿
        temp_file = f"{self._config_file}.tmp"
        with open(temp_file, 'wb') as f:
            f.write(encrypted_data)

        os.rename(temp_file, self._config_file)

        # ãƒ•ã‚¡ã‚¤ãƒ«æ¨©é™è¨­å®šï¼ˆæ‰€æœ‰è€…ã®ã¿èª­ã¿æ›¸ãå¯èƒ½ï¼‰
        os.chmod(self._config_file, 0o600)

    def get_secret(self, key: str) -> Optional[str]:
        """æ©Ÿå¯†æƒ…å ±ã®å®‰å…¨ãªå–å¾—"""
        return self._config.get('secrets', {}).get(key)

    def set_secret(self, key: str, value: str):
        """æ©Ÿå¯†æƒ…å ±ã®å®‰å…¨ãªä¿å­˜"""
        if 'secrets' not in self._config:
            self._config['secrets'] = {}

        self._config['secrets'][key] = value
        self._save_config()

    def _get_default_config(self) -> dict:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š"""
        return {
            'app': {
                'name': 'Novel Writing System',
                'version': '1.0.0',
                'debug': False
            },
            'security': {
                'session_timeout': 3600,
                'max_login_attempts': 5,
                'password_min_length': 8,
                'require_mfa': False
            },
            'secrets': {}
        }
```

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆã®å®Ÿè£…

#### è‡ªå‹•åŒ–ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
```python
import pytest
import requests
from unittest.mock import patch

class SecurityTestSuite:
    def test_sql_injection_protection(self, app_client):
        """SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–ãƒ†ã‚¹ãƒˆ"""
        malicious_inputs = [
            "'; DROP TABLE episodes; --",
            "1' OR '1'='1",
            "admin'; UPDATE users SET role='admin' WHERE id=1; --"
        ]

        for payload in malicious_inputs:
            response = app_client.get(f'/episodes?author_id={payload}')

            # SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ãŒé˜²ãŒã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
            assert response.status_code != 500
            assert 'error' not in response.json.get('data', {})

    def test_xss_protection(self, app_client):
        """XSSå¯¾ç­–ãƒ†ã‚¹ãƒˆ"""
        xss_payloads = [
            "<script>alert('xss')</script>",
            "javascript:alert('xss')",
            "<img src=x onerror=alert('xss')>",
            "'><script>alert('xss')</script>"
        ]

        for payload in xss_payloads:
            response = app_client.post('/episodes', json={
                'title': payload,
                'content': f'Content with {payload}'
            })

            # XSSãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
            if response.status_code == 200:
                html_content = response.data.decode('utf-8')
                assert '<script>' not in html_content
                assert 'javascript:' not in html_content

    def test_authentication_bypass(self, app_client):
        """èªè¨¼ãƒã‚¤ãƒ‘ã‚¹å¯¾ç­–ãƒ†ã‚¹ãƒˆ"""
        protected_endpoints = [
            '/admin/users',
            '/episodes/create',
            '/settings',
            '/api/admin'
        ]

        for endpoint in protected_endpoints:
            # èªè¨¼ãªã—ã§ã‚¢ã‚¯ã‚»ã‚¹
            response = app_client.get(endpoint)

            # é©åˆ‡ã«èªè¨¼ãŒè¦æ±‚ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
            assert response.status_code in [401, 403, 302]

    def test_session_security(self, app_client):
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ"""
        # æ­£å¸¸ãƒ­ã‚°ã‚¤ãƒ³
        login_response = app_client.post('/login', json={
            'username': 'testuser',
            'password': 'testpass'
        })

        assert login_response.status_code == 200

        # ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¯ãƒƒã‚­ãƒ¼ã®å±æ€§ç¢ºèª
        set_cookie = login_response.headers.get('Set-Cookie', '')
        assert 'HttpOnly' in set_cookie
        assert 'Secure' in set_cookie
        assert 'SameSite' in set_cookie

    def test_rate_limiting(self, app_client):
        """ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ†ã‚¹ãƒˆ"""
        # å¤§é‡ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡
        for i in range(100):
            response = app_client.post('/login', json={
                'username': 'testuser',
                'password': 'wrongpass'
            })

        # ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãŒæ©Ÿèƒ½ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
        assert response.status_code == 429  # Too Many Requests
```

---

## ğŸ“š æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

ã“ã®ã‚¬ã‚¤ãƒ‰ã§ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åŸºç¤ã‚’ç†è§£ã—ãŸå¾Œã¯ã€ä»¥ä¸‹ã®ã‚¬ã‚¤ãƒ‰ã§æ·±åŒ–ã•ã›ã¦ãã ã•ã„ï¼š

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®æ·±åŒ–
- **B42: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆãƒ»å®Ÿè£…** - é«˜åº¦ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®Ÿè£…
- **B43: ãƒ‡ãƒ¼ã‚¿ä¿è­·ãƒ»ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼** - GDPRå¯¾å¿œã¨ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·

### é–¢é€£é ˜åŸŸ
- **B33: ã‚³ãƒ¼ãƒ‰å“è³ªãƒ»é™çš„è§£æ** - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å“è³ªã®æ¸¬å®š
- **B52: ç›£è¦–ãƒ»ãƒ­ã‚°ç®¡ç†ãƒ»å¯è¦³æ¸¬æ€§** - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–
- **B72: Infrastructure as Code** - ã‚¤ãƒ³ãƒ•ãƒ©ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

---

**æ›´æ–°å±¥æ­´**
- 2025-08-04: åˆç‰ˆä½œæˆ
- ä½œæˆè€…: Claude Code
- ãƒ¬ãƒ“ãƒ¥ãƒ¼çŠ¶æ³: ç­–å®šå®Œäº†
