# Copyright 2025 CS Group
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tables for the performance indicator database"""

from sqlalchemy import (
    TIMESTAMP,
    BigInteger,
    Boolean,
    CheckConstraint,
    Column,
    ForeignKey,
    Integer,
    Text,
)
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import DeclarativeBase, relationship


class Base(DeclarativeBase):  # pylint: disable=too-few-public-methods
    """
    Set Base as a type, thus mypy understands it. Otherwise, error from mypy
    """

    pass  # pylint: disable=unnecessary-pass


class FlowRun(Base):  # pylint: disable=too-few-public-methods
    """
    The table flow_run brings together Prefect flow general information.
    """

    __tablename__ = "flow_run"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    flow_type = Column(Text)
    mission = Column(Text)
    prefect_flow_id = Column(UUID(as_uuid=True))
    prefect_flow_parent_id = Column(UUID(as_uuid=True))
    dask_version = Column(Text)
    python_version = Column(Text)
    dpr_processor_name = Column(Text)
    dpr_processor_version = Column(Text)
    dpr_processor_unit = Column(Text)
    dpr_processing_input_stac_items = Column(JSONB)
    dpr_processing_start_datetime = Column(TIMESTAMP)
    dpr_processing_stop_datetime = Column(TIMESTAMP)
    dpr_processing_status = Column(Text)
    excluded_from_pi = Column(Boolean, default=False)

    products_expected = relationship("ProductExpected", back_populates="flow_run", cascade="all, delete")
    products_realised = relationship("ProductRealised", back_populates="flow_run", cascade="all, delete")
    products_missing = relationship("ProductMissing", back_populates="flow_run", cascade="all, delete")


class PiCategory(Base):  # pylint: disable=too-few-public-methods
    """
    The table pi_category provides the list of PI per mission.
    """

    __tablename__ = "pi_category"

    id = Column(Integer, primary_key=True, autoincrement=True)
    mission = Column(Text)
    name = Column(Text)
    description = Column(Text)
    max_delay_seconds = Column(BigInteger)

    products_expected = relationship("ProductExpected", back_populates="pi_category")
    products_realised = relationship("ProductRealised", back_populates="pi_category")
    products_missing = relationship("ProductMissing", back_populates="pi_category")


class ProductExpected(Base):  # pylint: disable=too-few-public-methods
    """
    This table provides all expected product from a single flow_run.
    This is the difficult part of the PI computing: estimate the production.
    The computing depends on mission, level and more generally on every STAC ITEM
    provided as input to the DPR processor.
    """

    __tablename__ = "product_expected"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    flow_run_id = Column(BigInteger, ForeignKey("flow_run.id", ondelete="CASCADE", onupdate="CASCADE"))
    pi_category_id = Column(Integer, ForeignKey("pi_category.id"))
    eopf_type = Column(Text)
    sensing_start_datetime = Column(TIMESTAMP)
    min_count = Column(Integer)
    max_count = Column(Integer)

    __table_args__ = (
        CheckConstraint("min_count >= 0"),
        CheckConstraint("max_count >= min_count"),
    )

    flow_run = relationship("FlowRun", back_populates="products_expected")
    pi_category = relationship("PiCategory", back_populates="products_expected")


class ProductRealised(Base):  # pylint: disable=too-few-public-methods
    """
    The table product_realised provides the list of products generated by the DPR processor.
    """

    __tablename__ = "product_realised"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    flow_run_id = Column(BigInteger, ForeignKey("flow_run.id", ondelete="CASCADE", onupdate="CASCADE"))
    pi_category_id = Column(Integer, ForeignKey("pi_category.id"))
    eopf_type = Column(Text)
    stac_item = Column(JSONB)
    sensing_start_datetime = Column(TIMESTAMP)
    origin_date = Column(TIMESTAMP)
    catalog_stored_datetime = Column(TIMESTAMP)
    unexpected = Column(Boolean, default=False)
    on_time_0_day = Column(Boolean, default=False)
    on_time_1_day = Column(Boolean, default=False)
    on_time_2_day = Column(Boolean, default=False)
    on_time_3_day = Column(Boolean, default=False)
    on_time_7_day = Column(Boolean, default=False)

    flow_run = relationship("FlowRun", back_populates="products_realised")
    pi_category = relationship("PiCategory", back_populates="products_realised")


class ProductMissing(Base):  # pylint: disable=too-few-public-methods
    """
    The table product_missing provides the list of missing_products.
    The list is based on what has been estimated during the construction of the table product_estimated.
    """

    __tablename__ = "product_missing"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    flow_run_id = Column(BigInteger, ForeignKey("flow_run.id", ondelete="CASCADE", onupdate="CASCADE"))
    pi_category_id = Column(Integer, ForeignKey("pi_category.id"))
    eopf_type = Column(Text)
    sensing_start_datetime = Column(TIMESTAMP)
    count = Column(Integer)

    __table_args__ = (CheckConstraint("count >= 0"),)

    flow_run = relationship("FlowRun", back_populates="products_missing")
    pi_category = relationship("PiCategory", back_populates="products_missing")
